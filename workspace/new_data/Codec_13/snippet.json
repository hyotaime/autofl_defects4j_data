[
    {
        "src_path": "src/main/java/org/apache/commons/codec/BinaryDecoder.java",
        "class_name": "org.apache.commons.codec.BinaryDecoder",
        "signature": "org.apache.commons.codec.BinaryDecoder.decode(byte[])",
        "snippet": "    byte[] decode(byte[] source) throws DecoderException;",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Decodes a byte array and returns the results as a byte array.\n     *\n     * @param source\n     *            A byte array which has been encoded with the appropriate encoder\n     * @return a byte array that contains decoded content\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/BinaryEncoder.java",
        "class_name": "org.apache.commons.codec.BinaryEncoder",
        "signature": "org.apache.commons.codec.BinaryEncoder.encode(byte[])",
        "snippet": "    byte[] encode(byte[] source) throws EncoderException;",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Encodes a byte array and return the encoded data as a byte array.\n     *\n     * @param source\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException()",
        "snippet": "    public EncoderException() {\n        super();\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.String)",
        "snippet": "    public EncoderException(final String message) {\n        super(message);\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            a useful message relating to the encoder specific error.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public EncoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * Constructs a new exception with the specified detail message and cause.\n     *\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.Throwable)",
        "snippet": "    public EncoderException(final Throwable cause) {\n        super(cause);\n    }",
        "begin_line": 86,
        "end_line": 88,
        "comment": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/StringDecoder.java",
        "class_name": "org.apache.commons.codec.StringDecoder",
        "signature": "org.apache.commons.codec.StringDecoder.decode(java.lang.String)",
        "snippet": "    String decode(String source) throws DecoderException;",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Decodes a String and returns a String.\n     *\n     * @param source\n     *            the String to decode\n     * @return the encoded String\n     * @throws DecoderException\n     *             thrown if there is an error condition during the Encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/StringEncoder.java",
        "class_name": "org.apache.commons.codec.StringEncoder",
        "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
        "snippet": "    String encode(String source) throws EncoderException;",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Encodes a String and returns a String.\n     *\n     * @param source\n     *            the String to encode\n     * @return the encoded String\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.StringEncoderComparator()",
        "snippet": "    @Deprecated\n    public StringEncoderComparator() {\n        this.stringEncoder = null; // Trying to use this will cause things to break\n    }",
        "begin_line": 46,
        "end_line": 49,
        "comment": "\n     * Constructs a new instance.\n     *\n     * @deprecated Creating an instance without a {@link StringEncoder} leads to a {@link NullPointerException}. Will be\n     *             removed in 2.0.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.StringEncoderComparator(org.apache.commons.codec.StringEncoder)",
        "snippet": "    public StringEncoderComparator(final StringEncoder stringEncoder) {\n        this.stringEncoder = stringEncoder;\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     * Constructs a new instance with the given algorithm.\n     *\n     * @param stringEncoder\n     *            the StringEncoder used for comparisons.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.compare(java.lang.Object, java.lang.Object)",
        "snippet": "    @Override\n    public int compare(final Object o1, final Object o2) {\n\n        int compareCode = 0;\n\n        try {\n            @SuppressWarnings(\"unchecked\") // May fail with CCE if encode returns something that is not Comparable\n            // However this was always the case.\n            final Comparable<Comparable<?>> s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1);\n            final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2);\n            compareCode = s1.compareTo(s2);\n        } catch (final EncoderException ee) {\n            compareCode = 0;\n        }\n        return compareCode;\n    }",
        "begin_line": 74,
        "end_line": 89,
        "comment": "\n     * Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\n     * StringEncoder this Comparator was created with.\n     *\n     * If an {@link EncoderException} is encountered, return <code>0</code>.\n     *\n     * @param o1\n     *            the object to compare\n     * @param o2\n     *            the object to compare to\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n     * @see Comparable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException()",
        "snippet": "    public DecoderException() {\n        super();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     * Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.String)",
        "snippet": "    public DecoderException(final String message) {\n        super(message);\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public DecoderException(final String message, final Throwable cause) {\n        super(message, cause);\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n     * Constructs a new exception with the specified detail message and cause.\n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.Throwable)",
        "snippet": "    public DecoderException(final Throwable cause) {\n        super(cause);\n    }",
        "begin_line": 83,
        "end_line": 85,
        "comment": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/Decoder.java",
        "class_name": "org.apache.commons.codec.Decoder",
        "signature": "org.apache.commons.codec.Decoder.decode(java.lang.Object)",
        "snippet": "    Object decode(Object source) throws DecoderException;",
        "begin_line": 45,
        "end_line": 45,
        "comment": "\n     * Decodes an \"encoded\" Object and returns a \"decoded\" Object. Note that the implementation of this interface will\n     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a\n     * {@link ClassCastException} occurs this decode method will throw a DecoderException.\n     *\n     * @param source\n     *            the object to decode\n     * @return a 'decoded\" object\n     * @throws DecoderException\n     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the\n     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a\n     *             specific encoder.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/Encoder.java",
        "class_name": "org.apache.commons.codec.Encoder",
        "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
        "snippet": "    Object encode(Object source) throws EncoderException;",
        "begin_line": 42,
        "end_line": 42,
        "comment": "\n     * Encodes an \"Object\" and returns the encoded content as an Object. The Objects here may just be\n     * <code>byte[]</code> or <code>String</code>s depending on the implementation used.\n     *\n     * @param source\n     *            An object to encode\n     * @return An \"encoded\" Object\n     * @throws EncoderException\n     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding\n     *             process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/Charsets.java",
        "class_name": "org.apache.commons.codec.Charsets",
        "signature": "org.apache.commons.codec.Charsets.toCharset(java.nio.charset.Charset)",
        "snippet": "    public static Charset toCharset(final Charset charset) {\n        return charset == null ? Charset.defaultCharset() : charset;\n    }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "\n     * Returns the given Charset or the default Charset if the given Charset is null.\n     *\n     * @param charset\n     *            A charset or null.\n     * @return the given Charset or the default Charset if the given Charset is null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/Charsets.java",
        "class_name": "org.apache.commons.codec.Charsets",
        "signature": "org.apache.commons.codec.Charsets.toCharset(java.lang.String)",
        "snippet": "    public static Charset toCharset(final String charset) {\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n    }",
        "begin_line": 86,
        "end_line": 88,
        "comment": "\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])",
        "snippet": "    public static String apr1Crypt(final byte[] keyBytes) {\n        return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * See {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @return the hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
        "snippet": "    public static String apr1Crypt(final byte[] keyBytes, String salt) {\n        // to make the md5Crypt regex happy\n        if (salt != null && !salt.startsWith(APR1_PREFIX)) {\n            salt = APR1_PREFIX + salt;\n        }\n        return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\n    }",
        "begin_line": 87,
        "end_line": 93,
        "comment": "\n     * See {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt An APR1 salt.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String)",
        "snippet": "    public static String apr1Crypt(final String keyBytes) {\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\n    }",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * See {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @return the hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
        "snippet": "    public static String apr1Crypt(final String keyBytes, final String salt) {\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n    }",
        "begin_line": 125,
        "end_line": 127,
        "comment": "\n     * Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value.\n     * <p>\n     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n     * prefix.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n     *            null.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])",
        "snippet": "    public static String md5Crypt(final byte[] keyBytes) {\n        return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\n    }",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Generates a libc6 crypt() compatible \"$1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @return the hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
        "snippet": "    public static String md5Crypt(final byte[] keyBytes, final String salt) {\n        return md5Crypt(keyBytes, salt, MD5_PREFIX);\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n     * Generates a libc crypt() compatible \"$1$\" MD5 based hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n     *            null.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Md5Crypt",
        "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String, java.lang.String)",
        "snippet": "    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\n        final int keyLen = keyBytes.length;\n\n        // Extract the real salt from the given string which can be a complete hash string.\n        String saltString;\n        if (salt == null) {\n            saltString = B64.getRandomSalt(8);\n        } else {\n            final Pattern p = Pattern.compile(\"^\" + prefix.replace(\"$\", \"\\\\$\") + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\n            final Matcher m = p.matcher(salt);\n            if (m == null || !m.find()) {\n                throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n            }\n            saltString = m.group(1);\n        }\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\n\n        /*\n         * The password first, since that is what is most unknown\n         */\n        ctx.update(keyBytes);\n\n        /*\n         * Then our magic string\n         */\n        ctx.update(prefix.getBytes(Charsets.UTF_8));\n\n        /*\n         * Then the raw salt\n         */\n        ctx.update(saltBytes);\n\n        /*\n         * Then just as many characters of the MD5(pw,salt,pw)\n         */\n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\n        ctx1.update(keyBytes);\n        ctx1.update(saltBytes);\n        ctx1.update(keyBytes);\n        byte[] finalb = ctx1.digest();\n        int ii = keyLen;\n        while (ii > 0) {\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\n            ii -= 16;\n        }\n\n        /*\n         * Don't leave anything around in vm they could use.\n         */\n        Arrays.fill(finalb, (byte) 0);\n\n        /*\n         * Then something really weird...\n         */\n        ii = keyLen;\n        final int j = 0;\n        while (ii > 0) {\n            if ((ii & 1) == 1) {\n                ctx.update(finalb[j]);\n            } else {\n                ctx.update(keyBytes[j]);\n            }\n            ii >>= 1;\n        }\n\n        /*\n         * Now make the output string\n         */\n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \"$\");\n        finalb = ctx.digest();\n\n        /*\n         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 msec, so you would\n         * need 30 seconds to build a 1000 entry dictionary...\n         */\n        for (int i = 0; i < ROUNDS; i++) {\n            ctx1 = DigestUtils.getMd5Digest();\n            if ((i & 1) != 0) {\n                ctx1.update(keyBytes);\n            } else {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            }\n\n            if (i % 3 != 0) {\n                ctx1.update(saltBytes);\n            }\n\n            if (i % 7 != 0) {\n                ctx1.update(keyBytes);\n            }\n\n            if ((i & 1) != 0) {\n                ctx1.update(finalb, 0, BLOCKSIZE);\n            } else {\n                ctx1.update(keyBytes);\n            }\n            finalb = ctx1.digest();\n        }\n\n        // The following was nearly identical to the Sha2Crypt code.\n        // Again, the buflen is not really needed.\n        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\n\n        /*\n         * Don't leave anything around in vm they could use.\n         */\n        // Is there a better way to do this with the JVM?\n        ctx.reset();\n        ctx1.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n        Arrays.fill(finalb, (byte) 0);\n\n        return passwd.toString();\n    }",
        "begin_line": 179,
        "end_line": 301,
        "comment": "\n     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext string to hash.\n     * @param salt May be null.\n     * @param prefix salt prefix\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])",
        "snippet": "    public static String crypt(final byte[] original) {\n        return crypt(original, null);\n    }",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * As no salt is given, a random one will be used.\n     *\n     * @param original\n     *            plaintext password\n     * @return a 13 character string starting with the salt string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[], java.lang.String)",
        "snippet": "    public static String crypt(final byte[] original, String salt) {\n        if (salt == null) {\n            final Random randomGenerator = new Random();\n            final int numSaltChars = SALT_CHARS.length;\n            salt = \"\" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] +\n                    SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\n        } else if (!salt.matches(\"^[\" + B64.B64T + \"]{2,}$\")) {\n            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n        }\n\n        final StringBuilder buffer = new StringBuilder(\"             \");\n        final char charZero = salt.charAt(0);\n        final char charOne = salt.charAt(1);\n        buffer.setCharAt(0, charZero);\n        buffer.setCharAt(1, charOne);\n        final int eSwap0 = CON_SALT[charZero];\n        final int eSwap1 = CON_SALT[charOne] << 4;\n        final byte key[] = new byte[8];\n        for (int i = 0; i < key.length; i++) {\n            key[i] = 0;\n        }\n\n        for (int i = 0; i < key.length && i < original.length; i++) {\n            final int iChar = original[i];\n            key[i] = (byte) (iChar << 1);\n        }\n\n        final int schedule[] = desSetKey(key);\n        final int out[] = body(schedule, eSwap0, eSwap1);\n        final byte b[] = new byte[9];\n        intToFourBytes(out[0], b, 0);\n        intToFourBytes(out[1], b, 4);\n        b[8] = 0;\n        int i = 2;\n        int y = 0;\n        int u = 128;\n        for (; i < 13; i++) {\n            int j = 0;\n            int c = 0;\n            for (; j < 6; j++) {\n                c <<= 1;\n                if ((b[y] & u) != 0) {\n                    c |= 0x1;\n                }\n                u >>>= 1;\n                if (u == 0) {\n                    y++;\n                    u = 128;\n                }\n                buffer.setCharAt(i, (char) COV2CHAR[c]);\n            }\n        }\n        return buffer.toString();\n    }",
        "begin_line": 198,
        "end_line": 251,
        "comment": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * Using unspecified characters as salt results incompatible hash values.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String)",
        "snippet": "    public static String crypt(final String original) {\n        return crypt(original.getBytes(Charsets.UTF_8));\n    }",
        "begin_line": 262,
        "end_line": 264,
        "comment": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * As no salt is given, a random one is used.\n     *\n     * @param original\n     *            plaintext password\n     * @return a 13 character string starting with the salt string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String, java.lang.String)",
        "snippet": "    public static String crypt(final String original, final String salt) {\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\n    }",
        "begin_line": 277,
        "end_line": 279,
        "comment": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.body(int[], int, int)",
        "snippet": "    private static int[] body(final int schedule[], final int eSwap0, final int eSwap1) {\n        int left = 0;\n        int right = 0;\n        int t = 0;\n        for (int j = 0; j < 25; j++) {\n            for (int i = 0; i < 32; i += 4) {\n                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\n                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\n            }\n            t = left;\n            left = right;\n            right = t;\n        }\n\n        t = right;\n        right = left >>> 1 | left << 31;\n        left = t >>> 1 | t << 31;\n        final int results[] = new int[2];\n        permOp(right, left, 1, 0x55555555, results);\n        right = results[0];\n        left = results[1];\n        permOp(left, right, 8, 0xff00ff, results);\n        left = results[0];\n        right = results[1];\n        permOp(right, left, 2, 0x33333333, results);\n        right = results[0];\n        left = results[1];\n        permOp(left, right, 16, 65535, results);\n        left = results[0];\n        right = results[1];\n        permOp(right, left, 4, 0xf0f0f0f, results);\n        right = results[0];\n        left = results[1];\n        final int out[] = new int[2];\n        out[0] = left;\n        out[1] = right;\n        return out;\n    }",
        "begin_line": 281,
        "end_line": 318,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.byteToUnsigned(byte)",
        "snippet": "    private static int byteToUnsigned(final byte b) {\n        final int value = b;\n        return value < 0 ? value + 256 : value;\n    }",
        "begin_line": 320,
        "end_line": 323,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int, int, int, int, int, int[])",
        "snippet": "    private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int sArr[]) {\n        int v = r ^ r >>> 16;\n        int u = v & e0;\n        v &= e1;\n        u = u ^ u << 16 ^ r ^ sArr[s];\n        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\n        t = t >>> 4 | t << 28;\n        el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f] |\n                SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f] |\n                SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];\n        return el;\n    }",
        "begin_line": 325,
        "end_line": 336,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.desSetKey(byte[])",
        "snippet": "    private static int[] desSetKey(final byte key[]) {\n        final int schedule[] = new int[32];\n        int c = fourBytesToInt(key, 0);\n        int d = fourBytesToInt(key, 4);\n        final int results[] = new int[2];\n        permOp(d, c, 4, 0xf0f0f0f, results);\n        d = results[0];\n        c = results[1];\n        c = hPermOp(c, -2, 0xcccc0000);\n        d = hPermOp(d, -2, 0xcccc0000);\n        permOp(d, c, 1, 0x55555555, results);\n        d = results[0];\n        c = results[1];\n        permOp(c, d, 8, 0xff00ff, results);\n        c = results[0];\n        d = results[1];\n        permOp(d, c, 1, 0x55555555, results);\n        d = results[0];\n        c = results[1];\n        d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;\n        c &= 0xfffffff;\n        int j = 0;\n        for (int i = 0; i < 16; i++) {\n            if (SHIFT2[i]) {\n                c = c >>> 2 | c << 26;\n                d = d >>> 2 | d << 26;\n            } else {\n                c = c >>> 1 | c << 27;\n                d = d >>> 1 | d << 27;\n            }\n            c &= 0xfffffff;\n            d &= 0xfffffff;\n            int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] |\n                    SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] |\n                    SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\n            final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\n                    SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\n            schedule[j++] = (t << 16 | s & 0xffff);\n            s = s >>> 16 | t & 0xffff0000;\n            s = s << 4 | s >>> 28;\n            schedule[j++] = s;\n        }\n\n        return schedule;\n    }",
        "begin_line": 338,
        "end_line": 382,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[], int)",
        "snippet": "    private static int fourBytesToInt(final byte b[], int offset) {\n        int value = byteToUnsigned(b[offset++]);\n        value |= byteToUnsigned(b[offset++]) << 8;\n        value |= byteToUnsigned(b[offset++]) << 16;\n        value |= byteToUnsigned(b[offset++]) << 24;\n        return value;\n    }",
        "begin_line": 384,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.hPermOp(int, int, int)",
        "snippet": "    private static int hPermOp(int a, final int n, final int m) {\n        final int t = (a << 16 - n ^ a) & m;\n        a = a ^ t ^ t >>> 16 - n;\n        return a;\n    }",
        "begin_line": 392,
        "end_line": 396,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int, byte[], int)",
        "snippet": "    private static void intToFourBytes(final int iValue, final byte b[], int offset) {\n        b[offset++] = (byte) (iValue & 0xff);\n        b[offset++] = (byte) (iValue >>> 8 & 0xff);\n        b[offset++] = (byte) (iValue >>> 16 & 0xff);\n        b[offset++] = (byte) (iValue >>> 24 & 0xff);\n    }",
        "begin_line": 398,
        "end_line": 403,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/UnixCrypt.java",
        "class_name": "org.apache.commons.codec.digest.UnixCrypt",
        "signature": "org.apache.commons.codec.digest.UnixCrypt.permOp(int, int, int, int, int[])",
        "snippet": "    private static void permOp(int a, int b, final int n, final int m, final int results[]) {\n        final int t = (a >>> n ^ b) & m;\n        a ^= t << n;\n        b ^= t;\n        results[0] = a;\n        results[1] = b;\n    }",
        "begin_line": 405,
        "end_line": 411,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Sha2Crypt",
        "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])",
        "snippet": "    public static String sha256Crypt(final byte[] keyBytes) {\n        return sha256Crypt(keyBytes, null);\n    }",
        "begin_line": 82,
        "end_line": 84,
        "comment": "\n     * Generates a libc crypt() compatible \"$5$\" hash value with random salt.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @return complete hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Sha2Crypt",
        "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
        "snippet": "    public static String sha256Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\n    }",
        "begin_line": 101,
        "end_line": 106,
        "comment": "\n     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Sha2Crypt",
        "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[], java.lang.String, java.lang.String, int, java.lang.String)",
        "snippet": "    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\n            final int blocksize, final String algorithm) {\n\n        final int keyLen = keyBytes.length;\n\n        // Extracts effective salt and the number of rounds from the given salt.\n        int rounds = ROUNDS_DEFAULT;\n        boolean roundsCustom = false;\n        if (salt == null) {\n            throw new IllegalArgumentException(\"Salt must not be null\");\n        }\n\n        final Matcher m = SALT_PATTERN.matcher(salt);\n        if (m == null || !m.find()) {\n            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n        }\n        if (m.group(3) != null) {\n            rounds = Integer.parseInt(m.group(3));\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\n            roundsCustom = true;\n        }\n        final String saltString = m.group(4);\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n        final int saltLen = saltBytes.length;\n\n        // 1. start digest A\n        // Prepare for the real work.\n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\n\n        // 2. the password string is added to digest A\n        /*\n         * Add the key string.\n         */\n        ctx.update(keyBytes);\n\n        // 3. the salt string is added to digest A. This is just the salt string\n        // itself without the enclosing '$', without the magic salt_prefix $5$ and\n        // $6$ respectively and without the rounds=<N> specification.\n        //\n        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\n        // necessary since it is a constant string and does not add security\n        // and /possibly/ allows a plain text attack. Since the rounds=<N>\n        // specification should never be added this would also create an\n        // inconsistency.\n        /*\n         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\n         * (for compatibility with existing implementations).\n         */\n        ctx.update(saltBytes);\n\n        // 4. start digest B\n        /*\n         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\n         * context.\n         */\n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\n\n        // 5. add the password to digest B\n        /*\n         * Add key.\n         */\n        altCtx.update(keyBytes);\n\n        // 6. add the salt string to digest B\n        /*\n         * Add salt.\n         */\n        altCtx.update(saltBytes);\n\n        // 7. add the password again to digest B\n        /*\n         * Add key again.\n         */\n        altCtx.update(keyBytes);\n\n        // 8. finish digest B\n        /*\n         * Now get result of this (32 bytes) and add it to the other context.\n         */\n        byte[] altResult = altCtx.digest();\n\n        // 9. For each block of 32 or 64 bytes in the password string (excluding\n        // the terminating NUL in the C representation), add digest B to digest A\n        /*\n         * Add for any character in the key one byte of the alternate sum.\n         */\n        /*\n         * (Remark: the C code comment seems wrong for key length > 32!)\n         */\n        int cnt = keyBytes.length;\n        while (cnt > blocksize) {\n            ctx.update(altResult, 0, blocksize);\n            cnt -= blocksize;\n        }\n\n        // 10. For the remaining N bytes of the password string add the first\n        // N bytes of digest B to digest A\n        ctx.update(altResult, 0, cnt);\n\n        // 11. For each bit of the binary representation of the length of the\n        // password string up to and including the highest 1-digit, starting\n        // from to lowest bit position (numeric value 1):\n        //\n        // a) for a 1-digit add digest B to digest A\n        //\n        // b) for a 0-digit add the password string\n        //\n        // NB: this step differs significantly from the MD5 algorithm. It\n        // adds more randomness.\n        /*\n         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\n         * the key.\n         */\n        cnt = keyBytes.length;\n        while (cnt > 0) {\n            if ((cnt & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(keyBytes);\n            }\n            cnt >>= 1;\n        }\n\n        // 12. finish digest A\n        /*\n         * Create intermediate result.\n         */\n        altResult = ctx.digest();\n\n        // 13. start digest DP\n        /*\n         * Start computation of P byte sequence.\n         */\n        altCtx = DigestUtils.getDigest(algorithm);\n\n        // 14. for every byte in the password (excluding the terminating NUL byte\n        // in the C representation of the string)\n        //\n        // add the password to digest DP\n        /*\n         * For every character in the password add the entire password.\n         */\n        for (int i = 1; i <= keyLen; i++) {\n            altCtx.update(keyBytes);\n        }\n\n        // 15. finish digest DP\n        /*\n         * Finish the digest.\n         */\n        byte[] tempResult = altCtx.digest();\n\n        // 16. produce byte sequence P of the same length as the password where\n        //\n        // a) for each block of 32 or 64 bytes of length of the password string\n        // the entire digest DP is used\n        //\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\n        // bytes of digest DP\n        /*\n         * Create byte sequence P.\n         */\n        final byte[] pBytes = new byte[keyLen];\n        int cp = 0;\n        while (cp < keyLen - blocksize) {\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\n\n        // 17. start digest DS\n        /*\n         * Start computation of S byte sequence.\n         */\n        altCtx = DigestUtils.getDigest(algorithm);\n\n        // 18. repeast the following 16+A[0] times, where A[0] represents the first\n        // byte in digest A interpreted as an 8-bit unsigned value\n        //\n        // add the salt to digest DS\n        /*\n         * For every character in the password add the entire password.\n         */\n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\n            altCtx.update(saltBytes);\n        }\n\n        // 19. finish digest DS\n        /*\n         * Finish the digest.\n         */\n        tempResult = altCtx.digest();\n\n        // 20. produce byte sequence S of the same length as the salt string where\n        //\n        // a) for each block of 32 or 64 bytes of length of the salt string\n        // the entire digest DS is used\n        //\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\n        // bytes of digest DS\n        /*\n         * Create byte sequence S.\n         */\n        // Remark: The salt is limited to 16 chars, how does this make sense?\n        final byte[] sBytes = new byte[saltLen];\n        cp = 0;\n        while (cp < saltLen - blocksize) {\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\n            cp += blocksize;\n        }\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\n\n        // 21. repeat a loop according to the number specified in the rounds=<N>\n        // specification in the salt (or the default value if none is\n        // present). Each round is numbered, starting with 0 and up to N-1.\n        //\n        // The loop uses a digest as input. In the first round it is the\n        // digest produced in step 12. In the latter steps it is the digest\n        // produced in step 21.h. The following text uses the notation\n        // \"digest A/C\" to describe this behavior.\n        /*\n         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\n         */\n        for (int i = 0; i <= rounds - 1; i++) {\n            // a) start digest C\n            /*\n             * New context.\n             */\n            ctx = DigestUtils.getDigest(algorithm);\n\n            // b) for odd round numbers add the byte sequense P to digest C\n            // c) for even round numbers add digest A/C\n            /*\n             * Add key or last result.\n             */\n            if ((i & 1) != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            } else {\n                ctx.update(altResult, 0, blocksize);\n            }\n\n            // d) for all round numbers not divisible by 3 add the byte sequence S\n            /*\n             * Add salt for numbers not divisible by 3.\n             */\n            if (i % 3 != 0) {\n                ctx.update(sBytes, 0, saltLen);\n            }\n\n            // e) for all round numbers not divisible by 7 add the byte sequence P\n            /*\n             * Add key for numbers not divisible by 7.\n             */\n            if (i % 7 != 0) {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            // f) for odd round numbers add digest A/C\n            // g) for even round numbers add the byte sequence P\n            /*\n             * Add key or last result.\n             */\n            if ((i & 1) != 0) {\n                ctx.update(altResult, 0, blocksize);\n            } else {\n                ctx.update(pBytes, 0, keyLen);\n            }\n\n            // h) finish digest C.\n            /*\n             * Create intermediate result.\n             */\n            altResult = ctx.digest();\n        }\n\n        // 22. Produce the output string. This is an ASCII string of the maximum\n        // size specified above, consisting of multiple pieces:\n        //\n        // a) the salt salt_prefix, $5$ or $6$ respectively\n        //\n        // b) the rounds=<N> specification, if one was present in the input\n        // salt string. A trailing '$' is added in this case to separate\n        // the rounds specification from the following text.\n        //\n        // c) the salt string truncated to 16 characters\n        //\n        // d) a '$' character\n        /*\n         * Now we can construct the result string. It consists of three parts.\n         */\n        final StringBuilder buffer = new StringBuilder(saltPrefix);\n        if (roundsCustom) {\n            buffer.append(ROUNDS_PREFIX);\n            buffer.append(rounds);\n            buffer.append(\"$\");\n        }\n        buffer.append(saltString);\n        buffer.append(\"$\");\n\n        // e) the base-64 encoded final C digest. The encoding used is as\n        // follows:\n        // [...]\n        //\n        // Each group of three bytes from the digest produces four\n        // characters as output:\n        //\n        // 1. character: the six low bits of the first byte\n        // 2. character: the two high bits of the first byte and the\n        // four low bytes from the second byte\n        // 3. character: the four high bytes from the second byte and\n        // the two low bits from the third byte\n        // 4. character: the six high bits from the third byte\n        //\n        // The groups of three bytes are as follows (in this sequence).\n        // These are the indices into the byte array containing the\n        // digest, starting with index 0. For the last group there are\n        // not enough bytes left in the digest and the value zero is used\n        // in its place. This group also produces only three or two\n        // characters as output for SHA-512 and SHA-512 respectively.\n\n        // This was just a safeguard in the C implementation:\n        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\n\n        if (blocksize == 32) {\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\n        } else {\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\n        }\n\n        /*\n         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\n         * cannot get any information.\n         */\n        // Is there a better way to do this with the JVM?\n        Arrays.fill(tempResult, (byte) 0);\n        Arrays.fill(pBytes, (byte) 0);\n        Arrays.fill(sBytes, (byte) 0);\n        ctx.reset();\n        altCtx.reset();\n        Arrays.fill(keyBytes, (byte) 0);\n        Arrays.fill(saltBytes, (byte) 0);\n\n        return buffer.toString();\n    }",
        "begin_line": 133,
        "end_line": 507,
        "comment": "\n     * Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n     * <p>\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @param saltPrefix\n     *            either $5$ or $6$\n     * @param blocksize\n     *            a value that differs between $5$ and $6$\n     * @param algorithm\n     *            {@link MessageDigest} algorithm identifier string\n     * @return complete hash value including prefix and salt\n     * @throws IllegalArgumentException\n     *             if the given salt is {@code null} or does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @see MessageDigestAlgorithms\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Sha2Crypt",
        "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])",
        "snippet": "    public static String sha512Crypt(final byte[] keyBytes) {\n        return sha512Crypt(keyBytes, null);\n    }",
        "begin_line": 520,
        "end_line": 522,
        "comment": "\n     * Generates a libc crypt() compatible \"$6$\" hash value with random salt.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @return complete hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Sha2Crypt",
        "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
        "snippet": "    public static String sha512Crypt(final byte[] keyBytes, String salt) {\n        if (salt == null) {\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\n        }\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\n    }",
        "begin_line": 539,
        "end_line": 544,
        "comment": "\n     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext to hash\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
        "snippet": "    private static byte[] digest(final MessageDigest digest, final InputStream data) throws IOException {\n        return updateDigest(digest, data).digest();\n    }",
        "begin_line": 49,
        "end_line": 51,
        "comment": "\n     * Read through an InputStream and returns the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
        "snippet": "    public static MessageDigest getDigest(final String algorithm) {\n        try {\n            return MessageDigest.getInstance(algorithm);\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }",
        "begin_line": 66,
        "end_line": 72,
        "comment": "\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See <a\n     *            href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\">Appendix A in the Java\n     *            Cryptography Architecture Reference Guide</a> for information about standard algorithm\n     *            names.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getMd2Digest()",
        "snippet": "    public static MessageDigest getMd2Digest() {\n        return getDigest(MessageDigestAlgorithms.MD2);\n    }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n     * Returns an MD2 MessageDigest.\n     *\n     * @return An MD2 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD2\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()",
        "snippet": "    public static MessageDigest getMd5Digest() {\n        return getDigest(MessageDigestAlgorithms.MD5);\n    }",
        "begin_line": 97,
        "end_line": 99,
        "comment": "\n     * Returns an MD5 MessageDigest.\n     *\n     * @return An MD5 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#MD5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
        "snippet": "    public static MessageDigest getSha1Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_1);\n    }",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n     * Returns an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_1\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha256Digest()",
        "snippet": "    public static MessageDigest getSha256Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_256);\n    }",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * Returns an SHA-256 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-256 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_256\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha384Digest()",
        "snippet": "    public static MessageDigest getSha384Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_384);\n    }",
        "begin_line": 143,
        "end_line": 145,
        "comment": "\n     * Returns an SHA-384 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-384 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_384\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512Digest()",
        "snippet": "    public static MessageDigest getSha512Digest() {\n        return getDigest(MessageDigestAlgorithms.SHA_512);\n    }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n     * Returns an SHA-512 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @return An SHA-512 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a\n     *             built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_512\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getShaDigest()",
        "snippet": "    @Deprecated\n    public static MessageDigest getShaDigest() {\n        return getSha1Digest();\n    }",
        "begin_line": 171,
        "end_line": 174,
        "comment": "\n     * Returns an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @deprecated Use {@link #getSha1Digest()}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2(byte[])",
        "snippet": "    public static byte[] md2(final byte[] data) {\n        return getMd2Digest().digest(data);\n    }",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2(java.io.InputStream)",
        "snippet": "    public static byte[] md2(final InputStream data) throws IOException {\n        return digest(getMd2Digest(), data);\n    }",
        "begin_line": 198,
        "end_line": 200,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2(java.lang.String)",
        "snippet": "    public static byte[] md2(final String data) {\n        return md2(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 210,
        "end_line": 212,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD2 digest\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[])",
        "snippet": "    public static String md2Hex(final byte[] data) {\n        return Hex.encodeHexString(md2(data));\n    }",
        "begin_line": 222,
        "end_line": 224,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest as a hex string\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(java.io.InputStream)",
        "snippet": "    public static String md2Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(md2(data));\n    }",
        "begin_line": 236,
        "end_line": 238,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(java.lang.String)",
        "snippet": "    public static String md2Hex(final String data) {\n        return Hex.encodeHexString(md2(data));\n    }",
        "begin_line": 248,
        "end_line": 250,
        "comment": "\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD2 digest as a hex string\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(byte[])",
        "snippet": "    public static byte[] md5(final byte[] data) {\n        return getMd5Digest().digest(data);\n    }",
        "begin_line": 259,
        "end_line": 261,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.io.InputStream)",
        "snippet": "    public static byte[] md5(final InputStream data) throws IOException {\n        return digest(getMd5Digest(), data);\n    }",
        "begin_line": 273,
        "end_line": 275,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.lang.String)",
        "snippet": "    public static byte[] md5(final String data) {\n        return md5(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 284,
        "end_line": 286,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD5 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])",
        "snippet": "    public static String md5Hex(final byte[] data) {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 295,
        "end_line": 297,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.io.InputStream)",
        "snippet": "    public static String md5Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 309,
        "end_line": 311,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.lang.String)",
        "snippet": "    public static String md5Hex(final String data) {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 320,
        "end_line": 322,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(byte[])",
        "snippet": "    @Deprecated\n    public static byte[] sha(final byte[] data) {\n        return sha1(data);\n    }",
        "begin_line": 332,
        "end_line": 335,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @deprecated Use {@link #sha1(byte[])}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(java.io.InputStream)",
        "snippet": "    @Deprecated\n    public static byte[] sha(final InputStream data) throws IOException {\n        return sha1(data);\n    }",
        "begin_line": 348,
        "end_line": 351,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     * @deprecated Use {@link #sha1(InputStream)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(java.lang.String)",
        "snippet": "    @Deprecated\n    public static byte[] sha(final String data) {\n        return sha1(data);\n    }",
        "begin_line": 361,
        "end_line": 364,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @deprecated Use {@link #sha1(String)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(byte[])",
        "snippet": "    public static byte[] sha1(final byte[] data) {\n        return getSha1Digest().digest(data);\n    }",
        "begin_line": 374,
        "end_line": 376,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.io.InputStream)",
        "snippet": "    public static byte[] sha1(final InputStream data) throws IOException {\n        return digest(getSha1Digest(), data);\n    }",
        "begin_line": 388,
        "end_line": 390,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.lang.String)",
        "snippet": "    public static byte[] sha1(final String data) {\n        return sha1(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 399,
        "end_line": 401,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-1 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[])",
        "snippet": "    public static String sha1Hex(final byte[] data) {\n        return Hex.encodeHexString(sha1(data));\n    }",
        "begin_line": 411,
        "end_line": 413,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.io.InputStream)",
        "snippet": "    public static String sha1Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha1(data));\n    }",
        "begin_line": 425,
        "end_line": 427,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.lang.String)",
        "snippet": "    public static String sha1Hex(final String data) {\n        return Hex.encodeHexString(sha1(data));\n    }",
        "begin_line": 437,
        "end_line": 439,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(byte[])",
        "snippet": "    public static byte[] sha256(final byte[] data) {\n        return getSha256Digest().digest(data);\n    }",
        "begin_line": 452,
        "end_line": 454,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.io.InputStream)",
        "snippet": "    public static byte[] sha256(final InputStream data) throws IOException {\n        return digest(getSha256Digest(), data);\n    }",
        "begin_line": 469,
        "end_line": 471,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.lang.String)",
        "snippet": "    public static byte[] sha256(final String data) {\n        return sha256(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 484,
        "end_line": 486,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-256 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])",
        "snippet": "    public static String sha256Hex(final byte[] data) {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 499,
        "end_line": 501,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.io.InputStream)",
        "snippet": "    public static String sha256Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 516,
        "end_line": 518,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.lang.String)",
        "snippet": "    public static String sha256Hex(final String data) {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 531,
        "end_line": 533,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(byte[])",
        "snippet": "    public static byte[] sha384(final byte[] data) {\n        return getSha384Digest().digest(data);\n    }",
        "begin_line": 546,
        "end_line": 548,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.io.InputStream)",
        "snippet": "    public static byte[] sha384(final InputStream data) throws IOException {\n        return digest(getSha384Digest(), data);\n    }",
        "begin_line": 563,
        "end_line": 565,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.lang.String)",
        "snippet": "    public static byte[] sha384(final String data) {\n        return sha384(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 578,
        "end_line": 580,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-384 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])",
        "snippet": "    public static String sha384Hex(final byte[] data) {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 593,
        "end_line": 595,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.io.InputStream)",
        "snippet": "    public static String sha384Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 610,
        "end_line": 612,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.lang.String)",
        "snippet": "    public static String sha384Hex(final String data) {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 625,
        "end_line": 627,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(byte[])",
        "snippet": "    public static byte[] sha512(final byte[] data) {\n        return getSha512Digest().digest(data);\n    }",
        "begin_line": 640,
        "end_line": 642,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.io.InputStream)",
        "snippet": "    public static byte[] sha512(final InputStream data) throws IOException {\n        return digest(getSha512Digest(), data);\n    }",
        "begin_line": 657,
        "end_line": 659,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.lang.String)",
        "snippet": "    public static byte[] sha512(final String data) {\n        return sha512(StringUtils.getBytesUtf8(data));\n    }",
        "begin_line": 672,
        "end_line": 674,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])",
        "snippet": "    public static String sha512Hex(final byte[] data) {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 687,
        "end_line": 689,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.io.InputStream)",
        "snippet": "    public static String sha512Hex(final InputStream data) throws IOException {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 704,
        "end_line": 706,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.lang.String)",
        "snippet": "    public static String sha512Hex(final String data) {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 719,
        "end_line": 721,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(byte[])",
        "snippet": "    @Deprecated\n    public static String shaHex(final byte[] data) {\n        return sha1Hex(data);\n    }",
        "begin_line": 731,
        "end_line": 734,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(byte[])}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.io.InputStream)",
        "snippet": "    @Deprecated\n    public static String shaHex(final InputStream data) throws IOException {\n        return sha1Hex(data);\n    }",
        "begin_line": 747,
        "end_line": 750,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     * @deprecated Use {@link #sha1Hex(InputStream)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.lang.String)",
        "snippet": "    @Deprecated\n    public static String shaHex(final String data) {\n        return sha1Hex(data);\n    }",
        "begin_line": 760,
        "end_line": 763,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     *\n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @deprecated Use {@link #sha1Hex(String)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, byte[])",
        "snippet": "    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\n        messageDigest.update(valueToDigest);\n        return messageDigest;\n    }",
        "begin_line": 775,
        "end_line": 778,
        "comment": "\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.InputStream)",
        "snippet": "    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
        "begin_line": 792,
        "end_line": 802,
        "comment": "\n     * Reads through an InputStream and updates the digest for the data\n     *\n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return the digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.8\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.lang.String)",
        "snippet": "    public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\n        return messageDigest;\n    }",
        "begin_line": 815,
        "end_line": 818,
        "comment": "\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest\n     *            the {@link MessageDigest} to update\n     * @param valueToDigest\n     *            the value to update the {@link MessageDigest} with;\n     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/B64.java",
        "class_name": "org.apache.commons.codec.digest.B64",
        "signature": "org.apache.commons.codec.digest.B64.b64from24bit(byte, byte, byte, int, java.lang.StringBuilder)",
        "snippet": "    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\n                             final StringBuilder buffer) {\n        // The bit masking is necessary because the JVM byte type is signed!\n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n        // It's effectively a \"for\" loop but kept to resemble the original C code.\n        int n = outLen;\n        while (n-- > 0) {\n            buffer.append(B64T.charAt(w & 0x3f));\n            w >>= 6;\n        }\n    }",
        "begin_line": 54,
        "end_line": 64,
        "comment": "\n     * Base64 like conversion of bytes to ASCII chars.\n     *\n     * @param b2\n     *            A byte from the result.\n     * @param b1\n     *            A byte from the result.\n     * @param b0\n     *            A byte from the result.\n     * @param outLen\n     *            The number of expected output chars.\n     * @param buffer\n     *            Where the output chars is appended to.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/B64.java",
        "class_name": "org.apache.commons.codec.digest.B64",
        "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int)",
        "snippet": "    static String getRandomSalt(final int num) {\n        final StringBuilder saltString = new StringBuilder();\n        for (int i = 1; i <= num; i++) {\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\n        }\n        return saltString.toString();\n    }",
        "begin_line": 72,
        "end_line": 78,
        "comment": "\n     * Generates a string of random chars from the B64T set.\n     *\n     * @param num\n     *            Number of chars to generate.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/MessageDigestAlgorithms.java",
        "class_name": "org.apache.commons.codec.digest.MessageDigestAlgorithms",
        "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithms.MessageDigestAlgorithms()",
        "snippet": "    private MessageDigestAlgorithms() {\n        // cannot be instantiated.\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Crypt",
        "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[])",
        "snippet": "    public static String crypt(final byte[] keyBytes) {\n        return crypt(keyBytes, null);\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * A random salt and the default algorithm (currently SHA-512) are used. See {@link #crypt(String, String)} for\n     * details.\n     *\n     * @param keyBytes\n     *            plaintext password\n     * @return hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Crypt",
        "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
        "snippet": "    public static String crypt(final byte[] keyBytes, final String salt) {\n        if (salt == null) {\n            return Sha2Crypt.sha512Crypt(keyBytes);\n        } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\n            return Sha2Crypt.sha512Crypt(keyBytes, salt);\n        } else if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {\n            return Sha2Crypt.sha256Crypt(keyBytes, salt);\n        } else if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {\n            return Md5Crypt.md5Crypt(keyBytes, salt);\n        } else {\n            return UnixCrypt.crypt(keyBytes, salt);\n        }\n    }",
        "begin_line": 65,
        "end_line": 77,
        "comment": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See\n     * {@link #crypt(String, String)} for details.\n     *\n     * @param keyBytes\n     *            plaintext password\n     * @param salt\n     *            salt value\n     * @return hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Crypt",
        "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String)",
        "snippet": "    public static String crypt(final String key) {\n        return crypt(key, null);\n    }",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n     * Calculates the digest using the strongest crypt(3) algorithm.\n     * <p>\n     * A random salt and the default algorithm (currently SHA-512) are used.\n     *\n     * @see #crypt(String, String)\n     * @param key\n     *            plaintext password\n     * @return hash value\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/digest/Crypt.java",
        "class_name": "org.apache.commons.codec.digest.Crypt",
        "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
        "snippet": "    public static String crypt(final String key, final String salt) {\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\n    }",
        "begin_line": 148,
        "end_line": 150,
        "comment": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * The exact algorithm depends on the format of the salt string:\n     * <ul>\n     * <li>SHA-512 salts start with $6$ and are up to 16 chars long.\n     * <li>SHA-256 salts start with $5$ and are up to 16 chars long\n     * <li>MD5 salts start with \"$1$\" and are up to 8 chars long\n     * <li>DES, the traditional UnixCrypt algorithm is used else with only 2 chars\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n     * </ul>\n     * The magic strings \"$apr1$\" and \"$2a$\" are not recognised by this method as its output should be identical with\n     * that of the libc implementation.\n     * <p>\n     * The rest of the salt string is drawn from the set [a-zA-Z0-9./] and is cut at the maximum length of if a \"$\"\n     * sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a password\n     * with:\n     *\n     * <pre>\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n     * </pre>\n     * <p>\n     * The resulting string starts with the marker string ($6$), continues with the salt value and ends with a \"$\" sign\n     * followed by the actual hash value. For DES the string only contains the salt and actual hash. It's total length\n     * is dependent on the algorithm used:\n     * <ul>\n     * <li>SHA-512: 106 chars\n     * <li>SHA-256: 63 chars\n     * <li>MD5: 34 chars\n     * <li>DES: 13 chars\n     * </ul>\n     * <p>\n     * Example:\n     *\n     * <pre>\n     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n     * </pre>\n     * <p>\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n     *\n     * @see \"The man page of the libc crypt (3) function.\"\n     * @param key\n     *            plaintext password as entered by the used\n     * @param salt\n     *            salt value\n     * @return hash value, i.e. encrypted password including the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32InputStream",
        "signature": "org.apache.commons.codec.binary.Base32InputStream.Base32InputStream(java.io.InputStream)",
        "snippet": "    public Base32InputStream(final InputStream in) {\n        this(in, false);\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32InputStream",
        "signature": "org.apache.commons.codec.binary.Base32InputStream.Base32InputStream(java.io.InputStream, boolean)",
        "snippet": "    public Base32InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base32(false), doEncode);\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32InputStream",
        "signature": "org.apache.commons.codec.binary.Base32InputStream.Base32InputStream(java.io.InputStream, boolean, int, byte[])",
        "snippet": "    public Base32InputStream(final InputStream in, final boolean doEncode,\n                             final int lineLength, final byte[] lineSeparator) {\n        super(in, new Base32(lineLength, lineSeparator), doEncode);\n    }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\n     *            is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.BaseNCodecInputStream(java.io.InputStream, org.apache.commons.codec.binary.BaseNCodec, boolean)",
        "snippet": "    protected BaseNCodecInputStream(final InputStream in, final BaseNCodec baseNCodec, final boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }",
        "begin_line": 44,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.available()",
        "snippet": "    @Override\n    public int available() throws IOException {\n        // Note: the logic is similar to the InflaterInputStream:\n        //       as long as we have not reached EOF, indicate that there is more\n        //       data available. As we do not know for sure how much data is left,\n        //       just return 1 as a safe guess.\n\n        return context.eof ? 0 : 1;\n    }",
        "begin_line": 57,
        "end_line": 65,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n     * <code>1</code> otherwise\n     * @since 1.7\n     ",
        "resolved_comments": {
            "java.io.FilterInputStream": null
        }
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.mark(int)",
        "snippet": "    @Override\n    public synchronized void mark(final int readLimit) {\n    }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n     * Marks the current position in this input stream.\n     * <p>The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.</p>\n     *\n     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.markSupported()",
        "snippet": "    @Override\n    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }",
        "begin_line": 83,
        "end_line": 86,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @return always returns <code>false</code>\n     ",
        "resolved_comments": {
            "java.io.FilterInputStream": null
        }
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
        "snippet": "    @Override\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            final byte b = singleByte[0];\n            return b < 0 ? 256 + b : b;\n        }\n        return EOF;\n    }",
        "begin_line": 95,
        "end_line": 106,
        "comment": "\n     * Reads one <code>byte</code> from this input stream.\n     *\n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
        "snippet": "    @Override\n    public int read(final byte b[], final int offset, final int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base32, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!baseNCodec.hasData(context)) {\n                    final byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    final int c = in.read(buf);\n                    if (doEncode) {\n                        baseNCodec.encode(buf, 0, c, context);\n                    } else {\n                        baseNCodec.decode(buf, 0, c, context);\n                    }\n                }\n                readLen = baseNCodec.readResults(b, offset, len, context);\n            }\n            return readLen;\n        }\n    }",
        "begin_line": 127,
        "end_line": 169,
        "comment": "\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     *\n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.reset()",
        "snippet": "    @Override\n    public synchronized void reset() throws IOException {\n        throw new IOException(\"mark/reset not supported\");\n    }",
        "begin_line": 179,
        "end_line": 182,
        "comment": "\n     * Repositions this stream to the position at the time the mark method was last called on this input stream.\n     * <p>\n     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.\n     *\n     * @throws IOException if this method is invoked\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecInputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
        "snippet": "    @Override\n    public long skip(final long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Negative skip length: \" + n);\n        }\n\n        // skip in chunks of 512 bytes\n        final byte[] b = new byte[512];\n        long todo = n;\n\n        while (todo > 0) {\n            int len = (int) Math.min(b.length, todo);\n            len = this.read(b, 0, len);\n            if (len == EOF) {\n                break;\n            }\n            todo -= len;\n        }\n\n        return n - todo;\n    }",
        "begin_line": 190,
        "end_line": 210,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the provided skip length is negative\n     * @since 1.7\n     ",
        "resolved_comments": {
            "java.io.FilterInputStream": null
        }
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }",
        "begin_line": 80,
        "end_line": 85,
        "comment": "\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
        "snippet": "    public static byte[] getBytesIso8859_1(final String string) {\n        return getBytes(string, Charsets.ISO_8859_1);\n    }",
        "begin_line": 101,
        "end_line": 103,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(java.lang.String, java.lang.String)",
        "snippet": "    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }",
        "begin_line": 125,
        "end_line": 134,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
        "snippet": "    public static byte[] getBytesUsAscii(final String string) {\n        return getBytes(string, Charsets.US_ASCII);\n    }",
        "begin_line": 150,
        "end_line": 152,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16(final String string) {\n        return getBytes(string, Charsets.UTF_16);\n    }",
        "begin_line": 168,
        "end_line": 170,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16Be(final String string) {\n        return getBytes(string, Charsets.UTF_16BE);\n    }",
        "begin_line": 186,
        "end_line": 188,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16Le(final String string) {\n        return getBytes(string, Charsets.UTF_16LE);\n    }",
        "begin_line": 204,
        "end_line": 206,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf8(final String string) {\n        return getBytes(string, Charsets.UTF_8);\n    }",
        "begin_line": 222,
        "end_line": 224,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newIllegalStateException(java.lang.String, java.io.UnsupportedEncodingException)",
        "snippet": "    private static IllegalStateException newIllegalStateException(final String charsetName,\n                                                                  final UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }",
        "begin_line": 226,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
        "snippet": "    private static String newString(final byte[] bytes, final Charset charset) {\n        return bytes == null ? null : new String(bytes, charset);\n    }",
        "begin_line": 244,
        "end_line": 246,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.lang.String)",
        "snippet": "    public static String newString(final byte[] bytes, final String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }",
        "begin_line": 267,
        "end_line": 276,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])",
        "snippet": "    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }",
        "begin_line": 290,
        "end_line": 292,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
        "snippet": "    public static String newStringUsAscii(final byte[] bytes) {\n        return new String(bytes, Charsets.US_ASCII);\n    }",
        "begin_line": 306,
        "end_line": 308,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])",
        "snippet": "    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }",
        "begin_line": 322,
        "end_line": 324,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])",
        "snippet": "    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }",
        "begin_line": 338,
        "end_line": 340,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])",
        "snippet": "    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }",
        "begin_line": 354,
        "end_line": 356,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
        "snippet": "    public static String newStringUtf8(final byte[] bytes) {\n        return newString(bytes, Charsets.UTF_8);\n    }",
        "begin_line": 370,
        "end_line": 372,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream)",
        "snippet": "    public Base64InputStream(final InputStream in) {\n        this(in, false);\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream, boolean)",
        "snippet": "    public Base64InputStream(final InputStream in, final boolean doEncode) {\n        super(in, new Base64(false), doEncode);\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream, boolean, int, byte[])",
        "snippet": "    public Base64InputStream(final InputStream in, final boolean doEncode,\n                             final int lineLength, final byte[] lineSeparator) {\n        super(in, new Base64(lineLength, lineSeparator), doEncode);\n    }",
        "begin_line": 84,
        "end_line": 87,
        "comment": "\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.Context.Context()",
        "snippet": "        Context() {\n        }",
        "begin_line": 92,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.Context.toString()",
        "snippet": "        @SuppressWarnings(\"boxing\") // OK to ignore boxing here\n        @Override\n        public String toString() {\n            return String.format(\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \" +\n                    \"modulus=%s, pos=%s, readPos=%s]\", this.getClass().getSimpleName(), Arrays.toString(buffer),\n                    currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);\n        }",
        "begin_line": 100,
        "end_line": 106,
        "comment": "\n         * Returns a String useful for debugging (especially within a debugger.)\n         *\n         * @return a String useful for debugging.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.BaseNCodec(int, int, int, int)",
        "snippet": "    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\n                         final int lineLength, final int chunkSeparatorLength) {\n        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);\n    }",
        "begin_line": 190,
        "end_line": 193,
        "comment": "\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n     * @param chunkSeparatorLength the chunk separator length, if relevant\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.BaseNCodec(int, int, int, int, byte)",
        "snippet": "    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\n                         final int lineLength, final int chunkSeparatorLength, final byte pad) {\n        this.unencodedBlockSize = unencodedBlockSize;\n        this.encodedBlockSize = encodedBlockSize;\n        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n        this.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n        this.chunkSeparatorLength = chunkSeparatorLength;\n\n        this.pad = pad;\n    }",
        "begin_line": 204,
        "end_line": 213,
        "comment": "\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n     * @param chunkSeparatorLength the chunk separator length, if relevant\n     * @param pad byte used as padding byte.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.hasData(org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    boolean hasData(final Context context) {  // package protected for access from I/O streams\n        return context.buffer != null;\n    }",
        "begin_line": 221,
        "end_line": 223,
        "comment": "\n     * Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.available(org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    int available(final Context context) {  // package protected for access from I/O streams\n        return context.buffer != null ? context.pos - context.readPos : 0;\n    }",
        "begin_line": 231,
        "end_line": 233,
        "comment": "\n     * Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.getDefaultBufferSize()",
        "snippet": "    protected int getDefaultBufferSize() {\n        return DEFAULT_BUFFER_SIZE;\n    }",
        "begin_line": 240,
        "end_line": 242,
        "comment": "\n     * Get the default buffer size. Can be overridden.\n     *\n     * @return {@link #DEFAULT_BUFFER_SIZE}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    private byte[] resizeBuffer(final Context context) {\n        if (context.buffer == null) {\n            context.buffer = new byte[getDefaultBufferSize()];\n            context.pos = 0;\n            context.readPos = 0;\n        } else {\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n            context.buffer = b;\n        }\n        return context.buffer;\n    }",
        "begin_line": 248,
        "end_line": 259,
        "comment": "\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    protected byte[] ensureBufferSize(final int size, final Context context){\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n            return resizeBuffer(context);\n        }\n        return context.buffer;\n    }",
        "begin_line": 267,
        "end_line": 272,
        "comment": "\n     * Ensure that the buffer has room for <code>size</code> bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\n        if (context.buffer != null) {\n            final int len = Math.min(available(context), bAvail);\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n            context.readPos += len;\n            if (context.readPos >= context.pos) {\n                context.buffer = null; // so hasData() will return false, and this method can return -1\n            }\n            return len;\n        }\n        return context.eof ? EOF : 0;\n    }",
        "begin_line": 290,
        "end_line": 301,
        "comment": "\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package protected for access from I/O streams.\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.isWhiteSpace(byte)",
        "snippet": "    protected static boolean isWhiteSpace(final byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }",
        "begin_line": 310,
        "end_line": 320,
        "comment": "\n     * Checks if a byte value is whitespace or not.\n     * Whitespace is taken to mean: space, tab, CR, LF\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n        }\n        return encode((byte[]) obj);\n    }",
        "begin_line": 332,
        "end_line": 338,
        "comment": "\n     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
        "snippet": "    public String encodeToString(final byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }",
        "begin_line": 348,
        "end_line": 350,
        "comment": "\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
        "snippet": "    public String encodeAsString(final byte[] pArray){\n        return StringUtils.newStringUtf8(encode(pArray));\n    }",
        "begin_line": 359,
        "end_line": 361,
        "comment": "\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n    ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object obj) throws DecoderException {\n        if (obj instanceof byte[]) {\n            return decode((byte[]) obj);\n        } else if (obj instanceof String) {\n            return decode((String) obj);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base-N decode is not a byte[] or a String\");\n        }\n    }",
        "begin_line": 374,
        "end_line": 383,
        "comment": "\n     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     *\n     * @param obj\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String\n     *         supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
        "snippet": "    public byte[] decode(final String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }",
        "begin_line": 392,
        "end_line": 394,
        "comment": "\n     * Decodes a String containing characters in the Base-N alphabet.\n     *\n     * @param pArray\n     *            A String containing Base-N character data\n     * @return a byte array containing binary data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
        "snippet": "    @Override\n    public byte[] decode(final byte[] pArray) {\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        final Context context = new Context();\n        decode(pArray, 0, pArray.length, context);\n        decode(pArray, 0, EOF, context); // Notify decoder of EOF.\n        final byte[] result = new byte[context.pos];\n        readResults(result, 0, result.length, context);\n        return result;\n    }",
        "begin_line": 403,
        "end_line": 414,
        "comment": "\n     * Decodes a byte[] containing characters in the Base-N alphabet.\n     *\n     * @param pArray\n     *            A byte array containing Base-N character data\n     * @return a byte array containing binary data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
        "snippet": "    @Override\n    public byte[] encode(final byte[] pArray) {\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        final Context context = new Context();\n        encode(pArray, 0, pArray.length, context);\n        encode(pArray, 0, EOF, context); // Notify encoder of EOF.\n        final byte[] buf = new byte[context.pos - context.readPos];\n        readResults(buf, 0, buf.length, context);\n        return buf;\n    }",
        "begin_line": 423,
        "end_line": 434,
        "comment": "\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only the basen alphabetic character data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    abstract void encode(byte[] pArray, int i, int length, Context context);",
        "begin_line": 437,
        "end_line": 437,
        "comment": " package protected for access from I/O streams",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    abstract void decode(byte[] pArray, int i, int length, Context context);",
        "begin_line": 440,
        "end_line": 440,
        "comment": " package protected for access from I/O streams",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)",
        "snippet": "    protected abstract boolean isInAlphabet(byte value);",
        "begin_line": 450,
        "end_line": 450,
        "comment": "\n     * Returns whether or not the <code>octet</code> is in the current alphabet.\n     * Does not allow whitespace or pad.\n     *\n     * @param value The value to test\n     *\n     * @return {@code true} if the value is defined in the current alphabet, {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[], boolean)",
        "snippet": "    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isInAlphabet(arrayOctet[i]) &&\n                    (!allowWSPad || (arrayOctet[i] != pad) && !isWhiteSpace(arrayOctet[i]))) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 462,
        "end_line": 470,
        "comment": "\n     * Tests a given byte array to see if it contains only valid characters within the alphabet.\n     * The method optionally treats whitespace and pad as valid.\n     *\n     * @param arrayOctet byte array to test\n     * @param allowWSPad if {@code true}, then whitespace and PAD are also allowed\n     *\n     * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(java.lang.String)",
        "snippet": "    public boolean isInAlphabet(final String basen) {\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n    }",
        "begin_line": 481,
        "end_line": 483,
        "comment": "\n     * Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return {@code true} if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     * @see #isInAlphabet(byte[], boolean)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.containsAlphabetOrPad(byte[])",
        "snippet": "    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n        if (arrayOctet == null) {\n            return false;\n        }\n        for (final byte element : arrayOctet) {\n            if (pad == element || isInAlphabet(element)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 494,
        "end_line": 504,
        "comment": "\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodec.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodec",
        "signature": "org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])",
        "snippet": "    public long getEncodedLength(final byte[] pArray) {\n        // Calculate non-chunked size - rounded up to allow for padding\n        // cast to long is needed to avoid possibility of overflow\n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n        if (lineLength > 0) { // We're using chunking\n            // Round up to nearest multiple\n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n        }\n        return len;\n    }",
        "begin_line": 514,
        "end_line": 523,
        "comment": "\n     * Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encoded the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32OutputStream",
        "signature": "org.apache.commons.codec.binary.Base32OutputStream.Base32OutputStream(java.io.OutputStream)",
        "snippet": "    public Base32OutputStream(final OutputStream out) {\n        this(out, true);\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32OutputStream",
        "signature": "org.apache.commons.codec.binary.Base32OutputStream.Base32OutputStream(java.io.OutputStream, boolean)",
        "snippet": "    public Base32OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out, new Base32(false), doEncode);\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base32OutputStream",
        "signature": "org.apache.commons.codec.binary.Base32OutputStream.Base32OutputStream(java.io.OutputStream, boolean, int, byte[])",
        "snippet": "    public Base32OutputStream(final OutputStream out, final boolean doEncode,\n                              final int lineLength, final byte[] lineSeparator) {\n        super(out, new Base32(lineLength, lineSeparator), doEncode);\n    }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64()",
        "snippet": "    public Base64() {\n        this(0);\n    }",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(boolean)",
        "snippet": "    public Base64(final boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }",
        "begin_line": 188,
        "end_line": 190,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     *\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param urlSafe\n     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to {@code false}.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int)",
        "snippet": "    public Base64(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }",
        "begin_line": 211,
        "end_line": 213,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int, byte[])",
        "snippet": "    public Base64(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }",
        "begin_line": 238,
        "end_line": 240,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int, byte[], boolean)",
        "snippet": "    public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length);\n        // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\n        // @see test case Base64Test.testConstructors()\n        if (lineSeparator != null) {\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n            }\n            if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n                this.lineSeparator = new byte[lineSeparator.length];\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n            } else {\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n                this.lineSeparator = null;\n            }\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }",
        "begin_line": 269,
        "end_line": 294,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isUrlSafe()",
        "snippet": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }",
        "begin_line": 302,
        "end_line": 304,
        "comment": "\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     *\n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        if (context.eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; // no leftovers to process and not using chunking\n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { // 0-2\n                case 0 : // nothing to do here\n                    break;\n                case 1 : // 8 bits = 6 + 2\n                    // top 6 bits:\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\n                    // remaining 2:\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[context.pos++] = pad;\n                        buffer[context.pos++] = pad;\n                    }\n                    break;\n\n                case 2 : // 16 bits = 6 + 6 + 4\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[context.pos++] = pad;\n                    }\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n            if (lineLength > 0 && context.currentLinePos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE\n                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\n                    buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }",
        "begin_line": 327,
        "end_line": 397,
        "comment": "\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, to flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p><b>Note: no padding is added when encoding using the URL-safe alphabet.</b></p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context\n     *            the context to be used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n            final byte b = in[inPos++];\n            if (b == pad) {\n                // We're done.\n                context.eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    final int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) {\n                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (context.eof && context.modulus != 0) {\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            // We have some spare bits remaining\n            // Output all whole multiples of 8 bits and ignore the rest\n            switch (context.modulus) {\n//              case 0 : // impossible, as excluded above\n                case 1 : // 6 bits - ignore entirely\n                    // TODO not currently tested; perhaps it is impossible?\n                    break;\n                case 2 : // 12 bits = 8 + 4\n                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                    break;\n                case 3 : // 18 bits = 8 + 8 + 2\n                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }",
        "begin_line": 424,
        "end_line": 481,
        "comment": "\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context\n     *            the context to be used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isArrayByteBase64(byte[])",
        "snippet": "    @Deprecated\n    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\n        return isBase64(arrayOctet);\n    }",
        "begin_line": 493,
        "end_line": 496,
        "comment": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte)",
        "snippet": "    public static boolean isBase64(final byte octet) {\n        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }",
        "begin_line": 506,
        "end_line": 508,
        "comment": "\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the the base 64 alphabet, {@code false} otherwise.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isBase64(java.lang.String)",
        "snippet": "    public static boolean isBase64(final String base64) {\n        return isBase64(StringUtils.getBytesUtf8(base64));\n    }",
        "begin_line": 520,
        "end_line": 522,
        "comment": "\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param base64\n     *            String to test\n     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     *  @since 1.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
        "snippet": "    public static boolean isBase64(final byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 534,
        "end_line": 541,
        "comment": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     * @since 1.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
        "snippet": "    public static byte[] encodeBase64(final byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }",
        "begin_line": 550,
        "end_line": 552,
        "comment": "\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
        "snippet": "    public static String encodeBase64String(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }",
        "begin_line": 565,
        "end_line": 567,
        "comment": "\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[])",
        "snippet": "    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }",
        "begin_line": 578,
        "end_line": 580,
        "comment": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[])",
        "snippet": "    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }",
        "begin_line": 591,
        "end_line": 593,
        "comment": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
        "snippet": "    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }",
        "begin_line": 602,
        "end_line": 604,
        "comment": "\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
        "snippet": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }",
        "begin_line": 617,
        "end_line": 619,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean)",
        "snippet": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }",
        "begin_line": 636,
        "end_line": 638,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean, int)",
        "snippet": "    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                      final boolean urlSafe, final int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        // Create this so can use the super-class method\n        // Also ensures that the same roundings are performed by the ctor and the code\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        final long len = b64.getEncodedLength(binaryData);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maximum size of \" +\n                maxResultSize);\n        }\n\n        return b64.encode(binaryData);\n    }",
        "begin_line": 657,
        "end_line": 675,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
        "snippet": "    public static byte[] decodeBase64(final String base64String) {\n        return new Base64().decode(base64String);\n    }",
        "begin_line": 685,
        "end_line": 687,
        "comment": "\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
        "snippet": "    public static byte[] decodeBase64(final byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }",
        "begin_line": 696,
        "end_line": 698,
        "comment": "\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
        "snippet": "    public static BigInteger decodeInteger(final byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }",
        "begin_line": 711,
        "end_line": 713,
        "comment": "\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
        "snippet": "    public static byte[] encodeInteger(final BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }",
        "begin_line": 725,
        "end_line": 730,
        "comment": "\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     *\n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.toIntegerBytes(java.math.BigInteger)",
        "snippet": "    static byte[] toIntegerBytes(final BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        final byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        final byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }",
        "begin_line": 739,
        "end_line": 761,
        "comment": "\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     *\n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isInAlphabet(byte)",
        "snippet": "    @Override\n    protected boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }",
        "begin_line": 770,
        "end_line": 773,
        "comment": "\n     * Returns whether or not the <code>octet</code> is in the Base64 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the the Base64 alphabet {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32()",
        "snippet": "    public Base32() {\n        this(false);\n    }",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(byte)",
        "snippet": "    public Base32(final byte pad) {\n        this(false, pad);\n    }",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param pad byte used as padding byte.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(boolean)",
        "snippet": "    public Base32(final boolean useHex) {\n        this(0, null, useHex, PAD_DEFAULT);\n    }",
        "begin_line": 180,
        "end_line": 182,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(boolean, byte)",
        "snippet": "    public Base32(final boolean useHex, final byte pad) {\n        this(0, null, useHex, pad);\n    }",
        "begin_line": 192,
        "end_line": 194,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     * @param pad byte used as padding byte.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(int)",
        "snippet": "    public Base32(final int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }",
        "begin_line": 207,
        "end_line": 209,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(int, byte[])",
        "snippet": "    public Base32(final int lineLength, final byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n    }",
        "begin_line": 229,
        "end_line": 231,
        "comment": "\n     * Creates a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(int, byte[], boolean)",
        "snippet": "    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n    }",
        "begin_line": 254,
        "end_line": 256,
        "comment": "\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.Base32(int, byte[], boolean, byte)",
        "snippet": "    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\n        if (useHex) {\n            this.encodeTable = HEX_ENCODE_TABLE;\n            this.decodeTable = HEX_DECODE_TABLE;\n        } else {\n            this.encodeTable = ENCODE_TABLE;\n            this.decodeTable = DECODE_TABLE;\n        }\n        if (lineLength > 0) {\n            if (lineSeparator == null) {\n                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n            }\n            // Must be done after initializing the tables\n            if (containsAlphabetOrPad(lineSeparator)) {\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n            }\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n            this.lineSeparator = new byte[lineSeparator.length];\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        } else {\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n            this.lineSeparator = null;\n        }\n        this.decodeSize = this.encodeSize - 1;\n\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n        }\n    }",
        "begin_line": 280,
        "end_line": 311,
        "comment": "\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param useHex\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param pad byte used as padding byte.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     *             lineLength &gt; 0 and lineSeparator is null.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    @Override\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte b = in[inPos++];\n            if (b == pad) {\n                // We're done.\n                context.eof = true;\n                break;\n            } else {\n                final byte[] buffer = ensureBufferSize(decodeSize, context);\n                if (b >= 0 && b < this.decodeTable.length) {\n                    final int result = this.decodeTable[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                        // collect decoded bytes\n                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) { // we can output the 5 bytes\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            //  we ignore partial bytes, i.e. only multiples of 8 count\n            switch (context.modulus) {\n                case 2 : // 10 bits, drop 2 and output one byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                    break;\n                case 3 : // 15 bits, drop 7 and output 1 byte\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                    break;\n                case 4 : // 20 bits = 2*8 + 4\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 5 : // 25bits = 3*8 + 1\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 6 : // 30bits = 3*8 + 6\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                case 7 : // 35 = 4*8 +3\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                    break;\n                default:\n                    // modulus can be 0-7, and we excluded 0,1 already\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n        }\n    }",
        "begin_line": 335,
        "end_line": 414,
        "comment": "\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to Base32 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     *\n     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
        "snippet": "    @Override\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n        // package protected for access from I/O streams\n\n        if (context.eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            context.eof = true;\n            if (0 == context.modulus && lineLength == 0) {\n                return; // no leftovers to process and not using chunking\n            }\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\n            final int savedPos = context.pos;\n            switch (context.modulus) { // % 5\n                case 0 :\n                    break;\n                case 1 : // Only 1 octet; take top 5 bits then remainder\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 2 : // 2 octets = 16 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 3 : // 3 octets = 24 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    buffer[context.pos++] = pad;\n                    break;\n                case 4 : // 4 octets = 32 bits to use\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n                    buffer[context.pos++] = pad;\n                    break;\n                default:\n                    throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n            }\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                context.pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\n                if (0 == context.modulus) { // we have enough bytes to create our output\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                        context.pos += lineSeparator.length;\n                        context.currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }",
        "begin_line": 431,
        "end_line": 526,
        "comment": "\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 5).\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to Base32 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "class_name": "org.apache.commons.codec.binary.Base32",
        "signature": "org.apache.commons.codec.binary.Base32.isInAlphabet(byte)",
        "snippet": "    @Override\n    public boolean isInAlphabet(final byte octet) {\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n    }",
        "begin_line": 535,
        "end_line": 538,
        "comment": "\n     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream)",
        "snippet": "    public Base64OutputStream(final OutputStream out) {\n        this(out, true);\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream, boolean)",
        "snippet": "    public Base64OutputStream(final OutputStream out, final boolean doEncode) {\n        super(out,new Base64(false), doEncode);\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream, boolean, int, byte[])",
        "snippet": "    public Base64OutputStream(final OutputStream out, final boolean doEncode,\n                              final int lineLength, final byte[] lineSeparator) {\n        super(out, new Base64(lineLength, lineSeparator), doEncode);\n    }",
        "begin_line": 84,
        "end_line": 87,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
        "snippet": "    public static byte[] decodeHex(final char[] data) throws DecoderException {\n\n        final int len = data.length;\n\n        if ((len & 0x01) != 0) {\n            throw new DecoderException(\"Odd number of characters.\");\n        }\n\n        final byte[] out = new byte[len >> 1];\n\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n\n        return out;\n    }",
        "begin_line": 77,
        "end_line": 97,
        "comment": "\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param data\n     *            An array of characters containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException\n     *             Thrown if an odd number or illegal of characters is supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
        "snippet": "    public static char[] encodeHex(final byte[] data) {\n        return encodeHex(data, true);\n    }",
        "begin_line": 108,
        "end_line": 110,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A char[] containing hexadecimal characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
        "snippet": "    public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n    }",
        "begin_line": 124,
        "end_line": 126,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toLowerCase\n     *            {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], char[])",
        "snippet": "    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n            out[j++] = toDigits[0x0F & data[i]];\n        }\n        return out;\n    }",
        "begin_line": 140,
        "end_line": 149,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toDigits\n     *            the output alphabet\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
        "snippet": "    public static String encodeHexString(final byte[] data) {\n        return new String(encodeHex(data));\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A String containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.toDigit(char, int)",
        "snippet": "    protected static int toDigit(final char ch, final int index) throws DecoderException {\n        final int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new DecoderException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }",
        "begin_line": 175,
        "end_line": 181,
        "comment": "\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch\n     *            A character to convert to an integer digit\n     * @param index\n     *            The index of the character in the source\n     * @return An integer\n     * @throws DecoderException\n     *             Thrown if ch is an illegal hex character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.Hex()",
        "snippet": "    public Hex() {\n        // use default encoding\n        this.charset = DEFAULT_CHARSET;\n    }",
        "begin_line": 188,
        "end_line": 191,
        "comment": "\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.Hex(java.nio.charset.Charset)",
        "snippet": "    public Hex(final Charset charset) {\n        this.charset = charset;\n    }",
        "begin_line": 200,
        "end_line": 202,
        "comment": "\n     * Creates a new codec with the given Charset.\n     *\n     * @param charset\n     *            the charset.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.Hex(java.lang.String)",
        "snippet": "    public Hex(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Creates a new codec with the given charset name.\n     *\n     * @param charsetName\n     *            the charset name.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.4\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
        "snippet": "    @Override\n    public byte[] decode(final byte[] array) throws DecoderException {\n        return decodeHex(new String(array, getCharset()).toCharArray());\n    }",
        "begin_line": 230,
        "end_line": 233,
        "comment": "\n     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param array\n     *            An array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException\n     *             Thrown if an odd number of characters is supplied to this function\n     * @see #decodeHex(char[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object object) throws DecoderException {\n        try {\n            final char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n            return decodeHex(charArray);\n        } catch (final ClassCastException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 248,
        "end_line": 256,
        "comment": "\n     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param object\n     *            A String or, an array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException\n     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\n     *             char[]\n     * @see #decodeHex(char[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
        "snippet": "    @Override\n    public byte[] encode(final byte[] array) {\n        return encodeHexString(array).getBytes(this.getCharset());\n    }",
        "begin_line": 273,
        "end_line": 276,
        "comment": "\n     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n     * represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n     * {@link #getCharset()}.\n     * </p>\n     *\n     * @param array\n     *            a byte[] to convert to Hex characters\n     * @return A byte[] containing the bytes of the hexadecimal characters\n     * @since 1.7 No longer throws IllegalStateException if the charsetName is invalid.\n     * @see #encodeHex(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object object) throws EncoderException {\n        try {\n            final byte[] byteArray = object instanceof String ?\n                                   ((String) object).getBytes(this.getCharset()) : (byte[]) object;\n            return encodeHex(byteArray);\n        } catch (final ClassCastException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 294,
        "end_line": 303,
        "comment": "\n     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n     * characters to represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n     * {@link #getCharset()}.\n     * </p>\n     *\n     * @param object\n     *            a String, or byte[] to convert to Hex characters\n     * @return A char[] containing hexadecimal characters\n     * @throws EncoderException\n     *             Thrown if the given object is not a String or byte[]\n     * @see #encodeHex(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
        "snippet": "    public Charset getCharset() {\n        return this.charset;\n    }",
        "begin_line": 311,
        "end_line": 313,
        "comment": "\n     * Gets the charset.\n     *\n     * @return the charset.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.getCharsetName()",
        "snippet": "    public String getCharsetName() {\n        return this.charset.name();\n    }",
        "begin_line": 321,
        "end_line": 323,
        "comment": "\n     * Gets the charset name.\n     *\n     * @return the charset name.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return super.toString() + \"[charsetName=\" + this.charset + \"]\";\n    }",
        "begin_line": 330,
        "end_line": 333,
        "comment": "\n     * Returns a string representation of the object, which includes the charset name.\n     *\n     * @return a string representation of the object.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.BaseNCodecOutputStream(java.io.OutputStream, org.apache.commons.codec.binary.BaseNCodec, boolean)",
        "snippet": "    public BaseNCodecOutputStream(final OutputStream out, final BaseNCodec basedCodec, final boolean doEncode) {\n        super(out);\n        this.baseNCodec = basedCodec;\n        this.doEncode = doEncode;\n    }",
        "begin_line": 45,
        "end_line": 49,
        "comment": " TODO should this be protected?",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(int)",
        "snippet": "    @Override\n    public void write(final int i) throws IOException {\n        singleByte[0] = (byte) i;\n        write(singleByte, 0, 1);\n    }",
        "begin_line": 59,
        "end_line": 63,
        "comment": "\n     * Writes the specified <code>byte</code> to this output stream.\n     *\n     * @param i\n     *            source byte\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
        "snippet": "    @Override\n    public void write(final byte b[], final int offset, final int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len > 0) {\n            if (doEncode) {\n                baseNCodec.encode(b, offset, len, context);\n            } else {\n                baseNCodec.decode(b, offset, len, context);\n            }\n            flush(false);\n        }\n    }",
        "begin_line": 83,
        "end_line": 99,
        "comment": "\n     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n     * output stream.\n     *\n     * @param b\n     *            source byte array\n     * @param offset\n     *            where to start reading the bytes\n     * @param len\n     *            maximum number of bytes to write\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean)",
        "snippet": "    private void flush(final boolean propagate) throws IOException {\n        final int avail = baseNCodec.available(context);\n        if (avail > 0) {\n            final byte[] buf = new byte[avail];\n            final int c = baseNCodec.readResults(buf, 0, avail, context);\n            if (c > 0) {\n                out.write(buf, 0, c);\n            }\n        }\n        if (propagate) {\n            out.flush();\n        }\n    }",
        "begin_line": 110,
        "end_line": 122,
        "comment": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\n     * true, the wrapped stream will also be flushed.\n     *\n     * @param propagate\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.flush()",
        "snippet": "    @Override\n    public void flush() throws IOException {\n        flush(true);\n    }",
        "begin_line": 130,
        "end_line": 133,
        "comment": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java",
        "class_name": "org.apache.commons.codec.binary.BaseNCodecOutputStream",
        "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.close()",
        "snippet": "    @Override\n    public void close() throws IOException {\n        // Notify encoder of EOF (-1).\n        if (doEncode) {\n            baseNCodec.encode(singleByte, 0, EOF, context);\n        } else {\n            baseNCodec.decode(singleByte, 0, EOF, context);\n        }\n        flush();\n        out.close();\n    }",
        "begin_line": 141,
        "end_line": 151,
        "comment": "\n     * Closes this output stream and releases any system resources associated with the stream.\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(byte[])",
        "snippet": "    @Override\n    public byte[] encode(final byte[] raw) {\n        return toAsciiBytes(raw);\n    }",
        "begin_line": 81,
        "end_line": 84,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character bytes one for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object raw) throws EncoderException {\n        if (!(raw instanceof byte[])) {\n            throw new EncoderException(\"argument not a byte array\");\n        }\n        return toAsciiChars((byte[]) raw);\n    }",
        "begin_line": 96,
        "end_line": 102,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\n     * @throws EncoderException\n     *                  if the argument is not a byte[]\n     * @see org.apache.commons.codec.Encoder#encode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object ascii) throws DecoderException {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        if (ascii instanceof byte[]) {\n            return fromAscii((byte[]) ascii);\n        }\n        if (ascii instanceof char[]) {\n            return fromAscii((char[]) ascii);\n        }\n        if (ascii instanceof String) {\n            return fromAscii(((String) ascii).toCharArray());\n        }\n        throw new DecoderException(\"argument not a byte array\");\n    }",
        "begin_line": 114,
        "end_line": 129,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @throws DecoderException\n     *                  if argument is not a byte[], char[] or String\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(byte[])",
        "snippet": "    @Override\n    public byte[] decode(final byte[] ascii) {\n        return fromAscii(ascii);\n    }",
        "begin_line": 139,
        "end_line": 142,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toByteArray(java.lang.String)",
        "snippet": "    public byte[] toByteArray(final String ascii) {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return fromAscii(ascii.toCharArray());\n    }",
        "begin_line": 152,
        "end_line": 157,
        "comment": "\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])",
        "snippet": "    public static byte[] fromAscii(final char[] ascii) {\n        if (ascii == null || ascii.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get length/8 times bytes with 3 bit shifts to the right of the length\n        final byte[] l_raw = new byte[ascii.length >> 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '1') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }",
        "begin_line": 171,
        "end_line": 189,
        "comment": "\n     * Decodes a char array where each char represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each char represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])",
        "snippet": "    public static byte[] fromAscii(final byte[] ascii) {\n        if (isEmpty(ascii)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get length/8 times bytes with 3 bit shifts to the right of the length\n        final byte[] l_raw = new byte[ascii.length >> 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '1') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }",
        "begin_line": 198,
        "end_line": 216,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
        "snippet": "    private static boolean isEmpty(final byte[] array) {\n        return array == null || array.length == 0;\n    }",
        "begin_line": 225,
        "end_line": 227,
        "comment": "\n     * Returns {@code true} if the given array is {@code null} or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return {@code true} if the given array is {@code null} or empty (size 0.)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])",
        "snippet": "    public static byte[] toAsciiBytes(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        final byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '0';\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
        "begin_line": 238,
        "end_line": 258,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])",
        "snippet": "    public static char[] toAsciiChars(final byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        final char[] l_ascii = new char[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '0';\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
        "begin_line": 268,
        "end_line": 288,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[])",
        "snippet": "    public static String toAsciiString(final byte[] raw) {\n        return new String(toAsciiChars(raw));\n    }",
        "begin_line": 298,
        "end_line": 300,
        "comment": "\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.QuotedPrintableCodec()",
        "snippet": "    public QuotedPrintableCodec() {\n        this(Charsets.UTF_8);\n    }",
        "begin_line": 93,
        "end_line": 95,
        "comment": "\n     * Default constructor, assumes default charset of {@link Charsets#UTF_8}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.QuotedPrintableCodec(java.nio.charset.Charset)",
        "snippet": "    public QuotedPrintableCodec(final Charset charset) {\n        this.charset = charset;\n    }",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.QuotedPrintableCodec(java.lang.String)",
        "snippet": "    public QuotedPrintableCodec(final String charsetName)\n            throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {\n        this(Charset.forName(charsetName));\n    }",
        "begin_line": 123,
        "end_line": 126,
        "comment": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the default string charset to use.\n     * @throws UnsupportedCharsetException\n     *             If no support for the named charset is available\n     *             in this instance of the Java virtual machine\n     * @throws IllegalArgumentException\n     *             If the given charsetName is null\n     * @throws IllegalCharsetNameException\n     *             If the given charset name is illegal\n     *\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int, java.io.ByteArrayOutputStream)",
        "snippet": "    private static final void encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }",
        "begin_line": 136,
        "end_line": 142,
        "comment": "\n     * Encodes byte into its quoted-printable representation.\n     *\n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[])",
        "snippet": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (printable.get(b)) {\n                buffer.write(b);\n            } else {\n                encodeQuotedPrintable(b, buffer);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 156,
        "end_line": 176,
        "comment": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param printable\n     *            bitset of characters deemed quoted-printable\n     * @param bytes\n     *            array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])",
        "snippet": "    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 191,
        "end_line": 211,
        "comment": "\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521.\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
        "snippet": "    @Override\n    public byte[] encode(final byte[] bytes) {\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n    }",
        "begin_line": 223,
        "end_line": 226,
        "comment": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param bytes\n     *            array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])",
        "snippet": "    @Override\n    public byte[] decode(final byte[] bytes) throws DecoderException {\n        return decodeQuotedPrintable(bytes);\n    }",
        "begin_line": 241,
        "end_line": 244,
        "comment": "\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521.\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) throws EncoderException {\n        return this.encode(str, getCharset());\n    }",
        "begin_line": 260,
        "end_line": 263,
        "comment": "\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             Thrown if quoted-printable encoding is unsuccessful\n     *\n     * @see #getCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    public String decode(final String str, final Charset charset) throws DecoderException {\n        if (str == null) {\n            return null;\n        }\n        return new String(this.decode(StringUtils.getBytesUsAscii(str)), charset);\n    }",
        "begin_line": 278,
        "end_line": 283,
        "comment": "\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n     * are converted back to their original representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @param charset\n     *            the original string charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.lang.String)",
        "snippet": "    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\n    }",
        "begin_line": 299,
        "end_line": 304,
        "comment": "\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n     * are converted back to their original representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @param charset\n     *            the original string charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
        "snippet": "    @Override\n    public String decode(final String str) throws DecoderException {\n        return this.decode(str, this.getCharset());\n    }",
        "begin_line": 317,
        "end_line": 320,
        "comment": "\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful. Thrown if charset is not supported.\n     * @see #getCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof byte[]) {\n            return encode((byte[]) obj);\n        } else if (obj instanceof String) {\n            return encode((String) obj);\n        } else {\n            throw new EncoderException(\"Objects of type \" +\n                  obj.getClass().getName() +\n                  \" cannot be quoted-printable encoded\");\n        }\n    }",
        "begin_line": 332,
        "end_line": 345,
        "comment": "\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            string to convert to a quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *             Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n     *             unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object obj) throws DecoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof byte[]) {\n            return decode((byte[]) obj);\n        } else if (obj instanceof String) {\n            return decode((String) obj);\n        } else {\n            throw new DecoderException(\"Objects of type \" +\n                  obj.getClass().getName() +\n                  \" cannot be quoted-printable decoded\");\n        }\n    }",
        "begin_line": 358,
        "end_line": 371,
        "comment": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\n     *             condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getCharset()",
        "snippet": "    public Charset getCharset() {\n        return this.charset;\n    }",
        "begin_line": 379,
        "end_line": 381,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }",
        "begin_line": 388,
        "end_line": 390,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    public String encode(final String str, final Charset charset) {\n        if (str == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(this.encode(str.getBytes(charset)));\n    }",
        "begin_line": 405,
        "end_line": 410,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\n    }",
        "begin_line": 426,
        "end_line": 431,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @throws UnsupportedEncodingException\n     *             Thrown if the charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.BCodec()",
        "snippet": "    public BCodec() {\n        this(Charsets.UTF_8);\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.BCodec(java.nio.charset.Charset)",
        "snippet": "    public BCodec(final Charset charset) {\n        this.charset = charset;\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.BCodec(java.lang.String)",
        "snippet": "    public BCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }",
        "begin_line": 82,
        "end_line": 84,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     *\n     * @param charsetName\n     *            the default charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.getEncoding()",
        "snippet": "    @Override\n    protected String getEncoding() {\n        return \"B\";\n    }",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.doEncoding(byte[])",
        "snippet": "    @Override\n    protected byte[] doEncoding(final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        return Base64.encodeBase64(bytes);\n    }",
        "begin_line": 91,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.doDecoding(byte[])",
        "snippet": "    @Override\n    protected byte[] doDecoding(final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        return Base64.decodeBase64(bytes);\n    }",
        "begin_line": 99,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    public String encode(final String value, final Charset charset) throws EncoderException {\n        if (value == null) {\n            return null;\n        }\n        return encodeText(value, charset);\n    }",
        "begin_line": 119,
        "end_line": 124,
        "comment": "\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\n     *\n     * @param value\n     *            string to convert to Base64 form\n     * @param charset\n     *            the charset for <code>value</code>\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String value, final String charset) throws EncoderException {\n        if (value == null) {\n            return null;\n        }\n        try {\n            return this.encodeText(value, charset);\n        } catch (final UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 137,
        "end_line": 146,
        "comment": "\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\n     *\n     * @param value\n     *            string to convert to Base64 form\n     * @param charset\n     *            the charset for <code>value</code>\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String value) throws EncoderException {\n        if (value == null) {\n            return null;\n        }\n        return encode(value, this.getCharset());\n    }",
        "begin_line": 157,
        "end_line": 163,
        "comment": "\n     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.\n     *\n     * @param value\n     *            string to convert to Base64 form\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
        "snippet": "    @Override\n    public String decode(final String value) throws DecoderException {\n        if (value == null) {\n            return null;\n        }\n        try {\n            return this.decodeText(value);\n        } catch (final UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 175,
        "end_line": 185,
        "comment": "\n     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param value\n     *            Base64 string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object value) throws EncoderException {\n        if (value == null) {\n            return null;\n        } else if (value instanceof String) {\n            return encode((String) value);\n        } else {\n            throw new EncoderException(\"Objects of type \" +\n                  value.getClass().getName() +\n                  \" cannot be encoded using BCodec\");\n        }\n    }",
        "begin_line": 196,
        "end_line": 207,
        "comment": "\n     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.\n     *\n     * @param value\n     *            object to convert to Base64 form\n     * @return Base64 object\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object value) throws DecoderException {\n        if (value == null) {\n            return null;\n        } else if (value instanceof String) {\n            return decode((String) value);\n        } else {\n            throw new DecoderException(\"Objects of type \" +\n                  value.getClass().getName() +\n                  \" cannot be decoded using BCodec\");\n        }\n    }",
        "begin_line": 220,
        "end_line": 231,
        "comment": "\n     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param value\n     *            Base64 object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\n     *             during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.getCharset()",
        "snippet": "    public Charset getCharset() {\n        return this.charset;\n    }",
        "begin_line": 239,
        "end_line": 241,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }",
        "begin_line": 248,
        "end_line": 250,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    protected String encodeText(final String text, final Charset charset) throws EncoderException {\n        if (text == null) {\n            return null;\n        }\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(PREFIX);\n        buffer.append(charset);\n        buffer.append(SEP);\n        buffer.append(this.getEncoding());\n        buffer.append(SEP);\n        final byte [] rawData = this.doEncoding(text.getBytes(charset));\n        buffer.append(StringUtils.newStringUsAscii(rawData));\n        buffer.append(POSTFIX);\n        return buffer.toString();\n    }",
        "begin_line": 68,
        "end_line": 82,
        "comment": "\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\n     *\n     * @param text\n     *            a string to encode\n     * @param charset\n     *            a charset to be used\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
        "snippet": "    protected String encodeText(final String text, final String charsetName)\n            throws EncoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        return this.encodeText(text, Charset.forName(charsetName));\n    }",
        "begin_line": 102,
        "end_line": 108,
        "comment": "\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\n     *\n     * @param text\n     *            a string to encode\n     * @param charsetName\n     *            the charset to use\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @throws UnsupportedEncodingException\n     *             if charset is not available\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
        "snippet": "    protected String decodeText(final String text)\n            throws DecoderException, UnsupportedEncodingException {\n        if (text == null) {\n            return null;\n        }\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\n            throw new DecoderException(\"RFC 1522 violation: malformed encoded content\");\n        }\n        final int terminator = text.length() - 2;\n        int from = 2;\n        int to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"RFC 1522 violation: charset token not found\");\n        }\n        final String charset = text.substring(from, to);\n        if (charset.equals(\"\")) {\n            throw new DecoderException(\"RFC 1522 violation: charset not specified\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"RFC 1522 violation: encoding token not found\");\n        }\n        final String encoding = text.substring(from, to);\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\n            throw new DecoderException(\"This codec cannot decode \" + encoding + \" encoded content\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n        data = doDecoding(data);\n        return new String(data, charset);\n    }",
        "begin_line": 124,
        "end_line": 156,
        "comment": "\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\n     * <p>\n     * This method processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\n     *\n     * @param text\n     *            a string to decode\n     * @return A new decoded String or {@code null} if the input is {@code null}.\n     * @throws DecoderException\n     *             thrown if there is an error condition during the decoding process.\n     * @throws UnsupportedEncodingException\n     *             thrown if charset specified in the \"encoded-word\" header is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.getEncoding()",
        "snippet": "    protected abstract String getEncoding();",
        "begin_line": 163,
        "end_line": 163,
        "comment": "\n     * Returns the codec name (referred to as encoding in the RFC 1522).\n     *\n     * @return name of the codec\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[])",
        "snippet": "    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;",
        "begin_line": 174,
        "end_line": 174,
        "comment": "\n     * Encodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[])",
        "snippet": "    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;",
        "begin_line": 185,
        "end_line": 185,
        "comment": "\n     * Decodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be decoded\n     * @return a byte array that contains decoded data\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.URLCodec()",
        "snippet": "    public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }",
        "begin_line": 98,
        "end_line": 100,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.URLCodec(java.lang.String)",
        "snippet": "    public URLCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 107,
        "end_line": 110,
        "comment": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encodeUrl(java.util.BitSet, byte[])",
        "snippet": "    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL;\n        }\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (final byte c : bytes) {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == ' ') {\n                    b = '+';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 121,
        "end_line": 149,
        "comment": "\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])",
        "snippet": "    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == '+') {\n                buffer.write(' ');\n            } else if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 161,
        "end_line": 183,
        "comment": "\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(byte[])",
        "snippet": "    @Override\n    public byte[] encode(final byte[] bytes) {\n        return encodeUrl(WWW_FORM_URL, bytes);\n    }",
        "begin_line": 192,
        "end_line": 195,
        "comment": "\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(byte[])",
        "snippet": "    @Override\n    public byte[] decode(final byte[] bytes) throws DecoderException {\n        return decodeUrl(bytes);\n    }",
        "begin_line": 208,
        "end_line": 211,
        "comment": "\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\n    }",
        "begin_line": 224,
        "end_line": 229,
        "comment": "\n     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to a URL safe form\n     * @param charset\n     *            the charset for str\n     * @return URL safe string\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) throws EncoderException {\n        if (str == null) {\n            return null;\n        }\n        try {\n            return encode(str, getDefaultCharset());\n        } catch (final UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 242,
        "end_line": 252,
        "comment": "\n     * Encodes a string into its URL safe form using the default string charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to a URL safe form\n     * @return URL safe string\n     * @throws EncoderException\n     *             Thrown if URL encoding is unsuccessful\n     *\n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String, java.lang.String)",
        "snippet": "    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\n        if (str == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\n    }",
        "begin_line": 269,
        "end_line": 274,
        "comment": "\n     * Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param str\n     *            URL safe string to convert into its original form\n     * @param charset\n     *            the original string charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
        "snippet": "    @Override\n    public String decode(final String str) throws DecoderException {\n        if (str == null) {\n            return null;\n        }\n        try {\n            return decode(str, getDefaultCharset());\n        } catch (final UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 287,
        "end_line": 297,
        "comment": "\n     * Decodes a URL safe string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     *\n     * @param str\n     *            URL safe string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof byte[]) {\n            return encode((byte[])obj);\n        } else if (obj instanceof String) {\n            return encode((String)obj);\n        } else {\n            throw new EncoderException(\"Objects of type \" + obj.getClass().getName() + \" cannot be URL encoded\");\n\n        }\n    }",
        "begin_line": 308,
        "end_line": 320,
        "comment": "\n     * Encodes an object into its URL safe form. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            string to convert to a URL safe form\n     * @return URL safe object\n     * @throws EncoderException\n     *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object obj) throws DecoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof byte[]) {\n            return decode((byte[]) obj);\n        } else if (obj instanceof String) {\n            return decode((String) obj);\n        } else {\n            throw new DecoderException(\"Objects of type \" + obj.getClass().getName() + \" cannot be URL decoded\");\n\n        }\n    }",
        "begin_line": 333,
        "end_line": 345,
        "comment": "\n     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            URL safe object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\n     *             condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset;\n    }",
        "begin_line": 352,
        "end_line": 354,
        "comment": "\n     * The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.getEncoding()",
        "snippet": "    @Deprecated\n    public String getEncoding() {\n        return this.charset;\n    }",
        "begin_line": 363,
        "end_line": 366,
        "comment": "\n     * The <code>String</code> encoding used for decoding and encoding.\n     *\n     * @return Returns the encoding.\n     *\n     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.QCodec()",
        "snippet": "    public QCodec() {\n        this(Charsets.UTF_8);\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.QCodec(java.nio.charset.Charset)",
        "snippet": "    public QCodec(final Charset charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 128,
        "end_line": 131,
        "comment": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset\n     *            the default string charset to use.\n     *\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.QCodec(java.lang.String)",
        "snippet": "    public QCodec(final String charsetName) {\n        this(Charset.forName(charsetName));\n    }",
        "begin_line": 143,
        "end_line": 145,
        "comment": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charsetName\n     *            the charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.getEncoding()",
        "snippet": "    @Override\n    protected String getEncoding() {\n        return \"Q\";\n    }",
        "begin_line": 147,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.doEncoding(byte[])",
        "snippet": "    @Override\n    protected byte[] doEncoding(final byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n        if (this.encodeBlanks) {\n            for (int i = 0; i < data.length; i++) {\n                if (data[i] == BLANK) {\n                    data[i] = UNDERSCORE;\n                }\n            }\n        }\n        return data;\n    }",
        "begin_line": 152,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.doDecoding(byte[])",
        "snippet": "    @Override\n    protected byte[] doDecoding(final byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        boolean hasUnderscores = false;\n        for (final byte b : bytes) {\n            if (b == UNDERSCORE) {\n                hasUnderscores = true;\n                break;\n            }\n        }\n        if (hasUnderscores) {\n            final byte[] tmp = new byte[bytes.length];\n            for (int i = 0; i < bytes.length; i++) {\n                final byte b = bytes[i];\n                if (b != UNDERSCORE) {\n                    tmp[i] = b;\n                } else {\n                    tmp[i] = BLANK;\n                }\n            }\n            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\n        }\n        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);\n    }",
        "begin_line": 168,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String, java.nio.charset.Charset)",
        "snippet": "    public String encode(final String str, final Charset charset) throws EncoderException {\n        if (str == null) {\n            return null;\n        }\n        return encodeText(str, charset);\n    }",
        "begin_line": 207,
        "end_line": 212,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String str, final String charset) throws EncoderException {\n        if (str == null) {\n            return null;\n        }\n        try {\n            return encodeText(str, charset);\n        } catch (final UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 225,
        "end_line": 234,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @param charset\n     *            the charset for str\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) throws EncoderException {\n        if (str == null) {\n            return null;\n        }\n        return encode(str, getCharset());\n    }",
        "begin_line": 245,
        "end_line": 251,
        "comment": "\n     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to quoted-printable form\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
        "snippet": "    @Override\n    public String decode(final String str) throws DecoderException {\n        if (str == null) {\n            return null;\n        }\n        try {\n            return decodeText(str);\n        } catch (final UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 263,
        "end_line": 273,
        "comment": "\n     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof String) {\n            return encode((String) obj);\n        } else {\n            throw new EncoderException(\"Objects of type \" +\n                  obj.getClass().getName() +\n                  \" cannot be encoded using Q codec\");\n        }\n    }",
        "begin_line": 284,
        "end_line": 295,
        "comment": "\n     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            object to convert to quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.Object)",
        "snippet": "    @Override\n    public Object decode(final Object obj) throws DecoderException {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof String) {\n            return decode((String) obj);\n        } else {\n            throw new DecoderException(\"Objects of type \" +\n                  obj.getClass().getName() +\n                  \" cannot be decoded using Q codec\");\n        }\n    }",
        "begin_line": 308,
        "end_line": 319,
        "comment": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\n     *             during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.getCharset()",
        "snippet": "    public Charset getCharset() {\n        return this.charset;\n    }",
        "begin_line": 327,
        "end_line": 329,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset.name();\n    }",
        "begin_line": 336,
        "end_line": 338,
        "comment": "\n     * Gets the default charset name used for string decoding and encoding.\n     *\n     * @return the default charset name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.isEncodeBlanks()",
        "snippet": "    public boolean isEncodeBlanks() {\n        return this.encodeBlanks;\n    }",
        "begin_line": 345,
        "end_line": 347,
        "comment": "\n     * Tests if optional transformation of SPACE characters is to be used\n     *\n     * @return {@code true} if SPACE characters are to be transformed, {@code false} otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)",
        "snippet": "    public void setEncodeBlanks(final boolean b) {\n        this.encodeBlanks = b;\n    }",
        "begin_line": 355,
        "end_line": 357,
        "comment": "\n     * Defines whether optional transformation of SPACE characters is to be used\n     *\n     * @param b\n     *            {@code true} if SPACE characters are to be transformed, {@code false} otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/net/Utils.java",
        "class_name": "org.apache.commons.codec.net.Utils",
        "signature": "org.apache.commons.codec.net.Utils.digit16(byte)",
        "snippet": "    static int digit16(final byte b) throws DecoderException {\n        final int i = Character.digit((char) b, URLCodec.RADIX);\n        if (i == -1) {\n            throw new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n        }\n        return i;\n    }",
        "begin_line": 42,
        "end_line": 48,
        "comment": "\n     * Returns the numeric value of the character <code>b</code> in radix 16.\n     *\n     * @param b\n     *            The byte to be converted.\n     * @return The numeric value represented by the character in radix 16.\n     *\n     * @throws DecoderException\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphone()",
        "snippet": "    public DoubleMetaphone() {\n        super();\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Creates an instance of this DoubleMetaphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
        "snippet": "    public String doubleMetaphone(final String value) {\n        return doubleMetaphone(value, false);\n    }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n     * Encode a value with Double Metaphone.\n     *\n     * @param value String to encode\n     * @return an encoded string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
        "snippet": "    public String doubleMetaphone(String value, final boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n\n        final boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n\n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break;\n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }",
        "begin_line": 85,
        "end_line": 190,
        "comment": "\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\");\n        }\n        return doubleMetaphone((String) obj);\n    }",
        "begin_line": 200,
        "end_line": 206,
        "comment": "\n     * Encode the value using DoubleMetaphone.  It will only work if\n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String value) {\n        return doubleMetaphone(value);\n    }",
        "begin_line": 214,
        "end_line": 217,
        "comment": "\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }",
        "begin_line": 229,
        "end_line": 231,
        "comment": "\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
        "snippet": "    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n    }",
        "begin_line": 243,
        "end_line": 245,
        "comment": "\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if {@code true}.\n     * @return {@code true} if the encoded <code>String</code>s are equal;\n     *          {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.getMaxCodeLen()",
        "snippet": "    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }",
        "begin_line": 251,
        "end_line": 253,
        "comment": "\n     * Returns the maxCodeLen.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int)",
        "snippet": "    public void setMaxCodeLen(final int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }",
        "begin_line": 259,
        "end_line": 261,
        "comment": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }",
        "begin_line": 268,
        "end_line": 273,
        "comment": "\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") &&\n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") &&\n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") &&\n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n\n        return index;\n    }",
        "begin_line": 278,
        "end_line": 325,
        "comment": "\n     * Handles 'C' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") &&\n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n\n        return index;\n    }",
        "begin_line": 330,
        "end_line": 349,
        "comment": "\n     * Handles 'CC' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }",
        "begin_line": 354,
        "end_line": 378,
        "comment": "\n     * Handles 'CH' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleD(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }",
        "begin_line": 383,
        "end_line": 402,
        "comment": "\n     * Handles 'D' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleG(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") &&\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 &&\n                   (charAt(value, index + 1) == 'Y' ||\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") ||\n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") &&\n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if (contains(value, 0 ,4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\") ||\n                contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }",
        "begin_line": 407,
        "end_line": 460,
        "comment": "\n     * Handles 'G' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleGH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }",
        "begin_line": 465,
        "end_line": 492,
        "comment": "\n     * Handles 'GH' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }",
        "begin_line": 497,
        "end_line": 508,
        "comment": "\n     * Handles 'H' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleJ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\n                           !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }",
        "begin_line": 513,
        "end_line": 544,
        "comment": "\n     * Handles 'J' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleL(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }",
        "begin_line": 549,
        "end_line": 562,
        "comment": "\n     * Handles 'L' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleP(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 567,
        "end_line": 576,
        "comment": "\n     * Handles 'P' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleR(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n                        final boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic &&\n            contains(value, index - 2, 2, \"IE\") &&\n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }",
        "begin_line": 581,
        "end_line": 591,
        "comment": "\n     * Handles 'R' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleS(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) ||\n                   contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language although in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \"AI\", \"OI\")) {\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 596,
        "end_line": 641,
        "comment": "\n     * Handles 'S' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleSC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, 2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }",
        "begin_line": 646,
        "end_line": 670,
        "comment": "\n     * Handles 'SC' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleT(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, 3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") ||\n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") ||\n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 675,
        "end_line": 697,
        "comment": "\n     * Handles 'T' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleW(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, 5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }",
        "begin_line": 702,
        "end_line": 733,
        "comment": "\n     * Handles 'W' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleX(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) &&\n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") ||\n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 738,
        "end_line": 752,
        "comment": "\n     * Handles 'X' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleZ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n                        final boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") ||\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 757,
        "end_line": 773,
        "comment": "\n     * Handles 'Z' cases.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionC0(java.lang.String, int)",
        "snippet": "    private boolean conditionC0(final String value, final int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            final char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }",
        "begin_line": 780,
        "end_line": 794,
        "comment": "\n     * Complex condition 0 for 'C'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(java.lang.String, int)",
        "snippet": "    private boolean conditionCH0(final String value, final int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") &&\n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }",
        "begin_line": 799,
        "end_line": 810,
        "comment": "\n     * Complex condition 0 for 'CH'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(java.lang.String, int)",
        "snippet": "    private boolean conditionCH1(final String value, final int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }",
        "begin_line": 815,
        "end_line": 821,
        "comment": "\n     * Complex condition 1 for 'CH'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionL0(java.lang.String, int)",
        "snippet": "    private boolean conditionL0(final String value, final int index) {\n        if (index == value.length() - 3 &&\n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") ||\n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "begin_line": 826,
        "end_line": 837,
        "comment": "\n     * Complex condition 0 for 'L'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionM0(java.lang.String, int)",
        "snippet": "    private boolean conditionM0(final String value, final int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \"ER\"));\n    }",
        "begin_line": 842,
        "end_line": 848,
        "comment": "\n     * Complex condition 0 for 'M'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(java.lang.String)",
        "snippet": "    private boolean isSlavoGermanic(final String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }",
        "begin_line": 856,
        "end_line": 859,
        "comment": "\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
        "snippet": "    private boolean isVowel(final char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }",
        "begin_line": 864,
        "end_line": 866,
        "comment": "\n     * Determines whether or not a character is a vowel or not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(java.lang.String)",
        "snippet": "    private boolean isSilentStart(final String value) {\n        boolean result = false;\n        for (final String element : SILENT_START) {\n            if (value.startsWith(element)) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }",
        "begin_line": 873,
        "end_line": 882,
        "comment": "\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return {@code true} if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.cleanInput(java.lang.String)",
        "snippet": "    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "begin_line": 887,
        "end_line": 896,
        "comment": "\n     * Cleans the input.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
        "snippet": "    protected char charAt(final String value, final int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        }\n        return value.charAt(index);\n    }",
        "begin_line": 903,
        "end_line": 908,
        "comment": "\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
        "snippet": "    protected static boolean contains(final String value, final int start, final int length,\n                                      final String... criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            final String target = value.substring(start, start + length);\n\n            for (final String element : criteria) {\n                if (target.equals(element)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }",
        "begin_line": 914,
        "end_line": 928,
        "comment": "\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.DoubleMetaphoneResult(int)",
        "snippet": "        public DoubleMetaphoneResult(final int maxLength) {\n            this.maxLength = maxLength;\n        }",
        "begin_line": 941,
        "end_line": 943,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
        "snippet": "        public void append(final char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }",
        "begin_line": 945,
        "end_line": 948,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
        "snippet": "        public void append(final char primary, final char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }",
        "begin_line": 950,
        "end_line": 953,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)",
        "snippet": "        public void appendPrimary(final char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }",
        "begin_line": 955,
        "end_line": 959,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
        "snippet": "        public void appendAlternate(final char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }",
        "begin_line": 961,
        "end_line": 965,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
        "snippet": "        public void append(final String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }",
        "begin_line": 967,
        "end_line": 970,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
        "snippet": "        public void append(final String primary, final String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }",
        "begin_line": 972,
        "end_line": 975,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(java.lang.String)",
        "snippet": "        public void appendPrimary(final String value) {\n            final int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }",
        "begin_line": 977,
        "end_line": 984,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(java.lang.String)",
        "snippet": "        public void appendAlternate(final String value) {\n            final int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }",
        "begin_line": 986,
        "end_line": 993,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getPrimary()",
        "snippet": "        public String getPrimary() {\n            return this.primary.toString();\n        }",
        "begin_line": 995,
        "end_line": 997,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getAlternate()",
        "snippet": "        public String getAlternate() {\n            return this.alternate.toString();\n        }",
        "begin_line": 999,
        "end_line": 1001,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.isComplete()",
        "snippet": "        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength &&\n                   this.alternate.length() >= this.maxLength;\n        }",
        "begin_line": 1003,
        "end_line": 1006,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
        "snippet": "    static String clean(final String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        final int len = str.length();\n        final char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "begin_line": 41,
        "end_line": 57,
        "comment": "\n     * Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     *\n     * @param str\n     *                  The String to clean.\n     * @return A clean String.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.difference(org.apache.commons.codec.StringEncoder, java.lang.String, java.lang.String)",
        "snippet": "    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.differenceEncoded(java.lang.String, java.lang.String)",
        "snippet": "    static int differenceEncoded(final String es1, final String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }",
        "begin_line": 109,
        "end_line": 122,
        "comment": "\n     * Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.Metaphone()",
        "snippet": "    public Metaphone() {\n        super();\n    }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     * Creates an instance of the Metaphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
        "snippet": "    public String metaphone(final String txt) {\n        boolean hard = false;\n        int txtLength;\n        if (txt == null || (txtLength = txt.length()) == 0) {\n            return \"\";\n        }\n        // single character is itself\n        if (txtLength == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\n        }\n\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n\n        final StringBuilder local = new StringBuilder(40); // manipulate\n        final StringBuilder code = new StringBuilder(10); //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K':\n        case 'G':\n        case 'P': /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W': /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1);\n                break;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X': /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break;\n        default:\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        final int wdsz = local.length();\n        int n = 0;\n\n        while (code.length() < this.getMaxCodeLen() &&\n               n < wdsz ) { // max code size of 4 works well\n            final char symb = local.charAt(n);\n            // remove duplicate letters except C\n            if (symb != 'C' && isPreviousChar( local, n, symb ) ) {\n                n++;\n            } else { // not dup\n                switch(symb) {\n                case 'A':\n                case 'E':\n                case 'I':\n                case 'O':\n                case 'U':\n                    if (n == 0) {\n                        code.append(symb);\n                    }\n                    break; // only use vowel if leading char\n                case 'B':\n                    if ( isPreviousChar(local, n, 'M') &&\n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n                        break;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C': // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') &&\n                         !isLastChar(wdsz, n) &&\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X');\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n                        isNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K');\n                        break;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if (n == 0 &&\n                            wdsz >= 3 &&\n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else {\n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'D':\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, 'G') &&\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { // DGE DGI DGY -> J\n                        code.append('J'); n += 2;\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case 'G': // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) &&\n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&\n                        isNextChar(local,n,'H') &&\n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if (n > 0 &&\n                        ( regionMatch(local, n, \"GN\") ||\n                          regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\n                        hard = true;\n                    } else {\n                        hard = false;\n                    }\n                    if (!isLastChar(wdsz, n) &&\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\n                        !hard) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break; // terminal H\n                    }\n                    if (n > 0 &&\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F':\n                case 'J':\n                case 'L':\n                case 'M':\n                case 'N':\n                case 'R':\n                    code.append(symb);\n                    break;\n                case 'K':\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break;\n                case 'P':\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break;\n                case 'Q':\n                    code.append('K');\n                    break;\n                case 'S':\n                    if (regionMatch(local,n,\"SH\") ||\n                        regionMatch(local,n,\"SIO\") ||\n                        regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T':\n                    if (regionMatch(local,n,\"TIA\") ||\n                        regionMatch(local,n,\"TIO\")) {\n                        code.append('X');\n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n                        // Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break;\n                case 'V':\n                    code.append('F'); break;\n                case 'W':\n                case 'Y': // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) &&\n                        isVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break;\n                case 'X':\n                    code.append('K');\n                    code.append('S');\n                    break;\n                case 'Z':\n                    code.append('S');\n                    break;\n                default:\n                    // do nothing\n                    break;\n                } // end switch\n                n++;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) {\n                code.setLength(this.getMaxCodeLen());\n            }\n        }\n        return code.toString();\n    }",
        "begin_line": 92,
        "end_line": 336,
        "comment": "\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isVowel(java.lang.StringBuilder, int)",
        "snippet": "    private boolean isVowel(final StringBuilder string, final int index) {\n        return VOWELS.indexOf(string.charAt(index)) >= 0;\n    }",
        "begin_line": 338,
        "end_line": 340,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isPreviousChar(java.lang.StringBuilder, int, char)",
        "snippet": "    private boolean isPreviousChar(final StringBuilder string, final int index, final char c) {\n        boolean matches = false;\n        if( index > 0 &&\n            index < string.length() ) {\n            matches = string.charAt(index - 1) == c;\n        }\n        return matches;\n    }",
        "begin_line": 342,
        "end_line": 349,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isNextChar(java.lang.StringBuilder, int, char)",
        "snippet": "    private boolean isNextChar(final StringBuilder string, final int index, final char c) {\n        boolean matches = false;\n        if( index >= 0 &&\n            index < string.length() - 1 ) {\n            matches = string.charAt(index + 1) == c;\n        }\n        return matches;\n    }",
        "begin_line": 351,
        "end_line": 358,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.regionMatch(java.lang.StringBuilder, int, java.lang.String)",
        "snippet": "    private boolean regionMatch(final StringBuilder string, final int index, final String test) {\n        boolean matches = false;\n        if( index >= 0 &&\n            index + test.length() - 1 < string.length() ) {\n            final String substring = string.substring( index, index + test.length());\n            matches = substring.equals( test );\n        }\n        return matches;\n    }",
        "begin_line": 360,
        "end_line": 368,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isLastChar(int, int)",
        "snippet": "    private boolean isLastChar(final int wdsz, final int n) {\n        return n + 1 == wdsz;\n    }",
        "begin_line": 370,
        "end_line": 372,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\");\n        }\n        return metaphone((String) obj);\n    }",
        "begin_line": 387,
        "end_line": 393,
        "comment": "\n     * Encodes an Object using the metaphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param obj Object to encode\n     * @return An object (or type java.lang.String) containing the\n     *         metaphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) {\n        return metaphone(str);\n    }",
        "begin_line": 401,
        "end_line": 404,
        "comment": "\n     * Encodes a String using the Metaphone algorithm.\n     *\n     * @param str String object to encode\n     * @return The metaphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isMetaphoneEqual(final String str1, final String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }",
        "begin_line": 414,
        "end_line": 416,
        "comment": "\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return {@code true} if the metaphones of these strings are identical,\n     *        {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.getMaxCodeLen()",
        "snippet": "    public int getMaxCodeLen() { return this.maxCodeLen; }",
        "begin_line": 422,
        "end_line": 422,
        "comment": "\n     * Returns the maxCodeLen.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int)",
        "snippet": "    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }",
        "begin_line": 428,
        "end_line": 428,
        "comment": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex()",
        "snippet": "    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex(char[])",
        "snippet": "    public Soundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }",
        "begin_line": 95,
        "end_line": 98,
        "comment": "\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     *\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex(java.lang.String)",
        "snippet": "    public Soundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }",
        "begin_line": 108,
        "end_line": 110,
        "comment": "\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.difference(java.lang.String, java.lang.String)",
        "snippet": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }",
        "begin_line": 148,
        "end_line": 154,
        "comment": "\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }",
        "begin_line": 165,
        "end_line": 168,
        "comment": "\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getMappingCode(java.lang.String, int)",
        "snippet": "    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }",
        "begin_line": 183,
        "end_line": 198,
        "comment": "\n     * Used internally by the SoundEx algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getMaxLength()",
        "snippet": "    @Deprecated\n    public int getMaxLength() {\n        return this.maxLength;\n    }",
        "begin_line": 206,
        "end_line": 209,
        "comment": "\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getSoundexMapping()",
        "snippet": "    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }",
        "begin_line": 216,
        "end_line": 218,
        "comment": "\n     * Returns the soundex mapping.\n     *\n     * @return soundexMapping.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.map(char)",
        "snippet": "    private char map(final char ch) {\n        final int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }",
        "begin_line": 229,
        "end_line": 235,
        "comment": "\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.setMaxLength(int)",
        "snippet": "    @Deprecated\n    public void setMaxLength(final int maxLength) {\n        this.maxLength = maxLength;\n    }",
        "begin_line": 244,
        "end_line": 247,
        "comment": "\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
        "snippet": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char out[] = {'0', '0', '0', '0'};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        // getMappingCode() throws IllegalArgumentException\n        last = getMappingCode(str, 0);\n        while (incount < str.length() && count < out.length) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if (mapped != '0' && mapped != last) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }",
        "begin_line": 258,
        "end_line": 282,
        "comment": "\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.CologneBuffer(char[])",
        "snippet": "        public CologneBuffer(final char[] data) {\n            this.data = data;\n            this.length = data.length;\n        }",
        "begin_line": 202,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.CologneBuffer(int)",
        "snippet": "        public CologneBuffer(final int buffSize) {\n            this.data = new char[buffSize];\n            this.length = 0;\n        }",
        "begin_line": 207,
        "end_line": 210,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int, int)",
        "snippet": "        protected abstract char[] copyData(int start, final int length);",
        "begin_line": 212,
        "end_line": 212,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.length()",
        "snippet": "        public int length() {\n            return length;\n        }",
        "begin_line": 214,
        "end_line": 216,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return new String(copyData(0, length));\n        }",
        "begin_line": 218,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.CologneOutputBuffer(int)",
        "snippet": "        public CologneOutputBuffer(final int buffSize) {\n            super(buffSize);\n        }",
        "begin_line": 226,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.addRight(char)",
        "snippet": "        public void addRight(final char chr) {\n            data[length] = chr;\n            length++;\n        }",
        "begin_line": 230,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.copyData(int, int)",
        "snippet": "        @Override\n        protected char[] copyData(final int start, final int length) {\n            final char[] newData = new char[length];\n            System.arraycopy(data, start, newData, 0, length);\n            return newData;\n        }",
        "begin_line": 235,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.CologneInputBuffer(char[])",
        "snippet": "        public CologneInputBuffer(final char[] data) {\n            super(data);\n        }",
        "begin_line": 245,
        "end_line": 247,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.addLeft(char)",
        "snippet": "        public void addLeft(final char ch) {\n            length++;\n            data[getNextPos()] = ch;\n        }",
        "begin_line": 249,
        "end_line": 252,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.copyData(int, int)",
        "snippet": "        @Override\n        protected char[] copyData(final int start, final int length) {\n            final char[] newData = new char[length];\n            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\n            return newData;\n        }",
        "begin_line": 254,
        "end_line": 259,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextChar()",
        "snippet": "        public char getNextChar() {\n            return data[getNextPos()];\n        }",
        "begin_line": 261,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextPos()",
        "snippet": "        protected int getNextPos() {\n            return data.length - length;\n        }",
        "begin_line": 265,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.removeNext()",
        "snippet": "        public char removeNext() {\n            final char ch = getNextChar();\n            length--;\n            return ch;\n        }",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[], char)",
        "snippet": "    private static boolean arrayContains(final char[] arr, final char key) {\n        for (final char element : arr) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 295,
        "end_line": 302,
        "comment": "\n     * Returns whether the array contains the key, or not.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(java.lang.String)",
        "snippet": "    public String colognePhonetic(String text) {\n        if (text == null) {\n            return null;\n        }\n\n        text = preprocess(text);\n\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n\n        char nextChar;\n\n        char lastChar = '-';\n        char lastCode = '/';\n        char code;\n        char chr;\n\n        int rightLength = input.length();\n\n        while (rightLength > 0) {\n            chr = input.removeNext();\n\n            if ((rightLength = input.length()) > 0) {\n                nextChar = input.getNextChar();\n            } else {\n                nextChar = '-';\n            }\n\n            if (arrayContains(AEIJOUY, chr)) {\n                code = '0';\n            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                if (lastCode == '/') {\n                    continue;\n                }\n                code = '-';\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n                code = '1';\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\n                code = '2';\n            } else if (arrayContains(WFPV, chr)) {\n                code = '3';\n            } else if (arrayContains(GKQ, chr)) {\n                code = '4';\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\n                code = '4';\n                input.addLeft('S');\n                rightLength++;\n            } else if (chr == 'S' || chr == 'Z') {\n                code = '8';\n            } else if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code = '4';\n                    } else {\n                        code = '8';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code = '8';\n                    } else {\n                        code = '4';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code = '8';\n            } else if (chr == 'R') {\n                code = '7';\n            } else if (chr == 'L') {\n                code = '5';\n            } else if (chr == 'M' || chr == 'N') {\n                code = '6';\n            } else {\n                code = chr;\n            }\n\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\n                output.addRight(code);\n            }\n\n            lastChar = chr;\n            lastCode = code;\n        }\n        return output.toString();\n    }",
        "begin_line": 315,
        "end_line": 398,
        "comment": "\n     * <p>\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n     * </p>\n     * <p>\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n     * </p>\n     *\n     * @param text\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object object) throws EncoderException {\n        if (!(object instanceof String)) {\n            throw new EncoderException(\"This method's parameter was expected to be of the type \" +\n                String.class.getName() +\n                \". But actually it was of the type \" +\n                object.getClass().getName() +\n                \".\");\n        }\n        return encode((String) object);\n    }",
        "begin_line": 400,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String text) {\n        return colognePhonetic(text);\n    }",
        "begin_line": 412,
        "end_line": 415,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isEncodeEqual(final String text1, final String text2) {\n        return colognePhonetic(text1).equals(colognePhonetic(text2));\n    }",
        "begin_line": 417,
        "end_line": 419,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "class_name": "org.apache.commons.codec.language.ColognePhonetic",
        "signature": "org.apache.commons.codec.language.ColognePhonetic.preprocess(java.lang.String)",
        "snippet": "    private String preprocess(String text) {\n        text = text.toUpperCase(Locale.GERMAN);\n\n        final char[] chrs = text.toCharArray();\n\n        for (int index = 0; index < chrs.length; index++) {\n            if (chrs[index] > 'Z') {\n                for (final char[] element : PREPROCESS_MAP) {\n                    if (chrs[index] == element[0]) {\n                        chrs[index] = element[1];\n                        break;\n                    }\n                }\n            }\n        }\n        return new String(chrs);\n    }",
        "begin_line": 424,
        "end_line": 440,
        "comment": "\n     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java",
        "class_name": "org.apache.commons.codec.language.AbstractCaverphone",
        "signature": "org.apache.commons.codec.language.AbstractCaverphone.AbstractCaverphone()",
        "snippet": "    public AbstractCaverphone() {\n        super();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Creates an instance of the Caverphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java",
        "class_name": "org.apache.commons.codec.language.AbstractCaverphone",
        "signature": "org.apache.commons.codec.language.AbstractCaverphone.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object source) throws EncoderException {\n        if (!(source instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\");\n        }\n        return this.encode((String) source);\n    }",
        "begin_line": 55,
        "end_line": 61,
        "comment": "\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param source\n     *            Object to encode\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java",
        "class_name": "org.apache.commons.codec.language.AbstractCaverphone",
        "signature": "org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\n        return this.encode(str1).equals(this.encode(str2));\n    }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n     * Tests if the encodings of two strings are equal.\n     *\n     * This method might be promoted to a new AbstractStringEncoder superclass.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the encodings of these strings are identical, {@code false} otherwise.\n     * @throws EncoderException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex()",
        "snippet": "    public RefinedSoundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "\n     * Creates an instance of the RefinedSoundex object using the default US\n     * English mapping.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex(char[])",
        "snippet": "    public RefinedSoundex(final char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }",
        "begin_line": 76,
        "end_line": 79,
        "comment": "\n     * Creates a refined soundex instance using a custom mapping. This\n     * constructor can be used to customize the mapping, and/or possibly\n     * provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for\n     *                  a given character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex(java.lang.String)",
        "snippet": "    public RefinedSoundex(final String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }",
        "begin_line": 89,
        "end_line": 91,
        "comment": "\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.difference(java.lang.String, java.lang.String)",
        "snippet": "    public int difference(final String s1, final String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to to the length of the shortest encoded String.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) obj);\n    }",
        "begin_line": 132,
        "end_line": 138,
        "comment": "\n     * Encodes an Object using the refined soundex algorithm. This method is\n     * provided in order to satisfy the requirements of the Encoder interface,\n     * and will throw an EncoderException if the supplied object is not of type\n     * java.lang.String.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the refined\n     *             soundex code which corresponds to the String supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) {\n        return soundex(str);\n    }",
        "begin_line": 147,
        "end_line": 150,
        "comment": "\n     * Encodes a String using the refined soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)",
        "snippet": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\n    }",
        "begin_line": 161,
        "end_line": 166,
        "comment": "\n     * Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     *\n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
        "snippet": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(str.charAt(0));\n\n        char last, current;\n        last = '*';\n\n        for (int i = 0; i < str.length(); i++) {\n\n            current = getMappingCode(str.charAt(i));\n            if (current == last) {\n                continue;\n            } else if (current != 0) {\n                sBuf.append(current);\n            }\n\n            last = current;\n\n        }\n\n        return sBuf.toString();\n    }",
        "begin_line": 175,
        "end_line": 204,
        "comment": "\n     * Retrieves the Refined Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.isVowel(char)",
        "snippet": "    private static boolean isVowel(final char c) {\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n     * Tests if the given character is a vowel.\n     *\n     * @param c\n     *            the character to test\n     * @return {@code true} if the character is a vowel, {@code false} otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.transcodeRemaining(char, char, char, char)",
        "snippet": "    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\n        // 1. EV -> AF\n        if (curr == 'E' && next == 'V') {\n            return CHARS_AF;\n        }\n\n        // A, E, I, O, U -> A\n        if (isVowel(curr)) {\n            return CHARS_A;\n        }\n\n        // 2. Q -> G, Z -> S, M -> N\n        if (curr == 'Q') {\n            return CHARS_G;\n        } else if (curr == 'Z') {\n            return CHARS_S;\n        } else if (curr == 'M') {\n            return CHARS_N;\n        }\n\n        // 3. KN -> NN else K -> C\n        if (curr == 'K') {\n            if (next == 'N') {\n                return CHARS_NN;\n            } else {\n                return CHARS_C;\n            }\n        }\n\n        // 4. SCH -> SSS\n        if (curr == 'S' && next == 'C' && aNext == 'H') {\n            return CHARS_SSS;\n        }\n\n        // PH -> FF\n        if (curr == 'P' && next == 'H') {\n            return CHARS_FF;\n        }\n\n        // 5. H -> If previous or next is a non vowel, previous.\n        if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {\n            return new char[] { prev };\n        }\n\n        // 6. W -> If previous is vowel, previous.\n        if (curr == 'W' && isVowel(prev)) {\n            return new char[] { prev };\n        }\n\n        return new char[] { curr };\n    }",
        "begin_line": 118,
        "end_line": 168,
        "comment": "\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n     * a time: [i-1, i, i+1, i+2].\n     *\n     * @param prev\n     *            the previous character\n     * @param curr\n     *            the current character\n     * @param next\n     *            the next character\n     * @param aNext\n     *            the after next character\n     * @return a transcoded array of characters, starting from the current position\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.Nysiis()",
        "snippet": "    public Nysiis() {\n        this(true);\n    }",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\n     * i.e. encoded strings have a maximum length of 6.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.Nysiis(boolean)",
        "snippet": "    public Nysiis(final boolean strict) {\n        this.strict = strict;\n    }",
        "begin_line": 192,
        "end_line": 194,
        "comment": "\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\n     *\n     * <ul>\n     *  <li>{@code true}: encoded strings have a maximum length of 6</li>\n     *  <li>{@code false}: encoded strings may have arbitrary length</li>\n     * </ul>\n     *\n     * @param strict\n     *            the strict mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Nysiis encode is not of type java.lang.String\");\n        }\n        return this.nysiis((String) obj);\n    }",
        "begin_line": 209,
        "end_line": 215,
        "comment": "\n     * Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type\n     * {@link String}.\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.\n     * @throws EncoderException\n     *            if the parameter supplied is not of a {@link String}\n     * @throws IllegalArgumentException\n     *            if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) {\n        return this.nysiis(str);\n    }",
        "begin_line": 226,
        "end_line": 229,
        "comment": "\n     * Encodes a String using the NYSIIS algorithm.\n     *\n     * @param str\n     *            A String object to encode\n     * @return A Nysiis code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *            if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.isStrict()",
        "snippet": "    public boolean isStrict() {\n        return this.strict;\n    }",
        "begin_line": 236,
        "end_line": 238,
        "comment": "\n     * Indicates the strict mode for this {@link Nysiis} encoder.\n     *\n     * @return {@code true} if the encoder is configured for strict mode, {@code false} otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "class_name": "org.apache.commons.codec.language.Nysiis",
        "signature": "org.apache.commons.codec.language.Nysiis.nysiis(java.lang.String)",
        "snippet": "    public String nysiis(String str) {\n        if (str == null) {\n            return null;\n        }\n\n        // Use the same clean rules as Soundex\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        // Translate first characters of name:\n        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n        str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n        str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n        str = PAT_K.matcher(str).replaceFirst(\"C\");\n        str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n        str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n\n        // Translate last characters of name:\n        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n        str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n\n        // First character of key = first character of name.\n        final StringBuilder key = new StringBuilder(str.length());\n        key.append(str.charAt(0));\n\n        // Transcode remaining characters, incrementing by one character each time\n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n\n        for (int i = 1; i < len; i++) {\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n\n            // only append the current char to the key if it is different from the last one\n            if (chars[i] != chars[i - 1]) {\n                key.append(chars[i]);\n            }\n        }\n\n        if (key.length() > 1) {\n            char lastChar = key.charAt(key.length() - 1);\n\n            // If last character is S, remove it.\n            if (lastChar == 'S') {\n                key.deleteCharAt(key.length() - 1);\n                lastChar = key.charAt(key.length() - 1);\n            }\n\n            if (key.length() > 2) {\n                final char last2Char = key.charAt(key.length() - 2);\n                // If last characters are AY, replace with Y.\n                if (last2Char == 'A' && lastChar == 'Y') {\n                    key.deleteCharAt(key.length() - 2);\n                }\n            }\n\n            // If last character is A, remove it.\n            if (lastChar == 'A') {\n                key.deleteCharAt(key.length() - 1);\n            }\n        }\n\n        final String string = key.toString();\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n    }",
        "begin_line": 247,
        "end_line": 317,
        "comment": "\n     * Retrieves the NYSIIS code for a given String object.\n     *\n     * @param str\n     *            String to encode using the NYSIIS algorithm\n     * @return A NYSIIS code for the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(java.lang.String)",
        "snippet": "    String cleanName(final String name) {\n        String upperName = name.toUpperCase(Locale.ENGLISH);\n\n        final String[] charsToTrim = { \"\\\\-\", \"[&]\", \"\\\\'\", \"\\\\.\", \"[\\\\,]\" };\n        for (final String str : charsToTrim) {\n            upperName = upperName.replaceAll(str, EMPTY);\n        }\n\n        upperName = removeAccents(upperName);\n        upperName = upperName.replaceAll(\"\\\\s+\", EMPTY);\n\n        return upperName;\n    }",
        "begin_line": 83,
        "end_line": 95,
        "comment": "\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     * spaces.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to be cleaned\n     * @return The cleaned name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.Object)",
        "snippet": "    @Override\n    public final Object encode(final Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\n                    \"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\");\n        }\n        return encode((String) pObject);\n    }",
        "begin_line": 108,
        "end_line": 115,
        "comment": "\n     * Encodes an Object using the Match Rating Approach algorithm. Method is here to satisfy the requirements of the\n     * Encoder interface Throws an EncoderException if input object is not of type java.lang.String.\n     *\n     * @param pObject\n     *            Object to encode\n     * @return An object (or type java.lang.String) containing the Match Rating Approach code which corresponds to the\n     *         String supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
        "snippet": "    @Override\n    public final String encode(String name) {\n        // Bulletproof for trivial input - NINO\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n            return EMPTY;\n        }\n\n        // Preprocessing\n        name = cleanName(name);\n\n        // BEGIN: Actual encoding part of the algorithm...\n        // 1. Delete all vowels unless the vowel begins the word\n        name = removeVowels(name);\n\n        // 2. Remove second consonant from any double consonant\n        name = removeDoubleConsonants(name);\n\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n        name = getFirst3Last3(name);\n\n        return name;\n    }",
        "begin_line": 124,
        "end_line": 145,
        "comment": "\n     * Encodes a String using the Match Rating Approach (MRA) algorithm.\n     *\n     * @param name\n     *            String object to encode\n     * @return The MRA code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(java.lang.String)",
        "snippet": "    String getFirst3Last3(final String name) {\n        final int nameLength = name.length();\n\n        if (nameLength > SIX) {\n            final String firstThree = name.substring(0, THREE);\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\n            return firstThree + lastThree;\n        } else {\n            return name;\n        }\n    }",
        "begin_line": 159,
        "end_line": 169,
        "comment": "\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The string to get the substrings from\n     * @return Annexed first and last 3 letters of input word.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
        "snippet": "    int getMinRating(final int sumLength) {\n        int minRating = 0;\n\n        if (sumLength <= FOUR) {\n            minRating = FIVE;\n        } else if (sumLength >= FIVE && sumLength <= SEVEN) {\n            minRating = FOUR;\n        } else if (sumLength >= EIGHT && sumLength <= ELEVEN) {\n            minRating = THREE;\n        } else if (sumLength == TWELVE) {\n            minRating = TWO;\n        } else {\n            minRating = ONE; // docs said little here.\n        }\n\n        return minRating;\n    }",
        "begin_line": 184,
        "end_line": 200,
        "comment": "\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n     * min rating. Values strictly from documentation.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param sumLength\n     *            The length of 2 strings sent down\n     * @return The min rating value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isEncodeEquals(String name1, String name2) {\n        // Bulletproof for trivial input - NINO\n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\n            return false;\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\n            return false;\n        } else if (name1.length() == 1 || name2.length() == 1) {\n            return false;\n        } else if (name1.equalsIgnoreCase(name2)) {\n            return true;\n        }\n\n        // Preprocessing\n        name1 = cleanName(name1);\n        name2 = cleanName(name2);\n\n        // Actual MRA Algorithm\n\n        // 1. Remove vowels\n        name1 = removeVowels(name1);\n        name2 = removeVowels(name2);\n\n        // 2. Remove double consonants\n        name1 = removeDoubleConsonants(name1);\n        name2 = removeDoubleConsonants(name2);\n\n        // 3. Reduce down to 3 letters\n        name1 = getFirst3Last3(name1);\n        name2 = getFirst3Last3(name2);\n\n        // 4. Check for length difference - if 3 or greater then no similarity\n        // comparison is done\n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\n            return false;\n        }\n\n        // 5. Obtain the minimum rating value by calculating the length sum of the\n        // encoded Strings and sending it down.\n        final int sumLength = Math.abs(name1.length() + name2.length());\n        int minRating = 0;\n        minRating = getMinRating(sumLength);\n\n        // 6. Process the encoded Strings from left to right and remove any\n        // identical characters found from both Strings respectively.\n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\n\n        // 7. Each PNI item that has a similarity rating equal to or greater than\n        // the min is considered to be a good candidate match\n        return count >= minRating;\n\n    }",
        "begin_line": 212,
        "end_line": 262,
        "comment": "\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n     * strings are cleaned in the same way as {@link #encode(String)}.\n     *\n     * @param name1\n     *            First of the 2 strings (names) to compare\n     * @param name2\n     *            Second of the 2 names to compare\n     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(java.lang.String)",
        "snippet": "    boolean isVowel(final String letter) {\n        return letter.equalsIgnoreCase(\"E\") || letter.equalsIgnoreCase(\"A\") || letter.equalsIgnoreCase(\"O\") ||\n               letter.equalsIgnoreCase(\"I\") || letter.equalsIgnoreCase(\"U\");\n    }",
        "begin_line": 276,
        "end_line": 279,
        "comment": "\n     * Determines if a letter is a vowel.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param letter\n     *            The letter under investiagtion\n     * @return True if a vowel, else false\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(java.lang.String, java.lang.String)",
        "snippet": "    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\n        final char[] name1Char = name1.toCharArray();\n        final char[] name2Char = name2.toCharArray();\n\n        final int name1Size = name1.length() - 1;\n        final int name2Size = name2.length() - 1;\n\n        String name1LtRStart = EMPTY;\n        String name1LtREnd = EMPTY;\n\n        String name2RtLStart = EMPTY;\n        String name2RtLEnd = EMPTY;\n\n        for (int i = 0; i < name1Char.length; i++) {\n            if (i > name2Size) {\n                break;\n            }\n\n            name1LtRStart = name1.substring(i, i + 1);\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\n\n            name2RtLStart = name2.substring(i, i + 1);\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\n\n            // Left to right...\n            if (name1LtRStart.equals(name2RtLStart)) {\n                name1Char[i] = ' ';\n                name2Char[i] = ' ';\n            }\n\n            // Right to left...\n            if (name1LtREnd.equals(name2RtLEnd)) {\n                name1Char[name1Size - i] = ' ';\n                name2Char[name2Size - i] = ' ';\n            }\n        }\n\n        // Char arrays -> string & remove extraneous space\n        final String strA = new String(name1Char).replaceAll(\"\\\\s+\", EMPTY);\n        final String strB = new String(name2Char).replaceAll(\"\\\\s+\", EMPTY);\n\n        // Final bit - subtract longest string from 6 and return this int value\n        if (strA.length() > strB.length()) {\n            return Math.abs(SIX - strA.length());\n        } else {\n            return Math.abs(SIX - strB.length());\n        }\n    }",
        "begin_line": 294,
        "end_line": 341,
        "comment": "\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\n     * Then subtracts the longer string that remains from 6 and returns this.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name1\n     *            name2\n     * @return\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
        "snippet": "    String removeAccents(final String accentedWord) {\n        if (accentedWord == null) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n        final int n = accentedWord.length();\n\n        for (int i = 0; i < n; i++) {\n            final char c = accentedWord.charAt(i);\n            final int pos = UNICODE.indexOf(c);\n            if (pos > -1) {\n                sb.append(PLAIN_ASCII.charAt(pos));\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }",
        "begin_line": 351,
        "end_line": 370,
        "comment": "\n     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n     *\n     * @param accentedWord\n     *            The word that may have accents in it.\n     * @return De-accented word\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
        "snippet": "    String removeDoubleConsonants(final String name) {\n        String replacedName = name.toUpperCase();\n        for (final String dc : DOUBLE_CONSONANT) {\n            if (replacedName.contains(dc)) {\n                final String singleLetter = dc.substring(0, 1);\n                replacedName = replacedName.replace(dc, singleLetter);\n            }\n        }\n        return replacedName;\n    }",
        "begin_line": 384,
        "end_line": 393,
        "comment": "\n     * Replaces any double consonant pair with the single letter equivalent.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            String to have double consonants removed\n     * @return Single consonant word\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java",
        "class_name": "org.apache.commons.codec.language.MatchRatingApproachEncoder",
        "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
        "snippet": "    String removeVowels(String name) {\n        // Extract first letter\n        final String firstLetter = name.substring(0, 1);\n\n        name = name.replaceAll(\"A\", EMPTY);\n        name = name.replaceAll(\"E\", EMPTY);\n        name = name.replaceAll(\"I\", EMPTY);\n        name = name.replaceAll(\"O\", EMPTY);\n        name = name.replaceAll(\"U\", EMPTY);\n\n        name = name.replaceAll(\"\\\\s{2,}\\\\b\", SPACE);\n\n        // return isVowel(firstLetter) ? (firstLetter + name) : name;\n        if (isVowel(firstLetter)) {\n            return firstLetter + name;\n        } else {\n            return name;\n        }\n    }",
        "begin_line": 407,
        "end_line": 425,
        "comment": "\n     * Deletes all vowels unless the vowel begins the word.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to have vowels removed\n     * @return De-voweled word\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone2.java",
        "class_name": "org.apache.commons.codec.language.Caverphone2",
        "signature": "org.apache.commons.codec.language.Caverphone2.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String source) {\n        String txt = source;\n        if (txt == null || txt.length() == 0) {\n            return TEN_1;\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\"); // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\"); // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\"); // 2.0 only\n                                                   // note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End\n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\"); // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\"); // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\"); // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\"); // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\"); // 2.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\"); // 2.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\"); // 2.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\"); // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + TEN_1;\n\n        // 7. take the first ten characters as the code\n        return txt.substring(0, TEN_1.length());\n    }",
        "begin_line": 44,
        "end_line": 129,
        "comment": "\n     * Encodes the given String into a Caverphone 2.0 value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.Caverphone()",
        "snippet": "    public Caverphone() {\n        super();\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Creates an instance of the Caverphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.caverphone(java.lang.String)",
        "snippet": "    public String caverphone(final String source) {\n        return this.encoder.encode(source);\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\");\n        }\n        return this.caverphone((String) obj);\n    }",
        "begin_line": 72,
        "end_line": 78,
        "comment": "\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String str) {\n        return this.caverphone(str);\n    }",
        "begin_line": 87,
        "end_line": 90,
        "comment": "\n     * Encodes a String using the Caverphone algorithm.\n     *\n     * @param str\n     *            String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isCaverphoneEqual(final String str1, final String str2) {\n        return this.caverphone(str1).equals(this.caverphone(str2));\n    }",
        "begin_line": 101,
        "end_line": 103,
        "comment": "\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the caverphones of these strings are identical, {@code false} otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/Caverphone1.java",
        "class_name": "org.apache.commons.codec.language.Caverphone1",
        "signature": "org.apache.commons.codec.language.Caverphone1.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String source) {\n        String txt = source;\n        if (txt == null || txt.length() == 0) {\n            return SIX_1;\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 3. Handle various start options\n        // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End\n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        // 3 is a temporary placeholder marking a vowel\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        txt = txt.replaceAll(\"wy\", \"Wy\"); // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"why\", \"Why\"); // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"ry\", \"Ry\"); // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"ly\", \"Ly\"); // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        txt = txt.replaceAll(\"j\", \"y\"); // 1.0 only\n        txt = txt.replaceAll(\"y3\", \"Y3\"); // 1.0 only\n        txt = txt.replaceAll(\"y\", \"2\"); // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + SIX_1;\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, SIX_1.length());\n    }",
        "begin_line": 44,
        "end_line": 125,
        "comment": "\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/NameType.java",
        "class_name": "org.apache.commons.codec.language.bm.NameType",
        "signature": "org.apache.commons.codec.language.bm.NameType.NameType(java.lang.String)",
        "snippet": "    NameType(final String name) {\n        this.name = name;\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/NameType.java",
        "class_name": "org.apache.commons.codec.language.bm.NameType",
        "signature": "org.apache.commons.codec.language.bm.NameType.getName()",
        "snippet": "    public String getName() {\n        return this.name;\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "\n     * Gets the short version of the name type.\n     *\n     * @return the NameType short string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.Object)",
        "snippet": "    @Override\n    public Object encode(final Object source) throws EncoderException {\n        if (!(source instanceof String)) {\n            throw new EncoderException(\"BeiderMorseEncoder encode parameter is not of type String\");\n        }\n        return encode((String) source);\n    }",
        "begin_line": 78,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
        "snippet": "    @Override\n    public String encode(final String source) throws EncoderException {\n        if (source == null) {\n            return null;\n        }\n        return this.engine.encode(source);\n    }",
        "begin_line": 86,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.getNameType()",
        "snippet": "    public NameType getNameType() {\n        return this.engine.getNameType();\n    }",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n     * Gets the name type currently in operation.\n     *\n     * @return the NameType currently being used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.getRuleType()",
        "snippet": "    public RuleType getRuleType() {\n        return this.engine.getRuleType();\n    }",
        "begin_line": 108,
        "end_line": 110,
        "comment": "\n     * Gets the rule type currently in operation.\n     *\n     * @return the RuleType currently being used\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.isConcat()",
        "snippet": "    public boolean isConcat() {\n        return this.engine.isConcat();\n    }",
        "begin_line": 117,
        "end_line": 119,
        "comment": "\n     * Discovers if multiple possible encodings are concatenated.\n     *\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setConcat(boolean)",
        "snippet": "    public void setConcat(final boolean concat) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         concat,\n                                         this.engine.getMaxPhonemes());\n    }",
        "begin_line": 128,
        "end_line": 133,
        "comment": "\n     * Sets how multiple possible phonetic encodings are combined.\n     *\n     * @param concat\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n     *            to be considered\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(org.apache.commons.codec.language.bm.NameType)",
        "snippet": "    public void setNameType(final NameType nameType) {\n        this.engine = new PhoneticEngine(nameType,\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }",
        "begin_line": 142,
        "end_line": 147,
        "comment": "\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n     * optimized for Ashkenazi or Sephardic Jewish family names.\n     *\n     * @param nameType\n     *            the NameType in use\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(org.apache.commons.codec.language.bm.RuleType)",
        "snippet": "    public void setRuleType(final RuleType ruleType) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         ruleType,\n                                         this.engine.isConcat(),\n                                         this.engine.getMaxPhonemes());\n    }",
        "begin_line": 155,
        "end_line": 160,
        "comment": "\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n     *\n     * @param ruleType\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java",
        "class_name": "org.apache.commons.codec.language.bm.BeiderMorseEncoder",
        "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setMaxPhonemes(int)",
        "snippet": "    public void setMaxPhonemes(final int maxPhonemes) {\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                         this.engine.getRuleType(),\n                                         this.engine.isConcat(),\n                                         maxPhonemes);\n    }",
        "begin_line": 169,
        "end_line": 174,
        "comment": "\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\n     *\n     * @param maxPhonemes\n     *            the maximum number of phonemes returned by the engine\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.LangRule.LangRule(java.util.regex.Pattern, java.util.Set<java.lang.String>, boolean)",
        "snippet": "        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\n            this.pattern = pattern;\n            this.languages = languages;\n            this.acceptOnMatch = acceptOnMatch;\n        }",
        "begin_line": 85,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.LangRule.matches(java.lang.String)",
        "snippet": "        public boolean matches(final String txt) {\n            return this.pattern.matcher(txt).find();\n        }",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.instance(org.apache.commons.codec.language.bm.NameType)",
        "snippet": "    public static Lang instance(final NameType nameType) {\n        return Langs.get(nameType);\n    }",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.loadFromResource(java.lang.String, org.apache.commons.codec.language.bm.Languages)",
        "snippet": "    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n        final List<LangRule> rules = new ArrayList<LangRule>();\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n\n        if (lRulesIS == null) {\n            throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n        }\n\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (scanner.hasNextLine()) {\n                final String rawLine = scanner.nextLine();\n                String line = rawLine;\n                if (inExtendedComment) {\n                    // check for closing comment marker, otherwise discard doc comment line\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else {\n                        // discard comments\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\n                        if (cmtI >= 0) {\n                            line = line.substring(0, cmtI);\n                        }\n\n                        // trim leading-trailing whitespace\n                        line = line.trim();\n\n                        if (line.length() == 0) {\n                            continue; // empty lines can be safely skipped\n                        }\n\n                        // split it up\n                        final String[] parts = line.split(\"\\\\s+\");\n\n                        if (parts.length != 3) {\n                            throw new IllegalArgumentException(\"Malformed line '\" + rawLine +\n                                    \"' in language resource '\" + languageRulesResourceName + \"'\");\n                        }\n\n                        final Pattern pattern = Pattern.compile(parts[0]);\n                        final String[] langs = parts[1].split(\"\\\\+\");\n                        final boolean accept = parts[2].equals(\"true\");\n\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                    }\n                }\n            }\n        } finally {\n            scanner.close();\n        }\n        return new Lang(rules, languages);\n    }",
        "begin_line": 129,
        "end_line": 185,
        "comment": "\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.Lang(java.util.List<org.apache.commons.codec.language.bm.Lang.LangRule>, org.apache.commons.codec.language.bm.Languages)",
        "snippet": "    private Lang(final List<LangRule> rules, final Languages languages) {\n        this.rules = Collections.unmodifiableList(rules);\n        this.languages = languages;\n    }",
        "begin_line": 190,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.guessLanguage(java.lang.String)",
        "snippet": "    public String guessLanguage(final String text) {\n        final Languages.LanguageSet ls = guessLanguages(text);\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n    }",
        "begin_line": 202,
        "end_line": 205,
        "comment": "\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
        "class_name": "org.apache.commons.codec.language.bm.Lang",
        "signature": "org.apache.commons.codec.language.bm.Lang.guessLanguages(java.lang.String)",
        "snippet": "    public Languages.LanguageSet guessLanguages(final String input) {\n        final String text = input.toLowerCase(Locale.ENGLISH);\n\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n        for (final LangRule rule : this.rules) {\n            if (rule.matches(text)) {\n                if (rule.acceptOnMatch) {\n                    langs.retainAll(rule.languages);\n                } else {\n                    langs.removeAll(rule.languages);\n                }\n            }\n        }\n\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n    }",
        "begin_line": 214,
        "end_line": 230,
        "comment": "\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/RuleType.java",
        "class_name": "org.apache.commons.codec.language.bm.RuleType",
        "signature": "org.apache.commons.codec.language.bm.RuleType.RuleType(java.lang.String)",
        "snippet": "    RuleType(final String name) {\n        this.name = name;\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/RuleType.java",
        "class_name": "org.apache.commons.codec.language.bm.RuleType",
        "signature": "org.apache.commons.codec.language.bm.RuleType.getName()",
        "snippet": "    public String getName() {\n        return this.name;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Gets the rule name.\n     *\n     * @return the rule name.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.Anonymous-2e643426-cd5c-42af-8431-fd91c695eb54.compare(org.apache.commons.codec.language.bm.Rule.Phoneme, org.apache.commons.codec.language.bm.Rule.Phoneme)",
        "snippet": "            @Override\n            public int compare(final Phoneme o1, final Phoneme o2) {\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\n                    if (i >= o2.phonemeText.length()) {\n                        return +1;\n                    }\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n                    if (c != 0) {\n                        return c;\n                    }\n                }\n\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\n                    return -1;\n                }\n\n                return 0;\n            }",
        "begin_line": 86,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.Phoneme(java.lang.CharSequence, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\n            this.phonemeText = new StringBuilder(phonemeText);\n            this.languages = languages;\n        }",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.Phoneme(org.apache.commons.codec.language.bm.Rule.Phoneme, org.apache.commons.codec.language.bm.Rule.Phoneme)",
        "snippet": "        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }",
        "begin_line": 114,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.Phoneme(org.apache.commons.codec.language.bm.Rule.Phoneme, org.apache.commons.codec.language.bm.Rule.Phoneme, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\n            this(phonemeLeft.phonemeText, languages);\n            this.phonemeText.append(phonemeRight.phonemeText);\n        }",
        "begin_line": 119,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.append(java.lang.CharSequence)",
        "snippet": "        public Phoneme append(final CharSequence str) {\n            this.phonemeText.append(str);\n            return this;\n        }",
        "begin_line": 124,
        "end_line": 127,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getLanguages()",
        "snippet": "        public Languages.LanguageSet getLanguages() {\n            return this.languages;\n        }",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemes()",
        "snippet": "        @Override\n        public Iterable<Phoneme> getPhonemes() {\n            return Collections.singleton(this);\n        }",
        "begin_line": 133,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()",
        "snippet": "        public CharSequence getPhonemeText() {\n            return this.phonemeText;\n        }",
        "begin_line": 138,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.join(org.apache.commons.codec.language.bm.Rule.Phoneme)",
        "snippet": "        @Deprecated\n        public Phoneme join(final Phoneme right) {\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n                               this.languages.restrictTo(right.languages));\n        }",
        "begin_line": 145,
        "end_line": 149,
        "comment": "\n         * @deprecated since 1.9\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr.getPhonemes()",
        "snippet": "        Iterable<Phoneme> getPhonemes();",
        "begin_line": 153,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeList.PhonemeList(java.util.List<org.apache.commons.codec.language.bm.Rule.Phoneme>)",
        "snippet": "        public PhonemeList(final List<Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeList.getPhonemes()",
        "snippet": "        @Override\n        public List<Phoneme> getPhonemes() {\n            return this.phonemes;\n        }",
        "begin_line": 163,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.RPattern.isMatch(java.lang.CharSequence)",
        "snippet": "        boolean isMatch(CharSequence input);",
        "begin_line": 173,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-7e04ddef-2e1a-4870-b588-f72a7dde7aff.isMatch(java.lang.CharSequence)",
        "snippet": "        @Override\n        public boolean isMatch(final CharSequence input) {\n            return true;\n        }",
        "begin_line": 177,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.contains(java.lang.CharSequence, char)",
        "snippet": "    private static boolean contains(final CharSequence chars, final char input) {\n        for (int i = 0; i < chars.length(); i++) {\n            if (chars.charAt(i) == input) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 219,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.createResourceName(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
        "snippet": "    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\n        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n                             nameType.getName(), rt.getName(), lang);\n    }",
        "begin_line": 228,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.createScanner(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
        "snippet": "    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\n        final String resName = createResourceName(nameType, rt, lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }",
        "begin_line": 233,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.createScanner(java.lang.String)",
        "snippet": "    private static Scanner createScanner(final String lang) {\n        final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n\n        if (rulesIS == null) {\n            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n        }\n\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n    }",
        "begin_line": 244,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.endsWith(java.lang.CharSequence, java.lang.CharSequence)",
        "snippet": "    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\n        if (suffix.length() > input.length()) {\n            return false;\n        }\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n            if (input.charAt(i) != suffix.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 255,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getInstance(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\n                                         final Languages.LanguageSet langs) {\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\n        final List<Rule> allRules = new ArrayList<Rule>();\n        for (final List<Rule> rules : ruleMap.values()) {\n            allRules.addAll(rules);\n        }\n        return allRules;\n    }",
        "begin_line": 278,
        "end_line": 286,
        "comment": "\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a list of Rules that apply\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getInstance(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
        "snippet": "    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\n    }",
        "begin_line": 299,
        "end_line": 301,
        "comment": "\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final Languages.LanguageSet langs) {\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\n                                     getInstanceMap(nameType, rt, Languages.ANY);\n    }",
        "begin_line": 315,
        "end_line": 319,
        "comment": "\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
        "snippet": "    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\n                                                         final String lang) {\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n\n        if (rules == null) {\n            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n                                               nameType.getName(), rt.getName(), lang));\n        }\n\n        return rules;\n    }",
        "begin_line": 333,
        "end_line": 343,
        "comment": "\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.parsePhoneme(java.lang.String)",
        "snippet": "    private static Phoneme parsePhoneme(final String ph) {\n        final int open = ph.indexOf(\"[\");\n        if (open >= 0) {\n            if (!ph.endsWith(\"]\")) {\n                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n            }\n            final String before = ph.substring(0, open);\n            final String in = ph.substring(open + 1, ph.length() - 1);\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\n        } else {\n            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n        }\n    }",
        "begin_line": 345,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.parsePhonemeExpr(java.lang.String)",
        "snippet": "    private static PhonemeExpr parsePhonemeExpr(final String ph) {\n        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n            if (!ph.endsWith(\")\")) {\n                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n            }\n\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\n            final String body = ph.substring(1, ph.length() - 1);\n            for (final String part : body.split(\"[|]\")) {\n                phs.add(parsePhoneme(part));\n            }\n            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n            }\n\n            return new PhonemeList(phs);\n        } else {\n            return parsePhoneme(ph);\n        }\n    }",
        "begin_line": 361,
        "end_line": 380,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.parseRules(java.util.Scanner, java.lang.String)",
        "snippet": "    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\n        int currentLine = 0;\n\n        boolean inMultilineComment = false;\n        while (scanner.hasNextLine()) {\n            currentLine++;\n            final String rawLine = scanner.nextLine();\n            String line = rawLine;\n\n            if (inMultilineComment) {\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                    inMultilineComment = false;\n                }\n            } else {\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                    inMultilineComment = true;\n                } else {\n                    // discard comments\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\n                    if (cmtI >= 0) {\n                        line = line.substring(0, cmtI);\n                    }\n\n                    // trim leading-trailing whitespace\n                    line = line.trim();\n\n                    if (line.length() == 0) {\n                        continue; // empty lines can be safely skipped\n                    }\n\n                    if (line.startsWith(HASH_INCLUDE)) {\n                        // include statement\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\n                        if (incl.contains(\" \")) {\n                            throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                               location);\n                        } else {\n                            lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                        }\n                    } else {\n                        // rule\n                        final String[] parts = line.split(\"\\\\s+\");\n                        if (parts.length != 4) {\n                            throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                                               \" parts: \" + rawLine + \" in \" + location);\n                        } else {\n                            try {\n                                final String pat = stripQuotes(parts[0]);\n                                final String lCon = stripQuotes(parts[1]);\n                                final String rCon = stripQuotes(parts[2]);\n                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n                                final int cLine = currentLine;\n                                final Rule r = new Rule(pat, lCon, rCon, ph) {\n                                    private final int myLine = cLine;\n                                    private final String loc = location;\n\n                                    @Override\n                                    public String toString() {\n                                        final StringBuilder sb = new StringBuilder();\n                                        sb.append(\"Rule\");\n                                        sb.append(\"{line=\").append(myLine);\n                                        sb.append(\", loc='\").append(loc).append('\\'');\n                                        sb.append('}');\n                                        return sb.toString();\n                                    }\n                                };\n                                final String patternKey = r.pattern.substring(0,1);\n                                List<Rule> rules = lines.get(patternKey);\n                                if (rules == null) {\n                                    rules = new ArrayList<Rule>();\n                                    lines.put(patternKey, rules);\n                                }\n                                rules.add(r);\n                            } catch (final IllegalArgumentException e) {\n                                throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n                                                                location, e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return lines;\n    }",
        "begin_line": 382,
        "end_line": 467,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-a3f42861-a2ed-4586-8c11-2f64d2d42dd0.toString()",
        "snippet": "                                    @Override\n                                    public String toString() {\n                                        final StringBuilder sb = new StringBuilder();\n                                        sb.append(\"Rule\");\n                                        sb.append(\"{line=\").append(myLine);\n                                        sb.append(\", loc='\").append(loc).append('\\'');\n                                        sb.append('}');\n                                        return sb.toString();\n                                    }",
        "begin_line": 439,
        "end_line": 447,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.pattern(java.lang.String)",
        "snippet": "    private static RPattern pattern(final String regex) {\n        final boolean startsWith = regex.startsWith(\"^\");\n        final boolean endsWith = regex.endsWith(\"$\");\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n        final boolean boxes = content.contains(\"[\");\n\n        if (!boxes) {\n            if (startsWith && endsWith) {\n                // exact match\n                if (content.length() == 0) {\n                    // empty\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }\n                    };\n                } else {\n                    return new RPattern() {\n                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }\n                    };\n                }\n            } else if ((startsWith || endsWith) && content.length() == 0) {\n                // matches every string\n                return ALL_STRINGS_RMATCHER;\n            } else if (startsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }\n                };\n            } else if (endsWith) {\n                // matches from start\n                return new RPattern() {\n                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }\n                };\n            }\n        } else {\n            final boolean startsWithBox = content.startsWith(\"[\");\n            final boolean endsWithBox = content.endsWith(\"]\");\n\n            if (startsWithBox && endsWithBox) {\n                String boxContent = content.substring(1, content.length() - 1);\n                if (!boxContent.contains(\"[\")) {\n                    // box containing alternatives\n                    final boolean negate = boxContent.startsWith(\"^\");\n                    if (negate) {\n                        boxContent = boxContent.substring(1);\n                    }\n                    final String bContent = boxContent;\n                    final boolean shouldMatch = !negate;\n\n                    if (startsWith && endsWith) {\n                        // exact match\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (startsWith) {\n                        // first char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }\n                        };\n                    } else if (endsWith) {\n                        // last char\n                        return new RPattern() {\n                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        return new RPattern() {\n            Pattern pattern = Pattern.compile(regex);\n\n            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }\n        };\n    }",
        "begin_line": 476,
        "end_line": 575,
        "comment": "\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-b92b6efc-ee14-4bec-b787-827398da52a9.isMatch(java.lang.CharSequence)",
        "snippet": "                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 &&\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                            }",
        "begin_line": 555,
        "end_line": 559,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-78650ff1-ede2-44b8-8464-51cd32a4c188.isMatch(java.lang.CharSequence)",
        "snippet": "                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }",
        "begin_line": 547,
        "end_line": 550,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-3caacecf-1d46-4624-9fe7-3d9cb5ee95e9.isMatch(java.lang.CharSequence)",
        "snippet": "                            @Override\n                            public boolean isMatch(final CharSequence input) {\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                            }",
        "begin_line": 539,
        "end_line": 542,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-e4d7951a-7ebe-4ef8-8b9e-83fb6fc709ac.isMatch(java.lang.CharSequence)",
        "snippet": "                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return endsWith(input, content);\n                    }",
        "begin_line": 515,
        "end_line": 518,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-8e83b55c-ea8f-485b-9c1e-c0fb044d84d6.isMatch(java.lang.CharSequence)",
        "snippet": "                    @Override\n                    public boolean isMatch(final CharSequence input) {\n                        return startsWith(input, content);\n                    }",
        "begin_line": 507,
        "end_line": 510,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-94703cb9-fccf-49e9-b2de-30b86babfb3e.isMatch(java.lang.CharSequence)",
        "snippet": "                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.equals(content);\n                        }",
        "begin_line": 495,
        "end_line": 498,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-ce788977-caea-4907-8281-d5e83ce54d68.isMatch(java.lang.CharSequence)",
        "snippet": "                        @Override\n                        public boolean isMatch(final CharSequence input) {\n                            return input.length() == 0;\n                        }",
        "begin_line": 488,
        "end_line": 491,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Anonymous-eeb22210-3b73-4f09-a6ca-a2f8f80f5a84.isMatch(java.lang.CharSequence)",
        "snippet": "            @Override\n            public boolean isMatch(final CharSequence input) {\n                final Matcher matcher = pattern.matcher(input);\n                return matcher.find();\n            }",
        "begin_line": 569,
        "end_line": 573,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.startsWith(java.lang.CharSequence, java.lang.CharSequence)",
        "snippet": "    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\n        if (prefix.length() > input.length()) {\n            return false;\n        }\n        for (int i = 0; i < prefix.length(); i++) {\n            if (input.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 577,
        "end_line": 587,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.stripQuotes(java.lang.String)",
        "snippet": "    private static String stripQuotes(String str) {\n        if (str.startsWith(DOUBLE_QUOTE)) {\n            str = str.substring(1);\n        }\n\n        if (str.endsWith(DOUBLE_QUOTE)) {\n            str = str.substring(0, str.length() - 1);\n        }\n\n        return str;\n    }",
        "begin_line": 589,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.Rule(java.lang.String, java.lang.String, java.lang.String, org.apache.commons.codec.language.bm.Rule.PhonemeExpr)",
        "snippet": "    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n        this.pattern = pattern;\n        this.lContext = pattern(lContext + \"$\");\n        this.rContext = pattern(\"^\" + rContext);\n        this.phoneme = phoneme;\n    }",
        "begin_line": 621,
        "end_line": 626,
        "comment": "\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getLContext()",
        "snippet": "    public RPattern getLContext() {\n        return this.lContext;\n    }",
        "begin_line": 633,
        "end_line": 635,
        "comment": "\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getPattern()",
        "snippet": "    public String getPattern() {\n        return this.pattern;\n    }",
        "begin_line": 642,
        "end_line": 644,
        "comment": "\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getPhoneme()",
        "snippet": "    public PhonemeExpr getPhoneme() {\n        return this.phoneme;\n    }",
        "begin_line": 651,
        "end_line": 653,
        "comment": "\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.getRContext()",
        "snippet": "    public RPattern getRContext() {\n        return this.rContext;\n    }",
        "begin_line": 660,
        "end_line": 662,
        "comment": "\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "class_name": "org.apache.commons.codec.language.bm.Rule",
        "signature": "org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(java.lang.CharSequence, int)",
        "snippet": "    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n        }\n\n        final int patternLength = this.pattern.length();\n        final int ipl = i + patternLength;\n\n        if (ipl > input.length()) {\n            // not enough room for the pattern to match\n            return false;\n        }\n\n        // evaluate the pattern, left context and right context\n        // fail early if any of the evaluations is not successful\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\n            return false;\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\n            return false;\n        }\n        return this.lContext.isMatch(input.subSequence(0, i));\n    }",
        "begin_line": 675,
        "end_line": 696,
        "comment": "\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n            return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));\n        }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.PhonemeBuilder(org.apache.commons.codec.language.bm.Rule.Phoneme)",
        "snippet": "        private PhonemeBuilder(final Rule.Phoneme phoneme) {\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\n            this.phonemes.add(phoneme);\n        }",
        "begin_line": 77,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.PhonemeBuilder(java.util.Set<org.apache.commons.codec.language.bm.Rule.Phoneme>)",
        "snippet": "        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\n            this.phonemes = phonemes;\n        }",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.append(java.lang.CharSequence)",
        "snippet": "        public void append(final CharSequence str) {\n            for (final Rule.Phoneme ph : this.phonemes) {\n                ph.append(str);\n            }\n        }",
        "begin_line": 91,
        "end_line": 95,
        "comment": "\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n         *\n         * @param str   the characters to append to the phonemes\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(org.apache.commons.codec.language.bm.Rule.PhonemeExpr, int)",
        "snippet": "        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\n\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\n                    if (!languages.isEmpty()) {\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\n                        if (newPhonemes.size() < maxPhonemes) {\n                            newPhonemes.add(join);\n                            if (newPhonemes.size() >= maxPhonemes) {\n                                break EXPR;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.phonemes.clear();\n            this.phonemes.addAll(newPhonemes);\n        }",
        "begin_line": 106,
        "end_line": 126,
        "comment": "\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.getPhonemes()",
        "snippet": "        public Set<Rule.Phoneme> getPhonemes() {\n            return this.phonemes;\n        }",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.makeString()",
        "snippet": "        public String makeString() {\n            final StringBuilder sb = new StringBuilder();\n\n            for (final Rule.Phoneme ph : this.phonemes) {\n                if (sb.length() > 0) {\n                    sb.append(\"|\");\n                }\n                sb.append(ph.getPhonemeText());\n            }\n\n            return sb.toString();\n        }",
        "begin_line": 144,
        "end_line": 155,
        "comment": "\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.RulesApplication(java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>, java.lang.CharSequence, org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder, int, int)",
        "snippet": "        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\n            if (finalRules == null) {\n                throw new NullPointerException(\"The finalRules argument must not be null\");\n            }\n            this.finalRules = finalRules;\n            this.phonemeBuilder = phonemeBuilder;\n            this.input = input;\n            this.i = i;\n            this.maxPhonemes = maxPhonemes;\n        }",
        "begin_line": 179,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getI()",
        "snippet": "        public int getI() {\n            return this.i;\n        }",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getPhonemeBuilder()",
        "snippet": "        public PhonemeBuilder getPhonemeBuilder() {\n            return this.phonemeBuilder;\n        }",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.invoke()",
        "snippet": "        public RulesApplication invoke() {\n            this.found = false;\n            int patternLength = 1;\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n            if (rules != null) {\n                for (final Rule rule : rules) {\n                    final String pattern = rule.getPattern();\n                    patternLength = pattern.length();\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                        this.found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!this.found) {\n                patternLength = 1;\n            }\n\n            this.i += patternLength;\n            return this;\n        }",
        "begin_line": 206,
        "end_line": 228,
        "comment": "\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return <code>this</code>\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.isFound()",
        "snippet": "        public boolean isFound() {\n            return this.found;\n        }",
        "begin_line": 230,
        "end_line": 232,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.join(java.lang.Iterable<java.lang.String>, java.lang.String)",
        "snippet": "    private static String join(final Iterable<String> strings, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<String> si = strings.iterator();\n        if (si.hasNext()) {\n            sb.append(si.next());\n        }\n        while (si.hasNext()) {\n            sb.append(sep).append(si.next());\n        }\n\n        return sb.toString();\n    }",
        "begin_line": 257,
        "end_line": 268,
        "comment": "\n     * Joins some strings with an internal separator.\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhoneticEngine(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, boolean)",
        "snippet": "    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n    }",
        "begin_line": 292,
        "end_line": 294,
        "comment": "\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhoneticEngine(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, boolean, int)",
        "snippet": "    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\n                          final int maxPhonemes) {\n        if (ruleType == RuleType.RULES) {\n            throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n        }\n        this.nameType = nameType;\n        this.ruleType = ruleType;\n        this.concat = concat;\n        this.lang = Lang.instance(nameType);\n        this.maxPhonemes = maxPhonemes;\n    }",
        "begin_line": 309,
        "end_line": 319,
        "comment": "\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concat\n     *            if it will concatenate multiple encodings\n     * @param maxPhonemes\n     *            the maximum number of phonemes that will be handled\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder, java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>)",
        "snippet": "    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\n                                           final Map<String, List<Rule>> finalRules) {\n        if (finalRules == null) {\n            throw new NullPointerException(\"finalRules can not be null\");\n        }\n        if (finalRules.isEmpty()) {\n            return phonemeBuilder;\n        }\n\n        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n            final String phonemeText = phoneme.getPhonemeText().toString();\n\n            for (int i = 0; i < phonemeText.length();) {\n                final RulesApplication rulesApplication =\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                final boolean found = rulesApplication.isFound();\n                subBuilder = rulesApplication.getPhonemeBuilder();\n\n                if (!found) {\n                    // not found, appending as-is\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\n                }\n\n                i = rulesApplication.getI();\n            }\n\n            phonemes.addAll(subBuilder.getPhonemes());\n        }\n\n        return new PhonemeBuilder(phonemes);\n    }",
        "begin_line": 329,
        "end_line": 362,
        "comment": "\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
        "snippet": "    public String encode(final String input) {\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n        return encode(input, languageSet);\n    }",
        "begin_line": 371,
        "end_line": 374,
        "comment": "\n     * Encodes a string to its phonetic representation.\n     *\n     * @param input\n     *            the String to encode\n     * @return the encoding of the input\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<String>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            for (final String aWord : words) {\n                final String[] parts = aWord.split(\"'\");\n                final String lastPart = parts[parts.length - 1];\n                words2.add(lastPart);\n            }\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            for (final String word : words2) {\n                result.append(\"-\").append(encode(word));\n            }\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }",
        "begin_line": 385,
        "end_line": 469,
        "comment": "\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations\n     *   of the input\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getLang()",
        "snippet": "    public Lang getLang() {\n        return this.lang;\n    }",
        "begin_line": 476,
        "end_line": 478,
        "comment": "\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()",
        "snippet": "    public NameType getNameType() {\n        return this.nameType;\n    }",
        "begin_line": 485,
        "end_line": 487,
        "comment": "\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()",
        "snippet": "    public RuleType getRuleType() {\n        return this.ruleType;\n    }",
        "begin_line": 494,
        "end_line": 496,
        "comment": "\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()",
        "snippet": "    public boolean isConcat() {\n        return this.concat;\n    }",
        "begin_line": 503,
        "end_line": 505,
        "comment": "\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
        "class_name": "org.apache.commons.codec.language.bm.PhoneticEngine",
        "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getMaxPhonemes()",
        "snippet": "    public int getMaxPhonemes() {\n        return this.maxPhonemes;\n    }",
        "begin_line": 513,
        "end_line": 515,
        "comment": "\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
        "snippet": "        public static LanguageSet from(final Set<String> langs) {\n            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n        }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.contains(java.lang.String)",
        "snippet": "        public abstract boolean contains(String language);",
        "begin_line": 67,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.getAny()",
        "snippet": "        public abstract String getAny();",
        "begin_line": 69,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.isEmpty()",
        "snippet": "        public abstract boolean isEmpty();",
        "begin_line": 71,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.isSingleton()",
        "snippet": "        public abstract boolean isSingleton();",
        "begin_line": 73,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        public abstract LanguageSet restrictTo(LanguageSet other);",
        "begin_line": 75,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.SomeLanguages(java.util.Set<java.lang.String>)",
        "snippet": "        private SomeLanguages(final Set<String> languages) {\n            this.languages = Collections.unmodifiableSet(languages);\n        }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.contains(java.lang.String)",
        "snippet": "        @Override\n        public boolean contains(final String language) {\n            return this.languages.contains(language);\n        }",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.getAny()",
        "snippet": "        @Override\n        public String getAny() {\n            return this.languages.iterator().next();\n        }",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.getLanguages()",
        "snippet": "        public Set<String> getLanguages() {\n            return this.languages;\n        }",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.isEmpty()",
        "snippet": "        @Override\n        public boolean isEmpty() {\n            return this.languages.isEmpty();\n        }",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.isSingleton()",
        "snippet": "        @Override\n        public boolean isSingleton() {\n            return this.languages.size() == 1;\n        }",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        @Override\n        public LanguageSet restrictTo(final LanguageSet other) {\n            if (other == NO_LANGUAGES) {\n                return other;\n            } else if (other == ANY_LANGUAGE) {\n                return this;\n            } else {\n                final SomeLanguages sl = (SomeLanguages) other;\n                final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\n                for (String lang : languages) {\n                    if (sl.languages.contains(lang)) {\n                        ls.add(lang);\n                    }\n                }\n                return from(ls);\n            }\n        }",
        "begin_line": 112,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.SomeLanguages.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"Languages(\" + languages.toString() + \")\";\n        }",
        "begin_line": 130,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.getInstance(org.apache.commons.codec.language.bm.NameType)",
        "snippet": "    public static Languages getInstance(final NameType nameType) {\n        return LANGUAGES.get(nameType);\n    }",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.getInstance(java.lang.String)",
        "snippet": "    public static Languages getInstance(final String languagesResourceName) {\n        // read languages list\n        final Set<String> ls = new HashSet<String>();\n        final InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n\n        if (langIS == null) {\n            throw new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n        }\n\n        final Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\n        try {\n            boolean inExtendedComment = false;\n            while (lsScanner.hasNextLine()) {\n                final String line = lsScanner.nextLine().trim();\n                if (inExtendedComment) {\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                        inExtendedComment = false;\n                    }\n                } else {\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n                        inExtendedComment = true;\n                    } else if (line.length() > 0) {\n                        ls.add(line);\n                    }\n                }\n            }\n        } finally {\n            lsScanner.close();\n        }\n\n        return new Languages(Collections.unmodifiableSet(ls));\n    }",
        "begin_line": 151,
        "end_line": 182,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.langResourceName(org.apache.commons.codec.language.bm.NameType)",
        "snippet": "    private static String langResourceName(final NameType nameType) {\n        return String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n    }",
        "begin_line": 184,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-76740605-c78d-4a93-8cd7-ee322ce6dca0.contains(java.lang.String)",
        "snippet": "        @Override\n        public boolean contains(final String language) {\n            return false;\n        }",
        "begin_line": 194,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-b47d771b-f17a-4a67-a155-d06547d9d502.getAny()",
        "snippet": "        @Override\n        public String getAny() {\n            throw new NoSuchElementException(\"Can't fetch any language from the empty language set.\");\n        }",
        "begin_line": 199,
        "end_line": 202,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-697c6715-6e4b-4663-945c-d9bbadbecddf.isEmpty()",
        "snippet": "        @Override\n        public boolean isEmpty() {\n            return true;\n        }",
        "begin_line": 204,
        "end_line": 207,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-c2cad106-6fb3-41d7-baff-3a2af917ecea.isSingleton()",
        "snippet": "        @Override\n        public boolean isSingleton() {\n            return false;\n        }",
        "begin_line": 209,
        "end_line": 212,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-48bafb65-b8f9-4ab3-b504-adfea9064a8f.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        @Override\n        public LanguageSet restrictTo(final LanguageSet other) {\n            return this;\n        }",
        "begin_line": 214,
        "end_line": 217,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-fbe94474-bf14-4ec2-b9b8-92bf41e6e172.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"NO_LANGUAGES\";\n        }",
        "begin_line": 219,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-2b1d73d5-5d4b-4a4e-8e7d-9f48d283c4bc.contains(java.lang.String)",
        "snippet": "        @Override\n        public boolean contains(final String language) {\n            return true;\n        }",
        "begin_line": 229,
        "end_line": 232,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-b0b68c69-5cb1-428d-84ef-c9789ac9938d.getAny()",
        "snippet": "        @Override\n        public String getAny() {\n            throw new NoSuchElementException(\"Can't fetch any language from the any language set.\");\n        }",
        "begin_line": 234,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-31de46f1-cd08-4ddc-8424-38bc231d5c84.isEmpty()",
        "snippet": "        @Override\n        public boolean isEmpty() {\n            return false;\n        }",
        "begin_line": 239,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-07a3d2df-0ad8-4953-8e81-aac5288da486.isSingleton()",
        "snippet": "        @Override\n        public boolean isSingleton() {\n            return false;\n        }",
        "begin_line": 244,
        "end_line": 247,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-36fb9a88-2111-4050-9a49-20ee3d6e0350.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
        "snippet": "        @Override\n        public LanguageSet restrictTo(final LanguageSet other) {\n            return other;\n        }",
        "begin_line": 249,
        "end_line": 252,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Anonymous-f9ae27d3-722c-4172-8d34-70e6b9f01036.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"ANY_LANGUAGE\";\n        }",
        "begin_line": 254,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.Languages(java.util.Set<java.lang.String>)",
        "snippet": "    private Languages(final Set<String> languages) {\n        this.languages = languages;\n    }",
        "begin_line": 260,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/codec/language/bm/Languages.java",
        "class_name": "org.apache.commons.codec.language.bm.Languages",
        "signature": "org.apache.commons.codec.language.bm.Languages.getLanguages()",
        "snippet": "    public Set<String> getLanguages() {\n        return this.languages;\n    }",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {}
    }
]