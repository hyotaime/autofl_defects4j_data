[
    {
        "src_path": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "org.jsoup.SerializationException",
        "signature": "org.jsoup.SerializationException.SerializationException()",
        "snippet": "\tpublic SerializationException() {\n\t\tsuper();\n\t}",
        "begin_line": 11,
        "end_line": 13,
        "comment": "\n\t * Creates and initializes a new serialization exception with no error message and cause.\n\t ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "org.jsoup.SerializationException",
        "signature": "org.jsoup.SerializationException.SerializationException(java.lang.String)",
        "snippet": "\tpublic SerializationException(String message) {\n\t\tsuper(message);\n\t}",
        "begin_line": 21,
        "end_line": 23,
        "comment": "\n\t * Creates and initializes a new serialization exception with the given error message and no cause.\n\t * \n\t * @param message\n\t *            the error message of the new serialization exception (may be <code>null</code>).\n\t ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "org.jsoup.SerializationException",
        "signature": "org.jsoup.SerializationException.SerializationException(java.lang.Throwable)",
        "snippet": "\tpublic SerializationException(Throwable cause) {\n\t\tsuper(cause);\n\t}",
        "begin_line": 33,
        "end_line": 35,
        "comment": "\n\t * Creates and initializes a new serialization exception with the specified cause and an error message of\n     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n     * <code>cause</code>).\n\t * \n\t * @param cause\n\t *            the cause of the new serialization exception (may be <code>null</code>).\n\t ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/SerializationException.java",
        "class_name": "org.jsoup.SerializationException",
        "signature": "org.jsoup.SerializationException.SerializationException(java.lang.String, java.lang.Throwable)",
        "snippet": "\tpublic SerializationException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n\t * Creates and initializes a new serialization exception with the given error message and cause.\n\t * \n\t * @param message\n\t *            the error message of the new serialization exception.\n\t * @param cause\n\t *            the cause of the new serialization exception.\n\t ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UncheckedIOException.java",
        "class_name": "org.jsoup.UncheckedIOException",
        "signature": "org.jsoup.UncheckedIOException.UncheckedIOException(java.io.IOException)",
        "snippet": "    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }",
        "begin_line": 6,
        "end_line": 8,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UncheckedIOException.java",
        "class_name": "org.jsoup.UncheckedIOException",
        "signature": "org.jsoup.UncheckedIOException.ioException()",
        "snippet": "    public IOException ioException() {\n        return (IOException) getCause();\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Method.Method(boolean)",
        "snippet": "        Method(boolean hasBody) {\n            this.hasBody = hasBody;\n        }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Method.hasBody()",
        "snippet": "        public final boolean hasBody() {\n            return hasBody;\n        }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n         * Check if this HTTP method has/needs a request body\n         * @return if body needed\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.url(java.net.URL)",
        "snippet": "    Connection url(URL url);",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n     * @param url URL to connect to\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.url(java.lang.String)",
        "snippet": "    Connection url(String url);",
        "begin_line": 63,
        "end_line": 63,
        "comment": "\n     * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n     * @param url URL to connect to\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.proxy(java.net.Proxy)",
        "snippet": "    Connection proxy(Proxy proxy);",
        "begin_line": 70,
        "end_line": 70,
        "comment": "\n     * Set the proxy to use for this request. Set to <code>null</code> to disable.\n     * @param proxy proxy to use\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.proxy(java.lang.String, int)",
        "snippet": "    Connection proxy(String host, int port);",
        "begin_line": 78,
        "end_line": 78,
        "comment": "\n     * Set the HTTP proxy to use for this request.\n     * @param host the proxy hostname\n     * @param port the proxy port\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.userAgent(java.lang.String)",
        "snippet": "    Connection userAgent(String userAgent);",
        "begin_line": 86,
        "end_line": 86,
        "comment": "\n     * Set the request user-agent header.\n     * @param userAgent user-agent to use\n     * @return this Connection, for chaining\n     * @see org.jsoup.helper.HttpConnection#DEFAULT_UA\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.timeout(int)",
        "snippet": "    Connection timeout(int millis);",
        "begin_line": 97,
        "end_line": 97,
        "comment": "\n     * Set the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.\n     * <p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n     * <p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read\n     * the full response.\n     * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n     * @return this Connection, for chaining\n     * @see #maxBodySize(int)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.maxBodySize(int)",
        "snippet": "    Connection maxBodySize(int bytes);",
        "begin_line": 106,
        "end_line": 106,
        "comment": "\n     * Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\n     * and the input truncated. The default maximum is 1MB. A max size of zero is treated as an infinite amount (bounded\n     * only by your patience and the memory available on your machine).\n     * @param bytes number of bytes to read from the input before truncating\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.referrer(java.lang.String)",
        "snippet": "    Connection referrer(String referrer);",
        "begin_line": 113,
        "end_line": 113,
        "comment": "\n     * Set the request referrer (aka \"referer\") header.\n     * @param referrer referrer to use\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.followRedirects(boolean)",
        "snippet": "    Connection followRedirects(boolean followRedirects);",
        "begin_line": 120,
        "end_line": 120,
        "comment": "\n     * Configures the connection to (not) follow server redirects. By default this is <b>true</b>.\n     * @param followRedirects true if server redirects should be followed.\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.method(org.jsoup.Connection.Method)",
        "snippet": "    Connection method(Method method);",
        "begin_line": 127,
        "end_line": 127,
        "comment": "\n     * Set the request method to use, GET or POST. Default is GET.\n     * @param method HTTP request method\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.ignoreHttpErrors(boolean)",
        "snippet": "    Connection ignoreHttpErrors(boolean ignoreHttpErrors);",
        "begin_line": 136,
        "end_line": 136,
        "comment": "\n     * Configures the connection to not throw exceptions when a HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By\n     * default this is <b>false</b>; an IOException is thrown if an error is encountered. If set to <b>true</b>, the\n     * response is populated with the error body, and the status message will reflect the error.\n     * @param ignoreHttpErrors - false (default) if HTTP errors should be ignored.\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.ignoreContentType(boolean)",
        "snippet": "    Connection ignoreContentType(boolean ignoreContentType);",
        "begin_line": 146,
        "end_line": 146,
        "comment": "\n     * Ignore the document's Content-Type when parsing the response. By default this is <b>false</b>, an unrecognised\n     * content-type will cause an IOException to be thrown. (This is to prevent producing garbage by attempting to parse\n     * a JPEG binary image, for example.) Set to true to force a parse attempt regardless of content type.\n     * @param ignoreContentType set to true if you would like the content type ignored on parsing the response into a\n     * Document.\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.sslSocketFactory(javax.net.ssl.SSLSocketFactory)",
        "snippet": "    Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);",
        "begin_line": 153,
        "end_line": 153,
        "comment": "\n     * Set custom SSL socket factory\n     * @param sslSocketFactory custom SSL socket factory\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.lang.String, java.lang.String)",
        "snippet": "    Connection data(String key, String value);",
        "begin_line": 162,
        "end_line": 162,
        "comment": "\n     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n     * request body for POSTs. A request may have multiple values of the same name.\n     * @param key data key\n     * @param value data value\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.lang.String, java.lang.String, java.io.InputStream)",
        "snippet": "    Connection data(String key, String filename, InputStream inputStream);",
        "begin_line": 175,
        "end_line": 175,
        "comment": "\n     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n     * input stream.\n     * @param key data key (form item name)\n     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n     * component.\n     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n     * You must close the InputStream in a {@code finally} block.\n     * @return this Connections, for chaining\n     * @see #data(String, String, InputStream, String) if you want to set the uploaded file's mimetype.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.lang.String, java.lang.String, java.io.InputStream, java.lang.String)",
        "snippet": "    Connection data(String key, String filename, InputStream inputStream, String contentType);",
        "begin_line": 188,
        "end_line": 188,
        "comment": "\n     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n     * input stream.\n     * @param key data key (form item name)\n     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n     * component.\n     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n     * @param contentType the Content Type (aka mimetype) to specify for this file.\n     * You must close the InputStream in a {@code finally} block.\n     * @return this Connections, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.util.Collection<org.jsoup.Connection.KeyVal>)",
        "snippet": "    Connection data(Collection<KeyVal> data);",
        "begin_line": 195,
        "end_line": 195,
        "comment": "\n     * Adds all of the supplied data to the request data parameters\n     * @param data collection of data parameters\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    Connection data(Map<String, String> data);",
        "begin_line": 202,
        "end_line": 202,
        "comment": "\n     * Adds all of the supplied data to the request data parameters\n     * @param data map of data parameters\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.lang.String...)",
        "snippet": "    Connection data(String... keyvals);",
        "begin_line": 211,
        "end_line": 211,
        "comment": "\n     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n     * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n     * <code>{@literal ?name=jsoup&language=Java&language=English}</code>\n     * @param keyvals a set of key value pairs.\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.data(java.lang.String)",
        "snippet": "    KeyVal data(String key);",
        "begin_line": 218,
        "end_line": 218,
        "comment": "\n     * Get the data KeyVal for this key, if any\n     * @param key the data key\n     * @return null if not set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.requestBody(java.lang.String)",
        "snippet": "    Connection requestBody(String body);",
        "begin_line": 230,
        "end_line": 230,
        "comment": "\n     * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n     * encoded form key/value pairs. E.g.:\n     * <code><pre>Jsoup.connect(url)\n     * .requestBody(json)\n     * .header(\"Content-Type\", \"application/json\")\n     * .post();</pre></code>\n     * If any data key/vals are supplied, they will be sent as URL query params.\n     * @return this Request, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.header(java.lang.String, java.lang.String)",
        "snippet": "    Connection header(String name, String value);",
        "begin_line": 239,
        "end_line": 239,
        "comment": "\n     * Set a request header.\n     * @param name header name\n     * @param value header value\n     * @return this Connection, for chaining\n     * @see org.jsoup.Connection.Request#headers()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.headers(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    Connection headers(Map<String,String> headers);",
        "begin_line": 247,
        "end_line": 247,
        "comment": "\n     * Adds each of the supplied headers to the request.\n     * @param headers map of headers name {@literal ->} value pairs\n     * @return this Connection, for chaining\n     * @see org.jsoup.Connection.Request#headers()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.cookie(java.lang.String, java.lang.String)",
        "snippet": "    Connection cookie(String name, String value);",
        "begin_line": 255,
        "end_line": 255,
        "comment": "\n     * Set a cookie to be sent in the request.\n     * @param name name of cookie\n     * @param value value of cookie\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.cookies(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    Connection cookies(Map<String, String> cookies);",
        "begin_line": 262,
        "end_line": 262,
        "comment": "\n     * Adds each of the supplied cookies to the request.\n     * @param cookies map of cookie name {@literal ->} value pairs\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.parser(org.jsoup.parser.Parser)",
        "snippet": "    Connection parser(Parser parser);",
        "begin_line": 270,
        "end_line": 270,
        "comment": "\n     * Provide an alternate parser to use when parsing the response to a Document. If not set, defaults to the HTML\n     * parser, unless the response content-type is XML, in which case the XML parser is used.\n     * @param parser alternate parser\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.postDataCharset(java.lang.String)",
        "snippet": "    Connection postDataCharset(String charset);",
        "begin_line": 277,
        "end_line": 277,
        "comment": "\n     * Sets the default post data character set for x-www-form-urlencoded post data\n     * @param charset character set to encode post data\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.get()",
        "snippet": "    Document get() throws IOException;",
        "begin_line": 288,
        "end_line": 288,
        "comment": "\n     * Execute the request as a GET, and parse the result.\n     * @return parsed Document\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.post()",
        "snippet": "    Document post() throws IOException;",
        "begin_line": 299,
        "end_line": 299,
        "comment": "\n     * Execute the request as a POST, and parse the result.\n     * @return parsed Document\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.execute()",
        "snippet": "    Response execute() throws IOException;",
        "begin_line": 310,
        "end_line": 310,
        "comment": "\n     * Execute the request.\n     * @return a response object\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException on error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.request()",
        "snippet": "    Request request();",
        "begin_line": 316,
        "end_line": 316,
        "comment": "\n     * Get the request object associated with this connection\n     * @return request\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.request(org.jsoup.Connection.Request)",
        "snippet": "    Connection request(Request request);",
        "begin_line": 323,
        "end_line": 323,
        "comment": "\n     * Set the connection's request\n     * @param request new request object\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.response()",
        "snippet": "    Response response();",
        "begin_line": 329,
        "end_line": 329,
        "comment": "\n     * Get the response, once the request has been executed\n     * @return response\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.response(org.jsoup.Connection.Response)",
        "snippet": "    Connection response(Response response);",
        "begin_line": 336,
        "end_line": 336,
        "comment": "\n     * Set the connection's response\n     * @param response new response\n     * @return this Connection, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.url()",
        "snippet": "        URL url();",
        "begin_line": 348,
        "end_line": 348,
        "comment": "\n         * Get the URL\n         * @return URL\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.url(java.net.URL)",
        "snippet": "        T url(URL url);",
        "begin_line": 355,
        "end_line": 355,
        "comment": "\n         * Set the URL\n         * @param url new URL\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.method()",
        "snippet": "        Method method();",
        "begin_line": 361,
        "end_line": 361,
        "comment": "\n         * Get the request method\n         * @return method\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.method(org.jsoup.Connection.Method)",
        "snippet": "        T method(Method method);",
        "begin_line": 368,
        "end_line": 368,
        "comment": "\n         * Set the request method\n         * @param method new method\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.header(java.lang.String)",
        "snippet": "        String header(String name);",
        "begin_line": 381,
        "end_line": 381,
        "comment": "\n         * Get the value of a header. If there is more than one header value with the same name, the headers are returned\n         * comma seperated, per <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\">rfc2616-sec4</a>.\n         * <p>\n         * Header names are case insensitive.\n         * </p>\n         * @param name name of header (case insensitive)\n         * @return value of header, or null if not set.\n         * @see #hasHeader(String)\n         * @see #cookie(String)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.headers(java.lang.String)",
        "snippet": "        List<String> headers(String name);",
        "begin_line": 388,
        "end_line": 388,
        "comment": "\n         * Get the values of a header.\n         * @param name header name, case insensitive.\n         * @return a list of values for this header, or an empty list if not set.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.header(java.lang.String, java.lang.String)",
        "snippet": "        T header(String name, String value);",
        "begin_line": 398,
        "end_line": 398,
        "comment": "\n         * Set a header. This method will overwrite any existing header with the same case insensitive name. (If there\n         * is more than one value for this header, this method will update the first matching header.\n         * @param name Name of header\n         * @param value Value of header\n         * @return this, for chaining\n         * @see #addHeader(String, String)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.addHeader(java.lang.String, java.lang.String)",
        "snippet": "        T addHeader(String name, String value);",
        "begin_line": 406,
        "end_line": 406,
        "comment": "\n         * Add a header. The header will be added regardless of whether a header with the same name already exists.\n         * @param name Name of new header\n         * @param value Value of new header\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.hasHeader(java.lang.String)",
        "snippet": "        boolean hasHeader(String name);",
        "begin_line": 413,
        "end_line": 413,
        "comment": "\n         * Check if a header is present\n         * @param name name of header (case insensitive)\n         * @return if the header is present in this request/response\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.hasHeaderWithValue(java.lang.String, java.lang.String)",
        "snippet": "        boolean hasHeaderWithValue(String name, String value);",
        "begin_line": 421,
        "end_line": 421,
        "comment": "\n         * Check if a header is present, with the given value\n         * @param name header name (case insensitive)\n         * @param value value (case insensitive)\n         * @return if the header and value pair are set in this req/res\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.removeHeader(java.lang.String)",
        "snippet": "        T removeHeader(String name);",
        "begin_line": 428,
        "end_line": 428,
        "comment": "\n         * Remove headers by name. If there is more than one header with this name, they will all be removed.\n         * @param name name of header to remove (case insensitive)\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.headers()",
        "snippet": "        Map<String, String> headers();",
        "begin_line": 439,
        "end_line": 439,
        "comment": "\n         * Retrieve all of the request/response header names and corresponding values as a map. For headers with multiple\n         * values, only the first header is returned.\n         * <p>Note that this is a view of the headers only, and changes made to this map will not be reflected in the\n         * request/response object.</p>\n         * @return headers\n         * @see #multiHeaders()\n\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.multiHeaders()",
        "snippet": "        Map<String, List<String>> multiHeaders();",
        "begin_line": 445,
        "end_line": 445,
        "comment": "\n         * Retreive all of the headers, keyed by the header name, and with a list of values per header.\n         * @return a list of multiple values per header.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.cookie(java.lang.String)",
        "snippet": "        String cookie(String name);",
        "begin_line": 456,
        "end_line": 456,
        "comment": "\n         * Get a cookie value by name from this request/response.\n         * <p>\n         * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n         * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n         * </p>\n         * @param name name of cookie to retrieve.\n         * @return value of cookie, or null if not set\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.cookie(java.lang.String, java.lang.String)",
        "snippet": "        T cookie(String name, String value);",
        "begin_line": 464,
        "end_line": 464,
        "comment": "\n         * Set a cookie in this request/response.\n         * @param name name of cookie\n         * @param value value of cookie\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.hasCookie(java.lang.String)",
        "snippet": "        boolean hasCookie(String name);",
        "begin_line": 471,
        "end_line": 471,
        "comment": "\n         * Check if a cookie is present\n         * @param name name of cookie\n         * @return if the cookie is present in this request/response\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.removeCookie(java.lang.String)",
        "snippet": "        T removeCookie(String name);",
        "begin_line": 478,
        "end_line": 478,
        "comment": "\n         * Remove a cookie by name\n         * @param name name of cookie to remove\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Base.cookies()",
        "snippet": "        Map<String, String> cookies();",
        "begin_line": 484,
        "end_line": 484,
        "comment": "\n         * Retrieve all of the request/response cookies as a map\n         * @return cookies\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.proxy()",
        "snippet": "        Proxy proxy();",
        "begin_line": 495,
        "end_line": 495,
        "comment": "\n         * Get the proxy used for this request.\n         * @return the proxy; <code>null</code> if not enabled.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.proxy(java.net.Proxy)",
        "snippet": "        Request proxy(Proxy proxy);",
        "begin_line": 502,
        "end_line": 502,
        "comment": "\n         * Update the proxy for this request.\n         * @param proxy the proxy ot use; <code>null</code> to disable.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.proxy(java.lang.String, int)",
        "snippet": "        Request proxy(String host, int port);",
        "begin_line": 510,
        "end_line": 510,
        "comment": "\n         * Set the HTTP proxy to use for this request.\n         * @param host the proxy hostname\n         * @param port the proxy port\n         * @return this Connection, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.timeout()",
        "snippet": "        int timeout();",
        "begin_line": 516,
        "end_line": 516,
        "comment": "\n         * Get the request timeout, in milliseconds.\n         * @return the timeout in milliseconds.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.timeout(int)",
        "snippet": "        Request timeout(int millis);",
        "begin_line": 523,
        "end_line": 523,
        "comment": "\n         * Update the request timeout.\n         * @param millis timeout, in milliseconds\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.maxBodySize()",
        "snippet": "        int maxBodySize();",
        "begin_line": 529,
        "end_line": 529,
        "comment": "\n         * Get the maximum body size, in bytes.\n         * @return the maximum body size, in bytes.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.maxBodySize(int)",
        "snippet": "        Request maxBodySize(int bytes);",
        "begin_line": 536,
        "end_line": 536,
        "comment": "\n         * Update the maximum body size, in bytes.\n         * @param bytes maximum body size, in bytes.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.followRedirects()",
        "snippet": "        boolean followRedirects();",
        "begin_line": 542,
        "end_line": 542,
        "comment": "\n         * Get the current followRedirects configuration.\n         * @return true if followRedirects is enabled.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.followRedirects(boolean)",
        "snippet": "        Request followRedirects(boolean followRedirects);",
        "begin_line": 549,
        "end_line": 549,
        "comment": "\n         * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n         * @param followRedirects true if server redirects should be followed.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.ignoreHttpErrors()",
        "snippet": "        boolean ignoreHttpErrors();",
        "begin_line": 556,
        "end_line": 556,
        "comment": "\n         * Get the current ignoreHttpErrors configuration.\n         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be\n         * thrown.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.ignoreHttpErrors(boolean)",
        "snippet": "        Request ignoreHttpErrors(boolean ignoreHttpErrors);",
        "begin_line": 563,
        "end_line": 563,
        "comment": "\n         * Configures the request to ignore HTTP errors in the response.\n         * @param ignoreHttpErrors set to true to ignore HTTP errors.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.ignoreContentType()",
        "snippet": "        boolean ignoreContentType();",
        "begin_line": 570,
        "end_line": 570,
        "comment": "\n         * Get the current ignoreContentType configuration.\n         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to\n         * be thrown.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.ignoreContentType(boolean)",
        "snippet": "        Request ignoreContentType(boolean ignoreContentType);",
        "begin_line": 577,
        "end_line": 577,
        "comment": "\n         * Configures the request to ignore the Content-Type of the response.\n         * @param ignoreContentType set to true to ignore the content type.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.sslSocketFactory()",
        "snippet": "        SSLSocketFactory sslSocketFactory();",
        "begin_line": 583,
        "end_line": 583,
        "comment": "\n         * Get the current custom SSL socket factory, if any.\n         * @return custom SSL socket factory if set, null otherwise\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.sslSocketFactory(javax.net.ssl.SSLSocketFactory)",
        "snippet": "        void sslSocketFactory(SSLSocketFactory sslSocketFactory);",
        "begin_line": 589,
        "end_line": 589,
        "comment": "\n         * Set a custom SSL socket factory.\n         * @param sslSocketFactory SSL socket factory\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.data(org.jsoup.Connection.KeyVal)",
        "snippet": "        Request data(KeyVal keyval);",
        "begin_line": 596,
        "end_line": 596,
        "comment": "\n         * Add a data parameter to the request\n         * @param keyval data to add.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.data()",
        "snippet": "        Collection<KeyVal> data();",
        "begin_line": 602,
        "end_line": 602,
        "comment": "\n         * Get all of the request's data parameters\n         * @return collection of keyvals\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.requestBody(java.lang.String)",
        "snippet": "        Request requestBody(String body);",
        "begin_line": 614,
        "end_line": 614,
        "comment": "\n         * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n         * encoded form key/value pairs. E.g.:\n         * <code><pre>Jsoup.connect(url)\n         * .requestBody(json)\n         * .header(\"Content-Type\", \"application/json\")\n         * .post();</pre></code>\n         * If any data key/vals are supplied, they will be sent as URL query params.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.requestBody()",
        "snippet": "        String requestBody();",
        "begin_line": 620,
        "end_line": 620,
        "comment": "\n         * Get the current request body.\n         * @return null if not set.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.parser(org.jsoup.parser.Parser)",
        "snippet": "        Request parser(Parser parser);",
        "begin_line": 627,
        "end_line": 627,
        "comment": "\n         * Specify the parser to use when parsing the document.\n         * @param parser parser to use.\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.parser()",
        "snippet": "        Parser parser();",
        "begin_line": 633,
        "end_line": 633,
        "comment": "\n         * Get the current parser to use when parsing the document.\n         * @return current Parser\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.postDataCharset(java.lang.String)",
        "snippet": "        Request postDataCharset(String charset);",
        "begin_line": 640,
        "end_line": 640,
        "comment": "\n         * Sets the post data character set for x-www-form-urlencoded post data\n         * @param charset character set to encode post data\n         * @return this Request, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Request.postDataCharset()",
        "snippet": "        String postDataCharset();",
        "begin_line": 646,
        "end_line": 646,
        "comment": "\n         * Gets the post data character set for x-www-form-urlencoded post data\n         * @return character set to encode post data\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.statusCode()",
        "snippet": "        int statusCode();",
        "begin_line": 659,
        "end_line": 659,
        "comment": "\n         * Get the status code of the response.\n         * @return status code\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.statusMessage()",
        "snippet": "        String statusMessage();",
        "begin_line": 665,
        "end_line": 665,
        "comment": "\n         * Get the status message of the response.\n         * @return status message\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.charset()",
        "snippet": "        String charset();",
        "begin_line": 671,
        "end_line": 671,
        "comment": "\n         * Get the character set name of the response, derived from the content-type header.\n         * @return character set name\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.charset(java.lang.String)",
        "snippet": "        Response charset(String charset);",
        "begin_line": 678,
        "end_line": 678,
        "comment": "\n         * Set / override the response character set. When the document body is parsed it will be with this charset.\n         * @param charset to decode body as\n         * @return this Response, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.contentType()",
        "snippet": "        String contentType();",
        "begin_line": 684,
        "end_line": 684,
        "comment": "\n         * Get the response content type (e.g. \"text/html\");\n         * @return the response content type\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.parse()",
        "snippet": "        Document parse() throws IOException;",
        "begin_line": 692,
        "end_line": 692,
        "comment": "\n         * Read and parse the body of the response as a Document. If you intend to parse the same response multiple\n         * times, you should {@link #bufferUp()} first.\n         * @return a parsed Document\n         * @throws IOException on error\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.body()",
        "snippet": "        String body();",
        "begin_line": 698,
        "end_line": 698,
        "comment": "\n         * Get the body of the response as a plain string.\n         * @return body\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.bodyAsBytes()",
        "snippet": "        byte[] bodyAsBytes();",
        "begin_line": 704,
        "end_line": 704,
        "comment": "\n         * Get the body of the response as an array of bytes.\n         * @return body bytes\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.bufferUp()",
        "snippet": "        Response bufferUp();",
        "begin_line": 713,
        "end_line": 713,
        "comment": "\n         * Read the body of the response into a local buffer, so that {@link #parse()} may be called repeatedly on the\n         * same connection response (otherwise, once the response is read, its InputStream will have been drained and\n         * may not be re-read). Calling {@link #body() } or {@link #bodyAsBytes()} has the same effect.\n         * @return this response, for chaining\n         * @throws UncheckedIOException if an IO exception occurs during buffering.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.Response.bodyStream()",
        "snippet": "        BufferedInputStream bodyStream();",
        "begin_line": 721,
        "end_line": 721,
        "comment": "\n         * Get the body of the response as a (buffered) InputStream. You should close the input stream when you're done with it.\n         * Other body methods (like bufferUp, body, parse, etc) will not work in conjunction with this method.\n         * <p>This method is useful for writing large responses to disk, without buffering them completely into memory first.</p>\n         * @return the response body input stream\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.key(java.lang.String)",
        "snippet": "        KeyVal key(String key);",
        "begin_line": 734,
        "end_line": 734,
        "comment": "\n         * Update the key of a keyval\n         * @param key new key\n         * @return this KeyVal, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.key()",
        "snippet": "        String key();",
        "begin_line": 740,
        "end_line": 740,
        "comment": "\n         * Get the key of a keyval\n         * @return the key\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.value(java.lang.String)",
        "snippet": "        KeyVal value(String value);",
        "begin_line": 747,
        "end_line": 747,
        "comment": "\n         * Update the value of a keyval\n         * @param value the new value\n         * @return this KeyVal, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.value()",
        "snippet": "        String value();",
        "begin_line": 753,
        "end_line": 753,
        "comment": "\n         * Get the value of a keyval\n         * @return the value\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.inputStream(java.io.InputStream)",
        "snippet": "        KeyVal inputStream(InputStream inputStream);",
        "begin_line": 760,
        "end_line": 760,
        "comment": "\n         * Add or update an input stream to this keyVal\n         * @param inputStream new input stream\n         * @return this KeyVal, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.inputStream()",
        "snippet": "        InputStream inputStream();",
        "begin_line": 766,
        "end_line": 766,
        "comment": "\n         * Get the input stream associated with this keyval, if any\n         * @return input stream if set, or null\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.hasInputStream()",
        "snippet": "        boolean hasInputStream();",
        "begin_line": 772,
        "end_line": 772,
        "comment": "\n         * Does this keyval have an input stream?\n         * @return true if this keyval does indeed have an input stream\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.contentType(java.lang.String)",
        "snippet": "        KeyVal contentType(String contentType);",
        "begin_line": 781,
        "end_line": 781,
        "comment": "\n         * Set the Content Type header used in the MIME body (aka mimetype) when uploading files.\n         * Only useful if {@link #inputStream(InputStream)} is set.\n         * <p>Will default to {@code application/octet-stream}.</p>\n         * @param contentType the new content type\n         * @return this KeyVal\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Connection.java",
        "class_name": "org.jsoup.Connection",
        "signature": "org.jsoup.Connection.KeyVal.contentType()",
        "snippet": "        String contentType();",
        "begin_line": 787,
        "end_line": 787,
        "comment": "\n         * Get the current Content Type, or {@code null} if not set.\n         * @return the current Content Type.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "org.jsoup.HttpStatusException",
        "signature": "org.jsoup.HttpStatusException.HttpStatusException(java.lang.String, int, java.lang.String)",
        "snippet": "    public HttpStatusException(String message, int statusCode, String url) {\n        super(message);\n        this.statusCode = statusCode;\n        this.url = url;\n    }",
        "begin_line": 12,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "org.jsoup.HttpStatusException",
        "signature": "org.jsoup.HttpStatusException.getStatusCode()",
        "snippet": "    public int getStatusCode() {\n        return statusCode;\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "org.jsoup.HttpStatusException",
        "signature": "org.jsoup.HttpStatusException.getUrl()",
        "snippet": "    public String getUrl() {\n        return url;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/HttpStatusException.java",
        "class_name": "org.jsoup.HttpStatusException",
        "signature": "org.jsoup.HttpStatusException.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return super.toString() + \". Status=\" + statusCode + \", URL=\" + url;\n    }",
        "begin_line": 26,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.Jsoup()",
        "snippet": "    private Jsoup() {}",
        "begin_line": 20,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.lang.String, java.lang.String)",
        "snippet": "    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "\n     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @return sane HTML\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.lang.String, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.lang.String)",
        "snippet": "    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a\n     {@code <base href>} tag.\n\n     @param html HTML to parse\n     @return sane HTML\n\n     @see #parse(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.connect(java.lang.String)",
        "snippet": "    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * Creates a new {@link Connection} to a URL. Use to fetch and parse a HTML page.\n     * <p>\n     * Use examples:\n     * <ul>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();</code></li>\n     * </ul>\n     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.io.File, java.lang.String, java.lang.String)",
        "snippet": "    public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }",
        "begin_line": 87,
        "end_line": 89,
        "comment": "\n     Parse the contents of a file as HTML.\n\n     @param in          file to load HTML from\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.io.File, java.lang.String)",
        "snippet": "    public static Document parse(File in, String charsetName) throws IOException {\n        return DataUtil.load(in, charsetName, in.getAbsolutePath());\n    }",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n     @param in          file to load HTML from\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @see #parse(File, String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.io.InputStream, java.lang.String, java.lang.String)",
        "snippet": "    public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }",
        "begin_line": 117,
        "end_line": 119,
        "comment": "\n     Read an input stream, and parse it to a Document.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.io.InputStream, java.lang.String, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }",
        "begin_line": 134,
        "end_line": 136,
        "comment": "\n     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parseBodyFragment(java.lang.String, java.lang.String)",
        "snippet": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }",
        "begin_line": 147,
        "end_line": 149,
        "comment": "\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @param baseUri  URL to resolve relative URLs against.\n     @return sane HTML document\n\n     @see Document#body()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parseBodyFragment(java.lang.String)",
        "snippet": "    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @return sane HTML document\n\n     @see Document#body()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.parse(java.net.URL, int)",
        "snippet": "    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }",
        "begin_line": 180,
        "end_line": 184,
        "comment": "\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.clean(java.lang.String, java.lang.String, org.jsoup.safety.Whitelist)",
        "snippet": "    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }",
        "begin_line": 197,
        "end_line": 202,
        "comment": "\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n     tags and attributes.\n\n     @param bodyHtml  input untrusted HTML (body fragment)\n     @param baseUri   URL to resolve relative URLs against\n     @param whitelist white-list of permitted HTML elements\n     @return safe HTML (body fragment)\n\n     @see Cleaner#clean(Document)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.clean(java.lang.String, org.jsoup.safety.Whitelist)",
        "snippet": "    public static String clean(String bodyHtml, Whitelist whitelist) {\n        return clean(bodyHtml, \"\", whitelist);\n    }",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n     tags and attributes.\n\n     @param bodyHtml  input untrusted HTML (body fragment)\n     @param whitelist white-list of permitted HTML elements\n     @return safe HTML (body fragment)\n\n     @see Cleaner#clean(Document)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.clean(java.lang.String, java.lang.String, org.jsoup.safety.Whitelist, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }",
        "begin_line": 232,
        "end_line": 238,
        "comment": "\n     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of\n     * permitted tags and attributes.\n     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\n     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\n     * structural tags (<code>html, head, body</code> etc) to the whitelist.\n     *\n     * @param bodyHtml input untrusted HTML (body fragment)\n     * @param baseUri URL to resolve relative URLs against\n     * @param whitelist white-list of permitted HTML elements\n     * @param outputSettings document output settings; use to control pretty-printing and entity escape modes\n     * @return safe HTML (body fragment)\n     * @see Cleaner#clean(Document)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/Jsoup.java",
        "class_name": "org.jsoup.Jsoup",
        "signature": "org.jsoup.Jsoup.isValid(java.lang.String, org.jsoup.safety.Whitelist)",
        "snippet": "    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n    }",
        "begin_line": 249,
        "end_line": 251,
        "comment": "\n     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n     @param bodyHtml HTML to test\n     @param whitelist whitelist to test against\n     @return true if no tags or attributes were removed; false otherwise\n     @see #clean(String, org.jsoup.safety.Whitelist) \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "org.jsoup.UnsupportedMimeTypeException",
        "signature": "org.jsoup.UnsupportedMimeTypeException.UnsupportedMimeTypeException(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public UnsupportedMimeTypeException(String message, String mimeType, String url) {\n        super(message);\n        this.mimeType = mimeType;\n        this.url = url;\n    }",
        "begin_line": 12,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "org.jsoup.UnsupportedMimeTypeException",
        "signature": "org.jsoup.UnsupportedMimeTypeException.getMimeType()",
        "snippet": "    public String getMimeType() {\n        return mimeType;\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "org.jsoup.UnsupportedMimeTypeException",
        "signature": "org.jsoup.UnsupportedMimeTypeException.getUrl()",
        "snippet": "    public String getUrl() {\n        return url;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java",
        "class_name": "org.jsoup.UnsupportedMimeTypeException",
        "signature": "org.jsoup.UnsupportedMimeTypeException.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return super.toString() + \". Mimetype=\" + mimeType + \", URL=\"+url;\n    }",
        "begin_line": 26,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.ConstrainableInputStream(java.io.InputStream, int, int)",
        "snippet": "    private ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\n        super(in, bufferSize);\n        Validate.isTrue(maxSize >= 0);\n        this.maxSize = maxSize;\n        remaining = maxSize;\n        capped = maxSize != 0;\n        startTime = System.nanoTime();\n    }",
        "begin_line": 26,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.wrap(java.io.InputStream, int, int)",
        "snippet": "    public static ConstrainableInputStream wrap(InputStream in, int bufferSize, int maxSize) {\n        return in instanceof ConstrainableInputStream\n            ? (ConstrainableInputStream) in\n            : new ConstrainableInputStream(in, bufferSize, maxSize);\n    }",
        "begin_line": 42,
        "end_line": 46,
        "comment": "\n     * If this InputStream is not already a ConstrainableInputStream, let it be one.\n     * @param in the input stream to (maybe) wrap\n     * @param bufferSize the buffer size to use when reading\n     * @param maxSize the maximum size to allow to be read. 0 == infinite.\n     * @return a constrainable input stream\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.read(byte[], int, int)",
        "snippet": "    @Override\n    public int read(byte[] b, int off, int len) throws IOException {\n        if (interrupted || capped && remaining <= 0)\n            return -1;\n        if (Thread.interrupted()) {\n            // interrupted latches, because parse() may call twice (and we still want the thread interupt to clear)\n            interrupted = true;\n            return -1;\n        }\n        if (expired())\n            throw new SocketTimeoutException(\"Read timeout\");\n\n        if (capped && len > remaining)\n            len = remaining; // don't read more than desired, even if available\n\n        try {\n            final int read = super.read(b, off, len);\n            remaining -= read;\n            return read;\n        } catch (SocketTimeoutException e) {\n            return 0;\n        }\n    }",
        "begin_line": 48,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.readToByteBuffer(int)",
        "snippet": "    public ByteBuffer readToByteBuffer(int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean localCapped = max > 0; // still possibly capped in total stream\n        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n        final byte[] readBuffer = new byte[bufferSize];\n        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\n        int read;\n        int remaining = max;\n\n        while (true) {\n            read = read(readBuffer);\n            if (read == -1) break;\n            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n                if (read >= remaining) {\n                    outStream.write(readBuffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(readBuffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }",
        "begin_line": 76,
        "end_line": 99,
        "comment": "\n     * Reads this inputstream to a ByteBuffer. The supplied max may be less than the inputstream's max, to support\n     * reading just the first bytes.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.reset()",
        "snippet": "    @Override\n    public void reset() throws IOException {\n        super.reset();\n        remaining = maxSize - markpos;\n    }",
        "begin_line": 101,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.timeout(long, long)",
        "snippet": "    public ConstrainableInputStream timeout(long startTimeNanos, long timeoutMillis) {\n        this.startTime = startTimeNanos;\n        this.timeout = timeoutMillis * 1000000;\n        return this;\n    }",
        "begin_line": 107,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java",
        "class_name": "org.jsoup.internal.ConstrainableInputStream",
        "signature": "org.jsoup.internal.ConstrainableInputStream.expired()",
        "snippet": "    private boolean expired() {\n        if (timeout == 0)\n            return false;\n\n        final long now = System.nanoTime();\n        final long dur = now - startTime;\n        return (dur > timeout);\n    }",
        "begin_line": 113,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/Normalizer.java",
        "class_name": "org.jsoup.internal.Normalizer",
        "signature": "org.jsoup.internal.Normalizer.lowerCase(java.lang.String)",
        "snippet": "    public static String lowerCase(final String input) {\n        return input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/Normalizer.java",
        "class_name": "org.jsoup.internal.Normalizer",
        "signature": "org.jsoup.internal.Normalizer.normalize(java.lang.String)",
        "snippet": "    public static String normalize(final String input) {\n        return lowerCase(input).trim();\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.join(java.util.Collection, java.lang.String)",
        "snippet": "    public static String join(Collection strings, String sep) {\n        return join(strings.iterator(), sep);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "\n     * Join a collection of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.join(java.util.Iterator, java.lang.String)",
        "snippet": "    public static String join(Iterator strings, String sep) {\n        if (!strings.hasNext())\n            return \"\";\n\n        String start = strings.next().toString();\n        if (!strings.hasNext()) // only one, avoid builder\n            return start;\n\n        StringBuilder sb = StringUtil.borrowBuilder().append(start);\n        while (strings.hasNext()) {\n            sb.append(sep);\n            sb.append(strings.next());\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 37,
        "end_line": 51,
        "comment": "\n     * Join a collection of strings by a separator\n     * @param strings iterator of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.join(java.lang.String[], java.lang.String)",
        "snippet": "    public static String join(String[] strings, String sep) {\n        return join(Arrays.asList(strings), sep);\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Join an array of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.padding(int)",
        "snippet": "    public static String padding(int width) {\n        if (width < 0)\n            throw new IllegalArgumentException(\"width must be > 0\");\n\n        if (width < padding.length)\n            return padding[width];\n        char[] out = new char[width];\n        for (int i = 0; i < width; i++)\n            out[i] = ' ';\n        return String.valueOf(out);\n    }",
        "begin_line": 68,
        "end_line": 78,
        "comment": "\n     * Returns space padding\n     * @param width amount of padding desired\n     * @return string of spaces * width\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.isBlank(java.lang.String)",
        "snippet": "    public static boolean isBlank(String string) {\n        if (string == null || string.length() == 0)\n            return true;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }",
        "begin_line": 85,
        "end_line": 95,
        "comment": "\n     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n     * @param string string to test\n     * @return if string is blank\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.isNumeric(java.lang.String)",
        "snippet": "    public static boolean isNumeric(String string) {\n        if (string == null || string.length() == 0)\n            return false;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!Character.isDigit(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }",
        "begin_line": 102,
        "end_line": 112,
        "comment": "\n     * Tests if a string is numeric, i.e. contains only digit characters\n     * @param string string to test\n     * @return true if only digit chars, false if empty or null or contains non-digit chars\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.isWhitespace(int)",
        "snippet": "    public static boolean isWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n    }",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n     * Tests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     * @see #isActuallyWhitespace(int)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.isActuallyWhitespace(int)",
        "snippet": "    public static boolean isActuallyWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n    }",
        "begin_line": 129,
        "end_line": 132,
        "comment": "\n     * Tests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.isInvisibleChar(int)",
        "snippet": "    public static boolean isInvisibleChar(int c) {\n        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n        // zero width sp, zw non join, zw join, soft hyphen\n    }",
        "begin_line": 134,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.normaliseWhitespace(java.lang.String)",
        "snippet": "    public static String normaliseWhitespace(String string) {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        appendNormalisedWhitespace(sb, string, false);\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 145,
        "end_line": 149,
        "comment": "\n     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n     * (e.g. newline, tab) convert to a simple space\n     * @param string content to normalise\n     * @return normalised string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.appendNormalisedWhitespace(java.lang.StringBuilder, java.lang.String, boolean)",
        "snippet": "    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n\n        int len = string.length();\n        int c;\n        for (int i = 0; i < len; i+= Character.charCount(c)) {\n            c = string.codePointAt(i);\n            if (isActuallyWhitespace(c)) {\n                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n            }\n            else if (!isInvisibleChar(c)) {\n                accum.appendCodePoint(c);\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n    }",
        "begin_line": 157,
        "end_line": 177,
        "comment": "\n     * After normalizing the whitespace within a string, appends it to a string builder.\n     * @param accum builder to append to\n     * @param string string to normalize whitespace within\n     * @param stripLeading set to true if you wish to remove any leading whitespace\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.in(java.lang.String, java.lang.String...)",
        "snippet": "    public static boolean in(final String needle, final String... haystack) {\n        final int len = haystack.length;\n        for (int i = 0; i < len; i++) {\n            if (haystack[i].equals(needle))\n            return true;\n        }\n        return false;\n    }",
        "begin_line": 179,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.inSorted(java.lang.String, java.lang.String[])",
        "snippet": "    public static boolean inSorted(String needle, String[] haystack) {\n        return Arrays.binarySearch(haystack, needle) >= 0;\n    }",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.resolve(java.net.URL, java.lang.String)",
        "snippet": "    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n        if (relUrl.startsWith(\"?\"))\n            relUrl = base.getPath() + relUrl;\n        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n        }\n        return new URL(base, relUrl);\n    }",
        "begin_line": 199,
        "end_line": 208,
        "comment": "\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param base the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return the resolved absolute URL\n     * @throws MalformedURLException if an error occurred generating the URL\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.resolve(java.lang.String, java.lang.String)",
        "snippet": "    public static String resolve(final String baseUrl, final String relUrl) {\n        URL base;\n        try {\n            try {\n                base = new URL(baseUrl);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            return resolve(base, relUrl).toExternalForm();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }",
        "begin_line": 216,
        "end_line": 230,
        "comment": "\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param baseUrl the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return an absolute URL if one was able to be generated, or the empty string if not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.borrowBuilder()",
        "snippet": "    public static StringBuilder borrowBuilder() {\n        synchronized (builders) {\n            return builders.empty() ?\n                new StringBuilder(MaxCachedBuilderSize) :\n                builders.pop();\n        }\n    }",
        "begin_line": 242,
        "end_line": 248,
        "comment": "\n     * Maintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is\n     * prevented from growing too large.\n     * <p>\n     * Care must be taken to release the builder once its work has been completed, with {@see #releaseBuilder}\n     * @return an empty StringBuilder\n     * @\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/internal/StringUtil.java",
        "class_name": "org.jsoup.internal.StringUtil",
        "signature": "org.jsoup.internal.StringUtil.releaseBuilder(java.lang.StringBuilder)",
        "snippet": "    public static String releaseBuilder(StringBuilder sb) {\n        Validate.notNull(sb);\n        String string = sb.toString();\n\n        if (sb.length() > MaxCachedBuilderSize)\n            sb = new StringBuilder(MaxCachedBuilderSize); // make sure it hasn't grown too big\n        else\n            sb.delete(0, sb.length()); // make sure it's emptied on release\n\n        synchronized (builders) {\n            builders.push(sb);\n\n            while (builders.size() > MaxIdleBuilders) {\n                builders.pop();\n            }\n        }\n        return string;\n    }",
        "begin_line": 256,
        "end_line": 273,
        "comment": "\n     * Release a borrowed builder. Care must be taken not to use the builder after it has been returned, as its\n     * contents may be changed by this method, or by a concurrent thread.\n     * @param sb the StringBuilder to release.\n     * @return the string value of the released String Builder (as an incentive to release it!).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "org.jsoup.examples.ListLinks",
        "signature": "org.jsoup.examples.ListLinks.main(java.lang.String[])",
        "snippet": "    public static void main(String[] args) throws IOException {\n        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n        String url = args[0];\n        print(\"Fetching %s...\", url);\n\n        Document doc = Jsoup.connect(url).get();\n        Elements links = doc.select(\"a[href]\");\n        Elements media = doc.select(\"[src]\");\n        Elements imports = doc.select(\"link[href]\");\n\n        print(\"\\nMedia: (%d)\", media.size());\n        for (Element src : media) {\n            if (src.tagName().equals(\"img\"))\n                print(\" * %s: <%s> %sx%s (%s)\",\n                        src.tagName(), src.attr(\"abs:src\"), src.attr(\"width\"), src.attr(\"height\"),\n                        trim(src.attr(\"alt\"), 20));\n            else\n                print(\" * %s: <%s>\", src.tagName(), src.attr(\"abs:src\"));\n        }\n\n        print(\"\\nImports: (%d)\", imports.size());\n        for (Element link : imports) {\n            print(\" * %s <%s> (%s)\", link.tagName(),link.attr(\"abs:href\"), link.attr(\"rel\"));\n        }\n\n        print(\"\\nLinks: (%d)\", links.size());\n        for (Element link : links) {\n            print(\" * a: <%s>  (%s)\", link.attr(\"abs:href\"), trim(link.text(), 35));\n        }\n    }",
        "begin_line": 15,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "org.jsoup.examples.ListLinks",
        "signature": "org.jsoup.examples.ListLinks.print(java.lang.String, java.lang.Object...)",
        "snippet": "    private static void print(String msg, Object... args) {\n        System.out.println(String.format(msg, args));\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/ListLinks.java",
        "class_name": "org.jsoup.examples.ListLinks",
        "signature": "org.jsoup.examples.ListLinks.trim(java.lang.String, int)",
        "snippet": "    private static String trim(String s, int width) {\n        if (s.length() > width)\n            return s.substring(0, width-1) + \".\";\n        else\n            return s;\n    }",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.main(java.lang.String...)",
        "snippet": "    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }",
        "begin_line": 34,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.getPlainText(org.jsoup.nodes.Element)",
        "snippet": "    public String getPlainText(Element element) {\n        FormattingVisitor formatter = new FormattingVisitor();\n        NodeTraversor.traverse(formatter, element); // walk the DOM, and call .head() and .tail() for each node\n\n        return formatter.toString();\n    }",
        "begin_line": 61,
        "end_line": 66,
        "comment": "\n     * Format an Element to plain-text\n     * @param element the root element to format\n     * @return formatted text\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.FormattingVisitor.head(org.jsoup.nodes.Node, int)",
        "snippet": "        public void head(Node node, int depth) {\n            String name = node.nodeName();\n            if (node instanceof TextNode)\n                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n            else if (name.equals(\"li\"))\n                append(\"\\n * \");\n            else if (name.equals(\"dt\"))\n                append(\"  \");\n            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n                append(\"\\n\");\n        }",
        "begin_line": 75,
        "end_line": 85,
        "comment": " hit when the node is first seen",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.FormattingVisitor.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        public void tail(Node node, int depth) {\n            String name = node.nodeName();\n            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                append(\"\\n\");\n            else if (name.equals(\"a\"))\n                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n        }",
        "begin_line": 88,
        "end_line": 94,
        "comment": " hit when all of the node's children (if any) have been visited",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.FormattingVisitor.append(java.lang.String)",
        "snippet": "        private void append(String text) {\n            if (text.startsWith(\"\\n\"))\n                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n            if (text.equals(\" \") &&\n                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n                return; // don't accumulate long runs of empty spaces\n\n            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n                String words[] = text.split(\"\\\\s+\");\n                for (int i = 0; i < words.length; i++) {\n                    String word = words[i];\n                    boolean last = i == words.length - 1;\n                    if (!last) // insert a space if not the last word\n                        word = word + \" \";\n                    if (word.length() + width > maxWidth) { // wrap and reset counter\n                        accum.append(\"\\n\").append(word);\n                        width = word.length();\n                    } else {\n                        accum.append(word);\n                        width += word.length();\n                    }\n                }\n            } else { // fits as is, without need to wrap text\n                accum.append(text);\n                width += text.length();\n            }\n        }",
        "begin_line": 97,
        "end_line": 123,
        "comment": " appends text to the string builder with a simple word wrap method",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java",
        "class_name": "org.jsoup.examples.HtmlToPlainText",
        "signature": "org.jsoup.examples.HtmlToPlainText.FormattingVisitor.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return accum.toString();\n        }",
        "begin_line": 125,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/Wikipedia.java",
        "class_name": "org.jsoup.examples.Wikipedia",
        "signature": "org.jsoup.examples.Wikipedia.main(java.lang.String[])",
        "snippet": "    public static void main(String[] args) throws IOException {\n        Document doc = Jsoup.connect(\"http://en.wikipedia.org/\").get();\n        log(doc.title());\n\n        Elements newsHeadlines = doc.select(\"#mp-itn b a\");\n        for (Element headline : newsHeadlines) {\n            log(\"%s\\n\\t%s\", headline.attr(\"title\"), headline.absUrl(\"href\"));\n        }\n    }",
        "begin_line": 14,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/examples/Wikipedia.java",
        "class_name": "org.jsoup.examples.Wikipedia",
        "signature": "org.jsoup.examples.Wikipedia.log(java.lang.String, java.lang.String...)",
        "snippet": "    private static void log(String msg, String... vals) {\n        System.out.println(String.format(msg, vals));\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "org.jsoup.parser.ParseError",
        "signature": "org.jsoup.parser.ParseError.ParseError(int, java.lang.String)",
        "snippet": "    ParseError(int pos, String errorMsg) {\n        this.pos = pos;\n        this.errorMsg = errorMsg;\n    }",
        "begin_line": 10,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "org.jsoup.parser.ParseError",
        "signature": "org.jsoup.parser.ParseError.ParseError(int, java.lang.String, java.lang.Object...)",
        "snippet": "    ParseError(int pos, String errorFormat, Object... args) {\n        this.errorMsg = String.format(errorFormat, args);\n        this.pos = pos;\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "org.jsoup.parser.ParseError",
        "signature": "org.jsoup.parser.ParseError.getErrorMessage()",
        "snippet": "    public String getErrorMessage() {\n        return errorMsg;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "\n     * Retrieve the error message.\n     * @return the error message.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "org.jsoup.parser.ParseError",
        "signature": "org.jsoup.parser.ParseError.getPosition()",
        "snippet": "    public int getPosition() {\n        return pos;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "\n     * Retrieves the offset of the error.\n     * @return error offset within input\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseError.java",
        "class_name": "org.jsoup.parser.ParseError",
        "signature": "org.jsoup.parser.ParseError.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return pos + \": \" + errorMsg;\n    }",
        "begin_line": 36,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.Parser(org.jsoup.parser.TreeBuilder)",
        "snippet": "    public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n        errors = ParseErrorList.noTracking();\n    }",
        "begin_line": 24,
        "end_line": 28,
        "comment": "\n     * Create a new Parser, using the specified TreeBuilder\n     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseInput(java.lang.String, java.lang.String)",
        "snippet": "    public Document parseInput(String html, String baseUri) {\n        return treeBuilder.parse(new StringReader(html), baseUri, this);\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseInput(java.io.Reader, java.lang.String)",
        "snippet": "    public Document parseInput(Reader inputHtml, String baseUri) {\n        return treeBuilder.parse(inputHtml, baseUri, this);\n    }",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseFragmentInput(java.lang.String, org.jsoup.nodes.Element, java.lang.String)",
        "snippet": "    public List<Node> parseFragmentInput(String fragment, Element context, String baseUri) {\n        return treeBuilder.parseFragment(fragment, context, baseUri, this);\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.getTreeBuilder()",
        "snippet": "    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Get the TreeBuilder currently in use.\n     * @return current TreeBuilder.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.setTreeBuilder(org.jsoup.parser.TreeBuilder)",
        "snippet": "    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        treeBuilder.parser = this;\n        return this;\n    }",
        "begin_line": 55,
        "end_line": 59,
        "comment": "\n     * Update the TreeBuilder used when parsing content.\n     * @param treeBuilder current TreeBuilder\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.isTrackErrors()",
        "snippet": "    public boolean isTrackErrors() {\n        return errors.getMaxSize() > 0;\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * Check if parse error tracking is enabled.\n     * @return current track error state.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.setTrackErrors(int)",
        "snippet": "    public Parser setTrackErrors(int maxErrors) {\n        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return this;\n    }",
        "begin_line": 74,
        "end_line": 77,
        "comment": "\n     * Enable or disable parse error tracking for the next parse.\n     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.getErrors()",
        "snippet": "    public ParseErrorList getErrors() {\n        return errors;\n    }",
        "begin_line": 83,
        "end_line": 85,
        "comment": "\n     * Retrieve the parse errors, if any, from the last parse.\n     * @return list of parse errors, up to the size of the maximum errors tracked.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.settings(org.jsoup.parser.ParseSettings)",
        "snippet": "    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }",
        "begin_line": 87,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.settings()",
        "snippet": "    public ParseSettings settings() {\n        return settings;\n    }",
        "begin_line": 92,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parse(java.lang.String, java.lang.String)",
        "snippet": "    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));\n    }",
        "begin_line": 105,
        "end_line": 108,
        "comment": "\n     * Parse HTML into a Document.\n     *\n     * @param html HTML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseFragment(java.lang.String, org.jsoup.nodes.Element, java.lang.String)",
        "snippet": "    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));\n    }",
        "begin_line": 120,
        "end_line": 123,
        "comment": "\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseFragment(java.lang.String, org.jsoup.nodes.Element, java.lang.String, org.jsoup.parser.ParseErrorList)",
        "snippet": "    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        Parser parser = new Parser(treeBuilder);\n        parser.errors = errorList;\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);\n    }",
        "begin_line": 136,
        "end_line": 141,
        "comment": "\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @param errorList list to add errors to\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseXmlFragment(java.lang.String, java.lang.String)",
        "snippet": "    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, baseUri, new Parser(treeBuilder));\n    }",
        "begin_line": 150,
        "end_line": 153,
        "comment": "\n     * Parse a fragment of XML into a list of nodes.\n     *\n     * @param fragmentXml the fragment of XML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @return list of nodes parsed from the input XML.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseBodyFragment(java.lang.String, java.lang.String)",
        "snippet": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[0]); // the node list gets modified when re-parented\n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }",
        "begin_line": 163,
        "end_line": 175,
        "comment": "\n     * Parse a fragment of HTML into the {@code body} of a Document.\n     *\n     * @param bodyHtml fragment of HTML\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return Document, with empty head, and HTML parsed into body\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.unescapeEntities(java.lang.String, boolean)",
        "snippet": "    public static String unescapeEntities(String string, boolean inAttribute) {\n        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n        return tokeniser.unescapeEntities(inAttribute);\n    }",
        "begin_line": 183,
        "end_line": 186,
        "comment": "\n     * Utility method to unescape HTML entities from a string\n     * @param string HTML escaped string\n     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n     * @return an unescaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.parseBodyFragmentRelaxed(java.lang.String, java.lang.String)",
        "snippet": "    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        return parse(bodyHtml, baseUri);\n    }",
        "begin_line": 195,
        "end_line": 197,
        "comment": "\n     * @param bodyHtml HTML to parse\n     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.htmlParser()",
        "snippet": "    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }",
        "begin_line": 206,
        "end_line": 208,
        "comment": "\n     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n     * based on a knowledge of the semantics of the incoming tags.\n     * @return a new HTML parser.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Parser.java",
        "class_name": "org.jsoup.parser.Parser",
        "signature": "org.jsoup.parser.Parser.xmlParser()",
        "snippet": "    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }",
        "begin_line": 215,
        "end_line": 217,
        "comment": "\n     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n     * rather creates a simple tree directly from the input.\n     * @return a new simple XML parser.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.defaultSettings()",
        "snippet": "    abstract ParseSettings defaultSettings();",
        "begin_line": 28,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.initialiseParse(java.io.Reader, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNull(input, \"String input must not be null\");\n        Validate.notNull(baseUri, \"BaseURI must not be null\");\n\n        doc = new Document(baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        currentToken = null;\n        tokeniser = new Tokeniser(reader, parser.getErrors());\n        stack = new ArrayList<>(32);\n        this.baseUri = baseUri;\n    }",
        "begin_line": 30,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.parse(java.io.Reader, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    Document parse(Reader input, String baseUri, Parser parser) {\n        initialiseParse(input, baseUri, parser);\n        runParser();\n        return doc;\n    }",
        "begin_line": 45,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.parseFragment(java.lang.String, org.jsoup.nodes.Element, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    abstract List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser);",
        "begin_line": 51,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.runParser()",
        "snippet": "    protected void runParser() {\n        while (true) {\n            Token token = tokeniser.read();\n            process(token);\n            token.reset();\n\n            if (token.type == Token.TokenType.EOF)\n                break;\n        }\n    }",
        "begin_line": 53,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.process(org.jsoup.parser.Token)",
        "snippet": "    protected abstract boolean process(Token token);",
        "begin_line": 64,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.processStartTag(java.lang.String)",
        "snippet": "    protected boolean processStartTag(String name) {\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag().name(name));\n        }\n        return process(start.reset().name(name));\n    }",
        "begin_line": 66,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.processStartTag(java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "    public boolean processStartTag(String name, Attributes attrs) {\n        if (currentToken == start) { // don't recycle an in-use token\n            return process(new Token.StartTag().nameAttr(name, attrs));\n        }\n        start.reset();\n        start.nameAttr(name, attrs);\n        return process(start);\n    }",
        "begin_line": 73,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.processEndTag(java.lang.String)",
        "snippet": "    protected boolean processEndTag(String name) {\n        if (currentToken == end) { // don't recycle an in-use token\n            return process(new Token.EndTag().name(name));\n        }\n        return process(end.reset().name(name));\n    }",
        "begin_line": 82,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TreeBuilder.java",
        "class_name": "org.jsoup.parser.TreeBuilder",
        "signature": "org.jsoup.parser.TreeBuilder.currentElement()",
        "snippet": "    protected Element currentElement() {\n        int size = stack.size();\n        return size > 0 ? stack.get(size-1) : null;\n    }",
        "begin_line": 90,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Token()",
        "snippet": "    private Token() {\n    }",
        "begin_line": 14,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.tokenType()",
        "snippet": "    String tokenType() {\n        return this.getClass().getSimpleName();\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.reset()",
        "snippet": "    abstract Token reset();",
        "begin_line": 25,
        "end_line": 25,
        "comment": "\n     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n     * piece of data, which immediately get GCed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.reset(java.lang.StringBuilder)",
        "snippet": "    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }",
        "begin_line": 27,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.Doctype()",
        "snippet": "        Doctype() {\n            type = TokenType.Doctype;\n        }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.reset()",
        "snippet": "        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }",
        "begin_line": 44,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.getName()",
        "snippet": "        String getName() {\n            return name.toString();\n        }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.getPubSysKey()",
        "snippet": "        String getPubSysKey() {\n            return pubSysKey;\n        }",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.getPublicIdentifier()",
        "snippet": "        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.getSystemIdentifier()",
        "snippet": "        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Doctype.isForceQuirks()",
        "snippet": "        public boolean isForceQuirks() {\n            return forceQuirks;\n        }",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.reset()",
        "snippet": "        @Override\n        Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }",
        "begin_line": 86,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.newAttribute()",
        "snippet": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    attributes.put(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }",
        "begin_line": 100,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.finaliseTag()",
        "snippet": "        final void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }",
        "begin_line": 125,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.name()",
        "snippet": "        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }",
        "begin_line": 134,
        "end_line": 137,
        "comment": " Preserves case ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.normalName()",
        "snippet": "        final String normalName() { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }",
        "begin_line": 140,
        "end_line": 142,
        "comment": " Lower case ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.name(java.lang.String)",
        "snippet": "        final Tag name(String name) {\n            tagName = name;\n            normalName = lowerCase(name);\n            return this;\n        }",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.isSelfClosing()",
        "snippet": "        final boolean isSelfClosing() {\n            return selfClosing;\n        }",
        "begin_line": 150,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.getAttributes()",
        "snippet": "        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }",
        "begin_line": 154,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendTagName(java.lang.String)",
        "snippet": "        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = lowerCase(tagName);\n        }",
        "begin_line": 160,
        "end_line": 163,
        "comment": " these appenders are rarely hit in not null state-- caused by null chars.",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendTagName(char)",
        "snippet": "        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }",
        "begin_line": 165,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeName(java.lang.String)",
        "snippet": "        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeName(char)",
        "snippet": "        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }",
        "begin_line": 173,
        "end_line": 175,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeValue(java.lang.String)",
        "snippet": "        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }",
        "begin_line": 177,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeValue(char)",
        "snippet": "        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }",
        "begin_line": 186,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeValue(char[])",
        "snippet": "        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.appendAttributeValue(int[])",
        "snippet": "        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }",
        "begin_line": 196,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.setEmptyAttributeValue()",
        "snippet": "        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Tag.ensureAttributeValue()",
        "snippet": "        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }",
        "begin_line": 207,
        "end_line": 214,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.StartTag.StartTag()",
        "snippet": "        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }",
        "begin_line": 218,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.StartTag.reset()",
        "snippet": "        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            // todo - would prefer these to be null, but need to check Element assertions\n            return this;\n        }",
        "begin_line": 224,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.StartTag.nameAttr(java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = lowerCase(tagName);\n            return this;\n        }",
        "begin_line": 232,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.StartTag.toString()",
        "snippet": "        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }",
        "begin_line": 239,
        "end_line": 245,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.EndTag.EndTag()",
        "snippet": "        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }",
        "begin_line": 249,
        "end_line": 252,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.EndTag.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }",
        "begin_line": 254,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Comment.reset()",
        "snippet": "        @Override\n        Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }",
        "begin_line": 264,
        "end_line": 269,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Comment.Comment()",
        "snippet": "        Comment() {\n            type = TokenType.Comment;\n        }",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Comment.getData()",
        "snippet": "        String getData() {\n            return data.toString();\n        }",
        "begin_line": 275,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Comment.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }",
        "begin_line": 279,
        "end_line": 282,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Character.Character()",
        "snippet": "        Character() {\n            super();\n            type = TokenType.Character;\n        }",
        "begin_line": 288,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Character.reset()",
        "snippet": "        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }",
        "begin_line": 293,
        "end_line": 297,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Character.data(java.lang.String)",
        "snippet": "        Character data(String data) {\n            this.data = data;\n            return this;\n        }",
        "begin_line": 299,
        "end_line": 302,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Character.getData()",
        "snippet": "        String getData() {\n            return data;\n        }",
        "begin_line": 304,
        "end_line": 306,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.Character.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return getData();\n        }",
        "begin_line": 308,
        "end_line": 311,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.CData.CData(java.lang.String)",
        "snippet": "        CData(String data) {\n            super();\n            this.data(data);\n        }",
        "begin_line": 315,
        "end_line": 318,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.CData.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }",
        "begin_line": 320,
        "end_line": 323,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.EOF.EOF()",
        "snippet": "        EOF() {\n            type = Token.TokenType.EOF;\n        }",
        "begin_line": 328,
        "end_line": 330,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.EOF.reset()",
        "snippet": "        @Override\n        Token reset() {\n            return this;\n        }",
        "begin_line": 332,
        "end_line": 335,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isDoctype()",
        "snippet": "    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }",
        "begin_line": 338,
        "end_line": 340,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.asDoctype()",
        "snippet": "    final Doctype asDoctype() {\n        return (Doctype) this;\n    }",
        "begin_line": 342,
        "end_line": 344,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isStartTag()",
        "snippet": "    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }",
        "begin_line": 346,
        "end_line": 348,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.asStartTag()",
        "snippet": "    final StartTag asStartTag() {\n        return (StartTag) this;\n    }",
        "begin_line": 350,
        "end_line": 352,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isEndTag()",
        "snippet": "    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }",
        "begin_line": 354,
        "end_line": 356,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.asEndTag()",
        "snippet": "    final EndTag asEndTag() {\n        return (EndTag) this;\n    }",
        "begin_line": 358,
        "end_line": 360,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isComment()",
        "snippet": "    final boolean isComment() {\n        return type == TokenType.Comment;\n    }",
        "begin_line": 362,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.asComment()",
        "snippet": "    final Comment asComment() {\n        return (Comment) this;\n    }",
        "begin_line": 366,
        "end_line": 368,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isCharacter()",
        "snippet": "    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }",
        "begin_line": 370,
        "end_line": 372,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isCData()",
        "snippet": "    final boolean isCData() {\n        return this instanceof CData;\n    }",
        "begin_line": 374,
        "end_line": 376,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.asCharacter()",
        "snippet": "    final Character asCharacter() {\n        return (Character) this;\n    }",
        "begin_line": 378,
        "end_line": 380,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Token.java",
        "class_name": "org.jsoup.parser.Token",
        "signature": "org.jsoup.parser.Token.isEOF()",
        "snippet": "    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }",
        "begin_line": 382,
        "end_line": 384,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.CharacterReader(java.io.Reader, int)",
        "snippet": "    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n    }",
        "begin_line": 30,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.CharacterReader(java.io.Reader)",
        "snippet": "    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.CharacterReader(java.lang.String)",
        "snippet": "    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.bufferUp()",
        "snippet": "    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(pos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }",
        "begin_line": 46,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.pos()",
        "snippet": "    public int pos() {\n        return readerPos + bufPos;\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * Gets the current cursor position in the content.\n     * @return current position\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.isEmptyNoBufferUp()",
        "snippet": "    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.current()",
        "snippet": "    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }",
        "begin_line": 93,
        "end_line": 96,
        "comment": "\n     * Get the char at the current position.\n     * @return char\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consume()",
        "snippet": "    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }",
        "begin_line": 98,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.unconsume()",
        "snippet": "    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"No buffer left to unconsume\"));\n\n        bufPos--;\n    }",
        "begin_line": 105,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.advance()",
        "snippet": "    public void advance() {\n        bufPos++;\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * Moves the current position by one.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.mark()",
        "snippet": "    void mark() {\n        // extra buffer up, to get as much rewind capacity as possible\n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }",
        "begin_line": 119,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.rewindToMark()",
        "snippet": "    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n    }",
        "begin_line": 126,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.nextIndexOf(char)",
        "snippet": "    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }",
        "begin_line": 138,
        "end_line": 146,
        "comment": "\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.nextIndexOf(java.lang.CharSequence)",
        "snippet": "    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }",
        "begin_line": 154,
        "end_line": 171,
        "comment": "\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeTo(char)",
        "snippet": "    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }",
        "begin_line": 178,
        "end_line": 187,
        "comment": "\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeTo(java.lang.String)",
        "snippet": "    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }",
        "begin_line": 189,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeToAny(char...)",
        "snippet": "    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "begin_line": 205,
        "end_line": 224,
        "comment": "\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeToAnySorted(char...)",
        "snippet": "    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "begin_line": 226,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeData()",
        "snippet": "    String consumeData() {\n        // &, <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "begin_line": 242,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeTagName()",
        "snippet": "    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }",
        "begin_line": 264,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeToEnd()",
        "snippet": "    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }",
        "begin_line": 293,
        "end_line": 298,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeLetterSequence()",
        "snippet": "    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "begin_line": 300,
        "end_line": 312,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeLetterThenDigitSequence()",
        "snippet": "    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "begin_line": 314,
        "end_line": 333,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeHexSequence()",
        "snippet": "    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "begin_line": 335,
        "end_line": 346,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.consumeDigitSequence()",
        "snippet": "    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }",
        "begin_line": 348,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matches(char)",
        "snippet": "    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }",
        "begin_line": 361,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matches(java.lang.String)",
        "snippet": "    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }",
        "begin_line": 366,
        "end_line": 376,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchesIgnoreCase(java.lang.String)",
        "snippet": "    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }",
        "begin_line": 378,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchesAny(char...)",
        "snippet": "    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 393,
        "end_line": 404,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchesAnySorted(char[])",
        "snippet": "    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }",
        "begin_line": 406,
        "end_line": 409,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchesLetter()",
        "snippet": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }",
        "begin_line": 411,
        "end_line": 416,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchesDigit()",
        "snippet": "    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }",
        "begin_line": 418,
        "end_line": 423,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchConsume(java.lang.String)",
        "snippet": "    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "begin_line": 425,
        "end_line": 433,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.matchConsumeIgnoreCase(java.lang.String)",
        "snippet": "    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "begin_line": 435,
        "end_line": 442,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.containsIgnoreCase(java.lang.String)",
        "snippet": "    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }",
        "begin_line": 444,
        "end_line": 449,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }",
        "begin_line": 451,
        "end_line": 454,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.cacheString(char[], java.lang.String[], int, int)",
        "snippet": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }",
        "begin_line": 463,
        "end_line": 493,
        "comment": "\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.rangeEquals(char[], int, int, java.lang.String)",
        "snippet": "    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }",
        "begin_line": 498,
        "end_line": 509,
        "comment": "\n     * Check if the value of the provided range equals the string.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/CharacterReader.java",
        "class_name": "org.jsoup.parser.CharacterReader",
        "signature": "org.jsoup.parser.CharacterReader.rangeEquals(int, int, java.lang.String)",
        "snippet": "    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }",
        "begin_line": 512,
        "end_line": 514,
        "comment": " just used for testing",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true; // ignore whitespace\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                // todo: parse error check on expected doctypes\n                // todo: quirk state check on doctype ids\n                Token.Doctype d = t.asDoctype();\n                DocumentType doctype = new DocumentType(\n                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n                doctype.setPubSysKey(d.getPubSysKey());\n                tb.getDocument().appendChild(doctype);\n                if (d.isForceQuirks())\n                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                tb.transition(BeforeHtml);\n            } else {\n                // todo: check not iframe srcdoc\n                tb.transition(BeforeHtml);\n                return tb.process(t); // re-process token\n            }\n            return true;\n        }",
        "begin_line": 18,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (isWhitespace(t)) {\n                return true; // ignore whitespace\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                tb.insert(t.asStartTag());\n                tb.transition(BeforeHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                return anythingElse(t, tb);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 43,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.insertStartTag(\"html\");\n            tb.transition(BeforeHead);\n            return tb.process(t);\n        }",
        "begin_line": 65,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return true;\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return InBody.process(t, tb); // does not transition\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                Element head = tb.insert(t.asStartTag());\n                tb.setHeadElement(head);\n                tb.transition(InHead);\n            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.processStartTag(\"head\");\n                return tb.process(t);\n            }\n            return true;\n        }",
        "begin_line": 72,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\")) {\n                        return InBody.process(t, tb);\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                        Element el = tb.insertEmpty(start);\n                        // jsoup special: update base the frist time it is seen\n                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n                            tb.maybeSetBaseUri(el);\n                    } else if (name.equals(\"meta\")) {\n                        Element meta = tb.insertEmpty(start);\n                        // todo: charset switches\n                    } else if (name.equals(\"title\")) {\n                        handleRcData(start, tb);\n                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n                        handleRawtext(start, tb);\n                    } else if (name.equals(\"noscript\")) {\n                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\n                        tb.insert(start);\n                        tb.transition(InHeadNoscript);\n                    } else if (name.equals(\"script\")) {\n                        // skips some script rules as won't execute them\n\n                        tb.tokeniser.transition(TokeniserState.ScriptData);\n                        tb.markInsertionMode();\n                        tb.transition(Text);\n                        tb.insert(start);\n                    } else if (name.equals(\"head\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    if (name.equals(\"head\")) {\n                        tb.pop();\n                        tb.transition(AfterHead);\n                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.error(this);\n                        return false;\n                    }\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 100,
        "end_line": 164,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.TreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, TreeBuilder tb) {\n            tb.processEndTag(\"head\");\n            return tb.process(t);\n        }",
        "begin_line": 166,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                tb.pop();\n                tb.transition(InHead);\n            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                return tb.process(t, InHead);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                return anythingElse(t, tb);\n            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                tb.error(this);\n                return false;\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 172,
        "end_line": 192,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            tb.insert(new Token.Character().data(t.toString()));\n            return true;\n        }",
        "begin_line": 194,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"html\")) {\n                    return tb.process(t, InBody);\n                } else if (name.equals(\"body\")) {\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                    tb.transition(InBody);\n                } else if (name.equals(\"frameset\")) {\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                    tb.error(this);\n                    Element head = tb.getHeadElement();\n                    tb.push(head);\n                    tb.process(t, InHead);\n                    tb.removeFromStack(head);\n                } else if (name.equals(\"head\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                    anythingElse(t, tb);\n                } else {\n                    tb.error(this);\n                    return false;\n                }\n            } else {\n                anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 201,
        "end_line": 243,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.processStartTag(\"body\");\n            tb.framesetOk(true);\n            return tb.process(t);\n        }",
        "begin_line": 245,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    // todo - refactor to a switch statement\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        // same as final else, but short circuits lots of checks\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.normalName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) {\n                                tb.processEndTag(el.normalName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.normalName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.normalName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                // case will follow the original node (so honours ParseSettings)\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[0]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        // same as final fall through, but saves short circuit\n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().normalName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }",
        "begin_line": 252,
        "end_line": 765,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anyOtherEndTag(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.normalName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().normalName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }",
        "begin_line": 767,
        "end_line": 786,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n                tb.pop();\n                tb.transition(tb.originalState());\n                return tb.process(t);\n            } else if (t.isEndTag()) {\n                // if: An end tag whose tag name is \"script\" -- scripting nesting level, if evaluating scripts\n                tb.pop();\n                tb.transition(tb.originalState());\n            }\n            return true;\n        }",
        "begin_line": 790,
        "end_line": 805,
        "comment": " in script, style etc. normally treated as data tags",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.newPendingTableCharacters();\n                tb.markInsertionMode();\n                tb.transition(InTableText);\n                return tb.process(t);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n                return true;\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n                if (name.equals(\"caption\")) {\n                    tb.clearStackToTableContext();\n                    tb.insertMarkerToFormattingElements();\n                    tb.insert(startTag);\n                    tb.transition(InCaption);\n                } else if (name.equals(\"colgroup\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InColumnGroup);\n                } else if (name.equals(\"col\")) {\n                    tb.processStartTag(\"colgroup\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    tb.clearStackToTableContext();\n                    tb.insert(startTag);\n                    tb.transition(InTableBody);\n                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n                    tb.processStartTag(\"tbody\");\n                    return tb.process(t);\n                } else if (name.equals(\"table\")) {\n                    tb.error(this);\n                    boolean processed = tb.processEndTag(\"table\");\n                    if (processed) // only ignored if in fragment\n                        return tb.process(t);\n                } else if (StringUtil.in(name, \"style\", \"script\")) {\n                    return tb.process(t, InHead);\n                } else if (name.equals(\"input\")) {\n                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n                        return anythingElse(t, tb);\n                    } else {\n                        tb.insertEmpty(startTag);\n                    }\n                } else if (name.equals(\"form\")) {\n                    tb.error(this);\n                    if (tb.getFormElement() != null)\n                        return false;\n                    else {\n                        tb.insertForm(startTag, false);\n                    }\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"table\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.popStackToClose(\"table\");\n                    }\n                    tb.resetInsertionMode();\n                } else if (StringUtil.in(name,\n                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n                return true; // todo: as above todo\n            } else if (t.isEOF()) {\n                if (tb.currentElement().normalName().equals(\"html\"))\n                    tb.error(this);\n                return true; // stops parsing\n            }\n            return anythingElse(t, tb);\n        }",
        "begin_line": 808,
        "end_line": 892,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            boolean processed;\n            if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                tb.setFosterInserts(true);\n                processed = tb.process(t, InBody);\n                tb.setFosterInserts(false);\n            } else {\n                processed = tb.process(t, InBody);\n            }\n            return processed;\n        }",
        "begin_line": 894,
        "end_line": 905,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.getPendingTableCharacters().add(c.getData());\n                    }\n                    break;\n                default:\n                    // todo - don't really like the way these table character data lists are built\n                    if (tb.getPendingTableCharacters().size() > 0) {\n                        for (String character : tb.getPendingTableCharacters()) {\n                            if (!isWhitespace(character)) {\n                                // InTable anything else section:\n                                tb.error(this);\n                                if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    tb.setFosterInserts(true);\n                                    tb.process(new Token.Character().data(character), InBody);\n                                    tb.setFosterInserts(false);\n                                } else {\n                                    tb.process(new Token.Character().data(character), InBody);\n                                }\n                            } else\n                                tb.insert(new Token.Character().data(character));\n                        }\n                        tb.newPendingTableCharacters();\n                    }\n                    tb.transition(tb.originalState());\n                    return tb.process(t);\n            }\n            return true;\n        }",
        "begin_line": 908,
        "end_line": 942,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n                if (!tb.inTableScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().normalName().equals(\"caption\"))\n                        tb.error(this);\n                    tb.popStackToClose(\"caption\");\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InTable);\n                }\n            } else if ((\n                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                    ) {\n                tb.error(this);\n                boolean processed = tb.processEndTag(\"caption\");\n                if (processed)\n                    return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                return tb.process(t, InBody);\n            }\n            return true;\n        }",
        "begin_line": 945,
        "end_line": 977,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n                return true;\n            }\n            switch (t.type) {\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    break;\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    switch (startTag.normalName()) {\n                        case \"html\":\n                            return tb.process(t, InBody);\n                        case \"col\":\n                            tb.insertEmpty(startTag);\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    if (endTag.normalName.equals(\"colgroup\")) {\n                        if (tb.currentElement().normalName().equals(\"html\")) { // frag case\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EOF:\n                    if (tb.currentElement().normalName().equals(\"html\"))\n                        return true; // stop parsing; frag case\n                    else\n                        return anythingElse(t, tb);\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 980,
        "end_line": 1026,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.TreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"colgroup\");\n            if (processed) // only ignored in frag case\n                return tb.process(t);\n            return true;\n        }",
        "begin_line": 1028,
        "end_line": 1033,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName();\n                    if (name.equals(\"template\")) {\n                        tb.insert(startTag);\n                    } else if (name.equals(\"tr\")) {\n                        tb.clearStackToTableBodyContext();\n                        tb.insert(startTag);\n                        tb.transition(InRow);\n                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"tr\");\n                        return tb.process(startTag);\n                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                        return exitTableBody(t, tb);\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                        if (!tb.inTableScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.clearStackToTableBodyContext();\n                            tb.pop();\n                            tb.transition(InTable);\n                        }\n                    } else if (name.equals(\"table\")) {\n                        return exitTableBody(t, tb);\n                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else\n                        return anythingElse(t, tb);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 1036,
        "end_line": 1080,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.exitTableBody(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n                // frag case\n                tb.error(this);\n                return false;\n            }\n            tb.clearStackToTableBodyContext();\n            tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead\n            return tb.process(t);\n        }",
        "begin_line": 1082,
        "end_line": 1091,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }",
        "begin_line": 1093,
        "end_line": 1095,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag()) {\n                Token.StartTag startTag = t.asStartTag();\n                String name = startTag.normalName();\n\n                if (name.equals(\"template\")) {\n                    tb.insert(startTag);\n                } else if (StringUtil.in(name, \"th\", \"td\")) {\n                    tb.clearStackToTableRowContext();\n                    tb.insert(startTag);\n                    tb.transition(InCell);\n                    tb.insertMarkerToFormattingElements();\n                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                    return handleMissingTr(t, tb);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (name.equals(\"tr\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this); // frag\n                        return false;\n                    }\n                    tb.clearStackToTableRowContext();\n                    tb.pop(); // tr\n                    tb.transition(InTableBody);\n                } else if (name.equals(\"table\")) {\n                    return handleMissingTr(t, tb);\n                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.processEndTag(\"tr\");\n                    return tb.process(t);\n                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 1098,
        "end_line": 1146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InTable);\n        }",
        "begin_line": 1148,
        "end_line": 1150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.handleMissingTr(org.jsoup.parser.Token, org.jsoup.parser.TreeBuilder)",
        "snippet": "        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n            boolean processed = tb.processEndTag(\"tr\");\n            if (processed)\n                return tb.process(t);\n            else\n                return false;\n        }",
        "begin_line": 1152,
        "end_line": 1158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isEndTag()) {\n                Token.EndTag endTag = t.asEndTag();\n                String name = endTag.normalName();\n\n                if (StringUtil.inSorted(name, Constants.InCellNames)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().normalName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                    tb.transition(InRow);\n                } else if (StringUtil.inSorted(name, Constants.InCellBody)) {\n                    tb.error(this);\n                    return false;\n                } else if (StringUtil.inSorted(name, Constants.InCellTable)) {\n                    if (!tb.inTableScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    closeCell(tb);\n                    return tb.process(t);\n                } else {\n                    return anythingElse(t, tb);\n                }\n            } else if (t.isStartTag() &&\n                    StringUtil.inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {\n                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                    tb.error(this);\n                    return false;\n                }\n                closeCell(tb);\n                return tb.process(t);\n            } else {\n                return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 1161,
        "end_line": 1203,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            return tb.process(t, InBody);\n        }",
        "begin_line": 1205,
        "end_line": 1207,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.closeCell(org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private void closeCell(HtmlTreeBuilder tb) {\n            if (tb.inTableScope(\"td\"))\n                tb.processEndTag(\"td\");\n            else\n                tb.processEndTag(\"th\"); // only here if th or td in scope\n        }",
        "begin_line": 1209,
        "end_line": 1214,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character:\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.insert(c);\n                    }\n                    break;\n                case Comment:\n                    tb.insert(t.asComment());\n                    break;\n                case Doctype:\n                    tb.error(this);\n                    return false;\n                case StartTag:\n                    Token.StartTag start = t.asStartTag();\n                    String name = start.normalName();\n                    if (name.equals(\"html\"))\n                        return tb.process(start, InBody);\n                    else if (name.equals(\"option\")) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.insert(start);\n                    } else if (name.equals(\"optgroup\")) {\n                        if (tb.currentElement().normalName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        else if (tb.currentElement().normalName().equals(\"optgroup\"))\n                            tb.processEndTag(\"optgroup\");\n                        tb.insert(start);\n                    } else if (name.equals(\"select\")) {\n                        tb.error(this);\n                        return tb.processEndTag(\"select\");\n                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                        tb.error(this);\n                        if (!tb.inSelectScope(\"select\"))\n                            return false; // frag\n                        tb.processEndTag(\"select\");\n                        return tb.process(start);\n                    } else if (name.equals(\"script\")) {\n                        return tb.process(t, InHead);\n                    } else {\n                        return anythingElse(t, tb);\n                    }\n                    break;\n                case EndTag:\n                    Token.EndTag end = t.asEndTag();\n                    name = end.normalName();\n                    switch (name) {\n                        case \"optgroup\":\n                            if (tb.currentElement().normalName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(\"optgroup\"))\n                                tb.processEndTag(\"option\");\n                            if (tb.currentElement().normalName().equals(\"optgroup\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"option\":\n                            if (tb.currentElement().normalName().equals(\"option\"))\n                                tb.pop();\n                            else\n                                tb.error(this);\n                            break;\n                        case \"select\":\n                            if (!tb.inSelectScope(name)) {\n                                tb.error(this);\n                                return false;\n                            } else {\n                                tb.popStackToClose(name);\n                                tb.resetInsertionMode();\n                            }\n                            break;\n                        default:\n                            return anythingElse(t, tb);\n                    }\n                    break;\n                case EOF:\n                    if (!tb.currentElement().normalName().equals(\"html\"))\n                        tb.error(this);\n                    break;\n                default:\n                    return anythingElse(t, tb);\n            }\n            return true;\n        }",
        "begin_line": 1217,
        "end_line": 1303,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.anythingElse(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n            tb.error(this);\n            return false;\n        }",
        "begin_line": 1305,
        "end_line": 1308,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                tb.processEndTag(\"select\");\n                return tb.process(t);\n            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                tb.error(this);\n                if (tb.inTableScope(t.asEndTag().normalName())) {\n                    tb.processEndTag(\"select\");\n                    return (tb.process(t));\n                } else\n                    return false;\n            } else {\n                return tb.process(t, InSelect);\n            }\n        }",
        "begin_line": 1311,
        "end_line": 1326,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                return tb.process(t, InBody);\n            } else if (t.isComment()) {\n                tb.insert(t.asComment()); // into html node\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                if (tb.isFragmentParsing()) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterAfterBody);\n                }\n            } else if (t.isEOF()) {\n                // chillax! we're done\n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }",
        "begin_line": 1329,
        "end_line": 1354,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag()) {\n                Token.StartTag start = t.asStartTag();\n                switch (start.normalName()) {\n                    case \"html\":\n                        return tb.process(start, InBody);\n                    case \"frameset\":\n                        tb.insert(start);\n                        break;\n                    case \"frame\":\n                        tb.insertEmpty(start);\n                        break;\n                    case \"noframes\":\n                        return tb.process(start, InHead);\n                    default:\n                        tb.error(this);\n                        return false;\n                }\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                if (tb.currentElement().normalName().equals(\"html\")) { // frag\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.pop();\n                    if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals(\"frameset\")) {\n                        tb.transition(AfterFrameset);\n                    }\n                }\n            } else if (t.isEOF()) {\n                if (!tb.currentElement().normalName().equals(\"html\")) {\n                    tb.error(this);\n                    return true;\n                }\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }",
        "begin_line": 1357,
        "end_line": 1402,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (isWhitespace(t)) {\n                tb.insert(t.asCharacter());\n            } else if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype()) {\n                tb.error(this);\n                return false;\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                return tb.process(t, InBody);\n            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                tb.transition(AfterAfterFrameset);\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else if (t.isEOF()) {\n                // cool your heels, we're complete\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }",
        "begin_line": 1405,
        "end_line": 1426,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                // nice work chuck\n            } else {\n                tb.error(this);\n                tb.transition(InBody);\n                return tb.process(t);\n            }\n            return true;\n        }",
        "begin_line": 1429,
        "end_line": 1442,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isComment()) {\n                tb.insert(t.asComment());\n            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                return tb.process(t, InBody);\n            } else if (t.isEOF()) {\n                // nice work chuck\n            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                return tb.process(t, InHead);\n            } else {\n                tb.error(this);\n                return false;\n            }\n            return true;\n        }",
        "begin_line": 1445,
        "end_line": 1459,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            return true;\n            // todo: implement. Also; how do we get here?\n        }",
        "begin_line": 1462,
        "end_line": 1465,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "    abstract boolean process(Token t, HtmlTreeBuilder tb);",
        "begin_line": 1470,
        "end_line": 1470,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.isWhitespace(org.jsoup.parser.Token)",
        "snippet": "    private static boolean isWhitespace(Token t) {\n        if (t.isCharacter()) {\n            String data = t.asCharacter().getData();\n            return isWhitespace(data);\n        }\n        return false;\n    }",
        "begin_line": 1472,
        "end_line": 1478,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.isWhitespace(java.lang.String)",
        "snippet": "    private static boolean isWhitespace(String data) {\n        return StringUtil.isBlank(data);\n    }",
        "begin_line": 1480,
        "end_line": 1482,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.handleRcData(org.jsoup.parser.Token.StartTag, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rcdata);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }",
        "begin_line": 1484,
        "end_line": 1489,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilderState",
        "signature": "org.jsoup.parser.HtmlTreeBuilderState.handleRawtext(org.jsoup.parser.Token.StartTag, org.jsoup.parser.HtmlTreeBuilder)",
        "snippet": "    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }",
        "begin_line": 1491,
        "end_line": 1496,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.Tokeniser(org.jsoup.parser.CharacterReader, org.jsoup.parser.ParseErrorList)",
        "snippet": "    Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }",
        "begin_line": 50,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.read()",
        "snippet": "    Token read() {\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charsBuilder.length() > 0) {\n            String str = charsBuilder.toString();\n            charsBuilder.delete(0, charsBuilder.length());\n            charsString = null;\n            return charPending.data(str);\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }",
        "begin_line": 55,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emit(org.jsoup.parser.Token)",
        "snippet": "    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }",
        "begin_line": 75,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emit(java.lang.String)",
        "snippet": "    void emit(final String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        if (charsString == null) {\n            charsString = str;\n        }\n        else {\n            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n    }",
        "begin_line": 91,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emit(char[])",
        "snippet": "    void emit(char[] chars) {\n        emit(String.valueOf(chars));\n    }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emit(int[])",
        "snippet": "    void emit(int[] codepoints) {\n        emit(new String(codepoints, 0, codepoints.length));\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emit(char)",
        "snippet": "    void emit(char c) {\n        emit(String.valueOf(c));\n    }",
        "begin_line": 113,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.getState()",
        "snippet": "    TokeniserState getState() {\n        return state;\n    }",
        "begin_line": 117,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.transition(org.jsoup.parser.TokeniserState)",
        "snippet": "    void transition(TokeniserState state) {\n        this.state = state;\n    }",
        "begin_line": 121,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.advanceTransition(org.jsoup.parser.TokeniserState)",
        "snippet": "    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }",
        "begin_line": 125,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.consumeCharacterReference(java.lang.Character, boolean)",
        "snippet": "    int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAnySorted(notCharRefCharsSorted))\n            return null;\n\n        final int[] codeRef = codepointHolder;\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException ignored) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                codeRef[0] = replacementChar;\n                return codeRef;\n            } else {\n                // fix illegal unicode characters to match browser behavior\n                if (charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions.length) {\n                    characterReferenceError(\"character is not a valid unicode code point\");\n                    charval = win1252Extensions[charval - win1252ExtensionsStart];\n                }\n\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                codeRef[0] = charval;\n                return codeRef;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(String.format(\"invalid named reference '%s'\", nameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n            if (numChars == 1) {\n                codeRef[0] = multipointHolder[0];\n                return codeRef;\n            } else if (numChars ==2) {\n                return multipointHolder;\n            } else {\n                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n                return multipointHolder;\n            }\n        }\n    }",
        "begin_line": 132,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.createTagPending(boolean)",
        "snippet": "    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? startPending.reset() : endPending.reset();\n        return tagPending;\n    }",
        "begin_line": 207,
        "end_line": 210,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emitTagPending()",
        "snippet": "    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }",
        "begin_line": 212,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.createCommentPending()",
        "snippet": "    void createCommentPending() {\n        commentPending.reset();\n    }",
        "begin_line": 217,
        "end_line": 219,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emitCommentPending()",
        "snippet": "    void emitCommentPending() {\n        emit(commentPending);\n    }",
        "begin_line": 221,
        "end_line": 223,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.createDoctypePending()",
        "snippet": "    void createDoctypePending() {\n        doctypePending.reset();\n    }",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.emitDoctypePending()",
        "snippet": "    void emitDoctypePending() {\n        emit(doctypePending);\n    }",
        "begin_line": 229,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.createTempBuffer()",
        "snippet": "    void createTempBuffer() {\n        Token.reset(dataBuffer);\n    }",
        "begin_line": 233,
        "end_line": 235,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.isAppropriateEndTagToken()",
        "snippet": "    boolean isAppropriateEndTagToken() {\n        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n    }",
        "begin_line": 237,
        "end_line": 239,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.appropriateEndTagName()",
        "snippet": "    String appropriateEndTagName() {\n        return lastStartTag; // could be null\n    }",
        "begin_line": 241,
        "end_line": 243,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.error(org.jsoup.parser.TokeniserState)",
        "snippet": "    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }",
        "begin_line": 245,
        "end_line": 248,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.eofError(org.jsoup.parser.TokeniserState)",
        "snippet": "    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }",
        "begin_line": 250,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.characterReferenceError(java.lang.String)",
        "snippet": "    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }",
        "begin_line": 255,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.error(java.lang.String)",
        "snippet": "    void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }",
        "begin_line": 260,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.currentNodeInHtmlNS()",
        "snippet": "    boolean currentNodeInHtmlNS() {\n        // todo: implement namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }",
        "begin_line": 265,
        "end_line": 270,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tokeniser.java",
        "class_name": "org.jsoup.parser.Tokeniser",
        "signature": "org.jsoup.parser.Tokeniser.unescapeEntities(boolean)",
        "snippet": "    String unescapeEntities(boolean inAttribute) {\n        StringBuilder builder = StringUtil.borrowBuilder();\n        while (!reader.isEmpty()) {\n            builder.append(reader.consumeTo('&'));\n            if (reader.matches('&')) {\n                reader.consume();\n                int[] c = consumeCharacterReference(null, inAttribute);\n                if (c == null || c.length==0)\n                    builder.append('&');\n                else {\n                    builder.appendCodePoint(c[0]);\n                    if (c.length == 2)\n                        builder.appendCodePoint(c[1]);\n                }\n\n            }\n        }\n        return StringUtil.releaseBuilder(builder);\n    }",
        "begin_line": 277,
        "end_line": 295,
        "comment": "\n     * Utility method to consume reader and unescape entities found within.\n     * @param inAttribute if the text to be unescaped is in an attribute\n     * @return unescaped string from reader\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.defaultSettings()",
        "snippet": "    ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.initialiseParse(java.io.Reader, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag();\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }",
        "begin_line": 63,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.parseFragment(java.lang.String, org.jsoup.nodes.Element, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        contextElement = context;\n        fragmentParsing = true;\n        Element root = null;\n\n        if (context != null) {\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            String contextTag = context.tagName();\n            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n                tokeniser.transition(TokeniserState.Rcdata);\n            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n                tokeniser.transition(TokeniserState.Rawtext);\n            else if (contextTag.equals(\"script\"))\n                tokeniser.transition(TokeniserState.ScriptData);\n            else if (contextTag.equals((\"noscript\")))\n                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n            else if (contextTag.equals(\"plaintext\"))\n                tokeniser.transition(TokeniserState.Data);\n            else\n                tokeniser.transition(TokeniserState.Data); // default\n\n            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n            doc.appendChild(root);\n            stack.add(root);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Elements contextChain = context.parents();\n            contextChain.add(0, context);\n            for (Element parent: contextChain) {\n                if (parent instanceof FormElement) {\n                    formElement = (FormElement) parent;\n                    break;\n                }\n            }\n        }\n\n        runParser();\n        if (context != null)\n            return root.childNodes();\n        else\n            return doc.childNodes();\n    }",
        "begin_line": 82,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.process(org.jsoup.parser.Token)",
        "snippet": "    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n        return this.state.process(token, this);\n    }",
        "begin_line": 133,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.process(org.jsoup.parser.Token, org.jsoup.parser.HtmlTreeBuilderState)",
        "snippet": "    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }",
        "begin_line": 139,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.transition(org.jsoup.parser.HtmlTreeBuilderState)",
        "snippet": "    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }",
        "begin_line": 144,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.state()",
        "snippet": "    HtmlTreeBuilderState state() {\n        return state;\n    }",
        "begin_line": 148,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.markInsertionMode()",
        "snippet": "    void markInsertionMode() {\n        originalState = state;\n    }",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.originalState()",
        "snippet": "    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.framesetOk(boolean)",
        "snippet": "    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.framesetOk()",
        "snippet": "    boolean framesetOk() {\n        return framesetOk;\n    }",
        "begin_line": 164,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getDocument()",
        "snippet": "    Document getDocument() {\n        return doc;\n    }",
        "begin_line": 168,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getBaseUri()",
        "snippet": "    String getBaseUri() {\n        return baseUri;\n    }",
        "begin_line": 172,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.maybeSetBaseUri(org.jsoup.nodes.Element)",
        "snippet": "    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }",
        "begin_line": 176,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isFragmentParsing()",
        "snippet": "    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.error(org.jsoup.parser.HtmlTreeBuilderState)",
        "snippet": "    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }",
        "begin_line": 192,
        "end_line": 195,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insert(org.jsoup.parser.Token.StartTag)",
        "snippet": "    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n        insert(el);\n        return el;\n    }",
        "begin_line": 197,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertStartTag(java.lang.String)",
        "snippet": "    Element insertStartTag(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n        insert(el);\n        return el;\n    }",
        "begin_line": 213,
        "end_line": 217,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insert(org.jsoup.nodes.Element)",
        "snippet": "    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }",
        "begin_line": 219,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertEmpty(org.jsoup.parser.Token.StartTag)",
        "snippet": "    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n            }\n            else // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n        }\n        return el;\n    }",
        "begin_line": 224,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertForm(org.jsoup.parser.Token.StartTag, boolean)",
        "snippet": "    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }",
        "begin_line": 239,
        "end_line": 247,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insert(org.jsoup.parser.Token.Comment)",
        "snippet": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        insertNode(comment);\n    }",
        "begin_line": 249,
        "end_line": 252,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insert(org.jsoup.parser.Token.Character)",
        "snippet": "    void insert(Token.Character characterToken) {\n        final Node node;\n        final Element el = currentElement();\n        final String tagName = el.tagName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }",
        "begin_line": 254,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertNode(org.jsoup.nodes.Node)",
        "snippet": "    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }",
        "begin_line": 269,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.pop()",
        "snippet": "    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }",
        "begin_line": 285,
        "end_line": 288,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.push(org.jsoup.nodes.Element)",
        "snippet": "    void push(Element element) {\n        stack.add(element);\n    }",
        "begin_line": 290,
        "end_line": 292,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getStack()",
        "snippet": "    ArrayList<Element> getStack() {\n        return stack;\n    }",
        "begin_line": 294,
        "end_line": 296,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.onStack(org.jsoup.nodes.Element)",
        "snippet": "    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }",
        "begin_line": 298,
        "end_line": 300,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isElementInQueue(java.util.ArrayList<org.jsoup.nodes.Element>, org.jsoup.nodes.Element)",
        "snippet": "    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 302,
        "end_line": 310,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getFromStack(java.lang.String)",
        "snippet": "    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }",
        "begin_line": 312,
        "end_line": 320,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.removeFromStack(org.jsoup.nodes.Element)",
        "snippet": "    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 322,
        "end_line": 331,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.popStackToClose(java.lang.String)",
        "snippet": "    void popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next.normalName().equals(elName))\n                break;\n        }\n    }",
        "begin_line": 333,
        "end_line": 340,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.popStackToClose(java.lang.String...)",
        "snippet": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }",
        "begin_line": 343,
        "end_line": 350,
        "comment": " elnames is sorted, comes from Constants",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.popStackToBefore(java.lang.String)",
        "snippet": "    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.normalName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }",
        "begin_line": 352,
        "end_line": 361,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.clearStackToTableContext()",
        "snippet": "    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }",
        "begin_line": 363,
        "end_line": 365,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.clearStackToTableBodyContext()",
        "snippet": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }",
        "begin_line": 367,
        "end_line": 369,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.clearStackToTableRowContext()",
        "snippet": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }",
        "begin_line": 371,
        "end_line": 373,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.clearStackToContext(java.lang.String...)",
        "snippet": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }",
        "begin_line": 375,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.aboveOnStack(org.jsoup.nodes.Element)",
        "snippet": "    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }",
        "begin_line": 385,
        "end_line": 394,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertOnStackAfter(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }",
        "begin_line": 396,
        "end_line": 400,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.replaceOnStack(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }",
        "begin_line": 402,
        "end_line": 404,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.replaceInQueue(java.util.ArrayList<org.jsoup.nodes.Element>, org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }",
        "begin_line": 406,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.resetInsertionMode()",
        "snippet": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.normalName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }",
        "begin_line": 412,
        "end_line": 459,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inSpecificScope(java.lang.String, java.lang.String[], java.lang.String[])",
        "snippet": "    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }",
        "begin_line": 464,
        "end_line": 467,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inSpecificScope(java.lang.String[], java.lang.String[], java.lang.String[])",
        "snippet": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }",
        "begin_line": 469,
        "end_line": 486,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inScope(java.lang.String[])",
        "snippet": "    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }",
        "begin_line": 488,
        "end_line": 490,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inScope(java.lang.String)",
        "snippet": "    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }",
        "begin_line": 492,
        "end_line": 494,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inScope(java.lang.String, java.lang.String[])",
        "snippet": "    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }",
        "begin_line": 496,
        "end_line": 500,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inListItemScope(java.lang.String)",
        "snippet": "    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }",
        "begin_line": 502,
        "end_line": 504,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inButtonScope(java.lang.String)",
        "snippet": "    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }",
        "begin_line": 506,
        "end_line": 508,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inTableScope(java.lang.String)",
        "snippet": "    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }",
        "begin_line": 510,
        "end_line": 512,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.inSelectScope(java.lang.String)",
        "snippet": "    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }",
        "begin_line": 514,
        "end_line": 525,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.setHeadElement(org.jsoup.nodes.Element)",
        "snippet": "    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }",
        "begin_line": 527,
        "end_line": 529,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getHeadElement()",
        "snippet": "    Element getHeadElement() {\n        return headElement;\n    }",
        "begin_line": 531,
        "end_line": 533,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isFosterInserts()",
        "snippet": "    boolean isFosterInserts() {\n        return fosterInserts;\n    }",
        "begin_line": 535,
        "end_line": 537,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.setFosterInserts(boolean)",
        "snippet": "    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }",
        "begin_line": 539,
        "end_line": 541,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getFormElement()",
        "snippet": "    FormElement getFormElement() {\n        return formElement;\n    }",
        "begin_line": 543,
        "end_line": 545,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.setFormElement(org.jsoup.nodes.FormElement)",
        "snippet": "    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }",
        "begin_line": 547,
        "end_line": 549,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.newPendingTableCharacters()",
        "snippet": "    void newPendingTableCharacters() {\n        pendingTableCharacters = new ArrayList<>();\n    }",
        "begin_line": 551,
        "end_line": 553,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getPendingTableCharacters()",
        "snippet": "    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }",
        "begin_line": 555,
        "end_line": 557,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.generateImpliedEndTags(java.lang.String)",
        "snippet": "    void generateImpliedEndTags(String excludeTag) {\n        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n                inSorted(currentElement().normalName(), TagSearchEndTags))\n            pop();\n    }",
        "begin_line": 568,
        "end_line": 572,
        "comment": "\n     11.2.5.2 Closing elements that have implied end tags<p/>\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n     the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.generateImpliedEndTags()",
        "snippet": "    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }",
        "begin_line": 574,
        "end_line": 576,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isSpecial(org.jsoup.nodes.Element)",
        "snippet": "    boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }",
        "begin_line": 578,
        "end_line": 583,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.lastFormattingElement()",
        "snippet": "    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }",
        "begin_line": 585,
        "end_line": 587,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.removeLastFormattingElement()",
        "snippet": "    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }",
        "begin_line": 589,
        "end_line": 595,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.pushActiveFormattingElements(org.jsoup.nodes.Element)",
        "snippet": "    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }",
        "begin_line": 598,
        "end_line": 614,
        "comment": " active formatting elements",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isSameFormattingElement(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.normalName().equals(b.normalName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }",
        "begin_line": 616,
        "end_line": 622,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.reconstructFormattingElements()",
        "snippet": "    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }",
        "begin_line": 624,
        "end_line": 660,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.clearFormattingElementsToLastMarker()",
        "snippet": "    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }",
        "begin_line": 662,
        "end_line": 668,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.removeFromActiveFormattingElements(org.jsoup.nodes.Element)",
        "snippet": "    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }",
        "begin_line": 670,
        "end_line": 678,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.isInActiveFormattingElements(org.jsoup.nodes.Element)",
        "snippet": "    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }",
        "begin_line": 680,
        "end_line": 682,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.getActiveFormattingElement(java.lang.String)",
        "snippet": "    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.normalName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }",
        "begin_line": 684,
        "end_line": 693,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.replaceActiveFormattingElement(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }",
        "begin_line": 695,
        "end_line": 697,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertMarkerToFormattingElements()",
        "snippet": "    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }",
        "begin_line": 699,
        "end_line": 701,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.insertInFosterParent(org.jsoup.nodes.Node)",
        "snippet": "    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }",
        "begin_line": 703,
        "end_line": 723,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.HtmlTreeBuilder",
        "signature": "org.jsoup.parser.HtmlTreeBuilder.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }",
        "begin_line": 725,
        "end_line": 732,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); // NOT replacement character (oddly?)\n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }",
        "begin_line": 11,
        "end_line": 31,
        "comment": " in data state, gather characters until a character reference or tag is found",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Data);\n        }",
        "begin_line": 35,
        "end_line": 37,
        "comment": " from & in data",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }",
        "begin_line": 41,
        "end_line": 62,
        "comment": "/ handles data in title, textarea etc",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readCharRef(t, Rcdata);\n        }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, RawtextLessthanSign);\n        }",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readData(t, r, this, ScriptDataLessthanSign);\n        }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }",
        "begin_line": 80,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); // char that got us here\n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }",
        "begin_line": 99,
        "end_line": 121,
        "comment": " from < in data",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }",
        "begin_line": 124,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '<': // NOTE: out of spec, but clear author intent\n                    t.error(this);\n                    r.unconsume();\n                    // intended fall through to next >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }",
        "begin_line": 143,
        "end_line": 179,
        "comment": " from < or </ in data, will have start or end tag pending",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                // consuming to EOF; break out here\n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); // undo \"<\"\n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }",
        "begin_line": 183,
        "end_line": 198,
        "comment": " from < in rcdata",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }",
        "begin_line": 201,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name);\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }",
        "begin_line": 214,
        "end_line": 251,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.anythingElse(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }",
        "begin_line": 253,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }",
        "begin_line": 260,
        "end_line": 268,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, RawtextEndTagName, Rawtext);\n        }",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }",
        "begin_line": 276,
        "end_line": 278,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }",
        "begin_line": 281,
        "end_line": 296,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            readEndTag(t, r, ScriptDataEndTagName, ScriptData);\n        }",
        "begin_line": 299,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }",
        "begin_line": 304,
        "end_line": 306,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }",
        "begin_line": 309,
        "end_line": 316,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }",
        "begin_line": 319,
        "end_line": 326,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }",
        "begin_line": 329,
        "end_line": 353,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }",
        "begin_line": 356,
        "end_line": 381,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }",
        "begin_line": 384,
        "end_line": 412,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(r.current());\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }",
        "begin_line": 415,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(r.current());\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }",
        "begin_line": 431,
        "end_line": 441,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }",
        "begin_line": 444,
        "end_line": 446,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }",
        "begin_line": 449,
        "end_line": 451,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }",
        "begin_line": 454,
        "end_line": 478,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }",
        "begin_line": 481,
        "end_line": 505,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }",
        "begin_line": 508,
        "end_line": 535,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }",
        "begin_line": 538,
        "end_line": 546,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }",
        "begin_line": 549,
        "end_line": 551,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name)\n                    t.error(this);\n                    r.unconsume();\n                    // intended fall through as if >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }",
        "begin_line": 555,
        "end_line": 598,
        "comment": " from tagname <xxx",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendAttributeName(c);\n            }\n        }",
        "begin_line": 602,
        "end_line": 642,
        "comment": " from before attribute name",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }",
        "begin_line": 645,
        "end_line": 687,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    // ignore\n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }",
        "begin_line": 690,
        "end_line": 736,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // hit end of buffer in first read, still in attribute\n                    t.tagPending.appendAttributeValue(c);\n            }\n        }",
        "begin_line": 739,
        "end_line": 769,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n            else\n                t.tagPending.setEmptyAttributeValue();\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // hit end of buffer in first read, still in attribute\n                    t.tagPending.appendAttributeValue(c);\n            }\n        }",
        "begin_line": 772,
        "end_line": 802,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeValueUnquoted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    int[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                default: // hit end of buffer in first read, still in attribute\n                    t.tagPending.appendAttributeValue(c);\n            }\n\n        }",
        "begin_line": 805,
        "end_line": 850,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }",
        "begin_line": 854,
        "end_line": 881,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }",
        "begin_line": 884,
        "end_line": 901,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }",
        "begin_line": 904,
        "end_line": 914,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(\"[CDATA[\")) {\n                t.createTempBuffer();\n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind\n            }\n        }",
        "begin_line": 917,
        "end_line": 933,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }",
        "begin_line": 936,
        "end_line": 961,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }",
        "begin_line": 964,
        "end_line": 989,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }",
        "begin_line": 992,
        "end_line": 1011,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }",
        "begin_line": 1014,
        "end_line": 1034,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }",
        "begin_line": 1037,
        "end_line": 1067,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }",
        "begin_line": 1070,
        "end_line": 1095,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    // note: fall through to > case\n                case '>': // catch invalid <!DOCTYPE>\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }",
        "begin_line": 1098,
        "end_line": 1122,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }",
        "begin_line": 1125,
        "end_line": 1157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }",
        "begin_line": 1160,
        "end_line": 1192,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); // ignore whitespace\n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }",
        "begin_line": 1195,
        "end_line": 1220,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }",
        "begin_line": 1223,
        "end_line": 1260,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }",
        "begin_line": 1263,
        "end_line": 1297,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }",
        "begin_line": 1300,
        "end_line": 1325,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }",
        "begin_line": 1328,
        "end_line": 1353,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }",
        "begin_line": 1356,
        "end_line": 1391,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }",
        "begin_line": 1394,
        "end_line": 1428,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    // system id empty\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }",
        "begin_line": 1431,
        "end_line": 1468,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    // set system id to empty string\n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    // set public id to empty string\n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }",
        "begin_line": 1471,
        "end_line": 1505,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }",
        "begin_line": 1508,
        "end_line": 1533,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }",
        "begin_line": 1536,
        "end_line": 1561,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    // NOT force quirks\n            }\n        }",
        "begin_line": 1564,
        "end_line": 1588,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    // ignore char\n                    break;\n            }\n        }",
        "begin_line": 1591,
        "end_line": 1606,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.dataBuffer.append(data);\n            if (r.matchConsume(\"]]>\") || r.isEmpty()) {\n                t.emit(new Token.CData(t.dataBuffer.toString()));\n                t.transition(Data);\n            }// otherwise, buffer underrun, stay in data section\n        }",
        "begin_line": 1609,
        "end_line": 1616,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.read(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader)",
        "snippet": "    abstract void read(Tokeniser t, CharacterReader r);",
        "begin_line": 1620,
        "end_line": 1620,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.handleDataEndTag(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader, org.jsoup.parser.TokeniserState)",
        "snippet": "    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name);\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }",
        "begin_line": 1637,
        "end_line": 1675,
        "comment": "\n     * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n     * different else exit transitions.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.readData(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader, org.jsoup.parser.TokeniserState, org.jsoup.parser.TokeniserState)",
        "snippet": "    private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {\n        switch (r.current()) {\n            case '<':\n                t.advanceTransition(advance);\n                break;\n            case nullChar:\n                t.error(current);\n                r.advance();\n                t.emit(replacementChar);\n                break;\n            case eof:\n                t.emit(new Token.EOF());\n                break;\n            default:\n                String data = r.consumeToAny('<', nullChar); // todo - why hunt for null here? Just consumeTo'<'?\n                t.emit(data);\n                break;\n        }\n    }",
        "begin_line": 1677,
        "end_line": 1695,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.readCharRef(org.jsoup.parser.Tokeniser, org.jsoup.parser.TokeniserState)",
        "snippet": "    private static void readCharRef(Tokeniser t, TokeniserState advance) {\n        int[] c = t.consumeCharacterReference(null, false);\n        if (c == null)\n            t.emit('&');\n        else\n            t.emit(c);\n        t.transition(advance);\n    }",
        "begin_line": 1697,
        "end_line": 1704,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.readEndTag(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader, org.jsoup.parser.TokeniserState, org.jsoup.parser.TokeniserState)",
        "snippet": "    private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {\n        if (r.matchesLetter()) {\n            t.createTagPending(false);\n            t.transition(a);\n        } else {\n            t.emit(\"</\");\n            t.transition(b);\n        }\n    }",
        "begin_line": 1706,
        "end_line": 1714,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokeniserState.java",
        "class_name": "org.jsoup.parser.TokeniserState",
        "signature": "org.jsoup.parser.TokeniserState.handleDataDoubleEscapeTag(org.jsoup.parser.Tokeniser, org.jsoup.parser.CharacterReader, org.jsoup.parser.TokeniserState, org.jsoup.parser.TokeniserState)",
        "snippet": "    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name);\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }",
        "begin_line": 1716,
        "end_line": 1743,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "org.jsoup.parser.ParseSettings",
        "signature": "org.jsoup.parser.ParseSettings.ParseSettings(boolean, boolean)",
        "snippet": "    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }",
        "begin_line": 33,
        "end_line": 36,
        "comment": "\n     * Define parse settings.\n     * @param tag preserve tag case?\n     * @param attribute preserve attribute name case?\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "org.jsoup.parser.ParseSettings",
        "signature": "org.jsoup.parser.ParseSettings.normalizeTag(java.lang.String)",
        "snippet": "    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }",
        "begin_line": 41,
        "end_line": 46,
        "comment": "\n     * Normalizes a tag name according to the case preservation setting.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "org.jsoup.parser.ParseSettings",
        "signature": "org.jsoup.parser.ParseSettings.normalizeAttribute(java.lang.String)",
        "snippet": "    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }",
        "begin_line": 51,
        "end_line": 56,
        "comment": "\n     * Normalizes an attribute according to the case preservation setting.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseSettings.java",
        "class_name": "org.jsoup.parser.ParseSettings",
        "signature": "org.jsoup.parser.ParseSettings.normalizeAttributes(org.jsoup.nodes.Attributes)",
        "snippet": "    Attributes normalizeAttributes(Attributes attributes) {\n        if (!preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }",
        "begin_line": 58,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "org.jsoup.parser.ParseErrorList",
        "signature": "org.jsoup.parser.ParseErrorList.ParseErrorList(int, int)",
        "snippet": "    ParseErrorList(int initialCapacity, int maxSize) {\n        super(initialCapacity);\n        this.maxSize = maxSize;\n    }",
        "begin_line": 14,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "org.jsoup.parser.ParseErrorList",
        "signature": "org.jsoup.parser.ParseErrorList.canAddError()",
        "snippet": "    boolean canAddError() {\n        return size() < maxSize;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "org.jsoup.parser.ParseErrorList",
        "signature": "org.jsoup.parser.ParseErrorList.getMaxSize()",
        "snippet": "    int getMaxSize() {\n        return maxSize;\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "org.jsoup.parser.ParseErrorList",
        "signature": "org.jsoup.parser.ParseErrorList.noTracking()",
        "snippet": "    public static ParseErrorList noTracking() {\n        return new ParseErrorList(0, 0);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/ParseErrorList.java",
        "class_name": "org.jsoup.parser.ParseErrorList",
        "signature": "org.jsoup.parser.ParseErrorList.tracking(int)",
        "snippet": "    public static ParseErrorList tracking(int maxSize) {\n        return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.defaultSettings()",
        "snippet": "    ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.initialiseParse(java.io.Reader, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.parse(java.io.Reader, java.lang.String)",
        "snippet": "    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.parse(java.lang.String, java.lang.String)",
        "snippet": "    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.process(org.jsoup.parser.Token)",
        "snippet": "    @Override\n    protected boolean process(Token token) {\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }",
        "begin_line": 44,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.insertNode(org.jsoup.nodes.Node)",
        "snippet": "    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.insert(org.jsoup.parser.Token.StartTag)",
        "snippet": "    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }",
        "begin_line": 75,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.insert(org.jsoup.parser.Token.Comment)",
        "snippet": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            XmlDeclaration decl = comment.asXmlDeclaration(); // else, we couldn't parse it as a decl, so leave as a comment\n            if (decl != null)\n                insert = decl;\n        }\n        insertNode(insert);\n    }",
        "begin_line": 89,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.insert(org.jsoup.parser.Token.Character)",
        "snippet": "    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.insert(org.jsoup.parser.Token.Doctype)",
        "snippet": "    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }",
        "begin_line": 107,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.popStackToClose(org.jsoup.parser.Token.EndTag)",
        "snippet": "    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }",
        "begin_line": 119,
        "end_line": 139,
        "comment": "\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.parseFragment(java.lang.String, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        runParser();\n        return doc.childNodes();\n    }",
        "begin_line": 142,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java",
        "class_name": "org.jsoup.parser.XmlTreeBuilder",
        "signature": "org.jsoup.parser.XmlTreeBuilder.parseFragment(java.lang.String, org.jsoup.nodes.Element, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        return parseFragment(inputFragment, baseUri, parser);\n    }",
        "begin_line": 148,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.Tag(java.lang.String)",
        "snippet": "    private Tag(String tagName) {\n        this.tagName = tagName;\n        normalName = Normalizer.lowerCase(tagName);\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.getName()",
        "snippet": "    public String getName() {\n        return tagName;\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "\n     * Get this tag's name.\n     *\n     * @return the tag's name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.normalName()",
        "snippet": "    public String normalName() {\n        return normalName;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Get this tag's normalized (lowercased) name.\n     * @return the tag's normal name.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.valueOf(java.lang.String, org.jsoup.parser.ParseSettings)",
        "snippet": "    public static Tag valueOf(String tagName, ParseSettings settings) {\n        Validate.notNull(tagName);\n        Tag tag = tags.get(tagName);\n\n        if (tag == null) {\n            tagName = settings.normalizeTag(tagName);\n            Validate.notEmpty(tagName);\n            tag = tags.get(tagName);\n\n            if (tag == null) {\n                // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n                tag = new Tag(tagName);\n                tag.isBlock = false;\n            }\n        }\n        return tag;\n    }",
        "begin_line": 60,
        "end_line": 76,
        "comment": "\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p>\n     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     * </p>\n     * \n     * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n     * @param settings used to control tag name sensitivity\n     * @return The tag, either defined or new generic.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.valueOf(java.lang.String)",
        "snippet": "    public static Tag valueOf(String tagName) {\n        return valueOf(tagName, ParseSettings.preserveCase);\n    }",
        "begin_line": 87,
        "end_line": 89,
        "comment": "\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p>\n     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     * </p>\n     *\n     * @param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n     * @return The tag, either defined or new generic.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isBlock()",
        "snippet": "    public boolean isBlock() {\n        return isBlock;\n    }",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n     * Gets if this is a block tag.\n     *\n     * @return if block tag\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.formatAsBlock()",
        "snippet": "    public boolean formatAsBlock() {\n        return formatAsBlock;\n    }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "\n     * Gets if this tag should be formatted as a block (or as inline)\n     *\n     * @return if should be formatted as block or inline\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.canContainBlock()",
        "snippet": "    public boolean canContainBlock() {\n        return isBlock;\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * Gets if this tag can contain block tags.\n     *\n     * @return if tag can contain block tags\n     * @deprecated No longer used, and no different result than {{@link #isBlock()}}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isInline()",
        "snippet": "    public boolean isInline() {\n        return !isBlock;\n    }",
        "begin_line": 124,
        "end_line": 126,
        "comment": "\n     * Gets if this tag is an inline tag.\n     *\n     * @return if this tag is an inline tag.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isData()",
        "snippet": "    public boolean isData() {\n        return !canContainInline && !isEmpty();\n    }",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * Gets if this tag is a data only tag.\n     *\n     * @return if this tag is a data only tag\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return empty;\n    }",
        "begin_line": 142,
        "end_line": 144,
        "comment": "\n     * Get if this is an empty tag\n     *\n     * @return if this is an empty tag\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isSelfClosing()",
        "snippet": "    public boolean isSelfClosing() {\n        return empty || selfClosing;\n    }",
        "begin_line": 151,
        "end_line": 153,
        "comment": "\n     * Get if this tag is self closing.\n     *\n     * @return if this tag should be output as self closing.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isKnownTag()",
        "snippet": "    public boolean isKnownTag() {\n        return tags.containsKey(tagName);\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n     * Get if this is a pre-defined tag, or was auto created on parsing.\n     *\n     * @return if a known tag\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isKnownTag(java.lang.String)",
        "snippet": "    public static boolean isKnownTag(String tagName) {\n        return tags.containsKey(tagName);\n    }",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n     * Check if this tagname is a known tag.\n     *\n     * @param tagName name of tag\n     * @return if known HTML tag\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.preserveWhitespace()",
        "snippet": "    public boolean preserveWhitespace() {\n        return preserveWhitespace;\n    }",
        "begin_line": 179,
        "end_line": 181,
        "comment": "\n     * Get if this tag should preserve whitespace within child text nodes.\n     *\n     * @return if preserve whitespace\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isFormListed()",
        "snippet": "    public boolean isFormListed() {\n        return formList;\n    }",
        "begin_line": 187,
        "end_line": 189,
        "comment": "\n     * Get if this tag represents a control associated with a form. E.g. input, textarea, output\n     * @return if associated with a form\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.isFormSubmittable()",
        "snippet": "    public boolean isFormSubmittable() {\n        return formSubmit;\n    }",
        "begin_line": 195,
        "end_line": 197,
        "comment": "\n     * Get if this tag represents an element that should be submitted with a form. E.g. input, option\n     * @return if submittable with a form\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.setSelfClosing()",
        "snippet": "    Tag setSelfClosing() {\n        selfClosing = true;\n        return this;\n    }",
        "begin_line": 199,
        "end_line": 202,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tag)) return false;\n\n        Tag tag = (Tag) o;\n\n        if (!tagName.equals(tag.tagName)) return false;\n        if (canContainInline != tag.canContainInline) return false;\n        if (empty != tag.empty) return false;\n        if (formatAsBlock != tag.formatAsBlock) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (preserveWhitespace != tag.preserveWhitespace) return false;\n        if (selfClosing != tag.selfClosing) return false;\n        if (formList != tag.formList) return false;\n        return formSubmit == tag.formSubmit;\n    }",
        "begin_line": 204,
        "end_line": 220,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        int result = tagName.hashCode();\n        result = 31 * result + (isBlock ? 1 : 0);\n        result = 31 * result + (formatAsBlock ? 1 : 0);\n        result = 31 * result + (canContainInline ? 1 : 0);\n        result = 31 * result + (empty ? 1 : 0);\n        result = 31 * result + (selfClosing ? 1 : 0);\n        result = 31 * result + (preserveWhitespace ? 1 : 0);\n        result = 31 * result + (formList ? 1 : 0);\n        result = 31 * result + (formSubmit ? 1 : 0);\n        return result;\n    }",
        "begin_line": 222,
        "end_line": 234,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return tagName;\n    }",
        "begin_line": 236,
        "end_line": 239,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/Tag.java",
        "class_name": "org.jsoup.parser.Tag",
        "signature": "org.jsoup.parser.Tag.register(org.jsoup.parser.Tag)",
        "snippet": "    private static void register(Tag tag) {\n        tags.put(tag.tagName, tag);\n    }",
        "begin_line": 325,
        "end_line": 327,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.TokenQueue(java.lang.String)",
        "snippet": "    public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }",
        "begin_line": 21,
        "end_line": 24,
        "comment": "\n     Create a new TokenQueue.\n     @param data string of data to back queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "\n     * Is the queue empty?\n     * @return true if no data left in queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.remainingLength()",
        "snippet": "    private int remainingLength() {\n        return queue.length() - pos;\n    }",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.peek()",
        "snippet": "    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Retrieves but does not remove the first character from the queue.\n     * @return First character, or 0 if empty.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.addFirst(java.lang.Character)",
        "snippet": "    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "\n     Add a character to the start of the queue (will be the next character retrieved).\n     @param c character to add\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.addFirst(java.lang.String)",
        "snippet": "    public void addFirst(String seq) {\n        // not very performant, but an edge case\n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }",
        "begin_line": 58,
        "end_line": 62,
        "comment": "\n     Add a string to the start of the queue.\n     @param seq string to add.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matches(java.lang.String)",
        "snippet": "    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n     * Tests if the next characters on the queue match the sequence. Case insensitive.\n     * @param seq String to check queue for.\n     * @return true if the next characters match.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesCS(java.lang.String)",
        "snippet": "    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     * Case sensitive match test.\n     * @param seq string to case sensitively check for\n     * @return true if matched, false if not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesAny(java.lang.String...)",
        "snippet": "    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 88,
        "end_line": 94,
        "comment": "\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesAny(char...)",
        "snippet": "    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 96,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesStartTag()",
        "snippet": "    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchChomp(java.lang.String)",
        "snippet": "    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "begin_line": 118,
        "end_line": 125,
        "comment": "\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesWhitespace()",
        "snippet": "    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.matchesWord()",
        "snippet": "    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }",
        "begin_line": 139,
        "end_line": 141,
        "comment": "\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.advance()",
        "snippet": "    public void advance() {\n        if (!isEmpty()) pos++;\n    }",
        "begin_line": 146,
        "end_line": 148,
        "comment": "\n     * Drops the next character off the queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consume()",
        "snippet": "    public char consume() {\n        return queue.charAt(pos++);\n    }",
        "begin_line": 154,
        "end_line": 156,
        "comment": "\n     * Consume one character off queue.\n     * @return first character on queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consume(java.lang.String)",
        "snippet": "    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }",
        "begin_line": 165,
        "end_line": 173,
        "comment": "\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeTo(java.lang.String)",
        "snippet": "    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }",
        "begin_line": 180,
        "end_line": 189,
        "comment": "\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeToIgnoreCase(java.lang.String)",
        "snippet": "    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }",
        "begin_line": 191,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeToAny(java.lang.String...)",
        "snippet": "    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }",
        "begin_line": 222,
        "end_line": 229,
        "comment": " is is a case sensitive time...",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.chompTo(java.lang.String)",
        "snippet": "    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }",
        "begin_line": 239,
        "end_line": 243,
        "comment": "\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.chompToIgnoreCase(java.lang.String)",
        "snippet": "    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }",
        "begin_line": 245,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.chompBalanced(char, char)",
        "snippet": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
        "begin_line": 260,
        "end_line": 297,
        "comment": "\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.unescape(java.lang.String)",
        "snippet": "    public static String unescape(String in) {\n        StringBuilder out = StringUtil.borrowBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return StringUtil.releaseBuilder(out);\n    }",
        "begin_line": 304,
        "end_line": 317,
        "comment": "\n     * Unescape a \\ escaped string.\n     * @param in backslash escaped string\n     * @return unescaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeWhitespace()",
        "snippet": "    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }",
        "begin_line": 323,
        "end_line": 330,
        "comment": "\n     * Pulls the next run of whitespace characters of the queue.\n     * @return Whether consuming whitespace or not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeWord()",
        "snippet": "    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }",
        "begin_line": 336,
        "end_line": 341,
        "comment": "\n     * Retrieves the next run of word type (letter or digit) off the queue.\n     * @return String of word characters from queue, or empty string if none.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeTagName()",
        "snippet": "    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }",
        "begin_line": 348,
        "end_line": 354,
        "comment": "\n     * Consume an tag name off the queue (word or :, _, -)\n     * \n     * @return tag name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeElementSelector()",
        "snippet": "    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }",
        "begin_line": 361,
        "end_line": 367,
        "comment": "\n     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n     * \n     * @return tag name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeCssIdentifier()",
        "snippet": "    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }",
        "begin_line": 374,
        "end_line": 380,
        "comment": "\n     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)\n     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n     @return identifier\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.consumeAttributeKey()",
        "snippet": "    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }",
        "begin_line": 386,
        "end_line": 392,
        "comment": "\n     Consume an attribute key off the queue (letter, digit, -, _, :\")\n     @return attribute key\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.remainder()",
        "snippet": "    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }",
        "begin_line": 398,
        "end_line": 402,
        "comment": "\n     Consume and return whatever is left on the queue.\n     @return remained of queue.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/parser/TokenQueue.java",
        "class_name": "org.jsoup.parser.TokenQueue",
        "signature": "org.jsoup.parser.TokenQueue.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }",
        "begin_line": 404,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.connect(java.lang.String)",
        "snippet": "    public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }",
        "begin_line": 67,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.connect(java.net.URL)",
        "snippet": "    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.HttpConnection()",
        "snippet": "    public HttpConnection() {\n        req = new Request();\n        res = new Response();\n    }",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.encodeUrl(java.lang.String)",
        "snippet": "\tprivate static String encodeUrl(String url) {\n        try {\n            URL u = new URL(url);\n            return encodeUrl(u).toExternalForm();\n        } catch (Exception e) {\n            return url;\n        }\n\t}",
        "begin_line": 89,
        "end_line": 96,
        "comment": "\n     * Encodes the input URL into a safe ASCII URL string\n     * @param url unescaped URL\n     * @return escaped URL\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.encodeUrl(java.net.URL)",
        "snippet": "    static URL encodeUrl(URL u) {\n        try {\n            //  odd way to encode urls, but it works!\n            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n            urlS = urlS.replaceAll(\" \", \"%20\");\n            final URI uri = new URI(urlS);\n            return new URL(uri.toASCIIString());\n        } catch (Exception e) {\n            return u;\n        }\n    }",
        "begin_line": 98,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.encodeMimeName(java.lang.String)",
        "snippet": "    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }",
        "begin_line": 110,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.url(java.net.URL)",
        "snippet": "    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }",
        "begin_line": 119,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.url(java.lang.String)",
        "snippet": "    public Connection url(String url) {\n        Validate.notEmpty(url, \"Must supply a valid URL\");\n        try {\n            req.url(new URL(encodeUrl(url)));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Malformed URL: \" + url, e);\n        }\n        return this;\n    }",
        "begin_line": 124,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.proxy(java.net.Proxy)",
        "snippet": "    public Connection proxy(Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }",
        "begin_line": 134,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.proxy(java.lang.String, int)",
        "snippet": "    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }",
        "begin_line": 139,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.userAgent(java.lang.String)",
        "snippet": "    public Connection userAgent(String userAgent) {\n        Validate.notNull(userAgent, \"User agent must not be null\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.timeout(int)",
        "snippet": "    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }",
        "begin_line": 150,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.maxBodySize(int)",
        "snippet": "    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }",
        "begin_line": 155,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.followRedirects(boolean)",
        "snippet": "    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }",
        "begin_line": 160,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.referrer(java.lang.String)",
        "snippet": "    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }",
        "begin_line": 165,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.method(org.jsoup.Connection.Method)",
        "snippet": "    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.ignoreHttpErrors(boolean)",
        "snippet": "    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}",
        "begin_line": 176,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.ignoreContentType(boolean)",
        "snippet": "    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }",
        "begin_line": 181,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.lang.String, java.lang.String)",
        "snippet": "    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }",
        "begin_line": 187,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.sslSocketFactory(javax.net.ssl.SSLSocketFactory)",
        "snippet": "    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }",
        "begin_line": 192,
        "end_line": 195,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.lang.String, java.lang.String, java.io.InputStream)",
        "snippet": "    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }",
        "begin_line": 197,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.lang.String, java.lang.String, java.io.InputStream, java.lang.String)",
        "snippet": "    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }",
        "begin_line": 202,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    public Connection data(Map<String, String> data) {\n        Validate.notNull(data, \"Data map must not be null\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }",
        "begin_line": 208,
        "end_line": 214,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.lang.String...)",
        "snippet": "    public Connection data(String... keyvals) {\n        Validate.notNull(keyvals, \"Data key value pairs must not be null\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }",
        "begin_line": 216,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.util.Collection<org.jsoup.Connection.KeyVal>)",
        "snippet": "    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNull(data, \"Data collection must not be null\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }",
        "begin_line": 229,
        "end_line": 235,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.data(java.lang.String)",
        "snippet": "    public Connection.KeyVal data(String key) {\n        Validate.notEmpty(key, \"Data key must not be empty\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }",
        "begin_line": 237,
        "end_line": 244,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.requestBody(java.lang.String)",
        "snippet": "    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }",
        "begin_line": 246,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.header(java.lang.String, java.lang.String)",
        "snippet": "    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }",
        "begin_line": 251,
        "end_line": 254,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.headers(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    public Connection headers(Map<String,String> headers) {\n        Validate.notNull(headers, \"Header map must not be null\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }",
        "begin_line": 256,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.cookie(java.lang.String, java.lang.String)",
        "snippet": "    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }",
        "begin_line": 264,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.cookies(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNull(cookies, \"Cookie map must not be null\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }",
        "begin_line": 269,
        "end_line": 275,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.parser(org.jsoup.parser.Parser)",
        "snippet": "    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }",
        "begin_line": 277,
        "end_line": 280,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.get()",
        "snippet": "    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }",
        "begin_line": 282,
        "end_line": 286,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.post()",
        "snippet": "    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }",
        "begin_line": 288,
        "end_line": 292,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.execute()",
        "snippet": "    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }",
        "begin_line": 294,
        "end_line": 297,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.request()",
        "snippet": "    public Connection.Request request() {\n        return req;\n    }",
        "begin_line": 299,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.request(org.jsoup.Connection.Request)",
        "snippet": "    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }",
        "begin_line": 303,
        "end_line": 306,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.response()",
        "snippet": "    public Connection.Response response() {\n        return res;\n    }",
        "begin_line": 308,
        "end_line": 310,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.response(org.jsoup.Connection.Response)",
        "snippet": "    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }",
        "begin_line": 312,
        "end_line": 315,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.postDataCharset(java.lang.String)",
        "snippet": "    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }",
        "begin_line": 317,
        "end_line": 320,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.Base()",
        "snippet": "        private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }",
        "begin_line": 329,
        "end_line": 332,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.url()",
        "snippet": "        public URL url() {\n            return url;\n        }",
        "begin_line": 334,
        "end_line": 336,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.url(java.net.URL)",
        "snippet": "        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }",
        "begin_line": 338,
        "end_line": 342,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.method()",
        "snippet": "        public Method method() {\n            return method;\n        }",
        "begin_line": 344,
        "end_line": 346,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.method(org.jsoup.Connection.Method)",
        "snippet": "        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }",
        "begin_line": 348,
        "end_line": 352,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.header(java.lang.String)",
        "snippet": "        public String header(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }",
        "begin_line": 354,
        "end_line": 363,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.addHeader(java.lang.String, java.lang.String)",
        "snippet": "        @Override\n        public T addHeader(String name, String value) {\n            Validate.notEmpty(name);\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(fixHeaderEncoding(value));\n\n            return (T) this;\n        }",
        "begin_line": 365,
        "end_line": 378,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.headers(java.lang.String)",
        "snippet": "        @Override\n        public List<String> headers(String name) {\n            Validate.notEmpty(name);\n            return getHeadersCaseInsensitive(name);\n        }",
        "begin_line": 380,
        "end_line": 384,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.fixHeaderEncoding(java.lang.String)",
        "snippet": "        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // shouldn't happen as these both always exist\n                return val;\n            }\n        }",
        "begin_line": 386,
        "end_line": 396,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.looksLikeUtf8(byte[])",
        "snippet": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }",
        "begin_line": 398,
        "end_line": 433,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.header(java.lang.String, java.lang.String)",
        "snippet": "        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }",
        "begin_line": 435,
        "end_line": 440,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.hasHeader(java.lang.String)",
        "snippet": "        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeadersCaseInsensitive(name).size() != 0;\n        }",
        "begin_line": 442,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.hasHeaderWithValue(java.lang.String, java.lang.String)",
        "snippet": "        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }",
        "begin_line": 450,
        "end_line": 459,
        "comment": "\n         * Test if the request has a header with this value (case insensitive).\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.removeHeader(java.lang.String)",
        "snippet": "        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }",
        "begin_line": 461,
        "end_line": 467,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.headers()",
        "snippet": "        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }",
        "begin_line": 469,
        "end_line": 478,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.multiHeaders()",
        "snippet": "        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }",
        "begin_line": 480,
        "end_line": 483,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.getHeadersCaseInsensitive(java.lang.String)",
        "snippet": "        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }",
        "begin_line": 485,
        "end_line": 494,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.scanHeaders(java.lang.String)",
        "snippet": "        private Map.Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }",
        "begin_line": 496,
        "end_line": 503,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.cookie(java.lang.String)",
        "snippet": "        public String cookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.get(name);\n        }",
        "begin_line": 505,
        "end_line": 508,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.cookie(java.lang.String, java.lang.String)",
        "snippet": "        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }",
        "begin_line": 510,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.hasCookie(java.lang.String)",
        "snippet": "        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }",
        "begin_line": 517,
        "end_line": 520,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.removeCookie(java.lang.String)",
        "snippet": "        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }",
        "begin_line": 522,
        "end_line": 526,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Base.cookies()",
        "snippet": "        public Map<String, String> cookies() {\n            return cookies;\n        }",
        "begin_line": 528,
        "end_line": 530,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.Request()",
        "snippet": "        Request() {\n            timeoutMilliseconds = 30000; // 30 seconds\n            maxBodySizeBytes = 1024 * 1024; // 1MB\n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n        }",
        "begin_line": 547,
        "end_line": 556,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.proxy()",
        "snippet": "        public Proxy proxy() {\n            return proxy;\n        }",
        "begin_line": 558,
        "end_line": 560,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.proxy(java.net.Proxy)",
        "snippet": "        public Request proxy(Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }",
        "begin_line": 562,
        "end_line": 565,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.proxy(java.lang.String, int)",
        "snippet": "        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }",
        "begin_line": 567,
        "end_line": 570,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.timeout()",
        "snippet": "        public int timeout() {\n            return timeoutMilliseconds;\n        }",
        "begin_line": 572,
        "end_line": 574,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.timeout(int)",
        "snippet": "        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }",
        "begin_line": 576,
        "end_line": 580,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.maxBodySize()",
        "snippet": "        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }",
        "begin_line": 582,
        "end_line": 584,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.maxBodySize(int)",
        "snippet": "        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }",
        "begin_line": 586,
        "end_line": 590,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.followRedirects()",
        "snippet": "        public boolean followRedirects() {\n            return followRedirects;\n        }",
        "begin_line": 592,
        "end_line": 594,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.followRedirects(boolean)",
        "snippet": "        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }",
        "begin_line": 596,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.ignoreHttpErrors()",
        "snippet": "        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }",
        "begin_line": 601,
        "end_line": 603,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.sslSocketFactory()",
        "snippet": "        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }",
        "begin_line": 605,
        "end_line": 607,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.sslSocketFactory(javax.net.ssl.SSLSocketFactory)",
        "snippet": "        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }",
        "begin_line": 609,
        "end_line": 611,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.ignoreHttpErrors(boolean)",
        "snippet": "        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }",
        "begin_line": 613,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.ignoreContentType()",
        "snippet": "        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }",
        "begin_line": 618,
        "end_line": 620,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.ignoreContentType(boolean)",
        "snippet": "        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }",
        "begin_line": 622,
        "end_line": 625,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.data(org.jsoup.Connection.KeyVal)",
        "snippet": "        public Request data(Connection.KeyVal keyval) {\n            Validate.notNull(keyval, \"Key val must not be null\");\n            data.add(keyval);\n            return this;\n        }",
        "begin_line": 627,
        "end_line": 631,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.data()",
        "snippet": "        public Collection<Connection.KeyVal> data() {\n            return data;\n        }",
        "begin_line": 633,
        "end_line": 635,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.requestBody(java.lang.String)",
        "snippet": "        public Connection.Request requestBody(String body) {\n            this.body = body;\n            return this;\n        }",
        "begin_line": 637,
        "end_line": 640,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.requestBody()",
        "snippet": "        public String requestBody() {\n            return body;\n        }",
        "begin_line": 642,
        "end_line": 644,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.parser(org.jsoup.parser.Parser)",
        "snippet": "        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }",
        "begin_line": 646,
        "end_line": 650,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.parser()",
        "snippet": "        public Parser parser() {\n            return parser;\n        }",
        "begin_line": 652,
        "end_line": 654,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.postDataCharset(java.lang.String)",
        "snippet": "        public Connection.Request postDataCharset(String charset) {\n            Validate.notNull(charset, \"Charset must not be null\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }",
        "begin_line": 656,
        "end_line": 661,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Request.postDataCharset()",
        "snippet": "        public String postDataCharset() {\n            return postDataCharset;\n        }",
        "begin_line": 663,
        "end_line": 665,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.Response()",
        "snippet": "        Response() {\n            super();\n        }",
        "begin_line": 688,
        "end_line": 690,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.Response(org.jsoup.helper.HttpConnection.Response)",
        "snippet": "        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }",
        "begin_line": 692,
        "end_line": 699,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.execute(org.jsoup.Connection.Request)",
        "snippet": "        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }",
        "begin_line": 701,
        "end_line": 703,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.execute(org.jsoup.Connection.Request, org.jsoup.helper.HttpConnection.Response)",
        "snippet": "        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }",
        "begin_line": 705,
        "end_line": 802,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.statusCode()",
        "snippet": "        public int statusCode() {\n            return statusCode;\n        }",
        "begin_line": 804,
        "end_line": 806,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.statusMessage()",
        "snippet": "        public String statusMessage() {\n            return statusMessage;\n        }",
        "begin_line": 808,
        "end_line": 810,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.charset()",
        "snippet": "        public String charset() {\n            return charset;\n        }",
        "begin_line": 812,
        "end_line": 814,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.charset(java.lang.String)",
        "snippet": "        public Response charset(String charset) {\n            this.charset = charset;\n            return this;\n        }",
        "begin_line": 816,
        "end_line": 819,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.contentType()",
        "snippet": "        public String contentType() {\n            return contentType;\n        }",
        "begin_line": 821,
        "end_line": 823,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.parse()",
        "snippet": "        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                bodyStream = new ByteArrayInputStream(byteData.array());\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            inputStreamRead = true;\n            safeClose();\n            return doc;\n        }",
        "begin_line": 825,
        "end_line": 837,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.prepareByteData()",
        "snippet": "        private void prepareByteData() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }",
        "begin_line": 839,
        "end_line": 852,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.body()",
        "snippet": "        public String body() {\n            prepareByteData();\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body;\n            if (charset == null)\n                body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();\n            else\n                body = Charset.forName(charset).decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }",
        "begin_line": 854,
        "end_line": 864,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.bodyAsBytes()",
        "snippet": "        public byte[] bodyAsBytes() {\n            prepareByteData();\n            return byteData.array();\n        }",
        "begin_line": 866,
        "end_line": 869,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.bufferUp()",
        "snippet": "        @Override\n        public Connection.Response bufferUp() {\n            prepareByteData();\n            return this;\n        }",
        "begin_line": 871,
        "end_line": 875,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.bodyStream()",
        "snippet": "        @Override\n        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            inputStreamRead = true;\n            return ConstrainableInputStream.wrap(bodyStream, DataUtil.bufferSize, req.maxBodySize());\n        }",
        "begin_line": 877,
        "end_line": 883,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.createConnection(org.jsoup.Connection.Request)",
        "snippet": "        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            final HttpURLConnection conn = (HttpURLConnection) (\n                req.proxy() == null ?\n                req.url().openConnection() :\n                req.url().openConnection(req.proxy())\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }",
        "begin_line": 886,
        "end_line": 910,
        "comment": " set up connection defaults, and details from request",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.safeClose()",
        "snippet": "        private void safeClose() {\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n        }",
        "begin_line": 915,
        "end_line": 929,
        "comment": "\n         * Call on completion of stream read, to close the body (or error) stream\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.setupFromConnection(java.net.HttpURLConnection, org.jsoup.helper.HttpConnection.Response)",
        "snippet": "        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n            this.conn = conn;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n                previousResponse.safeClose();\n            }\n        }",
        "begin_line": 932,
        "end_line": 951,
        "comment": " set up url, method, header, cookies",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.createHeaderMap(java.net.HttpURLConnection)",
        "snippet": "        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }",
        "begin_line": 953,
        "end_line": 975,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.processResponseHeaders(java.util.Map<java.lang.String, java.util.List<java.lang.String>>)",
        "snippet": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                }\n                for (String value : values) {\n                    addHeader(name, value);\n                }\n            }\n        }",
        "begin_line": 977,
        "end_line": 1001,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.setOutputContentType(org.jsoup.Connection.Request)",
        "snippet": "        private static String setOutputContentType(final Connection.Request req) {\n            String bound = null;\n            if (req.hasHeader(CONTENT_TYPE)) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset or boundary if those aren't included\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }",
        "begin_line": 1003,
        "end_line": 1016,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.writePost(org.jsoup.Connection.Request, java.io.OutputStream, java.lang.String)",
        "snippet": "        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n\n            if (bound != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        w.write(keyVal.contentType() != null ? keyVal.contentType() : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else if (req.requestBody() != null) {\n                // data will be in query string, we're sending a plaintext body\n                w.write(req.requestBody());\n            }\n            else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }",
        "begin_line": 1018,
        "end_line": 1068,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.getRequestCookieString(org.jsoup.Connection.Request)",
        "snippet": "        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = StringUtil.borrowBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n            }\n            return StringUtil.releaseBuilder(sb);\n        }",
        "begin_line": 1070,
        "end_line": 1082,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.Response.serialiseRequestUrl(org.jsoup.Connection.Request)",
        "snippet": "        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = StringUtil.borrowBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(StringUtil.releaseBuilder(url)));\n            req.data().clear(); // moved into url as get params\n        }",
        "begin_line": 1085,
        "end_line": 1113,
        "comment": " for get url reqs, serialise the data map into the url",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.needsMultipart(org.jsoup.Connection.Request)",
        "snippet": "    private static boolean needsMultipart(Connection.Request req) {\n        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 1116,
        "end_line": 1123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.create(java.lang.String, java.lang.String)",
        "snippet": "        public static KeyVal create(String key, String value) {\n            return new KeyVal().key(key).value(value);\n        }",
        "begin_line": 1131,
        "end_line": 1133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.create(java.lang.String, java.lang.String, java.io.InputStream)",
        "snippet": "        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }",
        "begin_line": 1135,
        "end_line": 1137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.KeyVal()",
        "snippet": "        private KeyVal() {}",
        "begin_line": 1139,
        "end_line": 1139,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.key(java.lang.String)",
        "snippet": "        public KeyVal key(String key) {\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            this.key = key;\n            return this;\n        }",
        "begin_line": 1141,
        "end_line": 1145,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.key()",
        "snippet": "        public String key() {\n            return key;\n        }",
        "begin_line": 1147,
        "end_line": 1149,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.value(java.lang.String)",
        "snippet": "        public KeyVal value(String value) {\n            Validate.notNull(value, \"Data value must not be null\");\n            this.value = value;\n            return this;\n        }",
        "begin_line": 1151,
        "end_line": 1155,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.value()",
        "snippet": "        public String value() {\n            return value;\n        }",
        "begin_line": 1157,
        "end_line": 1159,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.inputStream(java.io.InputStream)",
        "snippet": "        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNull(value, \"Data input stream must not be null\");\n            this.stream = inputStream;\n            return this;\n        }",
        "begin_line": 1161,
        "end_line": 1165,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.inputStream()",
        "snippet": "        public InputStream inputStream() {\n            return stream;\n        }",
        "begin_line": 1167,
        "end_line": 1169,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.hasInputStream()",
        "snippet": "        public boolean hasInputStream() {\n            return stream != null;\n        }",
        "begin_line": 1171,
        "end_line": 1173,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.contentType(java.lang.String)",
        "snippet": "        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }",
        "begin_line": 1175,
        "end_line": 1180,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.contentType()",
        "snippet": "        @Override\n        public String contentType() {\n            return contentType;\n        }",
        "begin_line": 1182,
        "end_line": 1185,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/HttpConnection.java",
        "class_name": "org.jsoup.helper.HttpConnection",
        "signature": "org.jsoup.helper.HttpConnection.KeyVal.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }",
        "begin_line": 1187,
        "end_line": 1190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.ChangeNotifyingArrayList(int)",
        "snippet": "    public ChangeNotifyingArrayList(int initialCapacity) {\n        super(initialCapacity);\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.onContentsChanged()",
        "snippet": "    public abstract void onContentsChanged();",
        "begin_line": 14,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.set(int, E)",
        "snippet": "    @Override\n    public E set(int index, E element) {\n        onContentsChanged();\n        return super.set(index, element);\n    }",
        "begin_line": 16,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.add(E)",
        "snippet": "    @Override\n    public boolean add(E e) {\n        onContentsChanged();\n        return super.add(e);\n    }",
        "begin_line": 22,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.add(int, E)",
        "snippet": "    @Override\n    public void add(int index, E element) {\n        onContentsChanged();\n        super.add(index, element);\n    }",
        "begin_line": 28,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.remove(int)",
        "snippet": "    @Override\n    public E remove(int index) {\n        onContentsChanged();\n        return super.remove(index);\n    }",
        "begin_line": 34,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.remove(java.lang.Object)",
        "snippet": "    @Override\n    public boolean remove(Object o) {\n        onContentsChanged();\n        return super.remove(o);\n    }",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.clear()",
        "snippet": "    @Override\n    public void clear() {\n        onContentsChanged();\n        super.clear();\n    }",
        "begin_line": 46,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.addAll(java.util.Collection<? extends E>)",
        "snippet": "    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(c);\n    }",
        "begin_line": 52,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.addAll(int, java.util.Collection<? extends E>)",
        "snippet": "    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n        onContentsChanged();\n        return super.addAll(index, c);\n    }",
        "begin_line": 58,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.removeRange(int, int)",
        "snippet": "    @Override\n    protected void removeRange(int fromIndex, int toIndex) {\n        onContentsChanged();\n        super.removeRange(fromIndex, toIndex);\n    }",
        "begin_line": 64,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.removeAll(java.util.Collection<?>)",
        "snippet": "    @Override\n    public boolean removeAll(Collection<?> c) {\n        onContentsChanged();\n        return super.removeAll(c);\n    }",
        "begin_line": 70,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java",
        "class_name": "org.jsoup.helper.ChangeNotifyingArrayList",
        "signature": "org.jsoup.helper.ChangeNotifyingArrayList.retainAll(java.util.Collection<?>)",
        "snippet": "    @Override\n    public boolean retainAll(Collection<?> c) {\n        onContentsChanged();\n        return super.retainAll(c);\n    }",
        "begin_line": 76,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.Validate()",
        "snippet": "    private Validate() {}",
        "begin_line": 8,
        "end_line": 8,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.notNull(java.lang.Object)",
        "snippet": "    public static void notNull(Object obj) {\n        if (obj == null)\n            throw new IllegalArgumentException(\"Object must not be null\");\n    }",
        "begin_line": 14,
        "end_line": 17,
        "comment": "\n     * Validates that the object is not null\n     * @param obj object to test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.notNull(java.lang.Object, java.lang.String)",
        "snippet": "    public static void notNull(Object obj, String msg) {\n        if (obj == null)\n            throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 24,
        "end_line": 27,
        "comment": "\n     * Validates that the object is not null\n     * @param obj object to test\n     * @param msg message to output if validation fails\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.isTrue(boolean)",
        "snippet": "    public static void isTrue(boolean val) {\n        if (!val)\n            throw new IllegalArgumentException(\"Must be true\");\n    }",
        "begin_line": 33,
        "end_line": 36,
        "comment": "\n     * Validates that the value is true\n     * @param val object to test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.isTrue(boolean, java.lang.String)",
        "snippet": "    public static void isTrue(boolean val, String msg) {\n        if (!val)\n            throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 43,
        "end_line": 46,
        "comment": "\n     * Validates that the value is true\n     * @param val object to test\n     * @param msg message to output if validation fails\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.isFalse(boolean)",
        "snippet": "    public static void isFalse(boolean val) {\n        if (val)\n            throw new IllegalArgumentException(\"Must be false\");\n    }",
        "begin_line": 52,
        "end_line": 55,
        "comment": "\n     * Validates that the value is false\n     * @param val object to test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.isFalse(boolean, java.lang.String)",
        "snippet": "    public static void isFalse(boolean val, String msg) {\n        if (val)\n            throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 62,
        "end_line": 65,
        "comment": "\n     * Validates that the value is false\n     * @param val object to test\n     * @param msg message to output if validation fails\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.noNullElements(java.lang.Object[])",
        "snippet": "    public static void noNullElements(Object[] objects) {\n        noNullElements(objects, \"Array must not contain any null objects\");\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * Validates that the array contains no null elements\n     * @param objects the array to test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.noNullElements(java.lang.Object[], java.lang.String)",
        "snippet": "    public static void noNullElements(Object[] objects, String msg) {\n        for (Object obj : objects)\n            if (obj == null)\n                throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 80,
        "end_line": 84,
        "comment": "\n     * Validates that the array contains no null elements\n     * @param objects the array to test\n     * @param msg message to output if validation fails\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.notEmpty(java.lang.String)",
        "snippet": "    public static void notEmpty(String string) {\n        if (string == null || string.length() == 0)\n            throw new IllegalArgumentException(\"String must not be empty\");\n    }",
        "begin_line": 90,
        "end_line": 93,
        "comment": "\n     * Validates that the string is not empty\n     * @param string the string to test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.notEmpty(java.lang.String, java.lang.String)",
        "snippet": "    public static void notEmpty(String string, String msg) {\n        if (string == null || string.length() == 0)\n            throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 100,
        "end_line": 103,
        "comment": "\n     * Validates that the string is not empty\n     * @param string the string to test\n     * @param msg message to output if validation fails\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/Validate.java",
        "class_name": "org.jsoup.helper.Validate",
        "signature": "org.jsoup.helper.Validate.fail(java.lang.String)",
        "snippet": "    public static void fail(String msg) {\n        throw new IllegalArgumentException(msg);\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     Cause a failure.\n     @param msg message to output.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "org.jsoup.helper.W3CDom.fromJsoup(org.jsoup.nodes.Document)",
        "snippet": "    public Document fromJsoup(org.jsoup.nodes.Document in) {\n        Validate.notNull(in);\n        DocumentBuilder builder;\n        try {\n        \t//set the factory to be namespace-aware\n        \tfactory.setNamespaceAware(true);\n            builder = factory.newDocumentBuilder();\n            Document out = builder.newDocument();\n            convert(in, out);\n            return out;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "begin_line": 37,
        "end_line": 50,
        "comment": "\n     * Convert a jsoup Document to a W3C Document.\n     * @param in jsoup doc\n     * @return w3c doc\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "convert(org.jsoup.nodes.Document, Document)",
        "snippet": "    public void convert(org.jsoup.nodes.Document in, Document out) {\n        if (!StringUtil.isBlank(in.location()))\n            out.setDocumentURI(in.location());\n\n        org.jsoup.nodes.Element rootEl = in.child(0); // skip the #root node\n        NodeTraversor.traverse(new W3CBuilder(out), rootEl);\n    }",
        "begin_line": 59,
        "end_line": 65,
        "comment": "\n     * Converts a jsoup document into the provided W3C Document. If required, you can set options on the output document\n     * before converting.\n     * @param in jsoup doc\n     * @param out w3c doc\n     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Document)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "W3CBuilder(Document)",
        "snippet": "        public W3CBuilder(Document doc) {\n            this.doc = doc;\n            this.namespacesStack.push(new HashMap<String, String>());\n        }",
        "begin_line": 78,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "org.jsoup.helper.W3CDom.W3CBuilder.head(org.jsoup.nodes.Node, int)",
        "snippet": "        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespacesStack.peek().get(prefix);\n                String tagName = sourceEl.tagName();\n\n                Element el = namespace == null && tagName.contains(\":\") ?\n                    doc.createElementNS(\"\", tagName) : // doesn't have a real namespace defined\n                    doc.createElementNS(namespace, tagName);\n                copyAttributes(sourceEl, el);\n                if (dest == null) { // sets up the root\n                    doc.appendChild(el);\n                } else {\n                    dest.appendChild(el);\n                }\n                dest = el; // descend\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                dest.appendChild(text);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }",
        "begin_line": 83,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "org.jsoup.helper.W3CDom.W3CBuilder.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n            }\n            namespacesStack.pop();\n        }",
        "begin_line": 119,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "copyAttributes(org.jsoup.nodes.Node, Element)",
        "snippet": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                if (key.matches(\"[a-zA-Z_:][-a-zA-Z0-9_:.]*\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }",
        "begin_line": 126,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "org.jsoup.helper.W3CDom.W3CBuilder.updateNamespaces(org.jsoup.nodes.Element)",
        "snippet": "        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n                namespacesStack.peek().put(prefix, attr.getValue());\n            }\n\n            // get the element prefix if any\n            int pos = el.tagName().indexOf(\":\");\n            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n        }",
        "begin_line": 138,
        "end_line": 158,
        "comment": "\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/W3CDom.java",
        "class_name": "org.jsoup.helper.W3CDom",
        "signature": "asString(Document)",
        "snippet": "    public String asString(Document doc) {\n        try {\n            DOMSource domSource = new DOMSource(doc);\n            StringWriter writer = new StringWriter();\n            StreamResult result = new StreamResult(writer);\n            TransformerFactory tf = TransformerFactory.newInstance();\n            Transformer transformer = tf.newTransformer();\n            transformer.transform(domSource, result);\n            return writer.toString();\n        } catch (TransformerException e) {\n            throw new IllegalStateException(e);\n        }\n    }",
        "begin_line": 167,
        "end_line": 179,
        "comment": "\n     * Serialize a W3C document to a String.\n     * @param doc Document\n     * @return Document as string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.DataUtil()",
        "snippet": "    private DataUtil() {}",
        "begin_line": 43,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.load(java.io.File, java.lang.String, java.lang.String)",
        "snippet": "    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Loads a file to a Document.\n     * @param in file to load\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.load(java.io.InputStream, java.lang.String, java.lang.String)",
        "snippet": "    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * Parses a Document from an input steam.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.load(java.io.InputStream, java.lang.String, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(in, charsetName, baseUri, parser);\n    }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     * Parses a Document from an input steam, using the provided Parser.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n     * @return Document\n     * @throws IOException on IO error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.crossStreams(java.io.InputStream, java.io.OutputStream)",
        "snippet": "    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }",
        "begin_line": 88,
        "end_line": 94,
        "comment": "\n     * Writes the input stream to the output stream. Doesn't close them.\n     * @param in input stream to read from\n     * @param out output stream to write to\n     * @throws IOException on IO error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.parseInputStream(java.io.InputStream, java.lang.String, java.lang.String, org.jsoup.parser.Parser)",
        "snippet": "    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }",
        "begin_line": 96,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.readToByteBuffer(java.io.InputStream, int)",
        "snippet": "    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n        return input.readToByteBuffer(maxSize);\n    }",
        "begin_line": 189,
        "end_line": 193,
        "comment": "\n     * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this\n     * method is executing on. The data read until being interrupted will be available.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.emptyByteBuffer()",
        "snippet": "    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.getCharsetFromContentType(java.lang.String)",
        "snippet": "    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }",
        "begin_line": 205,
        "end_line": 214,
        "comment": "\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.validateCharset(java.lang.String)",
        "snippet": "    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            // if our this charset matching fails.... we just take the default\n        }\n        return null;\n    }",
        "begin_line": 216,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.mimeBoundary()",
        "snippet": "    static String mimeBoundary() {\n        final StringBuilder mime = StringUtil.borrowBuilder();\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return StringUtil.releaseBuilder(mime);\n    }",
        "begin_line": 232,
        "end_line": 239,
        "comment": "\n     * Creates a random string, suitable for use as a mime boundary\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.detectCharsetFromBom(java.nio.ByteBuffer)",
        "snippet": "    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n        final Buffer buffer = byteData; // .mark and rewind used to return Buffer, now ByteBuffer, so cast for backward compat\n        buffer.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            buffer.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n            return new BomCharset(\"UTF-32\", false); // and I hope it's on your system\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return new BomCharset(\"UTF-16\", false); // in all Javas\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            return new BomCharset(\"UTF-8\", true); // in all Javas\n            // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n        }\n        return null;\n    }",
        "begin_line": 241,
        "end_line": 260,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/helper/DataUtil.java",
        "class_name": "org.jsoup.helper.DataUtil",
        "signature": "org.jsoup.helper.DataUtil.BomCharset.BomCharset(java.lang.String, boolean)",
        "snippet": "        public BomCharset(String charset, boolean offset) {\n            this.charset = charset;\n            this.offset = offset;\n        }",
        "begin_line": 266,
        "end_line": 269,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.Comment(java.lang.String)",
        "snippet": "    public Comment(String data) {\n        value = data;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "\n     Create a new comment node.\n     @param data The contents of the comment\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.Comment(java.lang.String, java.lang.String)",
        "snippet": "    public Comment(String data, String baseUri) {\n        this(data);\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "\n     Create a new comment node.\n     @param data The contents of the comment\n     @param baseUri base URI not used. This is a leaf node.\n     @deprecated\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.nodeName()",
        "snippet": "    public String nodeName() {\n        return \"#comment\";\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.getData()",
        "snippet": "    public String getData() {\n        return coreValue();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     Get the contents of the comment.\n     @return comment content\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }",
        "begin_line": 45,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}",
        "begin_line": 54,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.isXmlDeclaration()",
        "snippet": "    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }",
        "begin_line": 65,
        "end_line": 68,
        "comment": "\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Comment.java",
        "class_name": "org.jsoup.nodes.Comment",
        "signature": "org.jsoup.nodes.Comment.asXmlDeclaration()",
        "snippet": "    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }",
        "begin_line": 74,
        "end_line": 84,
        "comment": "\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.hasAttributes()",
        "snippet": "    protected final boolean hasAttributes() {\n        return value instanceof Attributes;\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.attributes()",
        "snippet": "    @Override\n    public final Attributes attributes() {\n        ensureAttributes();\n        return (Attributes) value;\n    }",
        "begin_line": 17,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.ensureAttributes()",
        "snippet": "    private void ensureAttributes() {\n        if (!hasAttributes()) {\n            Object coreValue = value;\n            Attributes attributes = new Attributes();\n            value = attributes;\n            if (coreValue != null)\n                attributes.put(nodeName(), (String) coreValue);\n        }\n    }",
        "begin_line": 23,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.coreValue()",
        "snippet": "    String coreValue() {\n        return attr(nodeName());\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.coreValue(java.lang.String)",
        "snippet": "    void coreValue(String value) {\n        attr(nodeName(), value);\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.attr(java.lang.String)",
        "snippet": "    @Override\n    public String attr(String key) {\n        Validate.notNull(key);\n        if (!hasAttributes()) {\n            return key.equals(nodeName()) ? (String) value : EmptyString;\n        }\n        return super.attr(key);\n    }",
        "begin_line": 41,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.attr(java.lang.String, java.lang.String)",
        "snippet": "    @Override\n    public Node attr(String key, String value) {\n        if (!hasAttributes() && key.equals(nodeName())) {\n            this.value = value;\n        } else {\n            ensureAttributes();\n            super.attr(key, value);\n        }\n        return this;\n    }",
        "begin_line": 50,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.hasAttr(java.lang.String)",
        "snippet": "    @Override\n    public boolean hasAttr(String key) {\n        ensureAttributes();\n        return super.hasAttr(key);\n    }",
        "begin_line": 61,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.removeAttr(java.lang.String)",
        "snippet": "    @Override\n    public Node removeAttr(String key) {\n        ensureAttributes();\n        return super.removeAttr(key);\n    }",
        "begin_line": 67,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.absUrl(java.lang.String)",
        "snippet": "    @Override\n    public String absUrl(String key) {\n        ensureAttributes();\n        return super.absUrl(key);\n    }",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.baseUri()",
        "snippet": "    @Override\n    public String baseUri() {\n        return hasParent() ? parent().baseUri() : \"\";\n    }",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.doSetBaseUri(java.lang.String)",
        "snippet": "    @Override\n    protected void doSetBaseUri(String baseUri) {\n        // noop\n    }",
        "begin_line": 84,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.childNodeSize()",
        "snippet": "    @Override\n    public int childNodeSize() {\n        return 0;\n    }",
        "begin_line": 89,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/LeafNode.java",
        "class_name": "org.jsoup.nodes.LeafNode",
        "signature": "org.jsoup.nodes.LeafNode.ensureChildNodes()",
        "snippet": "    @Override\n    protected List<Node> ensureChildNodes() {\n        return EmptyNodes;\n    }",
        "begin_line": 94,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.DataNode(java.lang.String)",
        "snippet": "    public DataNode(String data) {\n        value = data;\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "\n     Create a new DataNode.\n     @param data data contents\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.DataNode(java.lang.String, java.lang.String)",
        "snippet": "    public DataNode(String data, String baseUri) {\n        this(data);\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "\n     Create a new DataNode.\n     @param data data contents\n     @param baseUri Unused, Leaf Nodes do not hold base URis\n     @deprecated use {@link #DataNode(String)} instead\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.nodeName()",
        "snippet": "    public String nodeName() {\n        return \"#data\";\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.getWholeData()",
        "snippet": "    public String getWholeData() {\n        return coreValue();\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "\n     Get the data contents of this node. Will be unescaped and with original new lines, space etc.\n     @return data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.setWholeData(java.lang.String)",
        "snippet": "    public DataNode setWholeData(String data) {\n        coreValue(data);\n        return this;\n    }",
        "begin_line": 46,
        "end_line": 49,
        "comment": "\n     * Set the data contents of this node.\n     * @param data unencoded data\n     * @return this node, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append(getWholeData()); // data is not escaped in return from data nodes, so \" in script, style is plain\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}",
        "begin_line": 55,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "begin_line": 57,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DataNode.java",
        "class_name": "org.jsoup.nodes.DataNode",
        "signature": "org.jsoup.nodes.DataNode.createFromEncoded(java.lang.String, java.lang.String)",
        "snippet": "    public static DataNode createFromEncoded(String encodedData, String baseUri) {\n        String data = Entities.unescape(encodedData);\n        return new DataNode(data);\n    }",
        "begin_line": 68,
        "end_line": 71,
        "comment": "\n     Create a new DataNode from HTML encoded data.\n     @param encodedData encoded data\n     @param baseUri bass URI\n     @return new DataNode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.checkCapacity(int)",
        "snippet": "    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }",
        "begin_line": 48,
        "end_line": 60,
        "comment": " check there's room for more",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.copyOf(java.lang.String[], int)",
        "snippet": "    private static String[] copyOf(String[] orig, int size) {\n        final String[] copy = new String[size];\n        System.arraycopy(orig, 0, copy, 0,\n                Math.min(orig.length, size));\n        return copy;\n    }",
        "begin_line": 63,
        "end_line": 68,
        "comment": " simple implementation of Arrays.copy, for support of Android API 8.",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.indexOfKey(java.lang.String)",
        "snippet": "    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }",
        "begin_line": 70,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.indexOfKeyIgnoreCase(java.lang.String)",
        "snippet": "    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }",
        "begin_line": 79,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.checkNotNull(java.lang.String)",
        "snippet": "    static String checkNotNull(String val) {\n        return val == null ? EmptyString : val;\n    }",
        "begin_line": 89,
        "end_line": 91,
        "comment": " we track boolean attributes as null in values - they're just keys. so returns empty for consumers",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.get(java.lang.String)",
        "snippet": "    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }",
        "begin_line": 99,
        "end_line": 102,
        "comment": "\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.getIgnoreCase(java.lang.String)",
        "snippet": "    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }",
        "begin_line": 109,
        "end_line": 112,
        "comment": "\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.add(java.lang.String, java.lang.String)",
        "snippet": "    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }",
        "begin_line": 115,
        "end_line": 120,
        "comment": " adds without checking if this key exists",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.put(java.lang.String, java.lang.String)",
        "snippet": "    public Attributes put(String key, String value) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }",
        "begin_line": 128,
        "end_line": 135,
        "comment": "\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.putIgnoreCase(java.lang.String, java.lang.String)",
        "snippet": "    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }",
        "begin_line": 137,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.put(java.lang.String, boolean)",
        "snippet": "    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }",
        "begin_line": 154,
        "end_line": 160,
        "comment": "\n     * Set a new boolean attribute, remove attribute if value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.put(org.jsoup.nodes.Attribute)",
        "snippet": "    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }",
        "begin_line": 167,
        "end_line": 172,
        "comment": "\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case sensitive key\n     @return these attributes, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.remove(int)",
        "snippet": "    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }",
        "begin_line": 175,
        "end_line": 185,
        "comment": " removes and shifts up",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.remove(java.lang.String)",
        "snippet": "    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }",
        "begin_line": 191,
        "end_line": 195,
        "comment": "\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.removeIgnoreCase(java.lang.String)",
        "snippet": "    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }",
        "begin_line": 201,
        "end_line": 205,
        "comment": "\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.hasKey(java.lang.String)",
        "snippet": "    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }",
        "begin_line": 212,
        "end_line": 214,
        "comment": "\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.hasKeyIgnoreCase(java.lang.String)",
        "snippet": "    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }",
        "begin_line": 221,
        "end_line": 223,
        "comment": "\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.size()",
        "snippet": "    public int size() {\n        return size;\n    }",
        "begin_line": 229,
        "end_line": 231,
        "comment": "\n     Get the number of attributes in this set.\n     @return size\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.addAll(org.jsoup.nodes.Attributes)",
        "snippet": "    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        for (Attribute attr : incoming) {\n            // todo - should this be case insensitive?\n            put(attr);\n        }\n\n    }",
        "begin_line": 237,
        "end_line": 247,
        "comment": "\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.iterator()",
        "snippet": "    public Iterator<Attribute> iterator() {\n        return new Iterator<Attribute>() {\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }\n        };\n    }",
        "begin_line": 249,
        "end_line": 270,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Anonymous-0efd3dd3-e4fb-4955-8b56-a0bbd9415d63.hasNext()",
        "snippet": "            @Override\n            public boolean hasNext() {\n                return i < size;\n            }",
        "begin_line": 253,
        "end_line": 256,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Anonymous-620e1452-7d27-46bf-8085-a165717371bf.next()",
        "snippet": "            @Override\n            public Attribute next() {\n                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n                i++;\n                return attr;\n            }",
        "begin_line": 258,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Anonymous-9fb72d51-b419-46ae-ba55-406bad08a46e.remove()",
        "snippet": "            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n            }",
        "begin_line": 265,
        "end_line": 268,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.asList()",
        "snippet": "    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }",
        "begin_line": 276,
        "end_line": 285,
        "comment": "\n     Get the attributes as a List, for iteration.\n     @return an view of the attributes as an unmodifialbe List.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.dataset()",
        "snippet": "    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }",
        "begin_line": 292,
        "end_line": 294,
        "comment": "\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.html()",
        "snippet": "    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 301,
        "end_line": 309,
        "comment": "\n     Get the HTML representation of these attributes.\n     @return HTML\n     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.html(java.lang.Appendable, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }",
        "begin_line": 311,
        "end_line": 326,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return html();\n    }",
        "begin_line": 328,
        "end_line": 331,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }",
        "begin_line": 338,
        "end_line": 348,
        "comment": "\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }",
        "begin_line": 354,
        "end_line": 360,
        "comment": "\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.clone()",
        "snippet": "    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }",
        "begin_line": 362,
        "end_line": 374,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.normalize()",
        "snippet": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }",
        "begin_line": 379,
        "end_line": 383,
        "comment": "\n     * Internal method. Lowercases all keys.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.Dataset(org.jsoup.nodes.Attributes)",
        "snippet": "        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }",
        "begin_line": 388,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.entrySet()",
        "snippet": "        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }",
        "begin_line": 392,
        "end_line": 395,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.put(java.lang.String, java.lang.String)",
        "snippet": "        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }",
        "begin_line": 397,
        "end_line": 403,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.EntrySet.iterator()",
        "snippet": "            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }",
        "begin_line": 407,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.EntrySet.size()",
        "snippet": "            @Override\n            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }",
        "begin_line": 412,
        "end_line": 419,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.DatasetIterator.hasNext()",
        "snippet": "            public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }",
        "begin_line": 425,
        "end_line": 431,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.DatasetIterator.next()",
        "snippet": "            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }",
        "begin_line": 433,
        "end_line": 435,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.Dataset.DatasetIterator.remove()",
        "snippet": "            public void remove() {\n                attributes.remove(attr.getKey());\n            }",
        "begin_line": 437,
        "end_line": 439,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attributes.java",
        "class_name": "org.jsoup.nodes.Attributes",
        "signature": "org.jsoup.nodes.Attributes.dataKey(java.lang.String)",
        "snippet": "    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }",
        "begin_line": 443,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.DocumentType(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public DocumentType(String name, String publicId, String systemId) {\n        Validate.notNull(name);\n        Validate.notNull(publicId);\n        Validate.notNull(systemId);\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        if (has(PUBLIC_ID)) {\n            attr(PUB_SYS_KEY, PUBLIC_KEY);\n        }\n        attr(SYSTEM_ID, systemId);\n    }",
        "begin_line": 28,
        "end_line": 38,
        "comment": "\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.DocumentType(java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        attr(NAME, name);\n        attr(PUBLIC_ID, publicId);\n        if (has(PUBLIC_ID)) {\n            attr(PUB_SYS_KEY, PUBLIC_KEY);\n        }\n        attr(SYSTEM_ID, systemId);\n    }",
        "begin_line": 48,
        "end_line": 55,
        "comment": "\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri unused\n     * @deprecated\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.DocumentType(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n        attr(NAME, name);\n        if (pubSysKey != null) {\n            attr(PUB_SYS_KEY, pubSysKey);\n        }\n        attr(PUBLIC_ID, publicId);\n        attr(SYSTEM_ID, systemId);\n    }",
        "begin_line": 65,
        "end_line": 72,
        "comment": "\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri unused\n     * @deprecated\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.setPubSysKey(java.lang.String)",
        "snippet": "    public void setPubSysKey(String value) {\n        if (value != null)\n            attr(PUB_SYS_KEY, value);\n    }",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.nodeName()",
        "snippet": "    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }",
        "begin_line": 78,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n            // looks like a html5 doctype, go lowercase for aesthetics\n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(NAME))\n            accum.append(\" \").append(attr(NAME));\n        if (has(PUB_SYS_KEY))\n            accum.append(\" \").append(attr(PUB_SYS_KEY));\n        if (has(PUBLIC_ID))\n            accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');\n        if (has(SYSTEM_ID))\n            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n        accum.append('>');\n    }",
        "begin_line": 83,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/DocumentType.java",
        "class_name": "org.jsoup.nodes.DocumentType",
        "signature": "org.jsoup.nodes.DocumentType.has(java.lang.String)",
        "snippet": "    private boolean has(final String attribute) {\n        return !StringUtil.isBlank(attr(attribute));\n    }",
        "begin_line": 106,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "org.jsoup.nodes.NodeUtils",
        "signature": "org.jsoup.nodes.NodeUtils.outputSettings(org.jsoup.nodes.Node)",
        "snippet": "    static Document.OutputSettings outputSettings(Node node) {\n        Document owner = node.ownerDocument();\n        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "\n     * Get the output setting for this node,  or if this node has no document (or parent), retrieve the default output\n     * settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/NodeUtils.java",
        "class_name": "org.jsoup.nodes.NodeUtils",
        "signature": "org.jsoup.nodes.NodeUtils.parser(org.jsoup.nodes.Node)",
        "snippet": "    static Parser parser(Node node) {\n        Document doc = node.ownerDocument();\n        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "\n     * Get the parser that was used to make this node, or the default HTML parser if it has no parent.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.EscapeMode.EscapeMode(java.lang.String, int)",
        "snippet": "        EscapeMode(String file, int size) {\n            load(this, file, size);\n        }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.EscapeMode.codepointForName(java.lang.String)",
        "snippet": "        int codepointForName(final String name) {\n            int index = Arrays.binarySearch(nameKeys, name);\n            return index >= 0 ? codeVals[index] : empty;\n        }",
        "begin_line": 55,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.EscapeMode.nameForCodepoint(int)",
        "snippet": "        String nameForCodepoint(final int codepoint) {\n            final int index = Arrays.binarySearch(codeKeys, codepoint);\n            if (index >= 0) {\n                // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n                // (and binary search for same item with multi results is undefined\n                return (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\n                    nameVals[index + 1] : nameVals[index];\n            }\n            return emptyName;\n        }",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.EscapeMode.size()",
        "snippet": "        private int size() {\n            return nameKeys.length;\n        }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.Entities()",
        "snippet": "    private Entities() {\n    }",
        "begin_line": 76,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.isNamedEntity(java.lang.String)",
        "snippet": "    public static boolean isNamedEntity(final String name) {\n        return extended.codepointForName(name) != empty;\n    }",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Check if the input is a known named entity\n     *\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.isBaseNamedEntity(java.lang.String)",
        "snippet": "    public static boolean isBaseNamedEntity(final String name) {\n        return base.codepointForName(name) != empty;\n    }",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n     * Check if the input is a known named entity in the base entity set.\n     *\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.getCharacterByName(java.lang.String)",
        "snippet": "    public static Character getCharacterByName(String name) {\n        return (char) extended.codepointForName(name);\n    }",
        "begin_line": 107,
        "end_line": 109,
        "comment": "\n     * Get the Character value of the named entity\n     *\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n     * @deprecated does not support characters outside the BMP or multiple character names\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.getByName(java.lang.String)",
        "snippet": "    public static String getByName(String name) {\n        String val = multipoints.get(name);\n        if (val != null)\n            return val;\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty)\n            return new String(new int[]{codepoint}, 0, 1);\n        return emptyName;\n    }",
        "begin_line": 117,
        "end_line": 125,
        "comment": "\n     * Get the character(s) represented by the named entity\n     *\n     * @param name entity (e.g. \"lt\" or \"amp\")\n     * @return the string value of the character(s) represented by this entity, or \"\" if not defined\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.codepointsForName(java.lang.String, int[])",
        "snippet": "    public static int codepointsForName(final String name, final int[] codepoints) {\n        String val = multipoints.get(name);\n        if (val != null) {\n            codepoints[0] = val.codePointAt(0);\n            codepoints[1] = val.codePointAt(1);\n            return 2;\n        }\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty) {\n            codepoints[0] = codepoint;\n            return 1;\n        }\n        return 0;\n    }",
        "begin_line": 127,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.escape(java.lang.String, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    public static String escape(String string, Document.OutputSettings out) {\n        if (string == null)\n            return \"\";\n        StringBuilder accum = StringUtil.borrowBuilder();\n        try {\n            escape(accum, string, out, false, false, false);\n        } catch (IOException e) {\n            throw new SerializationException(e); // doesn't happen\n        }\n        return StringUtil.releaseBuilder(accum);\n    }",
        "begin_line": 149,
        "end_line": 159,
        "comment": "\n     * HTML escape an input string. That is, {@code <} is returned as {@code &lt;}\n     *\n     * @param string the un-escaped string to escape\n     * @param out the output settings to use\n     * @return the escaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.escape(java.lang.String)",
        "snippet": "    public static String escape(String string) {\n        return escape(string, DefaultOutput);\n    }",
        "begin_line": 168,
        "end_line": 170,
        "comment": "\n     * HTML escape an input string, using the default settings (UTF-8, base entities). That is, {@code <} is returned as\n     * {@code &lt;}\n     *\n     * @param string the un-escaped string to escape\n     * @return the escaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.escape(java.lang.Appendable, java.lang.String, org.jsoup.nodes.Document.OutputSettings, boolean, boolean, boolean)",
        "snippet": "    static void escape(Appendable accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else\n                            appendEncoded(accum, escapeMode, codePoint);\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }",
        "begin_line": 173,
        "end_line": 246,
        "comment": " this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.appendEncoded(java.lang.Appendable, org.jsoup.nodes.Entities.EscapeMode, int)",
        "snippet": "    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {\n        final String name = escapeMode.nameForCodepoint(codePoint);\n        if (name != emptyName) // ok for identity check\n            accum.append('&').append(name).append(';');\n        else\n            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n    }",
        "begin_line": 248,
        "end_line": 254,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.unescape(java.lang.String)",
        "snippet": "    public static String unescape(String string) {\n        return unescape(string, false);\n    }",
        "begin_line": 262,
        "end_line": 264,
        "comment": "\n     * Un-escape an HTML escaped string. That is, {@code &lt;} is returned as {@code <}.\n     *\n     * @param string the HTML string to un-escape\n     * @return the unescaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.unescape(java.lang.String, boolean)",
        "snippet": "    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }",
        "begin_line": 273,
        "end_line": 275,
        "comment": "\n     * Unescape the input string.\n     *\n     * @param string to un-HTML-escape\n     * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n     * @return unescaped string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.canEncode(org.jsoup.nodes.Entities.CoreCharset, char, java.nio.charset.CharsetEncoder)",
        "snippet": "    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        // todo add more charset tests if impacted by Android's bad perf in canEncode\n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\n            default:\n                return fallback.canEncode(c);\n        }\n    }",
        "begin_line": 290,
        "end_line": 300,
        "comment": "\n     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n     * issues on Android if required.\n     *\n     * Benchmarks:     *\n     * OLD toHtml() impl v New (fastpath) in millis\n     * Wiki: 1895, 16\n     * CNN: 6378, 55\n     * Alterslash: 3013, 28\n     * Jsoup: 167, 2\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.CoreCharset.byName(java.lang.String)",
        "snippet": "        static CoreCharset byName(final String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n                return utf;\n            return fallback;\n        }",
        "begin_line": 305,
        "end_line": 311,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Entities.java",
        "class_name": "org.jsoup.nodes.Entities",
        "signature": "org.jsoup.nodes.Entities.load(org.jsoup.nodes.Entities.EscapeMode, java.lang.String, int)",
        "snippet": "    private static void load(EscapeMode e, String pointsData, int size) {\n        e.nameKeys = new String[size];\n        e.codeVals = new int[size];\n        e.codeKeys = new int[size];\n        e.nameVals = new String[size];\n\n        int i = 0;\n        CharacterReader reader = new CharacterReader(pointsData);\n\n        while (!reader.isEmpty()) {\n            // NotNestedLessLess=10913,824;1887&\n\n            final String name = reader.consumeTo('=');\n            reader.advance();\n            final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n            final char codeDelim = reader.current();\n            reader.advance();\n            final int cp2;\n            if (codeDelim == ',') {\n                cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n                reader.advance();\n            } else {\n                cp2 = empty;\n            }\n            final String indexS = reader.consumeTo('&');\n            final int index = Integer.parseInt(indexS, codepointRadix);\n            reader.advance();\n\n            e.nameKeys[i] = name;\n            e.codeVals[i] = cp1;\n            e.codeKeys[index] = cp1;\n            e.nameVals[index] = name;\n\n            if (cp2 != empty) {\n                multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n            }\n            i++;\n        }\n\n        Validate.isTrue(i == size, \"Unexpected count of entities loaded\");\n    }",
        "begin_line": 314,
        "end_line": 354,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.FormElement(org.jsoup.parser.Tag, java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "    public FormElement(Tag tag, String baseUri, Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "\n     * Create a new, standalone form element.\n     *\n     * @param tag        tag of this element\n     * @param baseUri    the base URI\n     * @param attributes initial attributes\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.elements()",
        "snippet": "    public Elements elements() {\n        return elements;\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * Get the list of form control elements associated with this form.\n     * @return form controls associated with this element.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.addElement(org.jsoup.nodes.Element)",
        "snippet": "    public FormElement addElement(Element element) {\n        elements.add(element);\n        return this;\n    }",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n     * Add a form control element to this form.\n     * @param element form control to add\n     * @return this form element, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.removeChild(org.jsoup.nodes.Node)",
        "snippet": "    @Override\n    protected void removeChild(Node out) {\n        super.removeChild(out);\n        elements.remove(out);\n    }",
        "begin_line": 49,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.submit()",
        "snippet": "    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        return Jsoup.connect(action)\n                .data(formData())\n                .method(method);\n    }",
        "begin_line": 62,
        "end_line": 71,
        "comment": "\n     * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n     * can then set up other options (like user-agent, timeout, cookies), then execute it.\n     * @return a connection prepared from the values of this form.\n     * @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n     * document's base URI when parsing.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/FormElement.java",
        "class_name": "org.jsoup.nodes.FormElement",
        "signature": "org.jsoup.nodes.FormElement.formData()",
        "snippet": "    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }",
        "begin_line": 78,
        "end_line": 112,
        "comment": "\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/BooleanAttribute.java",
        "class_name": "org.jsoup.nodes.BooleanAttribute",
        "signature": "org.jsoup.nodes.BooleanAttribute.BooleanAttribute(java.lang.String)",
        "snippet": "    public BooleanAttribute(String key) {\n        super(key, null);\n    }",
        "begin_line": 12,
        "end_line": 14,
        "comment": "\n     * Create a new boolean attribute from unencoded (raw) key.\n     * @param key attribute key\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/BooleanAttribute.java",
        "class_name": "org.jsoup.nodes.BooleanAttribute",
        "signature": "org.jsoup.nodes.BooleanAttribute.isBooleanAttribute()",
        "snippet": "    @Override\n    protected boolean isBooleanAttribute() {\n        return true;\n    }",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "org.jsoup.nodes.PseudoTextElement",
        "signature": "org.jsoup.nodes.PseudoTextElement.PseudoTextElement(org.jsoup.parser.Tag, java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "org.jsoup.nodes.PseudoTextElement",
        "signature": "org.jsoup.nodes.PseudoTextElement.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/PseudoTextElement.java",
        "class_name": "org.jsoup.nodes.PseudoTextElement",
        "signature": "org.jsoup.nodes.PseudoTextElement.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.Attribute(java.lang.String, java.lang.String)",
        "snippet": "    public Attribute(String key, String value) {\n        this(key, value, null);\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param value attribute value\n     * @see #createFromEncoded\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.Attribute(java.lang.String, java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }",
        "begin_line": 42,
        "end_line": 49,
        "comment": "\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.getKey()",
        "snippet": "    public String getKey() {\n        return key;\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     Get the attribute key.\n     @return the attribute key\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.setKey(java.lang.String)",
        "snippet": "    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }",
        "begin_line": 63,
        "end_line": 73,
        "comment": "\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.getValue()",
        "snippet": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     Get the attribute value.\n     @return the attribute value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.setValue(java.lang.String)",
        "snippet": "    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }",
        "begin_line": 87,
        "end_line": 96,
        "comment": "\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.html()",
        "snippet": "    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 102,
        "end_line": 111,
        "comment": "\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.html(java.lang.String, java.lang.String, java.lang.Appendable, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {\n        accum.append(key);\n        if (!shouldCollapseAttribute(key, val, out)) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);\n            accum.append('\"');\n        }\n    }",
        "begin_line": 113,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.html(java.lang.Appendable, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n        html(key, val, accum, out);\n    }",
        "begin_line": 122,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return html();\n    }",
        "begin_line": 130,
        "end_line": 133,
        "comment": "\n     Get the string representation of this attribute, implemented as {@link #html()}.\n     @return string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.createFromEncoded(java.lang.String, java.lang.String)",
        "snippet": "    public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n        String value = Entities.unescape(encodedValue, true);\n        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n    }",
        "begin_line": 141,
        "end_line": 144,
        "comment": "\n     * Create a new Attribute from an unencoded key and a HTML attribute encoded value.\n     * @param unencodedKey assumes the key is not encoded, as can be only run of simple \\w chars.\n     * @param encodedValue HTML attribute encoded value\n     * @return attribute\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.isDataAttribute()",
        "snippet": "    protected boolean isDataAttribute() {\n        return isDataAttribute(key);\n    }",
        "begin_line": 146,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.isDataAttribute(java.lang.String)",
        "snippet": "    protected static boolean isDataAttribute(String key) {\n        return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n    }",
        "begin_line": 150,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.shouldCollapseAttribute(org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n        return shouldCollapseAttribute(key, val, out);\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n     * Collapsible if it's a boolean attribute and value is empty or same as name\n     * \n     * @param out output settings\n     * @return  Returns whether collapsible or not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.shouldCollapseAttribute(java.lang.String, java.lang.String, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    protected static boolean shouldCollapseAttribute(final String key, final String val, final Document.OutputSettings out) {\n        return (\n            out.syntax() == Document.OutputSettings.Syntax.html &&\n                (val == null || (\"\".equals(val) || val.equalsIgnoreCase(key)) && Attribute.isBooleanAttribute(key)));\n    }",
        "begin_line": 164,
        "end_line": 168,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.isBooleanAttribute()",
        "snippet": "    protected boolean isBooleanAttribute() {\n        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n    }",
        "begin_line": 173,
        "end_line": 175,
        "comment": "\n     * @deprecated\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.isBooleanAttribute(java.lang.String)",
        "snippet": "    protected static boolean isBooleanAttribute(final String key) {\n        return Arrays.binarySearch(booleanAttributes, key) >= 0;\n    }",
        "begin_line": 180,
        "end_line": 182,
        "comment": "\n     * Checks if this attribute name is defined as a boolean attribute in HTML5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n        return val != null ? val.equals(attribute.val) : attribute.val == null;\n    }",
        "begin_line": 184,
        "end_line": 191,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.hashCode()",
        "snippet": "    @Override\n    public int hashCode() { // note parent not considered\n        int result = key != null ? key.hashCode() : 0;\n        result = 31 * result + (val != null ? val.hashCode() : 0);\n        return result;\n    }",
        "begin_line": 193,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Attribute.java",
        "class_name": "org.jsoup.nodes.Attribute",
        "signature": "org.jsoup.nodes.Attribute.clone()",
        "snippet": "    @Override\n    public Attribute clone() {\n        try {\n            return (Attribute) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "begin_line": 200,
        "end_line": 207,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.XmlDeclaration(java.lang.String, boolean)",
        "snippet": "    public XmlDeclaration(String name, boolean isProcessingInstruction) {\n        Validate.notNull(name);\n        value = name;\n        this.isProcessingInstruction = isProcessingInstruction;\n    }",
        "begin_line": 21,
        "end_line": 25,
        "comment": "\n     * Create a new XML declaration\n     * @param name of declaration\n     * @param isProcessingInstruction is processing instruction\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.XmlDeclaration(java.lang.String, java.lang.String, boolean)",
        "snippet": "    public XmlDeclaration(String name, String baseUri, boolean isProcessingInstruction) {\n        this(name, isProcessingInstruction);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * Create a new XML declaration\n     * @param name of declaration\n     * @param baseUri Leaf Nodes don't have base URIs; they inherit from their Element\n     * @param isProcessingInstruction is processing instruction\n     * @see XmlDeclaration#XmlDeclaration(String, boolean)\n     * @deprecated\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.nodeName()",
        "snippet": "    public String nodeName() {\n        return \"#declaration\";\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.name()",
        "snippet": "    public String name() {\n        return coreValue();\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * Get the name of this declaration.\n     * @return name of this declaration.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.getWholeDeclaration()",
        "snippet": "    public String getWholeDeclaration() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            getWholeDeclaration(sb, new Document.OutputSettings());\n        } catch (IOException e) {\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb).trim();\n    }",
        "begin_line": 55,
        "end_line": 63,
        "comment": "\n     * Get the unencoded XML declaration.\n     * @return XML declaration\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.getWholeDeclaration(java.lang.Appendable, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {\n        for (Attribute attribute : attributes()) {\n            if (!attribute.getKey().equals(nodeName())) { // skips coreValue (name)\n                accum.append(' ');\n                attribute.html(accum, out);\n            }\n        }\n    }",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<\")\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(coreValue());\n        getWholeDeclaration(accum, out);\n        accum\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(\">\");\n    }",
        "begin_line": 74,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }",
        "begin_line": 85,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java",
        "class_name": "org.jsoup.nodes.XmlDeclaration",
        "signature": "org.jsoup.nodes.XmlDeclaration.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Element(java.lang.String)",
        "snippet": "    public Element(String tag) {\n        this(Tag.valueOf(tag), \"\", new Attributes());\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Create a new, standalone element.\n     * @param tag tag name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Element(org.jsoup.parser.Tag, java.lang.String, org.jsoup.nodes.Attributes)",
        "snippet": "    public Element(Tag tag, String baseUri, Attributes attributes) {\n        Validate.notNull(tag);\n        Validate.notNull(baseUri);\n        childNodes = EMPTY_NODES;\n        this.baseUri = baseUri;\n        this.attributes = attributes;\n        this.tag = tag;\n    }",
        "begin_line": 65,
        "end_line": 72,
        "comment": "\n     * Create a new, standalone Element. (Standalone in that is has no parent.)\n     * \n     * @param tag tag of this element\n     * @param baseUri the base URI\n     * @param attributes initial attributes\n     * @see #appendChild(Node)\n     * @see #appendElement(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Element(org.jsoup.parser.Tag, java.lang.String)",
        "snippet": "    public Element(Tag tag, String baseUri) {\n        this(tag, baseUri, null);\n    }",
        "begin_line": 82,
        "end_line": 84,
        "comment": "\n     * Create a new Element from a tag and a base URI.\n     * \n     * @param tag element tag\n     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n     *            string, but not null.\n     * @see Tag#valueOf(String, ParseSettings)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.ensureChildNodes()",
        "snippet": "    protected List<Node> ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.hasAttributes()",
        "snippet": "    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.attributes()",
        "snippet": "    @Override\n    public Attributes attributes() {\n        if (!hasAttributes())\n            attributes = new Attributes();\n        return attributes;\n    }",
        "begin_line": 98,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.baseUri()",
        "snippet": "    @Override\n    public String baseUri() {\n        return baseUri;\n    }",
        "begin_line": 105,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.doSetBaseUri(java.lang.String)",
        "snippet": "    @Override\n    protected void doSetBaseUri(String baseUri) {\n        this.baseUri = baseUri;\n    }",
        "begin_line": 110,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.childNodeSize()",
        "snippet": "    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }",
        "begin_line": 115,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.nodeName()",
        "snippet": "    @Override\n    public String nodeName() {\n        return tag.getName();\n    }",
        "begin_line": 120,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.tagName()",
        "snippet": "    public String tagName() {\n        return tag.getName();\n    }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     * Get the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase\n     * case preserving parsing}, this will return the source's original case.\n     * \n     * @return the tag name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.normalName()",
        "snippet": "    public String normalName() {\n        return tag.normalName();\n    }",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Get the normalized name of this Element's tag. This will always be the lowercased version of the tag, regardless\n     * of the tag case preserving setting of the parser.\n     * @return\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.tagName(java.lang.String)",
        "snippet": "    public Element tagName(String tagName) {\n        Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }",
        "begin_line": 151,
        "end_line": 155,
        "comment": "\n     * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.tag()",
        "snippet": "    public Tag tag() {\n        return tag;\n    }",
        "begin_line": 162,
        "end_line": 164,
        "comment": "\n     * Get the Tag for this element.\n     * \n     * @return the tag object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.isBlock()",
        "snippet": "    public boolean isBlock() {\n        return tag.isBlock();\n    }",
        "begin_line": 172,
        "end_line": 174,
        "comment": "\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <p> == false}).\n     * \n     * @return true if block, false if not (and thus inline)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.id()",
        "snippet": "    public String id() {\n        return attributes().getIgnoreCase(\"id\");\n    }",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Get the {@code id} attribute of this element.\n     * \n     * @return The id attribute, if present, or an empty string if not.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.attr(java.lang.String, java.lang.String)",
        "snippet": "    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }",
        "begin_line": 191,
        "end_line": 194,
        "comment": "\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     * \n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.attr(java.lang.String, boolean)",
        "snippet": "    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }",
        "begin_line": 206,
        "end_line": 209,
        "comment": "\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     * \n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     * \n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.dataset()",
        "snippet": "    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }",
        "begin_line": 224,
        "end_line": 226,
        "comment": "\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.parent()",
        "snippet": "    @Override\n    public final Element parent() {\n        return (Element) parentNode;\n    }",
        "begin_line": 228,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.parents()",
        "snippet": "    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }",
        "begin_line": 237,
        "end_line": 241,
        "comment": "\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, closest first.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.accumulateParents(org.jsoup.nodes.Element, org.jsoup.select.Elements)",
        "snippet": "    private static void accumulateParents(Element el, Elements parents) {\n        Element parent = el.parent();\n        if (parent != null && !parent.tagName().equals(\"#root\")) {\n            parents.add(parent);\n            accumulateParents(parent, parents);\n        }\n    }",
        "begin_line": 243,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.child(int)",
        "snippet": "    public Element child(int index) {\n        return childElementsList().get(index);\n    }",
        "begin_line": 262,
        "end_line": 264,
        "comment": "\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     * \n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.children()",
        "snippet": "    public Elements children() {\n        return new Elements(childElementsList());\n    }",
        "begin_line": 274,
        "end_line": 276,
        "comment": "\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.childElementsList()",
        "snippet": "    private List<Element> childElementsList() {\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }",
        "begin_line": 283,
        "end_line": 297,
        "comment": "\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.nodelistChanged()",
        "snippet": "    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }",
        "begin_line": 302,
        "end_line": 306,
        "comment": "\n     * Clears the cached shadow child elements.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.textNodes()",
        "snippet": "    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
        "begin_line": 324,
        "end_line": 331,
        "comment": "\n     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n     * @return child text nodes. If this element has no text nodes, returns an\n     * empty list.\n     * </p>\n     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n     * <ul>\n     *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n     *     <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n     *     <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n     *     <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n     * </ul>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.dataNodes()",
        "snippet": "    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }",
        "begin_line": 342,
        "end_line": 349,
        "comment": "\n     * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n     * </p>\n     * @return child data nodes. If this element has no data nodes, returns an\n     * empty list.\n     * @see #data()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.select(java.lang.String)",
        "snippet": "    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }",
        "begin_line": 371,
        "end_line": 373,
        "comment": "\n     * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n     * may include this element, or any of its children.\n     * <p>\n     * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n     * multiple filters can be combined, e.g.:\n     * </p>\n     * <ul>\n     * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n     * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n     * </ul>\n     * <p>\n     * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n     * </p>\n     * \n     * @param cssQuery a {@link Selector} CSS-like query\n     * @return elements that match the query (empty if none match)\n     * @see org.jsoup.select.Selector\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.selectFirst(java.lang.String)",
        "snippet": "    public Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }",
        "begin_line": 382,
        "end_line": 384,
        "comment": "\n     * Find the first Element that matches the {@link Selector} CSS query, with this element as the starting context.\n     * <p>This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query\n     * execution stops on the first hit.</p>\n     * @param cssQuery cssQuery a {@link Selector} CSS-like query\n     * @return the first matching element, or <b>{@code null}</b> if there is no match.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.is(java.lang.String)",
        "snippet": "    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }",
        "begin_line": 391,
        "end_line": 393,
        "comment": "\n     * Check if this element matches the given {@link Selector} CSS query.\n     * @param cssQuery a {@link Selector} CSS query\n     * @return if this element matches the query\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.is(org.jsoup.select.Evaluator)",
        "snippet": "    public boolean is(Evaluator evaluator) {\n        return evaluator.matches((Element)this.root(), this);\n    }",
        "begin_line": 400,
        "end_line": 402,
        "comment": "\n     * Check if this element matches the given evaluator.\n     * @param evaluator an element evaluator\n     * @return if this element matches\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendChild(org.jsoup.nodes.Node)",
        "snippet": "    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        // was - Node#addChildren(child). short-circuits an array create and a loop.\n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }",
        "begin_line": 410,
        "end_line": 419,
        "comment": "\n     * Add a node child node to this element.\n     * \n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendTo(org.jsoup.nodes.Element)",
        "snippet": "    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }",
        "begin_line": 427,
        "end_line": 431,
        "comment": "\n     * Add this element to the supplied parent element, as its next child.\n     *\n     * @param parent element to which this element will be appended\n     * @return this element, so that you can continue modifying the element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.prependChild(org.jsoup.nodes.Node)",
        "snippet": "    public Element prependChild(Node child) {\n        Validate.notNull(child);\n        \n        addChildren(0, child);\n        return this;\n    }",
        "begin_line": 439,
        "end_line": 444,
        "comment": "\n     * Add a node to the start of this element's children.\n     * \n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.insertChildren(int, java.util.Collection<? extends org.jsoup.nodes.Node>)",
        "snippet": "    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[0]);\n        addChildren(index, nodeArray);\n        return this;\n    }",
        "begin_line": 456,
        "end_line": 466,
        "comment": "\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.insertChildren(int, org.jsoup.nodes.Node...)",
        "snippet": "    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }",
        "begin_line": 477,
        "end_line": 485,
        "comment": "\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendElement(java.lang.String)",
        "snippet": "    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }",
        "begin_line": 494,
        "end_line": 498,
        "comment": "\n     * Create a new element by tag name, and add it as the last child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.prependElement(java.lang.String)",
        "snippet": "    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }",
        "begin_line": 507,
        "end_line": 511,
        "comment": "\n     * Create a new element by tag name, and add it as the first child.\n     * \n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendText(java.lang.String)",
        "snippet": "    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }",
        "begin_line": 519,
        "end_line": 524,
        "comment": "\n     * Create and append a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.prependText(java.lang.String)",
        "snippet": "    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }",
        "begin_line": 532,
        "end_line": 537,
        "comment": "\n     * Create and prepend a new TextNode to this element.\n     * \n     * @param text the unencoded text to add\n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.append(java.lang.String)",
        "snippet": "    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[0]));\n        return this;\n    }",
        "begin_line": 545,
        "end_line": 550,
        "comment": "\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.prepend(java.lang.String)",
        "snippet": "    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[0]));\n        return this;\n    }",
        "begin_line": 558,
        "end_line": 563,
        "comment": "\n     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.before(java.lang.String)",
        "snippet": "    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }",
        "begin_line": 572,
        "end_line": 575,
        "comment": "\n     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n     *\n     * @param html HTML to add before this element\n     * @return this element, for chaining\n     * @see #after(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.before(org.jsoup.nodes.Node)",
        "snippet": "    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }",
        "begin_line": 583,
        "end_line": 586,
        "comment": "\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this element\n     * @return this Element, for chaining\n     * @see #after(Node)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.after(java.lang.String)",
        "snippet": "    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }",
        "begin_line": 595,
        "end_line": 598,
        "comment": "\n     * Insert the specified HTML into the DOM after this element (as a following sibling).\n     *\n     * @param html HTML to add after this element\n     * @return this element, for chaining\n     * @see #before(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.after(org.jsoup.nodes.Node)",
        "snippet": "    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }",
        "begin_line": 606,
        "end_line": 609,
        "comment": "\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this element\n     * @return this element, for chaining\n     * @see #before(Node)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.empty()",
        "snippet": "    public Element empty() {\n        childNodes.clear();\n        return this;\n    }",
        "begin_line": 615,
        "end_line": 618,
        "comment": "\n     * Remove all of the element's child nodes. Any attributes are left as-is.\n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.wrap(java.lang.String)",
        "snippet": "    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }",
        "begin_line": 626,
        "end_line": 629,
        "comment": "\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.cssSelector()",
        "snippet": "    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = tagName().replace(':', '|');\n        StringBuilder selector = new StringBuilder(tagName);\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }",
        "begin_line": 641,
        "end_line": 661,
        "comment": "\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.siblingElements()",
        "snippet": "    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }",
        "begin_line": 668,
        "end_line": 678,
        "comment": "\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.nextElementSibling()",
        "snippet": "    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }",
        "begin_line": 689,
        "end_line": 698,
        "comment": "\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * </p>\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.nextElementSiblings()",
        "snippet": "    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }",
        "begin_line": 705,
        "end_line": 707,
        "comment": "\n     * Get each of the sibling elements that come after this element.\n     *\n     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.previousElementSibling()",
        "snippet": "    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().childElementsList();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }",
        "begin_line": 714,
        "end_line": 723,
        "comment": "\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.previousElementSiblings()",
        "snippet": "    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }",
        "begin_line": 730,
        "end_line": 732,
        "comment": "\n     * Get each of the element siblings before this element.\n     *\n     * @return the previous element siblings, or an empty list if there are none.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.nextElementSiblings(boolean)",
        "snippet": "    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }",
        "begin_line": 734,
        "end_line": 740,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.firstElementSibling()",
        "snippet": "    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }",
        "begin_line": 746,
        "end_line": 750,
        "comment": "\n     * Gets the first element sibling of this element.\n     * @return the first sibling that is an element (aka the parent's first element child) \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.elementSiblingIndex()",
        "snippet": "    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }",
        "begin_line": 757,
        "end_line": 760,
        "comment": "\n     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n     * sibling, returns 0.\n     * @return position in element sibling list\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.lastElementSibling()",
        "snippet": "    public Element lastElementSibling() {\n        List<Element> siblings = parent().childElementsList();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }",
        "begin_line": 766,
        "end_line": 769,
        "comment": "\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.indexInList(org.jsoup.nodes.Element, java.util.List<E>)",
        "snippet": "    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }",
        "begin_line": 771,
        "end_line": 778,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByTag(java.lang.String)",
        "snippet": "    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }",
        "begin_line": 787,
        "end_line": 792,
        "comment": "\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementById(java.lang.String)",
        "snippet": "    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }",
        "begin_line": 803,
        "end_line": 811,
        "comment": "\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n     * use {@link Document#getElementById(String)}\n     * @param id The ID to search for.\n     * @return The first matching element by ID, starting with this element, or null if none found.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByClass(java.lang.String)",
        "snippet": "    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }",
        "begin_line": 824,
        "end_line": 828,
        "comment": "\n     * Find elements that have this class, including or under this element. Case insensitive.\n     * <p>\n     * Elements can have multiple classes (e.g. {@code <div class=\"header round first\">}. This method\n     * checks each class, so you can find the above with {@code el.getElementsByClass(\"header\");}.\n     * \n     * @param className the name of the class to search for.\n     * @return elements with the supplied class name, empty if none\n     * @see #hasClass(String)\n     * @see #classNames()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttribute(java.lang.String)",
        "snippet": "    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }",
        "begin_line": 836,
        "end_line": 841,
        "comment": "\n     * Find elements that have a named attribute set. Case insensitive.\n     *\n     * @param key name of the attribute, e.g. {@code href}\n     * @return elements that have this attribute, empty if none\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeStarting(java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }",
        "begin_line": 849,
        "end_line": 854,
        "comment": "\n     * Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements\n     * that have HTML5 datasets.\n     * @param keyPrefix name prefix of the attribute e.g. {@code data-}\n     * @return elements that have attribute names that start with with the prefix, empty if none.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValue(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }",
        "begin_line": 863,
        "end_line": 865,
        "comment": "\n     * Find elements that have an attribute with the specific value. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that have this attribute with this value, empty if none\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueNot(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }",
        "begin_line": 874,
        "end_line": 876,
        "comment": "\n     * Find elements that either do not have this attribute, or have it with a different value. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that do not have a matching attribute\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueStarting(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }",
        "begin_line": 885,
        "end_line": 887,
        "comment": "\n     * Find elements that have attributes that start with the value prefix. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param valuePrefix start of attribute value\n     * @return elements that have attributes that start with the value prefix\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueEnding(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }",
        "begin_line": 896,
        "end_line": 898,
        "comment": "\n     * Find elements that have attributes that end with the value suffix. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param valueSuffix end of the attribute value\n     * @return elements that have attributes that end with the value suffix\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueContaining(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }",
        "begin_line": 907,
        "end_line": 909,
        "comment": "\n     * Find elements that have attributes whose value contains the match string. Case insensitive.\n     * \n     * @param key name of the attribute\n     * @param match substring of value to search for\n     * @return elements that have attributes containing this text\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueMatching(java.lang.String, java.util.regex.Pattern)",
        "snippet": "    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n        \n    }",
        "begin_line": 917,
        "end_line": 920,
        "comment": "\n     * Find elements that have attributes whose values match the supplied regular expression.\n     * @param key name of the attribute\n     * @param pattern compiled regular expression to match against attribute values\n     * @return elements that have attributes matching this regular expression\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByAttributeValueMatching(java.lang.String, java.lang.String)",
        "snippet": "    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }",
        "begin_line": 928,
        "end_line": 936,
        "comment": "\n     * Find elements that have attributes whose values match the supplied regular expression.\n     * @param key name of the attribute\n     * @param regex regular expression to match against attribute values. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements that have attributes matching this regular expression\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByIndexLessThan(int)",
        "snippet": "    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }",
        "begin_line": 943,
        "end_line": 945,
        "comment": "\n     * Find elements whose sibling index is less than the supplied index.\n     * @param index 0-based index\n     * @return elements less than index\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByIndexGreaterThan(int)",
        "snippet": "    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }",
        "begin_line": 952,
        "end_line": 954,
        "comment": "\n     * Find elements whose sibling index is greater than the supplied index.\n     * @param index 0-based index\n     * @return elements greater than index\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsByIndexEquals(int)",
        "snippet": "    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }",
        "begin_line": 961,
        "end_line": 963,
        "comment": "\n     * Find elements whose sibling index is equal to the supplied index.\n     * @param index 0-based index\n     * @return elements equal to index\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsContainingText(java.lang.String)",
        "snippet": "    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }",
        "begin_line": 972,
        "end_line": 974,
        "comment": "\n     * Find elements that contain the specified string. The search is case insensitive. The text may appear directly\n     * in the element, or in any of its descendants.\n     * @param searchText to look for in the element's text\n     * @return elements that contain the string, case insensitive.\n     * @see Element#text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsContainingOwnText(java.lang.String)",
        "snippet": "    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }",
        "begin_line": 983,
        "end_line": 985,
        "comment": "\n     * Find elements that directly contain the specified string. The search is case insensitive. The text must appear directly\n     * in the element, not in any of its descendants.\n     * @param searchText to look for in the element's own text\n     * @return elements that contain the string, case insensitive.\n     * @see Element#ownText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsMatchingText(java.util.regex.Pattern)",
        "snippet": "    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }",
        "begin_line": 993,
        "end_line": 995,
        "comment": "\n     * Find elements whose text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsMatchingText(java.lang.String)",
        "snippet": "    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }",
        "begin_line": 1003,
        "end_line": 1011,
        "comment": "\n     * Find elements whose text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsMatchingOwnText(java.util.regex.Pattern)",
        "snippet": "    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }",
        "begin_line": 1019,
        "end_line": 1021,
        "comment": "\n     * Find elements whose own text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getElementsMatchingOwnText(java.lang.String)",
        "snippet": "    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }",
        "begin_line": 1029,
        "end_line": 1037,
        "comment": "\n     * Find elements whose text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as (?i) and (?m) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.getAllElements()",
        "snippet": "    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }",
        "begin_line": 1044,
        "end_line": 1046,
        "comment": "\n     * Find all elements under this element (including self, and children of children).\n     * \n     * @return all elements\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.text()",
        "snippet": "    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n                // make sure there is a space between block tags and immediately following text nodes <div>One</div>Two should be \"One Two\".\n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum).trim();\n    }",
        "begin_line": 1058,
        "end_line": 1086,
        "comment": "\n     * Gets the combined text of this element and all its children. Whitespace is normalized and trimmed.\n     * <p>\n     * For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code \"Hello there now!\"}\n     *\n     * @return unencoded, normalized text, or empty string if none.\n     * @see #wholeText() if you don't want the text to be normalized.\n     * @see #ownText()\n     * @see #textNodes()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Anonymous-58c8c254-d9eb-4756-9324-ab2c3ff2e2a1.head(org.jsoup.nodes.Node, int)",
        "snippet": "            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }",
        "begin_line": 1061,
        "end_line": 1072,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Anonymous-75e588ad-625d-49b5-87fa-e00f7e92203b.tail(org.jsoup.nodes.Node, int)",
        "snippet": "            public void tail(Node node, int depth) {\n                // make sure there is a space between block tags and immediately following text nodes <div>One</div>Two should be \"One Two\".\n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }",
        "begin_line": 1074,
        "end_line": 1082,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.wholeText()",
        "snippet": "    public String wholeText() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    accum.append(textNode.getWholeText());\n                }\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum);\n    }",
        "begin_line": 1095,
        "end_line": 1110,
        "comment": "\n     * Get the (unencoded) text of all children of this element, including any newlines and spaces present in the\n     * original.\n     *\n     * @return unencoded, un-normalized text\n     * @see #text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Anonymous-4bb1f2ac-14bc-4460-b198-191d23fb9187.head(org.jsoup.nodes.Node, int)",
        "snippet": "            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    accum.append(textNode.getWholeText());\n                }\n            }",
        "begin_line": 1098,
        "end_line": 1103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.Anonymous-c46fc2fd-db37-47f6-9b9d-3b8e8e9530d3.tail(org.jsoup.nodes.Node, int)",
        "snippet": "            public void tail(Node node, int depth) {\n            }",
        "begin_line": 1105,
        "end_line": 1106,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.ownText()",
        "snippet": "    public String ownText() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        ownText(sb);\n        return StringUtil.releaseBuilder(sb).trim();\n    }",
        "begin_line": 1123,
        "end_line": 1127,
        "comment": "\n     * Gets the text owned by this element only; does not get the combined text of all children.\n     * <p>\n     * For example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.ownText()} returns {@code \"Hello now!\"},\n     * whereas {@code p.text()} returns {@code \"Hello there now!\"}.\n     * Note that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.\n     *\n     * @return unencoded text, or empty string if none.\n     * @see #text()\n     * @see #textNodes()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.ownText(java.lang.StringBuilder)",
        "snippet": "    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }",
        "begin_line": 1129,
        "end_line": 1138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendNormalisedText(java.lang.StringBuilder, org.jsoup.nodes.TextNode)",
        "snippet": "    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }",
        "begin_line": 1140,
        "end_line": 1147,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.appendWhitespaceIfBr(org.jsoup.nodes.Element, java.lang.StringBuilder)",
        "snippet": "    private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\n        if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\n            accum.append(\" \");\n    }",
        "begin_line": 1149,
        "end_line": 1152,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.preserveWhitespace(org.jsoup.nodes.Node)",
        "snippet": "    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }",
        "begin_line": 1154,
        "end_line": 1167,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.text(java.lang.String)",
        "snippet": "    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text);\n        appendChild(textNode);\n\n        return this;\n    }",
        "begin_line": 1174,
        "end_line": 1182,
        "comment": "\n     * Set the text of this element. Any existing contents (text or elements) will be cleared\n     * @param text unencoded text\n     * @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.hasText()",
        "snippet": "    public boolean hasText() {\n        for (Node child: childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                if (!textNode.isBlank())\n                    return true;\n            } else if (child instanceof Element) {\n                Element el = (Element) child;\n                if (el.hasText())\n                    return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 1188,
        "end_line": 1201,
        "comment": "\n     Test if this element has any text content (that is not just whitespace).\n     @return true if element has non-blank text content.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.data()",
        "snippet": "    public String data() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            } else if (childNode instanceof CDataNode) {\n                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.\n                // but incase another type gets through.\n                CDataNode cDataNode = (CDataNode) childNode;\n                sb.append(cDataNode.getWholeText());\n            }\n        }\n        return StringUtil.releaseBuilder(sb);\n    }   ",
        "begin_line": 1212,
        "end_line": 1234,
        "comment": "\n     * Get the combined data of this element. Data is e.g. the inside of a {@code script} tag. Note that data is NOT the\n     * text of the element. Use {@link #text()} to get the text that would be visible to a user, and {@link #data()}\n     * for the contents of scripts, comments, CSS styles, etc.\n     *\n     * @return the data, or empty string if none\n     *\n     * @see #dataNodes()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.className()",
        "snippet": "    public String className() {\n        return attr(\"class\").trim();\n    }",
        "begin_line": 1241,
        "end_line": 1243,
        "comment": "\n     * Gets the literal value of this element's \"class\" attribute, which may include multiple class names, space\n     * separated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n     * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.classNames()",
        "snippet": "    public Set<String> classNames() {\n    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }",
        "begin_line": 1251,
        "end_line": 1257,
        "comment": "\n     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\">},\n     * returns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\n     * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n     * @return set of classnames, empty if no class attribute\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.classNames(java.util.Set<java.lang.String>)",
        "snippet": "    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        if (classNames.isEmpty()) {\n            attributes().remove(\"class\");\n        } else {\n            attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        }\n        return this;\n    }",
        "begin_line": 1264,
        "end_line": 1272,
        "comment": "\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.hasClass(java.lang.String)",
        "snippet": "    public boolean hasClass(String className) {\n        final String classAttr = attributes().getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }",
        "begin_line": 1280,
        "end_line": 1321,
        "comment": " performance sensitive",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.addClass(java.lang.String)",
        "snippet": "    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }",
        "begin_line": 1328,
        "end_line": 1336,
        "comment": "\n     Add a class name to this element's {@code class} attribute.\n     @param className class name to add\n     @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.removeClass(java.lang.String)",
        "snippet": "    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }",
        "begin_line": 1343,
        "end_line": 1351,
        "comment": "\n     Remove a class name from this element's {@code class} attribute.\n     @param className class name to remove\n     @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.toggleClass(java.lang.String)",
        "snippet": "    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }",
        "begin_line": 1358,
        "end_line": 1369,
        "comment": "\n     Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it.\n     @param className class name to toggle\n     @return this element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.val()",
        "snippet": "    public String val() {\n        if (tagName().equals(\"textarea\"))\n            return text();\n        else\n            return attr(\"value\");\n    }",
        "begin_line": 1375,
        "end_line": 1380,
        "comment": "\n     * Get the value of a form element (input, textarea, etc).\n     * @return the value of the form element, or empty string if not set.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.val(java.lang.String)",
        "snippet": "    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }",
        "begin_line": 1387,
        "end_line": 1393,
        "comment": "\n     * Set the value of a form element (input, textarea, etc).\n     * @param value value to set\n     * @return this element (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); // <img> in html, <img /> in xml\n        }\n        else\n            accum.append('>');\n    }",
        "begin_line": 1395,
        "end_line": 1416,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }",
        "begin_line": 1418,
        "end_line": 1426,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.html()",
        "snippet": "    public String html() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        html(accum);\n        String html = StringUtil.releaseBuilder(accum);\n        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n    }",
        "begin_line": 1435,
        "end_line": 1440,
        "comment": "\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.html(T)",
        "snippet": "    @Override\n    public <T extends Appendable> T html(T appendable) {\n        final int size = childNodes.size();\n        for (int i = 0; i < size; i++)\n            childNodes.get(i).outerHtml(appendable);\n\n        return appendable;\n    }",
        "begin_line": 1442,
        "end_line": 1449,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.html(java.lang.String)",
        "snippet": "    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }",
        "begin_line": 1457,
        "end_line": 1461,
        "comment": "\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.clone()",
        "snippet": "    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }",
        "begin_line": 1463,
        "end_line": 1466,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.shallowClone()",
        "snippet": "    @Override\n    public Element shallowClone() {\n        // simpler than implementing a clone version with no child copy\n        return new Element(tag, baseUri, attributes);\n    }",
        "begin_line": 1468,
        "end_line": 1472,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.doClone(org.jsoup.nodes.Node)",
        "snippet": "    @Override\n    protected Element doClone(Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); // the children then get iterated and cloned in Node.clone\n\n        return clone;\n    }",
        "begin_line": 1474,
        "end_line": 1483,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.NodeList.NodeList(org.jsoup.nodes.Element, int)",
        "snippet": "        NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }",
        "begin_line": 1488,
        "end_line": 1491,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Element.java",
        "class_name": "org.jsoup.nodes.Element",
        "signature": "org.jsoup.nodes.Element.NodeList.onContentsChanged()",
        "snippet": "        public void onContentsChanged() {\n            owner.nodelistChanged();\n        }",
        "begin_line": 1493,
        "end_line": 1495,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "org.jsoup.nodes.CDataNode",
        "signature": "org.jsoup.nodes.CDataNode.CDataNode(java.lang.String)",
        "snippet": "    public CDataNode(String text) {\n        super(text);\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "org.jsoup.nodes.CDataNode",
        "signature": "org.jsoup.nodes.CDataNode.nodeName()",
        "snippet": "    @Override\n    public String nodeName() {\n        return \"#cdata\";\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "org.jsoup.nodes.CDataNode",
        "signature": "org.jsoup.nodes.CDataNode.text()",
        "snippet": "    @Override\n    public String text() {\n        return getWholeText();\n    }",
        "begin_line": 24,
        "end_line": 27,
        "comment": "\n     * Get the unencoded, <b>non-normalized</b> text content of this CDataNode.\n     * @return unencoded, non-normalized text\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "org.jsoup.nodes.CDataNode",
        "signature": "org.jsoup.nodes.CDataNode.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<![CDATA[\")\n            .append(getWholeText());\n    }",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/CDataNode.java",
        "class_name": "org.jsoup.nodes.CDataNode",
        "signature": "org.jsoup.nodes.CDataNode.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n        try {\n            accum.append(\"]]>\");\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }",
        "begin_line": 36,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.Document(java.lang.String)",
        "snippet": "    public Document(String baseUri) {\n        super(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);\n        this.location = baseUri;\n    }",
        "begin_line": 32,
        "end_line": 35,
        "comment": "\n     Create a new, empty Document.\n     @param baseUri base URI of document\n     @see org.jsoup.Jsoup#parse\n     @see #createShell\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.createShell(java.lang.String)",
        "snippet": "    public static Document createShell(String baseUri) {\n        Validate.notNull(baseUri);\n\n        Document doc = new Document(baseUri);\n        doc.parser = doc.parser();\n        Element html = doc.appendElement(\"html\");\n        html.appendElement(\"head\");\n        html.appendElement(\"body\");\n\n        return doc;\n    }",
        "begin_line": 42,
        "end_line": 52,
        "comment": "\n     Create a valid, empty shell of a document, suitable for adding more elements to.\n     @param baseUri baseUri of document\n     @return document with html, head, and body elements.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.location()",
        "snippet": "    public String location() {\n     return location;\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Get the URL this Document was parsed from. If the starting URL is a redirect,\n     * this will return the final URL from which the document was served from.\n     * @return location\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.head()",
        "snippet": "    public Element head() {\n        return findFirstElementByTagName(\"head\", this);\n    }",
        "begin_line": 67,
        "end_line": 69,
        "comment": "\n     Accessor to the document's {@code head} element.\n     @return {@code head}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.body()",
        "snippet": "    public Element body() {\n        return findFirstElementByTagName(\"body\", this);\n    }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n     Accessor to the document's {@code body} element.\n     @return {@code body}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.title()",
        "snippet": "    public String title() {\n        // title is a preserve whitespace tag (for document output), but normalised here\n        Element titleEl = getElementsByTag(\"title\").first();\n        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : \"\";\n    }",
        "begin_line": 83,
        "end_line": 87,
        "comment": "\n     Get the string contents of the document's {@code title} element.\n     @return Trimmed title, or empty string if none set.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.title(java.lang.String)",
        "snippet": "    public void title(String title) {\n        Validate.notNull(title);\n        Element titleEl = getElementsByTag(\"title\").first();\n        if (titleEl == null) { // add to head\n            head().appendElement(\"title\").text(title);\n        } else {\n            titleEl.text(title);\n        }\n    }",
        "begin_line": 94,
        "end_line": 102,
        "comment": "\n     Set the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if\n     not present\n     @param title string to set as title\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.createElement(java.lang.String)",
        "snippet": "    public Element createElement(String tagName) {\n        return new Element(Tag.valueOf(tagName, ParseSettings.preserveCase), this.baseUri());\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     Create a new Element, with this document's base uri. Does not make the new element a child of this document.\n     @param tagName element tag name (e.g. {@code a})\n     @return new element\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.normalise()",
        "snippet": "    public Document normalise() {\n        Element htmlEl = findFirstElementByTagName(\"html\", this);\n        if (htmlEl == null)\n            htmlEl = appendElement(\"html\");\n        if (head() == null)\n            htmlEl.prependElement(\"head\");\n        if (body() == null)\n            htmlEl.appendElement(\"body\");\n\n        // pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care\n        // of. do in inverse order to maintain text order.\n        normaliseTextNodes(head());\n        normaliseTextNodes(htmlEl);\n        normaliseTextNodes(this);\n\n        normaliseStructure(\"head\", htmlEl);\n        normaliseStructure(\"body\", htmlEl);\n        \n        ensureMetaCharsetElement();\n        \n        return this;\n    }",
        "begin_line": 118,
        "end_line": 139,
        "comment": "\n     Normalise the document. This happens after the parse phase so generally does not need to be called.\n     Moves any text content that is not in the body element into the body.\n     @return this document after normalisation\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.normaliseTextNodes(org.jsoup.nodes.Element)",
        "snippet": "    private void normaliseTextNodes(Element element) {\n        List<Node> toMove = new ArrayList<>();\n        for (Node node: element.childNodes) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank())\n                    toMove.add(tn);\n            }\n        }\n\n        for (int i = toMove.size()-1; i >= 0; i--) {\n            Node node = toMove.get(i);\n            element.removeChild(node);\n            body().prependChild(new TextNode(\" \"));\n            body().prependChild(node);\n        }\n    }",
        "begin_line": 142,
        "end_line": 158,
        "comment": " does not recurse.",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.normaliseStructure(java.lang.String, org.jsoup.nodes.Element)",
        "snippet": "    private void normaliseStructure(String tag, Element htmlEl) {\n        Elements elements = this.getElementsByTag(tag);\n        Element master = elements.first(); // will always be available as created above if not existent\n        if (elements.size() > 1) { // dupes, move contents to master\n            List<Node> toMove = new ArrayList<>();\n            for (int i = 1; i < elements.size(); i++) {\n                Node dupe = elements.get(i);\n                toMove.addAll(dupe.ensureChildNodes());\n                dupe.remove();\n            }\n\n            for (Node dupe : toMove)\n                master.appendChild(dupe);\n        }\n        // ensure parented by <html>\n        if (!master.parent().equals(htmlEl)) {\n            htmlEl.appendChild(master); // includes remove()            \n        }\n    }",
        "begin_line": 161,
        "end_line": 179,
        "comment": " merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html>",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.findFirstElementByTagName(java.lang.String, org.jsoup.nodes.Node)",
        "snippet": "    private Element findFirstElementByTagName(String tag, Node node) {\n        if (node.nodeName().equals(tag))\n            return (Element) node;\n        else {\n            int size = node.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                Element found = findFirstElementByTagName(tag, node.childNode(i));\n                if (found != null)\n                    return found;\n            }\n        }\n        return null;\n    }",
        "begin_line": 182,
        "end_line": 194,
        "comment": " fast method to get first by tag name, used for html, head, body finders",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.outerHtml()",
        "snippet": "    @Override\n    public String outerHtml() {\n        return super.html(); // no outer wrapper tag\n    }",
        "begin_line": 196,
        "end_line": 199,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.text(java.lang.String)",
        "snippet": "    @Override\n    public Element text(String text) {\n        body().text(text); // overridden to not nuke doc structure\n        return this;\n    }",
        "begin_line": 206,
        "end_line": 210,
        "comment": "\n     Set the text of the {@code body} of this document. Any existing nodes within the body will be cleared.\n     @param text unencoded text\n     @return this document\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.nodeName()",
        "snippet": "    @Override\n    public String nodeName() {\n        return \"#document\";\n    }",
        "begin_line": 212,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.charset(java.nio.charset.Charset)",
        "snippet": "    public void charset(Charset charset) {\n        updateMetaCharsetElement(true);\n        outputSettings.charset(charset);\n        ensureMetaCharsetElement();\n    }",
        "begin_line": 241,
        "end_line": 245,
        "comment": "\n     * Sets the charset used in this document. This method is equivalent\n     * to {@link OutputSettings#charset(java.nio.charset.Charset)\n     * OutputSettings.charset(Charset)} but in addition it updates the\n     * charset / encoding element within the document.\n     * \n     * <p>This enables\n     * {@link #updateMetaCharsetElement(boolean) meta charset update}.</p>\n     * \n     * <p>If there's no element with charset / encoding information yet it will\n     * be created. Obsolete charset / encoding definitions are removed!</p>\n     * \n     * <p><b>Elements used:</b></p>\n     * \n     * <ul>\n     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n     * </ul>\n     * \n     * @param charset Charset\n     * \n     * @see #updateMetaCharsetElement(boolean) \n     * @see OutputSettings#charset(java.nio.charset.Charset) \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.charset()",
        "snippet": "    public Charset charset() {\n        return outputSettings.charset();\n    }",
        "begin_line": 255,
        "end_line": 257,
        "comment": "\n     * Returns the charset used in this document. This method is equivalent\n     * to {@link OutputSettings#charset()}.\n     * \n     * @return Current Charset\n     * \n     * @see OutputSettings#charset() \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.updateMetaCharsetElement(boolean)",
        "snippet": "    public void updateMetaCharsetElement(boolean update) {\n        this.updateMetaCharset = update;\n    }",
        "begin_line": 272,
        "end_line": 274,
        "comment": "\n     * Sets whether the element with charset information in this document is\n     * updated on changes through {@link #charset(java.nio.charset.Charset)\n     * Document.charset(Charset)} or not.\n     * \n     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements\n     * modified.</p>\n     * \n     * @param update If <tt>true</tt> the element updated on charset\n     * changes, <tt>false</tt> if not\n     * \n     * @see #charset(java.nio.charset.Charset) \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.updateMetaCharsetElement()",
        "snippet": "    public boolean updateMetaCharsetElement() {\n        return updateMetaCharset;\n    }",
        "begin_line": 284,
        "end_line": 286,
        "comment": "\n     * Returns whether the element with charset information in this document is\n     * updated on changes through {@link #charset(java.nio.charset.Charset)\n     * Document.charset(Charset)} or not.\n     * \n     * @return Returns <tt>true</tt> if the element is updated on charset\n     * changes, <tt>false</tt> if not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.clone()",
        "snippet": "    @Override\n    public Document clone() {\n        Document clone = (Document) super.clone();\n        clone.outputSettings = this.outputSettings.clone();\n        return clone;\n    }",
        "begin_line": 288,
        "end_line": 293,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.ensureMetaCharsetElement()",
        "snippet": "    private void ensureMetaCharsetElement() {\n        if (updateMetaCharset) {\n            OutputSettings.Syntax syntax = outputSettings().syntax();\n\n            if (syntax == OutputSettings.Syntax.html) {\n                Element metaCharset = select(\"meta[charset]\").first();\n\n                if (metaCharset != null) {\n                    metaCharset.attr(\"charset\", charset().displayName());\n                } else {\n                    Element head = head();\n\n                    if (head != null) {\n                        head.appendElement(\"meta\").attr(\"charset\", charset().displayName());\n                    }\n                }\n\n                // Remove obsolete elements\n                select(\"meta[name=charset]\").remove();\n            } else if (syntax == OutputSettings.Syntax.xml) {\n                Node node = childNodes().get(0);\n\n                if (node instanceof XmlDeclaration) {\n                    XmlDeclaration decl = (XmlDeclaration) node;\n\n                    if (decl.name().equals(\"xml\")) {\n                        decl.attr(\"encoding\", charset().displayName());\n\n                        final String version = decl.attr(\"version\");\n\n                        if (version != null) {\n                            decl.attr(\"version\", \"1.0\");\n                        }\n                    } else {\n                        decl = new XmlDeclaration(\"xml\", false);\n                        decl.attr(\"version\", \"1.0\");\n                        decl.attr(\"encoding\", charset().displayName());\n\n                        prependChild(decl);\n                    }\n                } else {\n                    XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n                    decl.attr(\"version\", \"1.0\");\n                    decl.attr(\"encoding\", charset().displayName());\n\n                    prependChild(decl);\n                }\n            }\n        }\n    }",
        "begin_line": 314,
        "end_line": 363,
        "comment": "\n     * Ensures a meta charset (html) or xml declaration (xml) with the current\n     * encoding used. This only applies with\n     * {@link #updateMetaCharsetElement(boolean) updateMetaCharset} set to\n     * <tt>true</tt>, otherwise this method does nothing.\n     * \n     * <ul>\n     * <li>An existing element gets updated with the current charset</li>\n     * <li>If there's no element yet it will be inserted</li>\n     * <li>Obsolete elements are removed</li>\n     * </ul>\n     * \n     * <p><b>Elements used:</b></p>\n     * \n     * <ul>\n     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n     * </ul>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.OutputSettings()",
        "snippet": "        public OutputSettings() {\n            charset(Charset.forName(\"UTF8\"));\n        }",
        "begin_line": 385,
        "end_line": 387,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.escapeMode()",
        "snippet": "        public Entities.EscapeMode escapeMode() {\n            return escapeMode;\n        }",
        "begin_line": 397,
        "end_line": 399,
        "comment": "\n         * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML\n         * entities and escapes other characters as numbered entities for maximum compatibility; or <code>extended</code>,\n         * which uses the complete set of HTML named entities.\n         * <p>\n         * The default escape mode is <code>base</code>.\n         * @return the document's current escape mode\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.escapeMode(org.jsoup.nodes.Entities.EscapeMode)",
        "snippet": "        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {\n            this.escapeMode = escapeMode;\n            return this;\n        }",
        "begin_line": 407,
        "end_line": 410,
        "comment": "\n         * Set the document's escape mode, which determines how characters are escaped when the output character set\n         * does not support a given character:- using either a named or a numbered escape.\n         * @param escapeMode the new escape mode to use\n         * @return the document's output settings, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.charset()",
        "snippet": "        public Charset charset() {\n            return charset;\n        }",
        "begin_line": 420,
        "end_line": 422,
        "comment": "\n         * Get the document's current output charset, which is used to control which characters are escaped when\n         * generating HTML (via the <code>html()</code> methods), and which are kept intact.\n         * <p>\n         * Where possible (when parsing from a URL or File), the document's output charset is automatically set to the\n         * input charset. Otherwise, it defaults to UTF-8.\n         * @return the document's current charset.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.charset(java.nio.charset.Charset)",
        "snippet": "        public OutputSettings charset(Charset charset) {\n            this.charset = charset;\n            return this;\n        }",
        "begin_line": 429,
        "end_line": 432,
        "comment": "\n         * Update the document's output charset.\n         * @param charset the new charset to use.\n         * @return the document's output settings, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.charset(java.lang.String)",
        "snippet": "        public OutputSettings charset(String charset) {\n            charset(Charset.forName(charset));\n            return this;\n        }",
        "begin_line": 439,
        "end_line": 442,
        "comment": "\n         * Update the document's output charset.\n         * @param charset the new charset (by name) to use.\n         * @return the document's output settings, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.prepareEncoder()",
        "snippet": "        CharsetEncoder prepareEncoder() {\n            // created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads\n            CharsetEncoder encoder = charset.newEncoder();\n            encoderThreadLocal.set(encoder);\n            coreCharset = Entities.CoreCharset.byName(encoder.charset().name());\n            return encoder;\n        }",
        "begin_line": 444,
        "end_line": 450,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.encoder()",
        "snippet": "        CharsetEncoder encoder() {\n            CharsetEncoder encoder = encoderThreadLocal.get();\n            return encoder != null ? encoder : prepareEncoder();\n        }",
        "begin_line": 452,
        "end_line": 455,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.syntax()",
        "snippet": "        public Syntax syntax() {\n            return syntax;\n        }",
        "begin_line": 461,
        "end_line": 463,
        "comment": "\n         * Get the document's current output syntax.\n         * @return current syntax\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.syntax(org.jsoup.nodes.Document.OutputSettings.Syntax)",
        "snippet": "        public OutputSettings syntax(Syntax syntax) {\n            this.syntax = syntax;\n            return this;\n        }",
        "begin_line": 471,
        "end_line": 474,
        "comment": "\n         * Set the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or\n         * {@code xml}, with self-closing tags.\n         * @param syntax serialization syntax\n         * @return the document's output settings, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.prettyPrint()",
        "snippet": "        public boolean prettyPrint() {\n            return prettyPrint;\n        }",
        "begin_line": 481,
        "end_line": 483,
        "comment": "\n         * Get if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format\n         * the output, and the output will generally look like the input.\n         * @return if pretty printing is enabled.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.prettyPrint(boolean)",
        "snippet": "        public OutputSettings prettyPrint(boolean pretty) {\n            prettyPrint = pretty;\n            return this;\n        }",
        "begin_line": 490,
        "end_line": 493,
        "comment": "\n         * Enable or disable pretty printing.\n         * @param pretty new pretty print setting\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.outline()",
        "snippet": "        public boolean outline() {\n            return outline;\n        }",
        "begin_line": 500,
        "end_line": 502,
        "comment": "\n         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n         * all tags as block.\n         * @return if outline mode is enabled.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.outline(boolean)",
        "snippet": "        public OutputSettings outline(boolean outlineMode) {\n            outline = outlineMode;\n            return this;\n        }",
        "begin_line": 509,
        "end_line": 512,
        "comment": "\n         * Enable or disable HTML outline mode.\n         * @param outlineMode new outline setting\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.indentAmount()",
        "snippet": "        public int indentAmount() {\n            return indentAmount;\n        }",
        "begin_line": 518,
        "end_line": 520,
        "comment": "\n         * Get the current tag indent amount, used when pretty printing.\n         * @return the current indent amount\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.indentAmount(int)",
        "snippet": "        public OutputSettings indentAmount(int indentAmount) {\n            Validate.isTrue(indentAmount >= 0);\n            this.indentAmount = indentAmount;\n            return this;\n        }",
        "begin_line": 527,
        "end_line": 531,
        "comment": "\n         * Set the indent amount for pretty printing\n         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n         * @return this, for chaining\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.OutputSettings.clone()",
        "snippet": "        @Override\n        public OutputSettings clone() {\n            OutputSettings clone;\n            try {\n                clone = (OutputSettings) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n            clone.charset(charset.name()); // new charset and charset encoder\n            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());\n            // indentAmount, prettyPrint are primitives so object.clone() will handle\n            return clone;\n        }",
        "begin_line": 533,
        "end_line": 545,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.outputSettings()",
        "snippet": "    public OutputSettings outputSettings() {\n        return outputSettings;\n    }",
        "begin_line": 552,
        "end_line": 554,
        "comment": "\n     * Get the document's current output settings.\n     * @return the document's current output settings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.outputSettings(org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    public Document outputSettings(OutputSettings outputSettings) {\n        Validate.notNull(outputSettings);\n        this.outputSettings = outputSettings;\n        return this;\n    }",
        "begin_line": 561,
        "end_line": 565,
        "comment": "\n     * Set the document's output settings.\n     * @param outputSettings new output settings.\n     * @return this document, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.quirksMode()",
        "snippet": "    public QuirksMode quirksMode() {\n        return quirksMode;\n    }",
        "begin_line": 571,
        "end_line": 573,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.quirksMode(org.jsoup.nodes.Document.QuirksMode)",
        "snippet": "    public Document quirksMode(QuirksMode quirksMode) {\n        this.quirksMode = quirksMode;\n        return this;\n    }",
        "begin_line": 575,
        "end_line": 578,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.parser()",
        "snippet": "    public Parser parser() {\n        return parser;\n    }",
        "begin_line": 584,
        "end_line": 586,
        "comment": "\n     * Get the parser that was used to parse this document.\n     * @return the parser\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Document.java",
        "class_name": "org.jsoup.nodes.Document",
        "signature": "org.jsoup.nodes.Document.parser(org.jsoup.parser.Parser)",
        "snippet": "    public Document parser(Parser parser) {\n        this.parser = parser;\n        return this;\n    }",
        "begin_line": 594,
        "end_line": 597,
        "comment": "\n     * Set the parser used to create this document. This parser is then used when further parsing within this document\n     * is required.\n     * @param parser the configured parser to use when further parsing is required for this document.\n     * @return this document, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.Node()",
        "snippet": "    protected Node() {\n    }",
        "begin_line": 25,
        "end_line": 26,
        "comment": "\n     * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.nodeName()",
        "snippet": "    public abstract String nodeName();",
        "begin_line": 32,
        "end_line": 32,
        "comment": "\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.hasAttributes()",
        "snippet": "    protected abstract boolean hasAttributes();",
        "begin_line": 37,
        "end_line": 37,
        "comment": "\n     * Check if this Node has an actual Attributes object.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.hasParent()",
        "snippet": "    public boolean hasParent() {\n        return parentNode != null;\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.attr(java.lang.String)",
        "snippet": "    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return EmptyString;\n\n        String val = attributes().getIgnoreCase(attributeKey);\n        if (val.length() > 0)\n            return val;\n        else if (attributeKey.startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }",
        "begin_line": 58,
        "end_line": 69,
        "comment": "\n     * Get an attribute's value by its key. <b>Case insensitive</b>\n     * <p>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.\n     * </p>\n     * E.g.:\n     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n     *\n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.attributes()",
        "snippet": "    public abstract Attributes attributes();",
        "begin_line": 75,
        "end_line": 75,
        "comment": "\n     * Get all of the element's attributes.\n     * @return attributes (which implements iterable, in same order as presented in original HTML).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.attr(java.lang.String, java.lang.String)",
        "snippet": "    public Node attr(String attributeKey, String attributeValue) {\n        attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);\n        attributes().putIgnoreCase(attributeKey, attributeValue);\n        return this;\n    }",
        "begin_line": 84,
        "end_line": 88,
        "comment": "\n     * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n     * <b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.hasAttr(java.lang.String)",
        "snippet": "    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes().hasKeyIgnoreCase(attributeKey);\n    }",
        "begin_line": 95,
        "end_line": 104,
        "comment": "\n     * Test if this element has an attribute. <b>Case insensitive</b>\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.removeAttr(java.lang.String)",
        "snippet": "    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes().removeIgnoreCase(attributeKey);\n        return this;\n    }",
        "begin_line": 111,
        "end_line": 115,
        "comment": "\n     * Remove an attribute from this element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.clearAttributes()",
        "snippet": "    public Node clearAttributes() {\n        Iterator<Attribute> it = attributes().iterator();\n        while (it.hasNext()) {\n            it.next();\n            it.remove();\n        }\n        return this;\n    }",
        "begin_line": 121,
        "end_line": 128,
        "comment": "\n     * Clear (remove) all of the attributes in this node.\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.baseUri()",
        "snippet": "    public abstract String baseUri();",
        "begin_line": 134,
        "end_line": 134,
        "comment": "\n     Get the base URI of this node.\n     @return base URI\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.doSetBaseUri(java.lang.String)",
        "snippet": "    protected abstract void doSetBaseUri(String baseUri);",
        "begin_line": 140,
        "end_line": 140,
        "comment": "\n     * Set the baseUri for just this node (not its descendants), if this Node tracks base URIs.\n     * @param baseUri new URI\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.setBaseUri(java.lang.String)",
        "snippet": "    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.doSetBaseUri(baseUri);\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }",
        "begin_line": 146,
        "end_line": 157,
        "comment": "\n     Update the base URI of this node and all of its descendants.\n     @param baseUri base URI to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.Anonymous-e20f9a4e-8872-4113-9984-594de0ceedcc.head(org.jsoup.nodes.Node, int)",
        "snippet": "            public void head(Node node, int depth) {\n                node.doSetBaseUri(baseUri);\n            }",
        "begin_line": 150,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.Anonymous-49cd0314-e41c-4534-aa3a-42b8bac625dd.tail(org.jsoup.nodes.Node, int)",
        "snippet": "            public void tail(Node node, int depth) {\n            }",
        "begin_line": 154,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.absUrl(java.lang.String)",
        "snippet": "    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            return StringUtil.resolve(baseUri(), attr(attributeKey));\n        }\n    }",
        "begin_line": 182,
        "end_line": 190,
        "comment": "\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href&gt;</code> or\n     * <code>&lt;img src&gt;</code>).\n     * <p>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * </p>\n     * <p>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * </p>\n     * <p>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     * </p>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.ensureChildNodes()",
        "snippet": "    protected abstract List<Node> ensureChildNodes();",
        "begin_line": 192,
        "end_line": 192,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.childNode(int)",
        "snippet": "    public Node childNode(int index) {\n        return ensureChildNodes().get(index);\n    }",
        "begin_line": 199,
        "end_line": 201,
        "comment": "\n     Get a child node by its 0-based index.\n     @param index index of child node\n     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.childNodes()",
        "snippet": "    public List<Node> childNodes() {\n        return Collections.unmodifiableList(ensureChildNodes());\n    }",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.childNodesCopy()",
        "snippet": "    public List<Node> childNodesCopy() {\n        final List<Node> nodes = ensureChildNodes();\n        final ArrayList<Node> children = new ArrayList<>(nodes.size());\n        for (Node node : nodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }",
        "begin_line": 217,
        "end_line": 224,
        "comment": "\n     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\n     * nodes\n     * @return a deep copy of this node's children\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.childNodeSize()",
        "snippet": "    public abstract int childNodeSize();",
        "begin_line": 230,
        "end_line": 230,
        "comment": "\n     * Get the number of child nodes that this node holds.\n     * @return the number of child nodes that this node holds.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.childNodesAsArray()",
        "snippet": "    protected Node[] childNodesAsArray() {\n        return ensureChildNodes().toArray(new Node[0]);\n    }",
        "begin_line": 232,
        "end_line": 234,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.parent()",
        "snippet": "    public Node parent() {\n        return parentNode;\n    }",
        "begin_line": 240,
        "end_line": 242,
        "comment": "\n     Gets this node's parent node.\n     @return parent node; or null if no parent.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.parentNode()",
        "snippet": "    public final Node parentNode() {\n        return parentNode;\n    }",
        "begin_line": 248,
        "end_line": 250,
        "comment": "\n     Gets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.\n     @return parent node; or null if no parent.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.root()",
        "snippet": "    public Node root() {\n        Node node = this;\n        while (node.parentNode != null)\n            node = node.parentNode;\n        return node;\n    }",
        "begin_line": 256,
        "end_line": 261,
        "comment": "\n     * Get this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.\n     * @return topmost ancestor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.ownerDocument()",
        "snippet": "    public Document ownerDocument() {\n        Node root = root();\n        return (root instanceof Document) ? (Document) root : null;\n    }",
        "begin_line": 267,
        "end_line": 270,
        "comment": "\n     * Gets the Document associated with this Node.\n     * @return the Document associated with this Node, or null if there is no such Document.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.remove()",
        "snippet": "    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }",
        "begin_line": 275,
        "end_line": 278,
        "comment": "\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.before(java.lang.String)",
        "snippet": "    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }",
        "begin_line": 286,
        "end_line": 289,
        "comment": "\n     * Insert the specified HTML into the DOM before this node (i.e. as a preceding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.before(org.jsoup.nodes.Node)",
        "snippet": "    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }",
        "begin_line": 297,
        "end_line": 303,
        "comment": "\n     * Insert the specified node into the DOM before this node (i.e. as a preceding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.after(java.lang.String)",
        "snippet": "    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }",
        "begin_line": 311,
        "end_line": 314,
        "comment": "\n     * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.after(org.jsoup.nodes.Node)",
        "snippet": "    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }",
        "begin_line": 322,
        "end_line": 328,
        "comment": "\n     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.addSiblingHtml(int, java.lang.String)",
        "snippet": "    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[0]));\n    }",
        "begin_line": 330,
        "end_line": 337,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.wrap(java.lang.String)",
        "snippet": "    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }",
        "begin_line": 344,
        "end_line": 368,
        "comment": "\n     Wrap the supplied HTML around this node.\n     @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this node, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.unwrap()",
        "snippet": "    public Node unwrap() {\n        Validate.notNull(parentNode);\n        final List<Node> childNodes = ensureChildNodes();\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }",
        "begin_line": 385,
        "end_line": 393,
        "comment": "\n     * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n     * the node but keeping its children.\n     * <p>\n     * For example, with the input html:\n     * </p>\n     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n     * and the {@code \"Two \"} {@link TextNode} being returned.\n     *\n     * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n     * @see #remove()\n     * @see #wrap(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.getDeepChild(org.jsoup.nodes.Element)",
        "snippet": "    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }",
        "begin_line": 395,
        "end_line": 401,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.nodelistChanged()",
        "snippet": "    void nodelistChanged() {\n        // Element overrides this to clear its shadow children elements\n    }",
        "begin_line": 403,
        "end_line": 405,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.replaceWith(org.jsoup.nodes.Node)",
        "snippet": "    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }",
        "begin_line": 411,
        "end_line": 415,
        "comment": "\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will will replace the existing node.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.setParentNode(org.jsoup.nodes.Node)",
        "snippet": "    protected void setParentNode(Node parentNode) {\n        Validate.notNull(parentNode);\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }",
        "begin_line": 417,
        "end_line": 422,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.replaceChild(org.jsoup.nodes.Node, org.jsoup.nodes.Node)",
        "snippet": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }",
        "begin_line": 424,
        "end_line": 435,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.removeChild(org.jsoup.nodes.Node)",
        "snippet": "    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        ensureChildNodes().remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }",
        "begin_line": 437,
        "end_line": 443,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.addChildren(org.jsoup.nodes.Node...)",
        "snippet": "    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        final List<Node> nodes = ensureChildNodes();\n\n        for (Node child: children) {\n            reparentChild(child);\n            nodes.add(child);\n            child.setSiblingIndex(nodes.size()-1);\n        }\n    }",
        "begin_line": 445,
        "end_line": 454,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.addChildren(int, org.jsoup.nodes.Node...)",
        "snippet": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        final List<Node> nodes = ensureChildNodes();\n\n        for (Node child : children) {\n            reparentChild(child);\n        }\n        nodes.addAll(index, Arrays.asList(children));\n        reindexChildren(index);\n    }",
        "begin_line": 456,
        "end_line": 465,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.reparentChild(org.jsoup.nodes.Node)",
        "snippet": "    protected void reparentChild(Node child) {\n        child.setParentNode(this);\n    }",
        "begin_line": 467,
        "end_line": 469,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.reindexChildren(int)",
        "snippet": "    private void reindexChildren(int start) {\n        final List<Node> childNodes = ensureChildNodes();\n\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }",
        "begin_line": 471,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.siblingNodes()",
        "snippet": "    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.ensureChildNodes();\n        List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }",
        "begin_line": 484,
        "end_line": 494,
        "comment": "\n     Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n     include this node (a node is not a sibling of itself).\n     @return node siblings. If the node has no parent, returns an empty list.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.nextSibling()",
        "snippet": "    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        final List<Node> siblings = parentNode.ensureChildNodes();\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }",
        "begin_line": 500,
        "end_line": 510,
        "comment": "\n     Get this node's next sibling.\n     @return next sibling, or null if this is the last sibling\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.previousSibling()",
        "snippet": "    public Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.ensureChildNodes().get(siblingIndex-1);\n        else\n            return null;\n    }",
        "begin_line": 516,
        "end_line": 524,
        "comment": "\n     Get this node's previous sibling.\n     @return the previous sibling, or null if this is the first sibling\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.siblingIndex()",
        "snippet": "    public int siblingIndex() {\n        return siblingIndex;\n    }",
        "begin_line": 532,
        "end_line": 534,
        "comment": "\n     * Get the list index of this node in its node sibling list. I.e. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.setSiblingIndex(int)",
        "snippet": "    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }",
        "begin_line": 536,
        "end_line": 538,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.traverse(org.jsoup.select.NodeVisitor)",
        "snippet": "    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }",
        "begin_line": 545,
        "end_line": 549,
        "comment": "\n     * Perform a depth-first traversal through this node and its descendants.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this node, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.filter(org.jsoup.select.NodeFilter)",
        "snippet": "    public Node filter(NodeFilter nodeFilter) {\n        Validate.notNull(nodeFilter);\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }",
        "begin_line": 556,
        "end_line": 560,
        "comment": "\n     * Perform a depth-first filtering through this node and its descendants.\n     * @param nodeFilter the filter callbacks to perform on each node\n     * @return this node, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.outerHtml()",
        "snippet": "    public String outerHtml() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        outerHtml(accum);\n        return StringUtil.releaseBuilder(accum);\n    }",
        "begin_line": 568,
        "end_line": 572,
        "comment": "\n     Get the outer HTML of this node. For example, on a {@code p} element, may return {@code <p>Para</p>}.\n     @return outer HTML\n     @see Element#html()\n     @see Element#text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.outerHtml(java.lang.Appendable)",
        "snippet": "    protected void outerHtml(Appendable accum) {\n        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);\n    }",
        "begin_line": 574,
        "end_line": 576,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;",
        "begin_line": 583,
        "end_line": 583,
        "comment": "\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     @throws IOException if appending to the given accumulator fails.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;",
        "begin_line": 585,
        "end_line": 585,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.html(T)",
        "snippet": "    public <T extends Appendable> T html(T appendable) {\n        outerHtml(appendable);\n        return appendable;\n    }",
        "begin_line": 593,
        "end_line": 596,
        "comment": "\n     * Write this node and its children to the given {@link Appendable}.\n     *\n     * @param appendable the {@link Appendable} to write to.\n     * @return the supplied {@link Appendable}, for chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.toString()",
        "snippet": "\tpublic String toString() {\n        return outerHtml();\n    }",
        "begin_line": 603,
        "end_line": 605,
        "comment": "\n     * Gets this node's outer HTML.\n     * @return outer HTML.\n     * @see #outerHtml()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.indent(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append('\\n').append(StringUtil.padding(depth * out.indentAmount()));\n    }",
        "begin_line": 607,
        "end_line": 609,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        // implemented just so that javadoc is clear this is an identity test\n        return this == o;\n    }",
        "begin_line": 617,
        "end_line": 621,
        "comment": "\n     * Check if this node is the same instance of another (object identity test).\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     * @see Node#hasSameValue(Object) to compare nodes by their value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.hasSameValue(java.lang.Object)",
        "snippet": "    public boolean hasSameValue(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        return this.outerHtml().equals(((Node) o).outerHtml());\n    }",
        "begin_line": 629,
        "end_line": 634,
        "comment": "\n     * Check if this node is has the same content as another node. A node is considered the same if its name, attributes and content match the\n     * other node; particularly its position in the tree does not influence its similarity.\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.clone()",
        "snippet": "    @Override\n    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        final LinkedList<Node> nodesToProcess = new LinkedList<>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            final int size = currParent.childNodeSize();\n            for (int i = 0; i < size; i++) {\n                final List<Node> childNodes = currParent.ensureChildNodes();\n                Node childClone = childNodes.get(i).doClone(currParent);\n                childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }",
        "begin_line": 645,
        "end_line": 666,
        "comment": "\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * <p>\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return a stand-alone cloned node, including clones of any children\n     * @see #shallowClone()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.shallowClone()",
        "snippet": "    public Node shallowClone() {\n        return doClone(null);\n    }",
        "begin_line": 674,
        "end_line": 676,
        "comment": "\n     * Create a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have\n     * no parent or sibling nodes.\n     * @return a single independent copy of this node\n     * @see #clone()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.doClone(org.jsoup.nodes.Node)",
        "snippet": "    protected Node doClone(Node parent) {\n        Node clone;\n\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n\n        return clone;\n    }",
        "begin_line": 682,
        "end_line": 695,
        "comment": "\n     * Return a clone of the node using the given parent (which can be null).\n     * Not a deep copy of children.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.OuterHtmlVisitor.OuterHtmlVisitor(java.lang.Appendable, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n            this.accum = accum;\n            this.out = out;\n            out.prepareEncoder();\n        }",
        "begin_line": 701,
        "end_line": 705,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.OuterHtmlVisitor.head(org.jsoup.nodes.Node, int)",
        "snippet": "        public void head(Node node, int depth) {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }",
        "begin_line": 707,
        "end_line": 713,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/Node.java",
        "class_name": "org.jsoup.nodes.Node",
        "signature": "org.jsoup.nodes.Node.OuterHtmlVisitor.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }",
        "begin_line": 715,
        "end_line": 723,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.TextNode(java.lang.String)",
        "snippet": "    public TextNode(String text) {\n        value = text;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @see #createFromEncoded(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.TextNode(java.lang.String, java.lang.String)",
        "snippet": "    public TextNode(String text, String baseUri) {\n        this(text);\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @param baseUri base uri - ignored for this node type\n     @see #createFromEncoded(String, String)\n     @deprecated use {@link TextNode#TextNode(String)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.nodeName()",
        "snippet": "\tpublic String nodeName() {\n        return \"#text\";\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.text()",
        "snippet": "    public String text() {\n        return StringUtil.normaliseWhitespace(getWholeText());\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Get the text content of this text node.\n     * @return Unencoded, normalised text.\n     * @see TextNode#getWholeText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.text(java.lang.String)",
        "snippet": "    public TextNode text(String text) {\n        coreValue(text);\n        return this;\n    }",
        "begin_line": 54,
        "end_line": 57,
        "comment": "\n     * Set the text content of this text node.\n     * @param text unencoded text\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.getWholeText()",
        "snippet": "    public String getWholeText() {\n        return coreValue();\n    }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "\n     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n     @return text\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.isBlank()",
        "snippet": "    public boolean isBlank() {\n        return StringUtil.isBlank(coreValue());\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     Test if this text node is blank -- that is, empty or only whitespace (including newlines).\n     @return true if this document is empty or only whitespace, false if it contains any text content.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.splitText(int)",
        "snippet": "    public TextNode splitText(int offset) {\n        final String text = coreValue();\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n\n        String head = text.substring(0, offset);\n        String tail = text.substring(offset);\n        text(head);\n        TextNode tailNode = new TextNode(tail);\n        if (parent() != null)\n            parent().addChildren(siblingIndex()+1, tailNode);\n\n        return tailNode;\n    }",
        "begin_line": 81,
        "end_line": 94,
        "comment": "\n     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the\n     * original text up to the offset, and will have a new text node sibling containing the text after the offset.\n     * @param offset string offset point to split node at.\n     * @return the newly created text node containing the text after the offset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.outerHtmlHead(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n            indent(accum, depth, out);\n\n        boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n                && !Element.preserveWhitespace(parent());\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, false);\n    }",
        "begin_line": 96,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.outerHtmlTail(java.lang.Appendable, int, org.jsoup.nodes.Document.OutputSettings)",
        "snippet": "\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}",
        "begin_line": 105,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.createFromEncoded(java.lang.String, java.lang.String)",
        "snippet": "    public static TextNode createFromEncoded(String encodedText, String baseUri) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }",
        "begin_line": 119,
        "end_line": 122,
        "comment": "\n     * Create a new TextNode from HTML encoded (aka escaped) data.\n     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n     * @param baseUri Base uri\n     * @return TextNode containing unencoded data (e.g. &lt;)\n     * @deprecated use {@link TextNode#createFromEncoded(String)} instead, as LeafNodes don't carry base URIs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.createFromEncoded(java.lang.String)",
        "snippet": "    public static TextNode createFromEncoded(String encodedText) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }",
        "begin_line": 129,
        "end_line": 132,
        "comment": "\n     * Create a new TextNode from HTML encoded (aka escaped) data.\n     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n     * @return TextNode containing unencoded data (e.g. &lt;)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.normaliseWhitespace(java.lang.String)",
        "snippet": "    static String normaliseWhitespace(String text) {\n        text = StringUtil.normaliseWhitespace(text);\n        return text;\n    }",
        "begin_line": 134,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.stripLeadingWhitespace(java.lang.String)",
        "snippet": "    static String stripLeadingWhitespace(String text) {\n        return text.replaceFirst(\"^\\\\s+\", \"\");\n    }",
        "begin_line": 139,
        "end_line": 141,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/nodes/TextNode.java",
        "class_name": "org.jsoup.nodes.TextNode",
        "signature": "org.jsoup.nodes.TextNode.lastCharIsWhitespace(java.lang.StringBuilder)",
        "snippet": "    static boolean lastCharIsWhitespace(StringBuilder sb) {\n        return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n    }",
        "begin_line": 143,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.Collector()",
        "snippet": "    private Collector() {\n    }",
        "begin_line": 16,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.collect(org.jsoup.select.Evaluator, org.jsoup.nodes.Element)",
        "snippet": "    public static Elements collect (Evaluator eval, Element root) {\n        Elements elements = new Elements();\n        NodeTraversor.traverse(new Accumulator(root, elements, eval), root);\n        return elements;\n    }",
        "begin_line": 25,
        "end_line": 29,
        "comment": "\n     Build a list of elements, by visiting root and every descendant of root, and testing it against the evaluator.\n     @param eval Evaluator to test elements against\n     @param root root of tree to descend\n     @return list of matches; empty if none\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.Accumulator.Accumulator(org.jsoup.nodes.Element, org.jsoup.select.Elements, org.jsoup.select.Evaluator)",
        "snippet": "        Accumulator(Element root, Elements elements, Evaluator eval) {\n            this.root = root;\n            this.elements = elements;\n            this.eval = eval;\n        }",
        "begin_line": 36,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.Accumulator.head(org.jsoup.nodes.Node, int)",
        "snippet": "        public void head(Node node, int depth) {\n            if (node instanceof Element) {\n                Element el = (Element) node;\n                if (eval.matches(root, el))\n                    elements.add(el);\n            }\n        }",
        "begin_line": 42,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.Accumulator.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        public void tail(Node node, int depth) {\n            // void\n        }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.findFirst(org.jsoup.select.Evaluator, org.jsoup.nodes.Element)",
        "snippet": "    public static Element findFirst(Evaluator eval, Element root) {\n        FirstFinder finder = new FirstFinder(root, eval);\n        NodeTraversor.filter(finder, root);\n        return finder.match;\n    }",
        "begin_line": 55,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.FirstFinder.FirstFinder(org.jsoup.nodes.Element, org.jsoup.select.Evaluator)",
        "snippet": "        FirstFinder(Element root, Evaluator eval) {\n            this.root = root;\n            this.eval = eval;\n        }",
        "begin_line": 66,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.FirstFinder.head(org.jsoup.nodes.Node, int)",
        "snippet": "        @Override\n        public FilterResult head(Node node, int depth) {\n            if (node instanceof Element) {\n                Element el = (Element) node;\n                if (eval.matches(root, el)) {\n                    match = el;\n                    return STOP;\n                }\n            }\n            return CONTINUE;\n        }",
        "begin_line": 71,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Collector.java",
        "class_name": "org.jsoup.select.Collector",
        "signature": "org.jsoup.select.Collector.FirstFinder.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        @Override\n        public FilterResult tail(Node node, int depth) {\n            return CONTINUE;\n        }",
        "begin_line": 83,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.QueryParser(java.lang.String)",
        "snippet": "    private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }",
        "begin_line": 29,
        "end_line": 32,
        "comment": "\n     * Create a new QueryParser.\n     * @param query CSS query\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.parse(java.lang.String)",
        "snippet": "    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }",
        "begin_line": 39,
        "end_line": 46,
        "comment": "\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.parse()",
        "snippet": "    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }",
        "begin_line": 52,
        "end_line": 79,
        "comment": "\n     * Parse the query\n     * @return Evaluator\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.combinator(char)",
        "snippet": "    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        if (combinator == '>')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n        else if (combinator == ' ')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n        else if (combinator == '+')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n        else if (combinator == '~')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n        else if (combinator == ',') { // group or.\n            CombiningEvaluator.Or or;\n            if (currentEval instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) currentEval;\n                or.add(newEval);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(currentEval);\n                or.add(newEval);\n            }\n            currentEval = or;\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }",
        "begin_line": 81,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.consumeSubQuery()",
        "snippet": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "begin_line": 133,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.findElements()",
        "snippet": "    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":containsData(\"))\n            containsData();\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n        else if (tq.matchChomp(\":matchText\"))\n            evals.add(new Evaluator.MatchText());\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }",
        "begin_line": 148,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.byId()",
        "snippet": "    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }",
        "begin_line": 210,
        "end_line": 214,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.byClass()",
        "snippet": "    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim()));\n    }",
        "begin_line": 216,
        "end_line": 220,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.byTag()",
        "snippet": "    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n\n        Validate.notEmpty(tagName);\n\n        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n        if (tagName.startsWith(\"*|\")) {\n            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(normalize(tagName)), new Evaluator.TagEndsWith(normalize(tagName.replace(\"*|\", \":\")))));\n        } else {\n            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n            if (tagName.contains(\"|\"))\n                tagName = tagName.replace(\"|\", \":\");\n\n            evals.add(new Evaluator.Tag(tagName.trim()));\n        }\n    }",
        "begin_line": 222,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.byAttribute()",
        "snippet": "    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }",
        "begin_line": 239,
        "end_line": 271,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.allElements()",
        "snippet": "    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }",
        "begin_line": 273,
        "end_line": 275,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.indexLessThan()",
        "snippet": "    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }",
        "begin_line": 278,
        "end_line": 280,
        "comment": " pseudo selectors :lt, :gt, :eq",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.indexGreaterThan()",
        "snippet": "    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }",
        "begin_line": 282,
        "end_line": 284,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.indexEquals()",
        "snippet": "    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }",
        "begin_line": 286,
        "end_line": 288,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.cssNthChild(boolean, boolean)",
        "snippet": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {\n\t\tString argS = normalize(tq.chompTo(\")\"));\n\t\tMatcher mAB = NTH_AB.matcher(argS);\n\t\tMatcher mB = NTH_B.matcher(argS);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n\t\t}\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n\t\t}\n\t}",
        "begin_line": 294,
        "end_line": 325,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.consumeIndex()",
        "snippet": "    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }",
        "begin_line": 327,
        "end_line": 331,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.has()",
        "snippet": "    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }",
        "begin_line": 334,
        "end_line": 339,
        "comment": " pseudo selector :has(el)",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.contains(boolean)",
        "snippet": "    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }",
        "begin_line": 342,
        "end_line": 350,
        "comment": " pseudo selector :contains(text), containsOwn(text)",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.containsData()",
        "snippet": "    private void containsData() {\n        tq.consume(\":containsData\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        evals.add(new Evaluator.ContainsData(searchText));\n    }",
        "begin_line": 353,
        "end_line": 358,
        "comment": " pseudo selector :containsData(data)",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.matches(boolean)",
        "snippet": "    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }",
        "begin_line": 361,
        "end_line": 370,
        "comment": " :matches(regex), matchesOwn(regex)",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/QueryParser.java",
        "class_name": "org.jsoup.select.QueryParser",
        "signature": "org.jsoup.select.QueryParser.not()",
        "snippet": "    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }",
        "begin_line": 373,
        "end_line": 379,
        "comment": " :not(selector)",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.Elements()",
        "snippet": "    public Elements() {\n    }",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.Elements(int)",
        "snippet": "    public Elements(int initialCapacity) {\n        super(initialCapacity);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.Elements(java.util.Collection<org.jsoup.nodes.Element>)",
        "snippet": "    public Elements(Collection<Element> elements) {\n        super(elements);\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.Elements(java.util.List<org.jsoup.nodes.Element>)",
        "snippet": "    public Elements(List<Element> elements) {\n        super(elements);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.Elements(org.jsoup.nodes.Element...)",
        "snippet": "    public Elements(Element... elements) {\n    \tsuper(Arrays.asList(elements));\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.clone()",
        "snippet": "    @Override\n\tpublic Elements clone() {\n        Elements clone = new Elements(size());\n\n        for(Element e : this)\n    \t\tclone.add(e.clone());\n    \t\n    \treturn clone;\n\t}",
        "begin_line": 47,
        "end_line": 55,
        "comment": "\n     * Creates a deep copy of these elements.\n     * @return a deep copy\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.attr(java.lang.String)",
        "snippet": "    public String attr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return element.attr(attributeKey);\n        }\n        return \"\";\n    }",
        "begin_line": 65,
        "end_line": 71,
        "comment": "\n     Get an attribute value from the first matched element that has the attribute.\n     @param attributeKey The attribute key.\n     @return The attribute value from the first matched element that has the attribute.. If no elements were matched (isEmpty() == true),\n     or if the no elements have the attribute, returns empty string.\n     @see #hasAttr(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.hasAttr(java.lang.String)",
        "snippet": "    public boolean hasAttr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 78,
        "end_line": 84,
        "comment": "\n     Checks if any of the matched elements have this attribute defined.\n     @param attributeKey attribute key\n     @return true if any of the elements have the attribute; false if none do.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.eachAttr(java.lang.String)",
        "snippet": "    public List<String> eachAttr(String attributeKey) {\n        List<String> attrs = new ArrayList<>(size());\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                attrs.add(element.attr(attributeKey));\n        }\n        return attrs;\n    }",
        "begin_line": 93,
        "end_line": 100,
        "comment": "\n     * Get the attribute value for each of the matched elements. If an element does not have this attribute, no value is\n     * included in the result set for that element.\n     * @param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to\n     * get absolute URLs from relative URLs, e.g.: {@code doc.select(\"a\").eachAttr(\"abs:href\")} .\n     * @return a list of each element's attribute value for the attribute\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.attr(java.lang.String, java.lang.String)",
        "snippet": "    public Elements attr(String attributeKey, String attributeValue) {\n        for (Element element : this) {\n            element.attr(attributeKey, attributeValue);\n        }\n        return this;\n    }",
        "begin_line": 108,
        "end_line": 113,
        "comment": "\n     * Set an attribute on all matched elements.\n     * @param attributeKey attribute key\n     * @param attributeValue attribute value\n     * @return this\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.removeAttr(java.lang.String)",
        "snippet": "    public Elements removeAttr(String attributeKey) {\n        for (Element element : this) {\n            element.removeAttr(attributeKey);\n        }\n        return this;\n    }",
        "begin_line": 120,
        "end_line": 125,
        "comment": "\n     * Remove an attribute from every matched element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.addClass(java.lang.String)",
        "snippet": "    public Elements addClass(String className) {\n        for (Element element : this) {\n            element.addClass(className);\n        }\n        return this;\n    }",
        "begin_line": 132,
        "end_line": 137,
        "comment": "\n     Add the class name to every matched element's {@code class} attribute.\n     @param className class name to add\n     @return this\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.removeClass(java.lang.String)",
        "snippet": "    public Elements removeClass(String className) {\n        for (Element element : this) {\n            element.removeClass(className);\n        }\n        return this;\n    }",
        "begin_line": 144,
        "end_line": 149,
        "comment": "\n     Remove the class name from every matched element's {@code class} attribute, if present.\n     @param className class name to remove\n     @return this\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.toggleClass(java.lang.String)",
        "snippet": "    public Elements toggleClass(String className) {\n        for (Element element : this) {\n            element.toggleClass(className);\n        }\n        return this;\n    }",
        "begin_line": 156,
        "end_line": 161,
        "comment": "\n     Toggle the class name on every matched element's {@code class} attribute.\n     @param className class name to add if missing, or remove if present, from every element.\n     @return this\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.hasClass(java.lang.String)",
        "snippet": "    public boolean hasClass(String className) {\n        for (Element element : this) {\n            if (element.hasClass(className))\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 168,
        "end_line": 174,
        "comment": "\n     Determine if any of the matched elements have this class name set in their {@code class} attribute.\n     @param className class name to check for\n     @return true if any do, false if none do\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.val()",
        "snippet": "    public String val() {\n        if (size() > 0)\n            return first().val();\n        else\n            return \"\";\n    }",
        "begin_line": 181,
        "end_line": 186,
        "comment": "\n     * Get the form element's value of the first matched element.\n     * @return The form element's value, or empty if not set.\n     * @see Element#val()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.val(java.lang.String)",
        "snippet": "    public Elements val(String value) {\n        for (Element element : this)\n            element.val(value);\n        return this;\n    }",
        "begin_line": 193,
        "end_line": 197,
        "comment": "\n     * Set the form element's value in each of the matched elements.\n     * @param value The value to set into each matched element\n     * @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.text()",
        "snippet": "    public String text() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        for (Element element : this) {\n            if (sb.length() != 0)\n                sb.append(\" \");\n            sb.append(element.text());\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 208,
        "end_line": 216,
        "comment": "\n     * Get the combined text of all the matched elements.\n     * <p>\n     * Note that it is possible to get repeats if the matched elements contain both parent elements and their own\n     * children, as the Element.text() method returns the combined text of a parent and all its children.\n     * @return string of all text: unescaped and no HTML.\n     * @see Element#text()\n     * @see #eachText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.hasText()",
        "snippet": "    public boolean hasText() {\n        for (Element element: this) {\n            if (element.hasText())\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 223,
        "end_line": 229,
        "comment": "\n     Test if any matched Element has any text content, that is not just whitespace.\n     @return true if any element has non-blank text content.\n     @see Element#hasText()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.eachText()",
        "snippet": "    public List<String> eachText() {\n        ArrayList<String> texts = new ArrayList<>(size());\n        for (Element el: this) {\n            if (el.hasText())\n                texts.add(el.text());\n        }\n        return texts;\n    }",
        "begin_line": 239,
        "end_line": 246,
        "comment": "\n     * Get the text content of each of the matched elements. If an element has no text, then it is not included in the\n     * result.\n     * @return A list of each matched element's text content.\n     * @see Element#text()\n     * @see Element#hasText()\n     * @see #text()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.html()",
        "snippet": "    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        for (Element element : this) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.html());\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 254,
        "end_line": 262,
        "comment": "\n     * Get the combined inner HTML of all matched elements.\n     * @return string of all element's inner HTML.\n     * @see #text()\n     * @see #outerHtml()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.outerHtml()",
        "snippet": "    public String outerHtml() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        for (Element element : this) {\n            if (sb.length() != 0)\n                sb.append(\"\\n\");\n            sb.append(element.outerHtml());\n        }\n        return StringUtil.releaseBuilder(sb);\n    }",
        "begin_line": 270,
        "end_line": 278,
        "comment": "\n     * Get the combined outer HTML of all matched elements.\n     * @return string of all element's outer HTML.\n     * @see #text()\n     * @see #html()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return outerHtml();\n    }",
        "begin_line": 286,
        "end_line": 289,
        "comment": "\n     * Get the combined outer HTML of all matched elements. Alias of {@link #outerHtml()}.\n     * @return string of all element's outer HTML.\n     * @see #text()\n     * @see #html()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.tagName(java.lang.String)",
        "snippet": "    public Elements tagName(String tagName) {\n        for (Element element : this) {\n            element.tagName(tagName);\n        }\n        return this;\n    }",
        "begin_line": 298,
        "end_line": 303,
        "comment": "\n     * Update the tag name of each matched element. For example, to change each {@code <i>} to a {@code <em>}, do\n     * {@code doc.select(\"i\").tagName(\"em\");}\n     * @param tagName the new tag name\n     * @return this, for chaining\n     * @see Element#tagName(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.html(java.lang.String)",
        "snippet": "    public Elements html(String html) {\n        for (Element element : this) {\n            element.html(html);\n        }\n        return this;\n    }",
        "begin_line": 311,
        "end_line": 316,
        "comment": "\n     * Set the inner HTML of each matched element.\n     * @param html HTML to parse and set into each matched element.\n     * @return this, for chaining\n     * @see Element#html(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.prepend(java.lang.String)",
        "snippet": "    public Elements prepend(String html) {\n        for (Element element : this) {\n            element.prepend(html);\n        }\n        return this;\n    }",
        "begin_line": 324,
        "end_line": 329,
        "comment": "\n     * Add the supplied HTML to the start of each matched element's inner HTML.\n     * @param html HTML to add inside each element, before the existing HTML\n     * @return this, for chaining\n     * @see Element#prepend(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.append(java.lang.String)",
        "snippet": "    public Elements append(String html) {\n        for (Element element : this) {\n            element.append(html);\n        }\n        return this;\n    }",
        "begin_line": 337,
        "end_line": 342,
        "comment": "\n     * Add the supplied HTML to the end of each matched element's inner HTML.\n     * @param html HTML to add inside each element, after the existing HTML\n     * @return this, for chaining\n     * @see Element#append(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.before(java.lang.String)",
        "snippet": "    public Elements before(String html) {\n        for (Element element : this) {\n            element.before(html);\n        }\n        return this;\n    }",
        "begin_line": 350,
        "end_line": 355,
        "comment": "\n     * Insert the supplied HTML before each matched element's outer HTML.\n     * @param html HTML to insert before each element\n     * @return this, for chaining\n     * @see Element#before(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.after(java.lang.String)",
        "snippet": "    public Elements after(String html) {\n        for (Element element : this) {\n            element.after(html);\n        }\n        return this;\n    }",
        "begin_line": 363,
        "end_line": 368,
        "comment": "\n     * Insert the supplied HTML after each matched element's outer HTML.\n     * @param html HTML to insert after each element\n     * @return this, for chaining\n     * @see Element#after(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.wrap(java.lang.String)",
        "snippet": "    public Elements wrap(String html) {\n        Validate.notEmpty(html);\n        for (Element element : this) {\n            element.wrap(html);\n        }\n        return this;\n    }",
        "begin_line": 379,
        "end_line": 385,
        "comment": "\n     Wrap the supplied HTML around each matched elements. For example, with HTML\n     {@code <p><b>This</b> is <b>Jsoup</b></p>},\n     <code>doc.select(\"b\").wrap(\"&lt;i&gt;&lt;/i&gt;\");</code>\n     becomes {@code <p><i><b>This</b></i> is <i><b>jsoup</b></i></p>}\n     @param html HTML to wrap around each element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this (for chaining)\n     @see Element#wrap\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.unwrap()",
        "snippet": "    public Elements unwrap() {\n        for (Element element : this) {\n            element.unwrap();\n        }\n        return this;\n    }",
        "begin_line": 401,
        "end_line": 406,
        "comment": "\n     * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of\n     * dropping the elements but keeping their children.\n     * <p>\n     * This is useful for e.g removing unwanted formatting elements but keeping their contents.\n     * </p>\n     * \n     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n     * <p>{@code doc.select(\"font\").unwrap();}</p>\n     * <p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n     *\n     * @return this (for chaining)\n     * @see Node#unwrap\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.empty()",
        "snippet": "    public Elements empty() {\n        for (Element element : this) {\n            element.empty();\n        }\n        return this;\n    }",
        "begin_line": 419,
        "end_line": 424,
        "comment": "\n     * Empty (remove all child nodes from) each matched element. This is similar to setting the inner HTML of each\n     * element to nothing.\n     * <p>\n     * E.g. HTML: {@code <div><p>Hello <b>there</b></p> <p>now</p></div>}<br>\n     * <code>doc.select(\"p\").empty();</code><br>\n     * HTML = {@code <div><p></p> <p></p></div>}\n     * @return this, for chaining\n     * @see Element#empty()\n     * @see #remove()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.remove()",
        "snippet": "    public Elements remove() {\n        for (Element element : this) {\n            element.remove();\n        }\n        return this;\n    }",
        "begin_line": 438,
        "end_line": 443,
        "comment": "\n     * Remove each matched element from the DOM. This is similar to setting the outer HTML of each element to nothing.\n     * <p>\n     * E.g. HTML: {@code <div><p>Hello</p> <p>there</p> <img /></div>}<br>\n     * <code>doc.select(\"p\").remove();</code><br>\n     * HTML = {@code <div> <img /></div>}\n     * <p>\n     * Note that this method should not be used to clean user-submitted HTML; rather, use {@link org.jsoup.safety.Cleaner} to clean HTML.\n     * @return this, for chaining\n     * @see Element#empty()\n     * @see #empty()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.select(java.lang.String)",
        "snippet": "    public Elements select(String query) {\n        return Selector.select(query, this);\n    }",
        "begin_line": 452,
        "end_line": 454,
        "comment": "\n     * Find matching elements within this element list.\n     * @param query A {@link Selector} query\n     * @return the filtered list of elements, or an empty list if none match.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.not(java.lang.String)",
        "snippet": "    public Elements not(String query) {\n        Elements out = Selector.select(query, this);\n        return Selector.filterOut(this, out);\n    }",
        "begin_line": 466,
        "end_line": 469,
        "comment": "\n     * Remove elements from this list that match the {@link Selector} query.\n     * <p>\n     * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>\n     * <code>Elements divs = doc.select(\"div\").not(\".logo\");</code><br>\n     * Result: {@code divs: [<div>Two</div>]}\n     * <p>\n     * @param query the selector query whose results should be removed from these elements\n     * @return a new elements list that contains only the filtered results\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.eq(int)",
        "snippet": "    public Elements eq(int index) {\n        return size() > index ? new Elements(get(index)) : new Elements();\n    }",
        "begin_line": 478,
        "end_line": 480,
        "comment": "\n     * Get the <i>nth</i> matched element as an Elements object.\n     * <p>\n     * See also {@link #get(int)} to retrieve an Element.\n     * @param index the (zero-based) index of the element in the list to retain\n     * @return Elements containing only the specified element, or, if that element did not exist, an empty list.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.is(java.lang.String)",
        "snippet": "    public boolean is(String query) {\n        Evaluator eval = QueryParser.parse(query);\n        for (Element e : this) {\n            if (e.is(eval))\n                return true;\n        }\n        return false;\n    }",
        "begin_line": 487,
        "end_line": 494,
        "comment": "\n     * Test if any of the matched elements match the supplied query.\n     * @param query A selector\n     * @return true if at least one element in the list matches the query.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.next()",
        "snippet": "    public Elements next() {\n        return siblings(null, true, false);\n    }",
        "begin_line": 500,
        "end_line": 502,
        "comment": "\n     * Get the immediate next element sibling of each element in this list.\n     * @return next element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.next(java.lang.String)",
        "snippet": "    public Elements next(String query) {\n        return siblings(query, true, false);\n    }",
        "begin_line": 509,
        "end_line": 511,
        "comment": "\n     * Get the immediate next element sibling of each element in this list, filtered by the query.\n     * @param query CSS query to match siblings against\n     * @return next element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.nextAll()",
        "snippet": "    public Elements nextAll() {\n        return siblings(null, true, true);\n    }",
        "begin_line": 517,
        "end_line": 519,
        "comment": "\n     * Get each of the following element siblings of each element in this list.\n     * @return all following element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.nextAll(java.lang.String)",
        "snippet": "    public Elements nextAll(String query) {\n        return siblings(query, true, true);\n    }",
        "begin_line": 526,
        "end_line": 528,
        "comment": "\n     * Get each of the following element siblings of each element in this list, that match the query.\n     * @param query CSS query to match siblings against\n     * @return all following element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.prev()",
        "snippet": "    public Elements prev() {\n        return siblings(null, false, false);\n    }",
        "begin_line": 534,
        "end_line": 536,
        "comment": "\n     * Get the immediate previous element sibling of each element in this list.\n     * @return previous element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.prev(java.lang.String)",
        "snippet": "    public Elements prev(String query) {\n        return siblings(query, false, false);\n    }",
        "begin_line": 543,
        "end_line": 545,
        "comment": "\n     * Get the immediate previous element sibling of each element in this list, filtered by the query.\n     * @param query CSS query to match siblings against\n     * @return previous element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.prevAll()",
        "snippet": "    public Elements prevAll() {\n        return siblings(null, false, true);\n    }",
        "begin_line": 551,
        "end_line": 553,
        "comment": "\n     * Get each of the previous element siblings of each element in this list.\n     * @return all previous element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.prevAll(java.lang.String)",
        "snippet": "    public Elements prevAll(String query) {\n        return siblings(query, false, true);\n    }",
        "begin_line": 560,
        "end_line": 562,
        "comment": "\n     * Get each of the previous element siblings of each element in this list, that match the query.\n     * @param query CSS query to match siblings against\n     * @return all previous element siblings.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.siblings(java.lang.String, boolean, boolean)",
        "snippet": "    private Elements siblings(String query, boolean next, boolean all) {\n        Elements els = new Elements();\n        Evaluator eval = query != null? QueryParser.parse(query) : null;\n        for (Element e : this) {\n            do {\n                Element sib = next ? e.nextElementSibling() : e.previousElementSibling();\n                if (sib == null) break;\n                if (eval == null)\n                    els.add(sib);\n                else if (sib.is(eval))\n                    els.add(sib);\n                e = sib;\n            } while (all);\n        }\n        return els;\n    }",
        "begin_line": 564,
        "end_line": 579,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.parents()",
        "snippet": "    public Elements parents() {\n        HashSet<Element> combo = new LinkedHashSet<>();\n        for (Element e: this) {\n            combo.addAll(e.parents());\n        }\n        return new Elements(combo);\n    }",
        "begin_line": 585,
        "end_line": 591,
        "comment": "\n     * Get all of the parents and ancestor elements of the matched elements.\n     * @return all of the parents and ancestor elements of the matched elements\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.first()",
        "snippet": "    public Element first() {\n        return isEmpty() ? null : get(0);\n    }",
        "begin_line": 598,
        "end_line": 600,
        "comment": "\n     Get the first matched element.\n     @return The first matched element, or <code>null</code> if contents is empty.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.last()",
        "snippet": "    public Element last() {\n        return isEmpty() ? null : get(size() - 1);\n    }",
        "begin_line": 606,
        "end_line": 608,
        "comment": "\n     Get the last matched element.\n     @return The last matched element, or <code>null</code> if contents is empty.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.traverse(org.jsoup.select.NodeVisitor)",
        "snippet": "    public Elements traverse(NodeVisitor nodeVisitor) {\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }",
        "begin_line": 615,
        "end_line": 618,
        "comment": "\n     * Perform a depth-first traversal on each of the selected elements.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.filter(org.jsoup.select.NodeFilter)",
        "snippet": "    public Elements filter(NodeFilter nodeFilter) {\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }",
        "begin_line": 625,
        "end_line": 628,
        "comment": "\n     * Perform a depth-first filtering on each of the selected elements.\n     * @param nodeFilter the filter callbacks to perform on each node\n     * @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Elements.java",
        "class_name": "org.jsoup.select.Elements",
        "signature": "org.jsoup.select.Elements.forms()",
        "snippet": "    public List<FormElement> forms() {\n        ArrayList<FormElement> forms = new ArrayList<>();\n        for (Element el: this)\n            if (el instanceof FormElement)\n                forms.add((FormElement) el);\n        return forms;\n    }",
        "begin_line": 635,
        "end_line": 641,
        "comment": "\n     * Get the {@link FormElement} forms from the selected elements, if any.\n     * @return a list of {@link FormElement}s pulled from the matched elements. The list will be empty if the elements contain\n     * no forms.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeVisitor.java",
        "class_name": "org.jsoup.select.NodeVisitor",
        "signature": "org.jsoup.select.NodeVisitor.head(org.jsoup.nodes.Node, int)",
        "snippet": "    void head(Node node, int depth);",
        "begin_line": 21,
        "end_line": 21,
        "comment": "\n     * Callback for when a node is first visited.\n     *\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n     * of that will have depth 1.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeVisitor.java",
        "class_name": "org.jsoup.select.NodeVisitor",
        "signature": "org.jsoup.select.NodeVisitor.tail(org.jsoup.nodes.Node, int)",
        "snippet": "    void tail(Node node, int depth);",
        "begin_line": 30,
        "end_line": 30,
        "comment": "\n     * Callback for when a node is last visited, after all of its descendants have been visited.\n     *\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n     * of that will have depth 1.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Root.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            return root == element;\n        }",
        "begin_line": 12,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Has.Has(org.jsoup.select.Evaluator)",
        "snippet": "        public Has(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Has.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            for (Element e : element.getAllElements()) {\n                if (e != element && evaluator.matches(root, e))\n                    return true;\n            }\n            return false;\n        }",
        "begin_line": 22,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Has.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":has(%s)\", evaluator);\n        }",
        "begin_line": 30,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Not.Not(org.jsoup.select.Evaluator)",
        "snippet": "        public Not(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Not.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element node) {\n            return !evaluator.matches(root, node);\n        }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Not.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":not%s\", evaluator);\n        }",
        "begin_line": 45,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Parent.Parent(org.jsoup.select.Evaluator)",
        "snippet": "        public Parent(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Parent.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element parent = element.parent();\n            while (true) {\n                if (evaluator.matches(root, parent))\n                    return true;\n                if (parent == root)\n                    break;\n                parent = parent.parent();\n            }\n            return false;\n        }",
        "begin_line": 56,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.Parent.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":parent%s\", evaluator);\n        }",
        "begin_line": 71,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediateParent.ImmediateParent(org.jsoup.select.Evaluator)",
        "snippet": "        public ImmediateParent(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediateParent.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element parent = element.parent();\n            return parent != null && evaluator.matches(root, parent);\n        }",
        "begin_line": 82,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediateParent.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":ImmediateParent%s\", evaluator);\n        }",
        "begin_line": 90,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.PreviousSibling.PreviousSibling(org.jsoup.select.Evaluator)",
        "snippet": "        public PreviousSibling(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 97,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.PreviousSibling.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n\n            while (prev != null) {\n                if (evaluator.matches(root, prev))\n                    return true;\n\n                prev = prev.previousElementSibling();\n            }\n            return false;\n        }",
        "begin_line": 101,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.PreviousSibling.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":prev*%s\", evaluator);\n        }",
        "begin_line": 116,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling.ImmediatePreviousSibling(org.jsoup.select.Evaluator)",
        "snippet": "        public ImmediatePreviousSibling(Evaluator evaluator) {\n            this.evaluator = evaluator;\n        }",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        public boolean matches(Element root, Element element) {\n            if (root == element)\n                return false;\n\n            Element prev = element.previousElementSibling();\n            return prev != null && evaluator.matches(root, prev);\n        }",
        "begin_line": 127,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/StructuralEvaluator.java",
        "class_name": "org.jsoup.select.StructuralEvaluator",
        "signature": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":prev%s\", evaluator);\n        }",
        "begin_line": 135,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeFilter.java",
        "class_name": "org.jsoup.select.NodeFilter",
        "signature": "org.jsoup.select.NodeFilter.head(org.jsoup.nodes.Node, int)",
        "snippet": "    FilterResult head(Node node, int depth);",
        "begin_line": 49,
        "end_line": 49,
        "comment": "\n     * Callback for when a node is first visited.\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n     * @return Filter decision\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeFilter.java",
        "class_name": "org.jsoup.select.NodeFilter",
        "signature": "org.jsoup.select.NodeFilter.tail(org.jsoup.nodes.Node, int)",
        "snippet": "    FilterResult tail(Node node, int depth);",
        "begin_line": 57,
        "end_line": 57,
        "comment": "\n     * Callback for when a node is last visited, after all of its descendants have been visited.\n     * @param node the node being visited.\n     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n     * @return Filter decision\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Evaluator()",
        "snippet": "    protected Evaluator() {\n    }",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    public abstract boolean matches(Element root, Element element);",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Test if the element meets the evaluator's requirements.\n     *\n     * @param root    Root of the matching subtree\n     * @param element tested element\n     * @return Returns <tt>true</tt> if the requirements are met or\n     * <tt>false</tt> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Tag.Tag(java.lang.String)",
        "snippet": "        public Tag(String tagName) {\n            this.tagName = tagName;\n        }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Tag.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.tagName().equalsIgnoreCase(tagName));\n        }",
        "begin_line": 48,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Tag.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }",
        "begin_line": 53,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.TagEndsWith.TagEndsWith(java.lang.String)",
        "snippet": "        public TagEndsWith(String tagName) {\n            this.tagName = tagName;\n        }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.TagEndsWith.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.tagName().endsWith(tagName));\n        }",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.TagEndsWith.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"%s\", tagName);\n        }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Id.Id(java.lang.String)",
        "snippet": "        public Id(String id) {\n            this.id = id;\n        }",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Id.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (id.equals(element.id()));\n        }",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Id.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"#%s\", id);\n        }",
        "begin_line": 96,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Class.Class(java.lang.String)",
        "snippet": "        public Class(String className) {\n            this.className = className;\n        }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Class.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return (element.hasClass(className));\n        }",
        "begin_line": 113,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Class.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\".%s\", className);\n        }",
        "begin_line": 118,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Attribute.Attribute(java.lang.String)",
        "snippet": "        public Attribute(String key) {\n            this.key = key;\n        }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Attribute.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key);\n        }",
        "begin_line": 135,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Attribute.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s]\", key);\n        }",
        "begin_line": 140,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeStarting.AttributeStarting(java.lang.String)",
        "snippet": "        public AttributeStarting(String keyPrefix) {\n            Validate.notEmpty(keyPrefix);\n            this.keyPrefix = lowerCase(keyPrefix);\n        }",
        "begin_line": 153,
        "end_line": 156,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeStarting.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n            for (org.jsoup.nodes.Attribute attribute : values) {\n                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                    return true;\n            }\n            return false;\n        }",
        "begin_line": 158,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeStarting.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[^%s]\", keyPrefix);\n        }",
        "begin_line": 168,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValue.AttributeWithValue(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeWithValue(String key, String value) {\n            super(key, value);\n        }",
        "begin_line": 179,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValue.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n        }",
        "begin_line": 183,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValue.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s=%s]\", key, value);\n        }",
        "begin_line": 188,
        "end_line": 191,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueNot.AttributeWithValueNot(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeWithValueNot(String key, String value) {\n            super(key, value);\n        }",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueNot.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return !value.equalsIgnoreCase(element.attr(key));\n        }",
        "begin_line": 203,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueNot.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s!=%s]\", key, value);\n        }",
        "begin_line": 208,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueStarting.AttributeWithValueStarting(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeWithValueStarting(String key, String value) {\n            super(key, value);\n        }",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueStarting.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n        }",
        "begin_line": 223,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueStarting.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s^=%s]\", key, value);\n        }",
        "begin_line": 228,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueEnding.AttributeWithValueEnding(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeWithValueEnding(String key, String value) {\n            super(key, value);\n        }",
        "begin_line": 239,
        "end_line": 241,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueEnding.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n        }",
        "begin_line": 243,
        "end_line": 246,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueEnding.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s$=%s]\", key, value);\n        }",
        "begin_line": 248,
        "end_line": 251,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueContaining.AttributeWithValueContaining(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeWithValueContaining(String key, String value) {\n            super(key, value);\n        }",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueContaining.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n        }",
        "begin_line": 263,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueContaining.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s*=%s]\", key, value);\n        }",
        "begin_line": 268,
        "end_line": 271,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueMatching.AttributeWithValueMatching(java.lang.String, java.util.regex.Pattern)",
        "snippet": "        public AttributeWithValueMatching(String key, Pattern pattern) {\n            this.key = normalize(key);\n            this.pattern = pattern;\n        }",
        "begin_line": 282,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueMatching.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n        }",
        "begin_line": 287,
        "end_line": 290,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeWithValueMatching.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\"[%s~=%s]\", key, pattern.toString());\n        }",
        "begin_line": 292,
        "end_line": 295,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AttributeKeyPair.AttributeKeyPair(java.lang.String, java.lang.String)",
        "snippet": "        public AttributeKeyPair(String key, String value) {\n            Validate.notEmpty(key);\n            Validate.notEmpty(value);\n\n            this.key = normalize(key);\n            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")\n                    || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n                value = value.substring(1, value.length()-1);\n            }\n            this.value = normalize(value);\n        }",
        "begin_line": 306,
        "end_line": 316,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AllElements.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return true;\n        }",
        "begin_line": 324,
        "end_line": 327,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.AllElements.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"*\";\n        }",
        "begin_line": 329,
        "end_line": 332,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexLessThan.IndexLessThan(int)",
        "snippet": "        public IndexLessThan(int index) {\n            super(index);\n        }",
        "begin_line": 339,
        "end_line": 341,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexLessThan.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return root != element && element.elementSiblingIndex() < index;\n        }",
        "begin_line": 343,
        "end_line": 346,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexLessThan.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":lt(%d)\", index);\n        }",
        "begin_line": 348,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexGreaterThan.IndexGreaterThan(int)",
        "snippet": "        public IndexGreaterThan(int index) {\n            super(index);\n        }",
        "begin_line": 359,
        "end_line": 361,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexGreaterThan.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() > index;\n        }",
        "begin_line": 363,
        "end_line": 366,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexGreaterThan.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":gt(%d)\", index);\n        }",
        "begin_line": 368,
        "end_line": 371,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexEquals.IndexEquals(int)",
        "snippet": "        public IndexEquals(int index) {\n            super(index);\n        }",
        "begin_line": 379,
        "end_line": 381,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexEquals.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return element.elementSiblingIndex() == index;\n        }",
        "begin_line": 383,
        "end_line": 386,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexEquals.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":eq(%d)\", index);\n        }",
        "begin_line": 388,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsLastChild.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p != null && !(p instanceof Document) && element.elementSiblingIndex() == p.children().size()-1;\n\t\t}",
        "begin_line": 399,
        "end_line": 403,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsLastChild.toString()",
        "snippet": "\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-child\";\n\t\t}",
        "begin_line": 405,
        "end_line": 408,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsFirstOfType.IsFirstOfType()",
        "snippet": "\t\tpublic IsFirstOfType() {\n\t\t\tsuper(0,1);\n\t\t}",
        "begin_line": 412,
        "end_line": 414,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsFirstOfType.toString()",
        "snippet": "\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":first-of-type\";\n\t\t}",
        "begin_line": 415,
        "end_line": 418,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsLastOfType.IsLastOfType()",
        "snippet": "\t\tpublic IsLastOfType() {\n\t\t\tsuper(0,1);\n\t\t}",
        "begin_line": 422,
        "end_line": 424,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsLastOfType.toString()",
        "snippet": "\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \":last-of-type\";\n\t\t}",
        "begin_line": 425,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.CssNthEvaluator(int, int)",
        "snippet": "    \tpublic CssNthEvaluator(int a, int b) {\n    \t\tthis.a = a;\n    \t\tthis.b = b;\n    \t}",
        "begin_line": 435,
        "end_line": 438,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.CssNthEvaluator(int)",
        "snippet": "    \tpublic CssNthEvaluator(int b) {\n    \t\tthis(0,b);\n    \t}",
        "begin_line": 439,
        "end_line": 441,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\tif (p == null || (p instanceof Document)) return false;\n    \t\t\n    \t\tfinal int pos = calculatePosition(root, element);\n    \t\tif (a == 0) return pos == b;\n    \t\t\n    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n    \t}",
        "begin_line": 443,
        "end_line": 452,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.toString()",
        "snippet": "\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (a == 0)\n\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n\t\t\tif (b == 0)\n\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n\t\t}",
        "begin_line": 454,
        "end_line": 461,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.getPseudoClass()",
        "snippet": "\t\tprotected abstract String getPseudoClass();",
        "begin_line": 463,
        "end_line": 463,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.CssNthEvaluator.calculatePosition(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\tprotected abstract int calculatePosition(Element root, Element element);",
        "begin_line": 464,
        "end_line": 464,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthChild.IsNthChild(int, int)",
        "snippet": "    \tpublic IsNthChild(int a, int b) {\n    \t\tsuper(a,b);\n\t\t}",
        "begin_line": 475,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthChild.calculatePosition(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\tprotected int calculatePosition(Element root, Element element) {\n\t\t\treturn element.elementSiblingIndex()+1;\n\t\t}",
        "begin_line": 479,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthChild.getPseudoClass()",
        "snippet": "\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-child\";\n\t\t}",
        "begin_line": 484,
        "end_line": 486,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastChild.IsNthLastChild(int, int)",
        "snippet": "    \tpublic IsNthLastChild(int a, int b) {\n    \t\tsuper(a,b);\n    \t}",
        "begin_line": 495,
        "end_line": 497,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastChild.calculatePosition(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        protected int calculatePosition(Element root, Element element) {\n        \treturn element.parent().children().size() - element.elementSiblingIndex();\n        }",
        "begin_line": 499,
        "end_line": 502,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastChild.getPseudoClass()",
        "snippet": "\t\t@Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-last-child\";\n\t\t}",
        "begin_line": 504,
        "end_line": 507,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthOfType.IsNthOfType(int, int)",
        "snippet": "    \tpublic IsNthOfType(int a, int b) {\n    \t\tsuper(a,b);\n    \t}",
        "begin_line": 515,
        "end_line": 517,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthOfType.calculatePosition(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\tprotected int calculatePosition(Element root, Element element) {\n\t\t\tint pos = 0;\n        \tElements family = element.parent().children();\n            for (Element el : family) {\n                if (el.tag().equals(element.tag())) pos++;\n                if (el == element) break;\n            }\n\t\t\treturn pos;\n\t\t}",
        "begin_line": 519,
        "end_line": 527,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthOfType.getPseudoClass()",
        "snippet": "\t\t@Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-of-type\";\n\t\t}",
        "begin_line": 529,
        "end_line": 532,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastOfType.IsNthLastOfType(int, int)",
        "snippet": "\t\tpublic IsNthLastOfType(int a, int b) {\n\t\t\tsuper(a, b);\n\t\t}",
        "begin_line": 537,
        "end_line": 539,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastOfType.calculatePosition(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\t@Override\n\t\tprotected int calculatePosition(Element root, Element element) {\n\t\t\tint pos = 0;\n        \tElements family = element.parent().children();\n        \tfor (int i = element.elementSiblingIndex(); i < family.size(); i++) {\n        \t\tif (family.get(i).tag().equals(element.tag())) pos++;\n        \t}\n\t\t\treturn pos;\n\t\t}",
        "begin_line": 541,
        "end_line": 549,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsNthLastOfType.getPseudoClass()",
        "snippet": "\t\t@Override\n\t\tprotected String getPseudoClass() {\n\t\t\treturn \"nth-last-of-type\";\n\t\t}",
        "begin_line": 551,
        "end_line": 554,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsFirstChild.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element p = element.parent();\n    \t\treturn p != null && !(p instanceof Document) && element.elementSiblingIndex() == 0;\n    \t}",
        "begin_line": 561,
        "end_line": 565,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsFirstChild.toString()",
        "snippet": "    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":first-child\";\n    \t}",
        "begin_line": 567,
        "end_line": 570,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsRoot.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    \t@Override\n    \tpublic boolean matches(Element root, Element element) {\n    \t\tfinal Element r = root instanceof Document?root.child(0):root;\n    \t\treturn element == r;\n    \t}",
        "begin_line": 579,
        "end_line": 583,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsRoot.toString()",
        "snippet": "    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":root\";\n    \t}",
        "begin_line": 584,
        "end_line": 587,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsOnlyChild.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().size() == 0;\n\t\t}",
        "begin_line": 591,
        "end_line": 595,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsOnlyChild.toString()",
        "snippet": "    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-child\";\n    \t}",
        "begin_line": 596,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsOnlyOfType.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n\t\t\tfinal Element p = element.parent();\n\t\t\tif (p==null || p instanceof Document) return false;\n\t\t\t\n\t\t\tint pos = 0;\n        \tElements family = p.children();\n            for (Element el : family) {\n                if (el.tag().equals(element.tag())) pos++;\n            }\n        \treturn pos == 1;\n\t\t}",
        "begin_line": 603,
        "end_line": 614,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsOnlyOfType.toString()",
        "snippet": "    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":only-of-type\";\n    \t}",
        "begin_line": 615,
        "end_line": 618,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsEmpty.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "\t\t@Override\n\t\tpublic boolean matches(Element root, Element element) {\n        \tList<Node> family = element.childNodes();\n            for (Node n : family) {\n                if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType)) return false;\n            }\n        \treturn true;\n\t\t}",
        "begin_line": 622,
        "end_line": 629,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IsEmpty.toString()",
        "snippet": "    \t@Override\n    \tpublic String toString() {\n    \t\treturn \":empty\";\n    \t}",
        "begin_line": 630,
        "end_line": 633,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.IndexEvaluator.IndexEvaluator(int)",
        "snippet": "        public IndexEvaluator(int index) {\n            this.index = index;\n        }",
        "begin_line": 644,
        "end_line": 646,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsText.ContainsText(java.lang.String)",
        "snippet": "        public ContainsText(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }",
        "begin_line": 655,
        "end_line": 657,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsText.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.text()).contains(searchText);\n        }",
        "begin_line": 659,
        "end_line": 662,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsText.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":contains(%s)\", searchText);\n        }",
        "begin_line": 664,
        "end_line": 667,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsData.ContainsData(java.lang.String)",
        "snippet": "        public ContainsData(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }",
        "begin_line": 676,
        "end_line": 678,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsData.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.data()).contains(searchText);\n        }",
        "begin_line": 680,
        "end_line": 683,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsData.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":containsData(%s)\", searchText);\n        }",
        "begin_line": 685,
        "end_line": 688,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsOwnText.ContainsOwnText(java.lang.String)",
        "snippet": "        public ContainsOwnText(String searchText) {\n            this.searchText = lowerCase(searchText);\n        }",
        "begin_line": 697,
        "end_line": 699,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsOwnText.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            return lowerCase(element.ownText()).contains(searchText);\n        }",
        "begin_line": 701,
        "end_line": 704,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.ContainsOwnText.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":containsOwn(%s)\", searchText);\n        }",
        "begin_line": 706,
        "end_line": 709,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Matches.Matches(java.util.regex.Pattern)",
        "snippet": "        public Matches(Pattern pattern) {\n            this.pattern = pattern;\n        }",
        "begin_line": 718,
        "end_line": 720,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Matches.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.text());\n            return m.find();\n        }",
        "begin_line": 722,
        "end_line": 726,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.Matches.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":matches(%s)\", pattern);\n        }",
        "begin_line": 728,
        "end_line": 731,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.MatchesOwn.MatchesOwn(java.util.regex.Pattern)",
        "snippet": "        public MatchesOwn(Pattern pattern) {\n            this.pattern = pattern;\n        }",
        "begin_line": 740,
        "end_line": 742,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.MatchesOwn.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            Matcher m = pattern.matcher(element.ownText());\n            return m.find();\n        }",
        "begin_line": 744,
        "end_line": 748,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.MatchesOwn.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return String.format(\":matchesOwn(%s)\", pattern);\n        }",
        "begin_line": 750,
        "end_line": 753,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.MatchText.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element element) {\n            if (element instanceof PseudoTextElement)\n                return true;\n\n            List<TextNode> textNodes = element.textNodes();\n            for (TextNode textNode : textNodes) {\n                PseudoTextElement pel = new PseudoTextElement(\n                    org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes());\n                textNode.replaceWith(pel);\n                pel.appendChild(textNode);\n            }\n            return false;\n        }",
        "begin_line": 758,
        "end_line": 771,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Evaluator.java",
        "class_name": "org.jsoup.select.Evaluator",
        "signature": "org.jsoup.select.Evaluator.MatchText.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \":matchText\";\n        }",
        "begin_line": 773,
        "end_line": 776,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.CombiningEvaluator()",
        "snippet": "    CombiningEvaluator() {\n        super();\n        evaluators = new ArrayList<>();\n    }",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.CombiningEvaluator(java.util.Collection<org.jsoup.select.Evaluator>)",
        "snippet": "    CombiningEvaluator(Collection<Evaluator> evaluators) {\n        this();\n        this.evaluators.addAll(evaluators);\n        updateNumEvaluators();\n    }",
        "begin_line": 22,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.rightMostEvaluator()",
        "snippet": "    Evaluator rightMostEvaluator() {\n        return num > 0 ? evaluators.get(num - 1) : null;\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.replaceRightMostEvaluator(org.jsoup.select.Evaluator)",
        "snippet": "    void replaceRightMostEvaluator(Evaluator replacement) {\n        evaluators.set(num - 1, replacement);\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.updateNumEvaluators()",
        "snippet": "    void updateNumEvaluators() {\n        // used so we don't need to bash on size() for every match test\n        num = evaluators.size();\n    }",
        "begin_line": 36,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.And.And(java.util.Collection<org.jsoup.select.Evaluator>)",
        "snippet": "        And(Collection<Evaluator> evaluators) {\n            super(evaluators);\n        }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.And.And(org.jsoup.select.Evaluator...)",
        "snippet": "        And(Evaluator... evaluators) {\n            this(Arrays.asList(evaluators));\n        }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.And.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element node) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = evaluators.get(i);\n                if (!s.matches(root, node))\n                    return false;\n            }\n            return true;\n        }",
        "begin_line": 50,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.And.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \" \");\n        }",
        "begin_line": 60,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.Or(java.util.Collection<org.jsoup.select.Evaluator>)",
        "snippet": "        Or(Collection<Evaluator> evaluators) {\n            super();\n            if (num > 1)\n                this.evaluators.add(new And(evaluators));\n            else // 0 or 1\n                this.evaluators.addAll(evaluators);\n            updateNumEvaluators();\n        }",
        "begin_line": 71,
        "end_line": 78,
        "comment": "\n         * Create a new Or evaluator. The initial evaluators are ANDed together and used as the first clause of the OR.\n         * @param evaluators initial OR clause (these are wrapped into an AND evaluator).\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.Or(org.jsoup.select.Evaluator...)",
        "snippet": "        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }",
        "begin_line": 80,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.Or()",
        "snippet": "        Or() {\n            super();\n        }",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.add(org.jsoup.select.Evaluator)",
        "snippet": "        public void add(Evaluator e) {\n            evaluators.add(e);\n            updateNumEvaluators();\n        }",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.matches(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        @Override\n        public boolean matches(Element root, Element node) {\n            for (int i = 0; i < num; i++) {\n                Evaluator s = evaluators.get(i);\n                if (s.matches(root, node))\n                    return true;\n            }\n            return false;\n        }",
        "begin_line": 91,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/CombiningEvaluator.java",
        "class_name": "org.jsoup.select.CombiningEvaluator",
        "signature": "org.jsoup.select.CombiningEvaluator.Or.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return StringUtil.join(evaluators, \", \");\n        }",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.NodeTraversor(org.jsoup.select.NodeVisitor)",
        "snippet": "    public NodeTraversor(NodeVisitor visitor) {\n        this.visitor = visitor;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "\n     * Create a new traversor.\n     * @param visitor a class implementing the {@link NodeVisitor} interface, to be called when visiting each node.\n     * @deprecated Just use the static {@link NodeTraversor#filter(NodeFilter, Node)} method.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.traverse(org.jsoup.nodes.Node)",
        "snippet": "    public void traverse(Node root) {\n        traverse(visitor, root);\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "\n     * Start a depth-first traverse of the root and all of its descendants.\n     * @param root the root node point to traverse.\n     * @deprecated Just use the static {@link NodeTraversor#filter(NodeFilter, Node)} method.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.traverse(org.jsoup.select.NodeVisitor, org.jsoup.nodes.Node)",
        "snippet": "    public static void traverse(NodeVisitor visitor, Node root) {\n        Node node = root;\n        int depth = 0;\n        \n        while (node != null) {\n            visitor.head(node, depth);\n            if (node.childNodeSize() > 0) {\n                node = node.childNode(0);\n                depth++;\n            } else {\n                while (node.nextSibling() == null && depth > 0) {\n                    visitor.tail(node, depth);\n                    node = node.parentNode();\n                    depth--;\n                }\n                visitor.tail(node, depth);\n                if (node == root)\n                    break;\n                node = node.nextSibling();\n            }\n        }\n    }",
        "begin_line": 40,
        "end_line": 61,
        "comment": "\n     * Start a depth-first traverse of the root and all of its descendants.\n     * @param visitor Node visitor.\n     * @param root the root node point to traverse.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.traverse(org.jsoup.select.NodeVisitor, org.jsoup.select.Elements)",
        "snippet": "    public static void traverse(NodeVisitor visitor, Elements elements) {\n        Validate.notNull(visitor);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            traverse(visitor, el);\n    }",
        "begin_line": 68,
        "end_line": 73,
        "comment": "\n     * Start a depth-first traverse of all elements.\n     * @param visitor Node visitor.\n     * @param elements Elements to filter.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.filter(org.jsoup.select.NodeFilter, org.jsoup.nodes.Node)",
        "snippet": "    public static FilterResult filter(NodeFilter filter, Node root) {\n        Node node = root;\n        int depth = 0;\n\n        while (node != null) {\n            FilterResult result = filter.head(node, depth);\n            if (result == FilterResult.STOP)\n                return result;\n            // Descend into child nodes:\n            if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {\n                node = node.childNode(0);\n                ++depth;\n                continue;\n            }\n            // No siblings, move upwards:\n            while (node.nextSibling() == null && depth > 0) {\n                // 'tail' current node:\n                if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                    result = filter.tail(node, depth);\n                    if (result == FilterResult.STOP)\n                        return result;\n                }\n                Node prev = node; // In case we need to remove it below.\n                node = node.parentNode();\n                depth--;\n                if (result == FilterResult.REMOVE)\n                    prev.remove(); // Remove AFTER finding parent.\n                result = FilterResult.CONTINUE; // Parent was not pruned.\n            }\n            // 'tail' current node, then proceed with siblings:\n            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                result = filter.tail(node, depth);\n                if (result == FilterResult.STOP)\n                    return result;\n            }\n            if (node == root)\n                return result;\n            Node prev = node; // In case we need to remove it below.\n            node = node.nextSibling();\n            if (result == FilterResult.REMOVE)\n                prev.remove(); // Remove AFTER finding sibling.\n        }\n        // root == null?\n        return FilterResult.CONTINUE;\n    }",
        "begin_line": 81,
        "end_line": 125,
        "comment": "\n     * Start a depth-first filtering of the root and all of its descendants.\n     * @param filter Node visitor.\n     * @param root the root node point to traverse.\n     * @return The filter result of the root node, or {@link FilterResult#STOP}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/NodeTraversor.java",
        "class_name": "org.jsoup.select.NodeTraversor",
        "signature": "org.jsoup.select.NodeTraversor.filter(org.jsoup.select.NodeFilter, org.jsoup.select.Elements)",
        "snippet": "    public static void filter(NodeFilter filter, Elements elements) {\n        Validate.notNull(filter);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            if (filter(filter, el) == FilterResult.STOP)\n                break;\n    }",
        "begin_line": 132,
        "end_line": 138,
        "comment": "\n     * Start a depth-first filtering of all elements.\n     * @param filter Node filter.\n     * @param elements Elements to filter.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.Selector()",
        "snippet": "    private Selector() {}",
        "begin_line": 79,
        "end_line": 79,
        "comment": " not instantiable",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.select(java.lang.String, org.jsoup.nodes.Element)",
        "snippet": "    public static Elements select(String query, Element root) {\n        Validate.notEmpty(query);\n        return select(QueryParser.parse(query), root);\n    }",
        "begin_line": 89,
        "end_line": 92,
        "comment": "\n     * Find elements matching selector.\n     *\n     * @param query CSS selector\n     * @param root  root element to descend into\n     * @return matching elements, empty if none\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.select(org.jsoup.select.Evaluator, org.jsoup.nodes.Element)",
        "snippet": "    public static Elements select(Evaluator evaluator, Element root) {\n        Validate.notNull(evaluator);\n        Validate.notNull(root);\n        return Collector.collect(evaluator, root);\n    }",
        "begin_line": 101,
        "end_line": 105,
        "comment": "\n     * Find elements matching selector.\n     *\n     * @param evaluator CSS selector\n     * @param root root element to descend into\n     * @return matching elements, empty if none\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.select(java.lang.String, java.lang.Iterable<org.jsoup.nodes.Element>)",
        "snippet": "    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        Evaluator evaluator = QueryParser.parse(query);\n        ArrayList<Element> elements = new ArrayList<>();\n        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();\n        // dedupe elements by identity, not equality\n\n        for (Element root : roots) {\n            final Elements found = select(evaluator, root);\n            for (Element el : found) {\n                if (!seenElements.containsKey(el)) {\n                    elements.add(el);\n                    seenElements.put(el, Boolean.TRUE);\n                }\n            }\n        }\n        return new Elements(elements);\n    }",
        "begin_line": 114,
        "end_line": 132,
        "comment": "\n     * Find elements matching selector.\n     *\n     * @param query CSS selector\n     * @param roots root elements to descend into\n     * @return matching elements, empty if none\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.filterOut(java.util.Collection<org.jsoup.nodes.Element>, java.util.Collection<org.jsoup.nodes.Element>)",
        "snippet": "    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el : elements) {\n            boolean found = false;\n            for (Element out : outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }",
        "begin_line": 135,
        "end_line": 149,
        "comment": " exclude set. package open so that Elements can implement .not() selector.",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.selectFirst(java.lang.String, org.jsoup.nodes.Element)",
        "snippet": "    public static Element selectFirst(String cssQuery, Element root) {\n        Validate.notEmpty(cssQuery);\n        return Collector.findFirst(QueryParser.parse(cssQuery), root);\n    }",
        "begin_line": 157,
        "end_line": 160,
        "comment": "\n     * Find the first element that matches the query.\n     * @param cssQuery CSS selector\n     * @param root root element to descend into\n     * @return the matching element, or <b>null</b> if none.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/select/Selector.java",
        "class_name": "org.jsoup.select.Selector",
        "signature": "org.jsoup.select.Selector.SelectorParseException.SelectorParseException(java.lang.String, java.lang.Object...)",
        "snippet": "        public SelectorParseException(String msg, Object... params) {\n            super(String.format(msg, params));\n        }",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.none()",
        "snippet": "    public static Whitelist none() {\n        return new Whitelist();\n    }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     This whitelist allows only text nodes: all HTML will be stripped.\n\n     @return whitelist\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.simpleText()",
        "snippet": "    public static Whitelist simpleText() {\n        return new Whitelist()\n                .addTags(\"b\", \"em\", \"i\", \"strong\", \"u\")\n                ;\n    }",
        "begin_line": 88,
        "end_line": 92,
        "comment": "\n     This whitelist allows only simple text formatting: <code>b, em, i, strong, u</code>. All other HTML (tags and\n     attributes) will be removed.\n\n     @return whitelist\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.basic()",
        "snippet": "    public static Whitelist basic() {\n        return new Whitelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"cite\", \"code\", \"dd\", \"dl\", \"dt\", \"em\",\n                        \"i\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\", \"sub\",\n                        \"sup\", \"u\", \"ul\")\n\n                .addAttributes(\"a\", \"href\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"q\", \"cite\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n\n                .addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")\n                ;\n\n    }",
        "begin_line": 109,
        "end_line": 127,
        "comment": "\n     <p>\n     This whitelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\n     ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n     </p>\n     <p>\n     Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n     <code>rel=nofollow</code> attribute.\n     </p>\n     <p>\n     Does not allow images.\n     </p>\n\n     @return whitelist\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.basicWithImages()",
        "snippet": "    public static Whitelist basicWithImages() {\n        return basic()\n                .addTags(\"img\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                ;\n    }",
        "begin_line": 135,
        "end_line": 141,
        "comment": "\n     This whitelist allows the same text tags as {@link #basic}, and also allows <code>img</code> tags, with appropriate\n     attributes, with <code>src</code> pointing to <code>http</code> or <code>https</code>.\n\n     @return whitelist\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.relaxed()",
        "snippet": "    public static Whitelist relaxed() {\n        return new Whitelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"caption\", \"cite\", \"code\", \"col\",\n                        \"colgroup\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n                        \"i\", \"img\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\",\n                        \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"u\",\n                        \"ul\")\n\n                .addAttributes(\"a\", \"href\", \"title\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"col\", \"span\", \"width\")\n                .addAttributes(\"colgroup\", \"span\", \"width\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addAttributes(\"ol\", \"start\", \"type\")\n                .addAttributes(\"q\", \"cite\")\n                .addAttributes(\"table\", \"summary\", \"width\")\n                .addAttributes(\"td\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"width\")\n                .addAttributes(\n                        \"th\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"scope\",\n                        \"width\")\n                .addAttributes(\"ul\", \"type\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                .addProtocols(\"q\", \"cite\", \"http\", \"https\")\n                ;\n    }",
        "begin_line": 153,
        "end_line": 182,
        "comment": "\n     This whitelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\n     code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\n     sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n     <p>\n     Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n     </p>\n\n     @return whitelist\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.Whitelist()",
        "snippet": "    public Whitelist() {\n        tagNames = new HashSet<>();\n        attributes = new HashMap<>();\n        enforcedAttributes = new HashMap<>();\n        protocols = new HashMap<>();\n        preserveRelativeLinks = false;\n    }",
        "begin_line": 192,
        "end_line": 198,
        "comment": "\n     Create a new, empty whitelist. Generally it will be better to start with a default prepared whitelist instead.\n\n     @see #basic()\n     @see #basicWithImages()\n     @see #simpleText()\n     @see #relaxed()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.addTags(java.lang.String...)",
        "snippet": "    public Whitelist addTags(String... tags) {\n        Validate.notNull(tags);\n\n        for (String tagName : tags) {\n            Validate.notEmpty(tagName);\n            tagNames.add(TagName.valueOf(tagName));\n        }\n        return this;\n    }",
        "begin_line": 206,
        "end_line": 214,
        "comment": "\n     Add a list of allowed elements to a whitelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n     @param tags tag names to allow\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.removeTags(java.lang.String...)",
        "snippet": "    public Whitelist removeTags(String... tags) {\n        Validate.notNull(tags);\n\n        for(String tag: tags) {\n            Validate.notEmpty(tag);\n            TagName tagName = TagName.valueOf(tag);\n\n            if(tagNames.remove(tagName)) { // Only look in sub-maps if tag was allowed\n                attributes.remove(tagName);\n                enforcedAttributes.remove(tagName);\n                protocols.remove(tagName);\n            }\n        }\n        return this;\n    }",
        "begin_line": 222,
        "end_line": 236,
        "comment": "\n     Remove a list of allowed elements from a whitelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n     @param tags tag names to disallow\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.addAttributes(java.lang.String, java.lang.String...)",
        "snippet": "    public Whitelist addAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        TagName tagName = TagName.valueOf(tag);\n        tagNames.add(tagName);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        if (this.attributes.containsKey(tagName)) {\n            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n            currentSet.addAll(attributeSet);\n        } else {\n            this.attributes.put(tagName, attributeSet);\n        }\n        return this;\n    }",
        "begin_line": 253,
        "end_line": 272,
        "comment": "\n     Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n     <p>\n     E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n     on <code>a</code> tags.\n     </p>\n     <p>\n     To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n     <code>addAttributes(\":all\", \"class\")</code>.\n     </p>\n\n     @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n     @param attributes List of valid attributes for the tag\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.removeAttributes(java.lang.String, java.lang.String...)",
        "snippet": "    public Whitelist removeAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        TagName tagName = TagName.valueOf(tag);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        if(tagNames.contains(tagName) && this.attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n            currentSet.removeAll(attributeSet);\n\n            if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                this.attributes.remove(tagName);\n        }\n        if(tag.equals(\":all\")) // Attribute needs to be removed from all individually set tags\n            for(TagName name: this.attributes.keySet()) {\n                Set<AttributeKey> currentSet = this.attributes.get(name);\n                currentSet.removeAll(attributeSet);\n\n                if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                    this.attributes.remove(name);\n            }\n        return this;\n    }",
        "begin_line": 289,
        "end_line": 316,
        "comment": "\n     Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n     <p>\n     E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n     attributes on <code>a</code> tags.\n     </p>\n     <p>\n     To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n     <code>removeAttributes(\":all\", \"class\")</code>.\n     </p>\n\n     @param tag  The tag the attributes are for.\n     @param attributes List of invalid attributes for the tag\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.addEnforcedAttribute(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public Whitelist addEnforcedAttribute(String tag, String attribute, String value) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notEmpty(value);\n\n        TagName tagName = TagName.valueOf(tag);\n        tagNames.add(tagName);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        AttributeValue attrVal = AttributeValue.valueOf(value);\n\n        if (enforcedAttributes.containsKey(tagName)) {\n            enforcedAttributes.get(tagName).put(attrKey, attrVal);\n        } else {\n            Map<AttributeKey, AttributeValue> attrMap = new HashMap<>();\n            attrMap.put(attrKey, attrVal);\n            enforcedAttributes.put(tagName, attrMap);\n        }\n        return this;\n    }",
        "begin_line": 331,
        "end_line": 349,
        "comment": "\n     Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n     already has the attribute set, it will be overridden with this value.\n     <p>\n     E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n     <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n     </p>\n\n     @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n     @param attribute   The attribute name\n     @param value The enforced attribute value\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.removeEnforcedAttribute(java.lang.String, java.lang.String)",
        "snippet": "    public Whitelist removeEnforcedAttribute(String tag, String attribute) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n\n        TagName tagName = TagName.valueOf(tag);\n        if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {\n            AttributeKey attrKey = AttributeKey.valueOf(attribute);\n            Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);\n            attrMap.remove(attrKey);\n\n            if(attrMap.isEmpty()) // Remove tag from enforced attribute map if no enforced attributes are present\n                enforcedAttributes.remove(tagName);\n        }\n        return this;\n    }",
        "begin_line": 358,
        "end_line": 372,
        "comment": "\n     Remove a previously configured enforced attribute from a tag.\n\n     @param tag   The tag the enforced attribute is for.\n     @param attribute   The attribute name\n     @return this (for chaining)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.preserveRelativeLinks(boolean)",
        "snippet": "    public Whitelist preserveRelativeLinks(boolean preserve) {\n        preserveRelativeLinks = preserve;\n        return this;\n    }",
        "begin_line": 389,
        "end_line": 392,
        "comment": "\n     * Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute\n     * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\n     * e.g. {@code http://}.\n     * <p>\n     * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when\n     * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\n     * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\n     * will be removed.\n     * </p>\n     *\n     * @param preserve {@code true} to allow relative links, {@code false} (default) to deny\n     * @return this Whitelist, for chaining.\n     * @see #addProtocols\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.addProtocols(java.lang.String, java.lang.String, java.lang.String...)",
        "snippet": "    public Whitelist addProtocols(String tag, String attribute, String... protocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(protocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        Map<AttributeKey, Set<Protocol>> attrMap;\n        Set<Protocol> protSet;\n\n        if (this.protocols.containsKey(tagName)) {\n            attrMap = this.protocols.get(tagName);\n        } else {\n            attrMap = new HashMap<>();\n            this.protocols.put(tagName, attrMap);\n        }\n        if (attrMap.containsKey(attrKey)) {\n            protSet = attrMap.get(attrKey);\n        } else {\n            protSet = new HashSet<>();\n            attrMap.put(attrKey, protSet);\n        }\n        for (String protocol : protocols) {\n            Validate.notEmpty(protocol);\n            Protocol prot = Protocol.valueOf(protocol);\n            protSet.add(prot);\n        }\n        return this;\n    }",
        "begin_line": 410,
        "end_line": 438,
        "comment": "\n     Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\n     URLs with the defined protocol.\n     <p>\n     E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n     </p>\n     <p>\n     To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n     E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n     </p>\n\n     @param tag       Tag the URL protocol is for\n     @param attribute       Attribute name\n     @param protocols List of valid protocols\n     @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.removeProtocols(java.lang.String, java.lang.String, java.lang.String...)",
        "snippet": "    public Whitelist removeProtocols(String tag, String attribute, String... removeProtocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(removeProtocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attr = AttributeKey.valueOf(attribute);\n\n        // make sure that what we're removing actually exists; otherwise can open the tag to any data and that can\n        // be surprising\n        Validate.isTrue(protocols.containsKey(tagName), \"Cannot remove a protocol that is not set.\");\n        Map<AttributeKey, Set<Protocol>> tagProtocols = protocols.get(tagName);\n        Validate.isTrue(tagProtocols.containsKey(attr), \"Cannot remove a protocol that is not set.\");\n\n        Set<Protocol> attrProtocols = tagProtocols.get(attr);\n        for (String protocol : removeProtocols) {\n            Validate.notEmpty(protocol);\n            attrProtocols.remove(Protocol.valueOf(protocol));\n        }\n\n        if (attrProtocols.isEmpty()) { // Remove protocol set if empty\n            tagProtocols.remove(attr);\n            if (tagProtocols.isEmpty()) // Remove entry for tag if empty\n                protocols.remove(tagName);\n        }\n        return this;\n    }",
        "begin_line": 452,
        "end_line": 478,
        "comment": "\n     Remove allowed URL protocols for an element's URL attribute. If you remove all protocols for an attribute, that\n     attribute will allow any protocol.\n     <p>\n     E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n     </p>\n\n     @param tag Tag the URL protocol is for\n     @param attribute Attribute name\n     @param removeProtocols List of invalid protocols\n     @return this, for chaining\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.isSafeTag(java.lang.String)",
        "snippet": "    protected boolean isSafeTag(String tag) {\n        return tagNames.contains(TagName.valueOf(tag));\n    }",
        "begin_line": 485,
        "end_line": 487,
        "comment": "\n     * Test if the supplied tag is allowed by this whitelist\n     * @param tag test tag\n     * @return true if allowed\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.isSafeAttribute(java.lang.String, org.jsoup.nodes.Element, org.jsoup.nodes.Attribute)",
        "snippet": "    protected boolean isSafeAttribute(String tagName, Element el, Attribute attr) {\n        TagName tag = TagName.valueOf(tagName);\n        AttributeKey key = AttributeKey.valueOf(attr.getKey());\n\n        Set<AttributeKey> okSet = attributes.get(tag);\n        if (okSet != null && okSet.contains(key)) {\n            if (protocols.containsKey(tag)) {\n                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n                // ok if not defined protocol; otherwise test\n                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n            } else { // attribute found, no protocols defined, so OK\n                return true;\n            }\n        }\n        // might be an enforced attribute?\n        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\n        if (enforcedSet != null) {\n            Attributes expect = getEnforcedAttributes(tagName);\n            String attrKey = attr.getKey();\n            if (expect.hasKeyIgnoreCase(attrKey)) {\n                return expect.getIgnoreCase(attrKey).equals(attr.getValue());\n            }\n        }\n        // no attributes defined for tag, try :all tag\n        return !tagName.equals(\":all\") && isSafeAttribute(\":all\", el, attr);\n    }",
        "begin_line": 496,
        "end_line": 521,
        "comment": "\n     * Test if the supplied attribute is allowed by this whitelist for this tag\n     * @param tagName tag to consider allowing the attribute in\n     * @param el element under test, to confirm protocol\n     * @param attr attribute under test\n     * @return true if allowed\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.testValidProtocol(org.jsoup.nodes.Element, org.jsoup.nodes.Attribute, java.util.Set<org.jsoup.safety.Whitelist.Protocol>)",
        "snippet": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n        // rels without a baseuri get removed\n        String value = el.absUrl(attr.getKey());\n        if (value.length() == 0)\n            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        \n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString();\n\n            if (prot.equals(\"#\")) { // allows anchor links\n                if (isValidAnchor(value)) {\n                    return true;\n                } else {\n                    continue;\n                }\n            }\n\n            prot += \":\";\n\n            if (lowerCase(value).startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 523,
        "end_line": 550,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.isValidAnchor(java.lang.String)",
        "snippet": "    private boolean isValidAnchor(String value) {\n        return value.startsWith(\"#\") && !value.matches(\".*\\\\s.*\");\n    }",
        "begin_line": 552,
        "end_line": 554,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.getEnforcedAttributes(java.lang.String)",
        "snippet": "    Attributes getEnforcedAttributes(String tagName) {\n        Attributes attrs = new Attributes();\n        TagName tag = TagName.valueOf(tagName);\n        if (enforcedAttributes.containsKey(tag)) {\n            Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag);\n            for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) {\n                attrs.put(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n        return attrs;\n    }",
        "begin_line": 556,
        "end_line": 566,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TagName.TagName(java.lang.String)",
        "snippet": "        TagName(String value) {\n            super(value);\n        }",
        "begin_line": 571,
        "end_line": 573,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TagName.valueOf(java.lang.String)",
        "snippet": "        static TagName valueOf(String value) {\n            return new TagName(value);\n        }",
        "begin_line": 575,
        "end_line": 577,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.AttributeKey.AttributeKey(java.lang.String)",
        "snippet": "        AttributeKey(String value) {\n            super(value);\n        }",
        "begin_line": 581,
        "end_line": 583,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.AttributeKey.valueOf(java.lang.String)",
        "snippet": "        static AttributeKey valueOf(String value) {\n            return new AttributeKey(value);\n        }",
        "begin_line": 585,
        "end_line": 587,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.AttributeValue.AttributeValue(java.lang.String)",
        "snippet": "        AttributeValue(String value) {\n            super(value);\n        }",
        "begin_line": 591,
        "end_line": 593,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.AttributeValue.valueOf(java.lang.String)",
        "snippet": "        static AttributeValue valueOf(String value) {\n            return new AttributeValue(value);\n        }",
        "begin_line": 595,
        "end_line": 597,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.Protocol.Protocol(java.lang.String)",
        "snippet": "        Protocol(String value) {\n            super(value);\n        }",
        "begin_line": 601,
        "end_line": 603,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.Protocol.valueOf(java.lang.String)",
        "snippet": "        static Protocol valueOf(String value) {\n            return new Protocol(value);\n        }",
        "begin_line": 605,
        "end_line": 607,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TypedValue.TypedValue(java.lang.String)",
        "snippet": "        TypedValue(String value) {\n            Validate.notNull(value);\n            this.value = value;\n        }",
        "begin_line": 613,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TypedValue.hashCode()",
        "snippet": "        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((value == null) ? 0 : value.hashCode());\n            return result;\n        }",
        "begin_line": 618,
        "end_line": 624,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TypedValue.equals(java.lang.Object)",
        "snippet": "        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null) return false;\n            if (getClass() != obj.getClass()) return false;\n            TypedValue other = (TypedValue) obj;\n            if (value == null) {\n                return other.value == null;\n            } else return value.equals(other.value);\n        }",
        "begin_line": 626,
        "end_line": 635,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Whitelist.java",
        "class_name": "org.jsoup.safety.Whitelist",
        "signature": "org.jsoup.safety.Whitelist.TypedValue.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return value;\n        }",
        "begin_line": 637,
        "end_line": 640,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.Cleaner(org.jsoup.safety.Whitelist)",
        "snippet": "    public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }",
        "begin_line": 42,
        "end_line": 45,
        "comment": "\n     Create a new cleaner, that sanitizes documents using the supplied whitelist.\n     @param whitelist white-list to clean with\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.clean(org.jsoup.nodes.Document)",
        "snippet": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }",
        "begin_line": 53,
        "end_line": 61,
        "comment": "\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.isValid(org.jsoup.nodes.Document)",
        "snippet": "    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0\n            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n    }",
        "begin_line": 74,
        "end_line": 81,
        "comment": "\n     Determines if the input document <b>body</b>is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist, and that there is no content in the <code>head</code>.\n     <p>\n     This method can be used as a validator for user input. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     </p>\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.isValidBodyHtml(java.lang.String)",
        "snippet": "    public boolean isValidBodyHtml(String bodyHtml) {\n        Document clean = Document.createShell(\"\");\n        Document dirty = Document.createShell(\"\");\n        ParseErrorList errorList = ParseErrorList.tracking(1);\n        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n        dirty.body().insertChildren(0, nodes);\n        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n        return numDiscarded == 0 && errorList.size() == 0;\n    }",
        "begin_line": 83,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.CleaningVisitor.CleaningVisitor(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "        private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.CleaningVisitor.head(org.jsoup.nodes.Node, int)",
        "snippet": "        public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && whitelist.isSafeTag(source.parent().nodeName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }",
        "begin_line": 106,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.CleaningVisitor.tail(org.jsoup.nodes.Node, int)",
        "snippet": "        public void tail(Node source, int depth) {\n            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }",
        "begin_line": 133,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.copySafeNodes(org.jsoup.nodes.Element, org.jsoup.nodes.Element)",
        "snippet": "    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor.traverse(cleaningVisitor, source);\n        return cleaningVisitor.numDiscarded;\n    }",
        "begin_line": 140,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.createSafeElement(org.jsoup.nodes.Element)",
        "snippet": "    private ElementMeta createSafeElement(Element sourceEl) {\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = new Attributes();\n        Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs);\n        int numDiscarded = 0;\n\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n\n        return new ElementMeta(dest, numDiscarded);\n    }",
        "begin_line": 146,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/jsoup/safety/Cleaner.java",
        "class_name": "org.jsoup.safety.Cleaner",
        "signature": "org.jsoup.safety.Cleaner.ElementMeta.ElementMeta(org.jsoup.nodes.Element, int)",
        "snippet": "        ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }",
        "begin_line": 169,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {}
    }
]