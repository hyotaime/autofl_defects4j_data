[
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.parse(java.io.File, java.nio.charset.Charset, org.apache.commons.csv.CSVFormat)",
        "snippet": "    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }",
        "begin_line": 156,
        "end_line": 161,
        "comment": "\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.parse(java.lang.String, org.apache.commons.csv.CSVFormat)",
        "snippet": "    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }",
        "begin_line": 176,
        "end_line": 181,
        "comment": "\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.parse(java.net.URL, java.nio.charset.Charset, org.apache.commons.csv.CSVFormat)",
        "snippet": "    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }",
        "begin_line": 203,
        "end_line": 209,
        "comment": "\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.CSVParser(java.io.Reader, org.apache.commons.csv.CSVFormat)",
        "snippet": "    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }",
        "begin_line": 244,
        "end_line": 251,
        "comment": "\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.addRecordValue()",
        "snippet": "    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }",
        "begin_line": 253,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.close()",
        "snippet": "    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }",
        "begin_line": 269,
        "end_line": 273,
        "comment": "\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.getCurrentLineNumber()",
        "snippet": "    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }",
        "begin_line": 285,
        "end_line": 287,
        "comment": "\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.getHeaderMap()",
        "snippet": "    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }",
        "begin_line": 296,
        "end_line": 298,
        "comment": "\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.getRecordNumber()",
        "snippet": "    public long getRecordNumber() {\n        return this.recordNumber;\n    }",
        "begin_line": 310,
        "end_line": 312,
        "comment": "\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.getRecords()",
        "snippet": "    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }",
        "begin_line": 326,
        "end_line": 328,
        "comment": "\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.getRecords(T)",
        "snippet": "    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }",
        "begin_line": 345,
        "end_line": 351,
        "comment": "\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.initializeHeader()",
        "snippet": "    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }",
        "begin_line": 359,
        "end_line": 394,
        "comment": "\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.isClosed()",
        "snippet": "    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }",
        "begin_line": 396,
        "end_line": 398,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.iterator()",
        "snippet": "    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }",
        "begin_line": 408,
        "end_line": 454,
        "comment": "\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.Anonymous-e654e49a-e0eb-44b2-a301-986921c3fd46.getNextRecord()",
        "snippet": "            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }",
        "begin_line": 412,
        "end_line": 419,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.Anonymous-6fc3de2d-c6af-42b8-bd6d-a95e572ece03.hasNext()",
        "snippet": "            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }",
        "begin_line": 421,
        "end_line": 430,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.Anonymous-27265aa4-c698-4fd1-945f-7a856399d336.next()",
        "snippet": "            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }",
        "begin_line": 432,
        "end_line": 448,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.Anonymous-8f8b0244-bf44-419c-a340-b991e128565f.remove()",
        "snippet": "            public void remove() {\n                throw new UnsupportedOperationException();\n            }",
        "begin_line": 450,
        "end_line": 452,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "class_name": "org.apache.commons.csv.CSVParser",
        "signature": "org.apache.commons.csv.CSVParser.nextRecord()",
        "snippet": "    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }",
        "begin_line": 463,
        "end_line": 505,
        "comment": "\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Token.java",
        "class_name": "org.apache.commons.csv.Token",
        "signature": "org.apache.commons.csv.Token.reset()",
        "snippet": "    void reset() {\n        content.setLength(0);\n        type = INVALID;\n        isReady = false;\n    }",
        "begin_line": 60,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Token.java",
        "class_name": "org.apache.commons.csv.Token",
        "signature": "org.apache.commons.csv.Token.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return type.name() + \" [\" + content.toString() + \"]\";\n    }",
        "begin_line": 71,
        "end_line": 74,
        "comment": "\n     * Eases IDE debugging.\n     *\n     * @return a string helpful for debugging.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isLineBreak(char)",
        "snippet": "    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }",
        "begin_line": 243,
        "end_line": 245,
        "comment": "\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isLineBreak(java.lang.Character)",
        "snippet": "    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }",
        "begin_line": 255,
        "end_line": 257,
        "comment": "\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.newFormat(char)",
        "snippet": "    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n    }",
        "begin_line": 267,
        "end_line": 269,
        "comment": "\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.CSVFormat(char, java.lang.Character, org.apache.commons.csv.Quote, java.lang.Character, java.lang.Character, boolean, boolean, java.lang.String, java.lang.String, java.lang.String[], boolean, boolean)",
        "snippet": "    private CSVFormat(final char delimiter, final Character quoteChar,\n            final Quote quotePolicy, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, final boolean skipHeaderRecord,\n            final boolean ignoreEmptyHeaders) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteChar = quoteChar;\n        this.quotePolicy = quotePolicy;\n        this.commentStart = commentStart;\n        this.escape = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.ignoreEmptyHeaders = ignoreEmptyHeaders;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n            this.header = null;\n        } else {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n            this.header = header.clone();\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n        validate();\n    }",
        "begin_line": 298,
        "end_line": 331,
        "comment": "\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quotePolicy\n     *            the quote policy\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            <tt>true</tt> when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            <tt>true</tt> when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @param ignoreEmptyHeaders TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quotePolicy != other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar == null) {\n            if (other.quoteChar != null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart == null) {\n            if (other.commentStart != null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape == null) {\n            if (other.escape != null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }",
        "begin_line": 333,
        "end_line": 400,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.format(java.lang.Object...)",
        "snippet": "    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }",
        "begin_line": 409,
        "end_line": 418,
        "comment": "\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getCommentStart()",
        "snippet": "    public Character getCommentStart() {\n        return commentStart;\n    }",
        "begin_line": 425,
        "end_line": 427,
        "comment": "\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getDelimiter()",
        "snippet": "    public char getDelimiter() {\n        return delimiter;\n    }",
        "begin_line": 434,
        "end_line": 436,
        "comment": "\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getEscape()",
        "snippet": "    public Character getEscape() {\n        return escape;\n    }",
        "begin_line": 443,
        "end_line": 445,
        "comment": "\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getHeader()",
        "snippet": "    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }",
        "begin_line": 452,
        "end_line": 454,
        "comment": "\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getIgnoreEmptyHeaders()",
        "snippet": "    public boolean getIgnoreEmptyHeaders() {\n        return ignoreEmptyHeaders;\n    }",
        "begin_line": 462,
        "end_line": 464,
        "comment": "\n     * Specifies whether empty headers are ignored when parsing the header line.\n     *\n     * @return <tt>true</tt> if headers are ignored when parsing the header line, <tt>false</tt> to throw an\n     *         {@link IllegalArgumentException}..\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getIgnoreEmptyLines()",
        "snippet": "    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }",
        "begin_line": 472,
        "end_line": 474,
        "comment": "\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n     *         records.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getIgnoreSurroundingSpaces()",
        "snippet": "    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }",
        "begin_line": 482,
        "end_line": 484,
        "comment": "\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n     *         value.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getNullString()",
        "snippet": "    public String getNullString() {\n        return nullString;\n    }",
        "begin_line": 499,
        "end_line": 501,
        "comment": "\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.\n     * </li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getQuoteChar()",
        "snippet": "    public Character getQuoteChar() {\n        return quoteChar;\n    }",
        "begin_line": 508,
        "end_line": 510,
        "comment": "\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getQuotePolicy()",
        "snippet": "    public Quote getQuotePolicy() {\n        return quotePolicy;\n    }",
        "begin_line": 517,
        "end_line": 519,
        "comment": "\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getRecordSeparator()",
        "snippet": "    public String getRecordSeparator() {\n        return recordSeparator;\n    }",
        "begin_line": 526,
        "end_line": 528,
        "comment": "\n     * Returns the line separator delimiting output records.\n     *\n     * @return the line separator\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.getSkipHeaderRecord()",
        "snippet": "    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }",
        "begin_line": 535,
        "end_line": 537,
        "comment": "\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.hashCode()",
        "snippet": "    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }",
        "begin_line": 539,
        "end_line": 557,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isCommentingEnabled()",
        "snippet": "    public boolean isCommentingEnabled() {\n        return commentStart != null;\n    }",
        "begin_line": 566,
        "end_line": 568,
        "comment": "\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isEscaping()",
        "snippet": "    public boolean isEscaping() {\n        return escape != null;\n    }",
        "begin_line": 575,
        "end_line": 577,
        "comment": "\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isNullHandling()",
        "snippet": "    public boolean isNullHandling() {\n        return nullString != null;\n    }",
        "begin_line": 584,
        "end_line": 586,
        "comment": "\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.isQuoting()",
        "snippet": "    public boolean isQuoting() {\n        return quoteChar != null;\n    }",
        "begin_line": 593,
        "end_line": 595,
        "comment": "\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.parse(java.io.Reader)",
        "snippet": "    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }",
        "begin_line": 610,
        "end_line": 612,
        "comment": "\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.print(java.lang.Appendable)",
        "snippet": "    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }",
        "begin_line": 627,
        "end_line": 629,
        "comment": "\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *        the output\n     * @return a printer to an output\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.toString()",
        "snippet": "    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscaping()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escape).append('>');\n        }\n        if (isQuoting()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n        }\n        if (isCommentingEnabled()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n        }\n        if (isNullHandling()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }",
        "begin_line": 631,
        "end_line": 667,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.validate()",
        "snippet": "    private void validate() throws IllegalArgumentException {\n        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n        }\n\n        if (escape != null && delimiter == escape.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n        }\n\n        if (commentStart != null && delimiter == commentStart.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (quoteChar != null && quoteChar.equals(commentStart)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape != null && escape.equals(commentStart)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape == null && quotePolicy == Quote.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        if(recordSeparator != null &&\n                !(CRLF.equals(recordSeparator) ||\n                        String.valueOf(CR).equals(recordSeparator) ||\n                        String.valueOf(LF).equals(recordSeparator))) {\n            throw new IllegalArgumentException(\"Record separator can only by CR, LF or CRLF\");\n        }\n    }",
        "begin_line": 674,
        "end_line": 710,
        "comment": "\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withCommentStart(char)",
        "snippet": "    public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }",
        "begin_line": 723,
        "end_line": 725,
        "comment": "\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withCommentStart(java.lang.Character)",
        "snippet": "    public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 738,
        "end_line": 745,
        "comment": "\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withDelimiter(char)",
        "snippet": "    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 756,
        "end_line": 763,
        "comment": "\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withEscape(char)",
        "snippet": "    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }",
        "begin_line": 774,
        "end_line": 776,
        "comment": "\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withEscape(java.lang.Character)",
        "snippet": "    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 787,
        "end_line": 794,
        "comment": "\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withHeader(java.lang.String...)",
        "snippet": "    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 813,
        "end_line": 817,
        "comment": "\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withIgnoreEmptyHeaders(boolean)",
        "snippet": "    public CSVFormat withIgnoreEmptyHeaders(final boolean ignoreEmptyHeaders) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyHeaders, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 827,
        "end_line": 831,
        "comment": "\n     * Sets the empty header behavior of the format.\n     *\n     * @param ignoreEmptyHeaders\n     *            the empty header behavior, <tt>true</tt> to ignore empty headers in the header line,\n     *            <tt>false</tt> to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified empty header behavior.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withIgnoreEmptyLines(boolean)",
        "snippet": "    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 841,
        "end_line": 845,
        "comment": "\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n     *            <tt>false</tt> to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withIgnoreSurroundingSpaces(boolean)",
        "snippet": "    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 855,
        "end_line": 859,
        "comment": "\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withNullString(java.lang.String)",
        "snippet": "    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 876,
        "end_line": 880,
        "comment": "\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withQuoteChar(char)",
        "snippet": "    public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }",
        "begin_line": 891,
        "end_line": 893,
        "comment": "\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withQuoteChar(java.lang.Character)",
        "snippet": "    public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 904,
        "end_line": 911,
        "comment": "\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withQuotePolicy(org.apache.commons.csv.Quote)",
        "snippet": "    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 921,
        "end_line": 925,
        "comment": "\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quotePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withRecordSeparator(char)",
        "snippet": "    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }",
        "begin_line": 939,
        "end_line": 941,
        "comment": "\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p><strong>Note:</strong> Currently only CR and LF are supported.</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is neither CR nor LF\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withRecordSeparator(java.lang.String)",
        "snippet": "    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 955,
        "end_line": 959,
        "comment": "\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p><strong>Note:</strong> Currently only CR, LF and CRLF are supported.</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is none of CR, LF or CRLF\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "class_name": "org.apache.commons.csv.CSVFormat",
        "signature": "org.apache.commons.csv.CSVFormat.withSkipHeaderRecord(boolean)",
        "snippet": "    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                ignoreEmptyHeaders);\n    }",
        "begin_line": 970,
        "end_line": 974,
        "comment": "\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Assertions.java",
        "class_name": "org.apache.commons.csv.Assertions",
        "signature": "org.apache.commons.csv.Assertions.Assertions()",
        "snippet": "    private Assertions() {\n        // can not be instantiated\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Assertions.java",
        "class_name": "org.apache.commons.csv.Assertions",
        "signature": "org.apache.commons.csv.Assertions.notNull(java.lang.Object, java.lang.String)",
        "snippet": "    public static void notNull(final Object parameter, final String parameterName) {\n        if (parameter == null) {\n            throw new IllegalArgumentException(\"Parameter '\" + parameterName + \"' must not be null!\");\n        }\n    }",
        "begin_line": 31,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.CSVRecord(java.lang.String[], java.util.Map<java.lang.String, java.lang.Integer>, java.lang.String, long)",
        "snippet": "    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }",
        "begin_line": 51,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.get(java.lang.Enum<?>)",
        "snippet": "    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.get(int)",
        "snippet": "    public String get(final int i) {\n        return values[i];\n    }",
        "begin_line": 77,
        "end_line": 79,
        "comment": "\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.get(java.lang.String)",
        "snippet": "    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }",
        "begin_line": 94,
        "end_line": 111,
        "comment": "\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.getComment()",
        "snippet": "    public String getComment() {\n        return comment;\n    }",
        "begin_line": 119,
        "end_line": 121,
        "comment": "\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.getRecordNumber()",
        "snippet": "    public long getRecordNumber() {\n        return recordNumber;\n    }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.isConsistent()",
        "snippet": "    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.isMapped(java.lang.String)",
        "snippet": "    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.isSet(java.lang.String)",
        "snippet": "    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.iterator()",
        "snippet": "    public Iterator<String> iterator() {\n        return toList().iterator();\n    }",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.putIn(M)",
        "snippet": "    <M extends Map<String, String>> M putIn(final M map) {\n        if (mapping == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }",
        "begin_line": 179,
        "end_line": 190,
        "comment": "\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.size()",
        "snippet": "    public int size() {\n        return values.length;\n    }",
        "begin_line": 197,
        "end_line": 199,
        "comment": "\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.toList()",
        "snippet": "    private List<String> toList() {\n        return Arrays.asList(values);\n    }",
        "begin_line": 207,
        "end_line": 209,
        "comment": "\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.toMap()",
        "snippet": "    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }",
        "begin_line": 216,
        "end_line": 218,
        "comment": "\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }",
        "begin_line": 220,
        "end_line": 223,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVRecord.java",
        "class_name": "org.apache.commons.csv.CSVRecord",
        "signature": "org.apache.commons.csv.CSVRecord.values()",
        "snippet": "    String[] values() {\n        return values;\n    }",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.Lexer(org.apache.commons.csv.CSVFormat, org.apache.commons.csv.ExtendedBufferedReader)",
        "snippet": "    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscape());\n        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n        this.commentStart = mapNullToDisabled(format.getCommentStart());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }",
        "begin_line": 62,
        "end_line": 70,
        "comment": " INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.nextToken(org.apache.commons.csv.Token)",
        "snippet": "    Token nextToken(final Token token) throws IOException {\n\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n\n        // read the next char and set eol\n        int c = reader.read();\n        /*\n         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n         * - they are equivalent here.\n         */\n        boolean eol = readEndOfLine(c);\n\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached end of file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n\n        // did we reach eof during the last iteration already ? EOF\n        if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {\n            token.type = EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = COMMENT;\n            return token;\n        }\n\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }",
        "begin_line": 83,
        "end_line": 165,
        "comment": "\n     * Returns the next token.\n     * <p/>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found\n     * @throws java.io.IOException\n     *             on stream access error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.parseSimpleToken(org.apache.commons.csv.Token, int)",
        "snippet": "    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        while (true) {\n            if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                break;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n                ch = reader.read(); // continue\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read(); // continue\n            }\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }",
        "begin_line": 186,
        "end_line": 218,
        "comment": "\n     * Parses a simple token.\n     * <p/>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.parseEncapsulatedToken(org.apache.commons.csv.Token)",
        "snippet": "    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isEscape(c)) {\n                final int unescaped = readEscape();\n                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) c).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.lookAhead())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = TOKEN;\n                            return token;\n                        } else if (isEndOfFile(c)) {\n                            token.type = EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        } else if (readEndOfLine(c)) {\n                            token.type = EORECORD;\n                            return token;\n                        } else if (!isWhitespace(c)) {\n                            // error invalid char between token and next delimiter\n                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                    \") invalid char between encapsulated token and delimiter\");\n                        }\n                    }\n                }\n            } else if (isEndOfFile(c)) {\n                // error condition (end of file before end of token)\n                throw new IOException(\"(startline \" + startLineNumber +\n                        \") EOF reached before encapsulated token finished\");\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }",
        "begin_line": 240,
        "end_line": 289,
        "comment": "\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.mapNullToDisabled(java.lang.Character)",
        "snippet": "    private char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }",
        "begin_line": 291,
        "end_line": 293,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.getCurrentLineNumber()",
        "snippet": "    long getCurrentLineNumber() {\n        return reader.getCurrentLineNumber();\n    }",
        "begin_line": 300,
        "end_line": 302,
        "comment": "\n     * Returns the current line number\n     *\n     * @return the current line number\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.readEscape()",
        "snippet": "    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return ch;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }",
        "begin_line": 316,
        "end_line": 346,
        "comment": "\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of strem\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.trimTrailingSpaces(java.lang.StringBuilder)",
        "snippet": "    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }",
        "begin_line": 348,
        "end_line": 356,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.readEndOfLine(int)",
        "snippet": "    boolean readEndOfLine(int ch) throws IOException {\n        // check if we have \\r\\n...\n        if (ch == CR && reader.lookAhead() == LF) {\n            // note: does not change ch outside of this method!\n            ch = reader.read();\n        }\n        return ch == LF || ch == CR;\n    }",
        "begin_line": 363,
        "end_line": 370,
        "comment": "\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isClosed()",
        "snippet": "    boolean isClosed() {\n        return reader.isClosed();\n    }",
        "begin_line": 372,
        "end_line": 374,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isWhitespace(int)",
        "snippet": "    boolean isWhitespace(final int ch) {\n        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n    }",
        "begin_line": 379,
        "end_line": 381,
        "comment": "\n     * @return true if the given char is a whitespace character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isStartOfLine(int)",
        "snippet": "    boolean isStartOfLine(final int ch) {\n        return ch == LF || ch == CR || ch == UNDEFINED;\n    }",
        "begin_line": 389,
        "end_line": 391,
        "comment": "\n     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isEndOfFile(int)",
        "snippet": "    boolean isEndOfFile(final int ch) {\n        return ch == END_OF_STREAM;\n    }",
        "begin_line": 396,
        "end_line": 398,
        "comment": "\n     * @return true if the given character indicates end of file\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isDelimiter(int)",
        "snippet": "    boolean isDelimiter(final int ch) {\n        return ch == delimiter;\n    }",
        "begin_line": 400,
        "end_line": 402,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isEscape(int)",
        "snippet": "    boolean isEscape(final int ch) {\n        return ch == escape;\n    }",
        "begin_line": 404,
        "end_line": 406,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isQuoteChar(int)",
        "snippet": "    boolean isQuoteChar(final int ch) {\n        return ch == quoteChar;\n    }",
        "begin_line": 408,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isCommentStart(int)",
        "snippet": "    boolean isCommentStart(final int ch) {\n        return ch == commentStart;\n    }",
        "begin_line": 412,
        "end_line": 414,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.isMetaChar(int)",
        "snippet": "    private boolean isMetaChar(final int ch) {\n        return ch == delimiter ||\n               ch == escape ||\n               ch == quoteChar ||\n               ch == commentStart;\n    }",
        "begin_line": 416,
        "end_line": 421,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "class_name": "org.apache.commons.csv.Lexer",
        "signature": "org.apache.commons.csv.Lexer.close()",
        "snippet": "    public void close() throws IOException {\n        reader.close();\n    }",
        "begin_line": 429,
        "end_line": 431,
        "comment": "\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.ExtendedBufferedReader(java.io.Reader)",
        "snippet": "    ExtendedBufferedReader(final Reader reader) {\n        super(reader);\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "\n     * Created extended buffered reader using default buffer-size\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.read()",
        "snippet": "    @Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || (current == LF && lastChar != CR)) {\n            eolCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }",
        "begin_line": 54,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.getLastChar()",
        "snippet": "    int getLastChar() {\n        return lastChar;\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.read(char[], int, int)",
        "snippet": "    @Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n\n        final int len = super.read(buf, offset, length);\n\n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > 0 ? buf[i - 1] : lastChar)) {\n                        eolCounter++;\n                    }\n                } else if (ch == CR) {\n                    eolCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n\n        return len;\n    }",
        "begin_line": 76,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.readLine()",
        "snippet": "    @Override\n    public String readLine() throws IOException {\n        final String line = super.readLine();\n\n        if (line != null) {\n            lastChar = LF; // needed for detecting start of line\n            eolCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }",
        "begin_line": 116,
        "end_line": 128,
        "comment": "\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n     * when processing a comment, otherwise information can be lost.\n     * <p>\n     * Increments {@link #eolCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise to LF\n     *\n     * @return the line that was read, or null if reached EOF.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.lookAhead()",
        "snippet": "    int lookAhead() throws IOException {\n        super.mark(1);\n        final int c = super.read();\n        super.reset();\n\n        return c;\n    }",
        "begin_line": 139,
        "end_line": 145,
        "comment": "\n     * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n     * still return this value. Does not affect line number or last character.\n     *\n     * @return the next character\n     *\n     * @throws IOException\n     *             if there is an error in reading\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.getCurrentLineNumber()",
        "snippet": "    long getCurrentLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n            return eolCounter; // counter is accurate\n        }\n        return eolCounter + 1; // Allow for counter being incremented only at EOL\n    }",
        "begin_line": 152,
        "end_line": 158,
        "comment": "\n     * Returns the current line number\n     *\n     * @return the current line number\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.isClosed()",
        "snippet": "    public boolean isClosed() {\n        return closed;\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java",
        "class_name": "org.apache.commons.csv.ExtendedBufferedReader",
        "signature": "org.apache.commons.csv.ExtendedBufferedReader.close()",
        "snippet": "    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        closed = true;\n        lastChar = END_OF_STREAM;\n        super.close();\n    }",
        "begin_line": 170,
        "end_line": 176,
        "comment": "\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.CSVPrinter(java.lang.Appendable, org.apache.commons.csv.CSVFormat)",
        "snippet": "    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }",
        "begin_line": 61,
        "end_line": 72,
        "comment": "\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     *\n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.close()",
        "snippet": "    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }",
        "begin_line": 78,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.flush()",
        "snippet": "    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }",
        "begin_line": 90,
        "end_line": 94,
        "comment": "\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.print(java.lang.Object)",
        "snippet": "    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }",
        "begin_line": 104,
        "end_line": 114,
        "comment": "\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.print(java.lang.Object, java.lang.CharSequence, int, int)",
        "snippet": "    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }",
        "begin_line": 116,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printAndEscape(java.lang.CharSequence, int, int)",
        "snippet": "    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }",
        "begin_line": 135,
        "end_line": 169,
        "comment": "\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printAndQuote(java.lang.Object, java.lang.CharSequence, int, int)",
        "snippet": "    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }",
        "begin_line": 175,
        "end_line": 282,
        "comment": " the original object is needed so can check for Number",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printComment(java.lang.String)",
        "snippet": "    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }",
        "begin_line": 299,
        "end_line": 327,
        "comment": "\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.println()",
        "snippet": "    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }",
        "begin_line": 335,
        "end_line": 341,
        "comment": "\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printRecord(java.lang.Iterable<?>)",
        "snippet": "    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }",
        "begin_line": 352,
        "end_line": 357,
        "comment": "\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printRecord(java.lang.Object...)",
        "snippet": "    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }",
        "begin_line": 368,
        "end_line": 373,
        "comment": "\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printRecords(java.lang.Iterable<?>)",
        "snippet": "    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }",
        "begin_line": 383,
        "end_line": 393,
        "comment": "\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printRecords(java.lang.Object[])",
        "snippet": "    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }",
        "begin_line": 403,
        "end_line": 413,
        "comment": "\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.printRecords(java.sql.ResultSet)",
        "snippet": "    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }",
        "begin_line": 424,
        "end_line": 432,
        "comment": "\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java",
        "class_name": "org.apache.commons.csv.CSVPrinter",
        "signature": "org.apache.commons.csv.CSVPrinter.getOut()",
        "snippet": "    public Appendable getOut() {\n        return this.out;\n    }",
        "begin_line": 439,
        "end_line": 441,
        "comment": "\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     ",
        "resolved_comments": {}
    }
]