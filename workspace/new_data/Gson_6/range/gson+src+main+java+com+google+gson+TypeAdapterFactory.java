{
  "filepath": "/tmp/Gson-6b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java",
  "nodes": [
    {
      "type": "class_interface",
      "name": "TypeAdapterFactory",
      "is_interface": true,
      "parent_types": [],
      "begin_line": 163,
      "end_line": 170,
      "comment": "\n * Creates type adapters for set of related types. Type adapter factories are\n * most useful when several types share similar structure in their JSON form.\n *\n * \u003ch3\u003eExample: Converting enums to lowercase\u003c/h3\u003e\n * In this example, we implement a factory that creates type adapters for all\n * enums. The type adapters will write enums in lowercase, despite the fact\n * that they\u0027re defined in {@code CONSTANT_CASE} in the corresponding Java\n * model: \u003cpre\u003e   {@code\n *\n *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapterFactory {\n *     public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\n *       Class\u003cT\u003e rawType \u003d (Class\u003cT\u003e) type.getRawType();\n *       if (!rawType.isEnum()) {\n *         return null;\n *       }\n *\n *       final Map\u003cString, T\u003e lowercaseToConstant \u003d new HashMap\u003cString, T\u003e();\n *       for (T constant : rawType.getEnumConstants()) {\n *         lowercaseToConstant.put(toLowercase(constant), constant);\n *       }\n *\n *       return new TypeAdapter\u003cT\u003e() {\n *         public void write(JsonWriter out, T value) throws IOException {\n *           if (value \u003d\u003d null) {\n *             out.nullValue();\n *           } else {\n *             out.value(toLowercase(value));\n *           }\n *         }\n *\n *         public T read(JsonReader reader) throws IOException {\n *           if (reader.peek() \u003d\u003d JsonToken.NULL) {\n *             reader.nextNull();\n *             return null;\n *           } else {\n *             return lowercaseToConstant.get(reader.nextString());\n *           }\n *         }\n *       };\n *     }\n *\n *     private String toLowercase(Object o) {\n *       return o.toString().toLowerCase(Locale.US);\n *     }\n *   }\n * }\u003c/pre\u003e\n *\n * \u003cp\u003eType adapter factories select which types they provide type adapters\n * for. If a factory cannot support a given type, it must return null when\n * that type is passed to {@link #create}. Factories should expect {@code\n * create()} to be called on them for many types and should return null for\n * most of those types. In the above example the factory returns null for\n * calls to {@code create()} where {@code type} is not an enum.\n *\n * \u003cp\u003eA factory is typically called once per type, but the returned type\n * adapter may be used many times. It is most efficient to do expensive work\n * like reflection in {@code create()} so that the type adapter\u0027s {@code\n * read()} and {@code write()} methods can be very fast. In this example the\n * mapping from lowercase name to enum value is computed eagerly.\n *\n * \u003cp\u003eAs with type adapters, factories must be \u003ci\u003eregistered\u003c/i\u003e with a {@link\n * com.google.gson.GsonBuilder} for them to take effect: \u003cpre\u003e   {@code\n *\n *  GsonBuilder builder \u003d new GsonBuilder();\n *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\n *  ...\n *  Gson gson \u003d builder.create();\n * }\u003c/pre\u003e\n * If multiple factories support the same type, the factory registered earlier\n * takes precedence.\n *\n * \u003ch3\u003eExample: composing other type adapters\u003c/h3\u003e\n * In this example we implement a factory for Guava\u0027s {@code Multiset}\n * collection type. The factory can be used to create type adapters for\n * multisets of any element type: the type adapter for {@code\n * Multiset\u003cString\u003e} is different from the type adapter for {@code\n * Multiset\u003cURL\u003e}.\n *\n * \u003cp\u003eThe type adapter \u003ci\u003edelegates\u003c/i\u003e to another type adapter for the\n * multiset elements. It figures out the element type by reflecting on the\n * multiset\u0027s type token. A {@code Gson} is passed in to {@code create} for\n * just this purpose: \u003cpre\u003e   {@code\n *\n *   public class MultisetTypeAdapterFactory implements TypeAdapterFactory {\n *     public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e typeToken) {\n *       Type type \u003d typeToken.getType();\n *       if (typeToken.getRawType() !\u003d Multiset.class\n *           || !(type instanceof ParameterizedType)) {\n *         return null;\n *       }\n *\n *       Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\n *       TypeAdapter\u003c?\u003e elementAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\n *       return (TypeAdapter\u003cT\u003e) newMultisetAdapter(elementAdapter);\n *     }\n *\n *     private \u003cE\u003e TypeAdapter\u003cMultiset\u003cE\u003e\u003e newMultisetAdapter(\n *         final TypeAdapter\u003cE\u003e elementAdapter) {\n *       return new TypeAdapter\u003cMultiset\u003cE\u003e\u003e() {\n *         public void write(JsonWriter out, Multiset\u003cE\u003e value) throws IOException {\n *           if (value \u003d\u003d null) {\n *             out.nullValue();\n *             return;\n *           }\n *\n *           out.beginArray();\n *           for (Multiset.Entry\u003cE\u003e entry : value.entrySet()) {\n *             out.value(entry.getCount());\n *             elementAdapter.write(out, entry.getElement());\n *           }\n *           out.endArray();\n *         }\n *\n *         public Multiset\u003cE\u003e read(JsonReader in) throws IOException {\n *           if (in.peek() \u003d\u003d JsonToken.NULL) {\n *             in.nextNull();\n *             return null;\n *           }\n *\n *           Multiset\u003cE\u003e result \u003d LinkedHashMultiset.create();\n *           in.beginArray();\n *           while (in.hasNext()) {\n *             int count \u003d in.nextInt();\n *             E element \u003d elementAdapter.read(in);\n *             result.add(element, count);\n *           }\n *           in.endArray();\n *           return result;\n *         }\n *       };\n *     }\n *   }\n * }\u003c/pre\u003e\n * Delegating from one type adapter to another is extremely powerful; it\u0027s\n * the foundation of how Gson converts Java objects and collections. Whenever\n * possible your factory should retrieve its delegate type adapter in the\n * {@code create()} method; this ensures potentially-expensive type adapter\n * creation happens only once.\n *\n * @since 2.1\n "
    },
    {
      "type": "method",
      "signature": "com.google.gson.TypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
      "begin_line": 169,
      "end_line": 169,
      "comment": "\n   * Returns a type adapter for {@code type}, or null if this factory doesn\u0027t\n   * support {@code type}.\n   ",
      "child_ranges": []
    }
  ]
}