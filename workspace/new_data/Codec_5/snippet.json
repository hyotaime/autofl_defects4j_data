[
    {
        "src_path": "src/java/org/apache/commons/codec/BinaryDecoder.java",
        "class_name": "org.apache.commons.codec.BinaryDecoder",
        "signature": "org.apache.commons.codec.BinaryDecoder.decode(byte[])",
        "snippet": "    byte[] decode(byte[] pArray) throws DecoderException;",
        "begin_line": 40,
        "end_line": 40,
        "comment": "\n     * Decodes a byte array and returns the results as a byte array. \n     *\n     * @param pArray A byte array which has been encoded with the\n     *      appropriate encoder\n     * \n     * @return a byte array that contains decoded content\n     * \n     * @throws DecoderException A decoder exception is thrown\n     *          if a Decoder encounters a failure condition during\n     *          the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/BinaryEncoder.java",
        "class_name": "org.apache.commons.codec.BinaryEncoder",
        "signature": "org.apache.commons.codec.BinaryEncoder.encode(byte[])",
        "snippet": "    byte[] encode(byte[] pArray) throws EncoderException;",
        "begin_line": 40,
        "end_line": 40,
        "comment": "\n     * Encodes a byte array and return the encoded data\n     * as a byte array.\n     * \n     * @param pArray Data to be encoded\n     *\n     * @return A byte array containing the encoded data\n     * \n     * @throws EncoderException thrown if the Encoder\n     *      encounters a failure condition during the\n     *      encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException()",
        "snippet": "    public EncoderException() {\n        super();\n    }",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     * \n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.String)",
        "snippet": "    public EncoderException(String message) {\n        super(message);\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     * \n     * @param message\n     *            a useful message relating to the encoder specific error.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public EncoderException(String message, Throwable cause) {\n        super(message, cause);\n    }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "\n     * Constructs a new exception with the specified detail message and cause.\n     * \n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     * \n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/EncoderException.java",
        "class_name": "org.apache.commons.codec.EncoderException",
        "signature": "org.apache.commons.codec.EncoderException.EncoderException(java.lang.Throwable)",
        "snippet": "    public EncoderException(Throwable cause) {\n        super(cause);\n    }",
        "begin_line": 87,
        "end_line": 89,
        "comment": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     * \n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/StringDecoder.java",
        "class_name": "org.apache.commons.codec.StringDecoder",
        "signature": "org.apache.commons.codec.StringDecoder.decode(java.lang.String)",
        "snippet": "    String decode(String pString) throws DecoderException;",
        "begin_line": 38,
        "end_line": 38,
        "comment": "\n     * Decodes a String and returns a String.\n     * \n     * @param pString a String to encode\n     * \n     * @return the encoded String\n     * \n     * @throws DecoderException thrown if there is\n     *  an error conidition during the Encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/StringEncoder.java",
        "class_name": "org.apache.commons.codec.StringEncoder",
        "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
        "snippet": "    String encode(String pString) throws EncoderException;",
        "begin_line": 38,
        "end_line": 38,
        "comment": "\n     * Encodes a String and returns a String.\n     * \n     * @param pString a String to encode\n     * \n     * @return the encoded String\n     * \n     * @throws EncoderException thrown if there is\n     *  an error conidition during the Encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.StringEncoderComparator()",
        "snippet": "    public StringEncoderComparator() {\n        this.stringEncoder = null;   // Trying to use this will cause things to break\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Constructs a new instance.\n     * @deprecated as creating without a StringEncoder will lead to a \n     *             broken NullPointerException creating comparator.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.StringEncoderComparator(org.apache.commons.codec.StringEncoder)",
        "snippet": "    public StringEncoderComparator(StringEncoder stringEncoder) {\n        this.stringEncoder = stringEncoder;\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "\n     * Constructs a new instance with the given algorithm.\n     * @param stringEncoder the StringEncoder used for comparisons.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/StringEncoderComparator.java",
        "class_name": "org.apache.commons.codec.StringEncoderComparator",
        "signature": "org.apache.commons.codec.StringEncoderComparator.compare(java.lang.Object, java.lang.Object)",
        "snippet": "    public int compare(Object o1, Object o2) {\n\n        int compareCode = 0;\n\n        try {\n            Comparable s1 = (Comparable) this.stringEncoder.encode(o1);\n            Comparable s2 = (Comparable) this.stringEncoder.encode(o2);\n            compareCode = s1.compareTo(s2);\n        } \n        catch (EncoderException ee) {\n            compareCode = 0;\n        }\n        return compareCode;\n    }",
        "begin_line": 71,
        "end_line": 84,
        "comment": "\n     * Compares two strings based not on the strings \n     * themselves, but on an encoding of the two \n     * strings using the StringEncoder this Comparator\n     * was created with.\n     * \n     * If an {@link EncoderException} is encountered, return <code>0</code>.\n     * \n     * @param o1 the object to compare\n     * @param o2 the object to compare to\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n     * @see Comparable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException()",
        "snippet": "    public DecoderException() {\n        super();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     * \n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.String)",
        "snippet": "    public DecoderException(String message) {\n        super(message);\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     * \n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public DecoderException(String message, Throwable cause) {\n        super(message, cause);\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * Constructsa new exception with the specified detail message and cause.\n     * \n     * <p>\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     * \n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/DecoderException.java",
        "class_name": "org.apache.commons.codec.DecoderException",
        "signature": "org.apache.commons.codec.DecoderException.DecoderException(java.lang.Throwable)",
        "snippet": "    public DecoderException(Throwable cause) {\n        super(cause);\n    }",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     * \n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/Decoder.java",
        "class_name": "org.apache.commons.codec.Decoder",
        "signature": "org.apache.commons.codec.Decoder.decode(java.lang.Object)",
        "snippet": "    Object decode(Object pObject) throws DecoderException;",
        "begin_line": 53,
        "end_line": 53,
        "comment": "\n     * Decodes an \"encoded\" Object and returns a \"decoded\"\n     * Object.  Note that the implementation of this\n     * interface will try to cast the Object parameter\n     * to the specific type expected by a particular Decoder\n     * implementation.  If a {@link ClassCastException} occurs\n     * this decode method will throw a DecoderException.\n     * \n     * @param pObject an object to \"decode\"\n     * \n     * @return a 'decoded\" object\n     * \n     * @throws DecoderException a decoder exception can\n     * be thrown for any number of reasons.  Some good\n     * candidates are that the parameter passed to this\n     * method is null, a param cannot be cast to the\n     * appropriate type for a specific encoder.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/Encoder.java",
        "class_name": "org.apache.commons.codec.Encoder",
        "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
        "snippet": "    Object encode(Object pObject) throws EncoderException;",
        "begin_line": 44,
        "end_line": 44,
        "comment": "\n     * Encodes an \"Object\" and returns the encoded content \n     * as an Object.  The Objects here may just be <code>byte[]</code>\n     * or <code>String</code>s depending on the implementation used.\n     *   \n     * @param pObject An object ot encode\n     * \n     * @return An \"encoded\" Object\n     * \n     * @throws EncoderException an encoder exception is\n     *  thrown if the encoder experiences a failure\n     *  condition during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
        "snippet": "    private static byte[] digest(MessageDigest digest, InputStream data) throws IOException {\n        byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest.digest();\n    }",
        "begin_line": 49,
        "end_line": 59,
        "comment": "\n     * Read through an InputStream and returns the digest for the data\n     * \n     * @param digest\n     *            The MessageDigest to use (e.g. MD5)\n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     * @throws IOException\n     *             On error reading from the stream\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getBytesUtf8(java.lang.String)",
        "snippet": "    private static byte[] getBytesUtf8(String data) {\n        return StringUtils.getBytesUtf8(data);\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Calls {@link StringUtils#getBytesUtf8(String)}\n     * \n     * @param data\n     *            the String to encode\n     * @return encoded bytes\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
        "snippet": "    static MessageDigest getDigest(String algorithm) {\n        try {\n            return MessageDigest.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e.getMessage());\n        }\n    }",
        "begin_line": 85,
        "end_line": 91,
        "comment": "\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\n     * \n     * @param algorithm\n     *            the name of the algorithm requested. See <a\n     *            href=\"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">Appendix A in the Java\n     *            Cryptography Architecture API Specification & Reference</a> for information about standard algorithm\n     *            names.\n     * @return An MD5 digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()",
        "snippet": "    private static MessageDigest getMd5Digest() {\n        return getDigest(\"MD5\");\n    }",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n     * Returns an MD5 MessageDigest.\n     * \n     * @return An MD5 digest instance.\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha256Digest()",
        "snippet": "    private static MessageDigest getSha256Digest() {\n        return getDigest(\"SHA-256\");\n    }",
        "begin_line": 114,
        "end_line": 116,
        "comment": "\n     * Returns an SHA-256 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @return An SHA-256 digest instance.\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha384Digest()",
        "snippet": "    private static MessageDigest getSha384Digest() {\n        return getDigest(\"SHA-384\");\n    }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n     * Returns an SHA-384 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @return An SHA-384 digest instance.\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512Digest()",
        "snippet": "    private static MessageDigest getSha512Digest() {\n        return getDigest(\"SHA-512\");\n    }",
        "begin_line": 142,
        "end_line": 144,
        "comment": "\n     * Returns an SHA-512 digest.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @return An SHA-512 digest instance.\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.getShaDigest()",
        "snippet": "    private static MessageDigest getShaDigest() {\n        return getDigest(\"SHA\");\n    }",
        "begin_line": 153,
        "end_line": 155,
        "comment": "\n     * Returns an SHA-1 digest.\n     * \n     * @return An SHA-1 digest instance.\n     * @throws RuntimeException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(byte[])",
        "snippet": "    public static byte[] md5(byte[] data) {\n        return getMd5Digest().digest(data);\n    }",
        "begin_line": 164,
        "end_line": 166,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.io.InputStream)",
        "snippet": "    public static byte[] md5(InputStream data) throws IOException {\n        return digest(getMd5Digest(), data);\n    }",
        "begin_line": 178,
        "end_line": 180,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.lang.String)",
        "snippet": "    public static byte[] md5(String data) {\n        return md5(getBytesUtf8(data));\n    }",
        "begin_line": 189,
        "end_line": 191,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])",
        "snippet": "    public static String md5Hex(byte[] data) {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 200,
        "end_line": 202,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.io.InputStream)",
        "snippet": "    public static String md5Hex(InputStream data) throws IOException {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.lang.String)",
        "snippet": "    public static String md5Hex(String data) {\n        return Hex.encodeHexString(md5(data));\n    }",
        "begin_line": 225,
        "end_line": 227,
        "comment": "\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return MD5 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(byte[])",
        "snippet": "    public static byte[] sha(byte[] data) {\n        return getShaDigest().digest(data);\n    }",
        "begin_line": 236,
        "end_line": 238,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(java.io.InputStream)",
        "snippet": "    public static byte[] sha(InputStream data) throws IOException {\n        return digest(getShaDigest(), data);\n    }",
        "begin_line": 250,
        "end_line": 252,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha(java.lang.String)",
        "snippet": "    public static byte[] sha(String data) {\n        return sha(getBytesUtf8(data));\n    }",
        "begin_line": 261,
        "end_line": 263,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(byte[])",
        "snippet": "    public static byte[] sha256(byte[] data) {\n        return getSha256Digest().digest(data);\n    }",
        "begin_line": 276,
        "end_line": 278,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.io.InputStream)",
        "snippet": "    public static byte[] sha256(InputStream data) throws IOException {\n        return digest(getSha256Digest(), data);\n    }",
        "begin_line": 293,
        "end_line": 295,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.lang.String)",
        "snippet": "    public static byte[] sha256(String data) {\n        return sha256(getBytesUtf8(data));\n    }",
        "begin_line": 308,
        "end_line": 310,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])",
        "snippet": "    public static String sha256Hex(byte[] data) {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 323,
        "end_line": 325,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.io.InputStream)",
        "snippet": "    public static String sha256Hex(InputStream data) throws IOException {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 340,
        "end_line": 342,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.lang.String)",
        "snippet": "    public static String sha256Hex(String data) {\n        return Hex.encodeHexString(sha256(data));\n    }",
        "begin_line": 355,
        "end_line": 357,
        "comment": "\n     * Calculates the SHA-256 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-256 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(byte[])",
        "snippet": "    public static byte[] sha384(byte[] data) {\n        return getSha384Digest().digest(data);\n    }",
        "begin_line": 370,
        "end_line": 372,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.io.InputStream)",
        "snippet": "    public static byte[] sha384(InputStream data) throws IOException {\n        return digest(getSha384Digest(), data);\n    }",
        "begin_line": 387,
        "end_line": 389,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.lang.String)",
        "snippet": "    public static byte[] sha384(String data) {\n        return sha384(getBytesUtf8(data));\n    }",
        "begin_line": 402,
        "end_line": 404,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])",
        "snippet": "    public static String sha384Hex(byte[] data) {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 417,
        "end_line": 419,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.io.InputStream)",
        "snippet": "    public static String sha384Hex(InputStream data) throws IOException {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 434,
        "end_line": 436,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.lang.String)",
        "snippet": "    public static String sha384Hex(String data) {\n        return Hex.encodeHexString(sha384(data));\n    }",
        "begin_line": 449,
        "end_line": 451,
        "comment": "\n     * Calculates the SHA-384 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-384 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(byte[])",
        "snippet": "    public static byte[] sha512(byte[] data) {\n        return getSha512Digest().digest(data);\n    }",
        "begin_line": 464,
        "end_line": 466,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.io.InputStream)",
        "snippet": "    public static byte[] sha512(InputStream data) throws IOException {\n        return digest(getSha512Digest(), data);\n    }",
        "begin_line": 481,
        "end_line": 483,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.lang.String)",
        "snippet": "    public static byte[] sha512(String data) {\n        return sha512(getBytesUtf8(data));\n    }",
        "begin_line": 496,
        "end_line": 498,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])",
        "snippet": "    public static String sha512Hex(byte[] data) {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 511,
        "end_line": 513,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.io.InputStream)",
        "snippet": "    public static String sha512Hex(InputStream data) throws IOException {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 528,
        "end_line": 530,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.lang.String)",
        "snippet": "    public static String sha512Hex(String data) {\n        return Hex.encodeHexString(sha512(data));\n    }",
        "begin_line": 543,
        "end_line": 545,
        "comment": "\n     * Calculates the SHA-512 digest and returns the value as a hex string.\n     * <p>\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n     * </p>\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-512 digest as a hex string\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(byte[])",
        "snippet": "    public static String shaHex(byte[] data) {\n        return Hex.encodeHexString(sha(data));\n    }",
        "begin_line": 554,
        "end_line": 556,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.io.InputStream)",
        "snippet": "    public static String shaHex(InputStream data) throws IOException {\n        return Hex.encodeHexString(sha(data));\n    }",
        "begin_line": 568,
        "end_line": 570,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     * @throws IOException\n     *             On error reading from the stream\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/digest/DigestUtils.java",
        "class_name": "org.apache.commons.codec.digest.DigestUtils",
        "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.lang.String)",
        "snippet": "    public static String shaHex(String data) {\n        return Hex.encodeHexString(sha(data));\n    }",
        "begin_line": 579,
        "end_line": 581,
        "comment": "\n     * Calculates the SHA-1 digest and returns the value as a hex string.\n     * \n     * @param data\n     *            Data to digest\n     * @return SHA-1 digest as a hex string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
        "snippet": "    public static byte[] getBytesIso8859_1(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.ISO_8859_1);\n    }",
        "begin_line": 48,
        "end_line": 50,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
        "snippet": "    public static byte[] getBytesUsAscii(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16);\n    }",
        "begin_line": 80,
        "end_line": 82,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16Be(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16BE);\n    }",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf16Le(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16LE);\n    }",
        "begin_line": 112,
        "end_line": 114,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
        "snippet": "    public static byte[] getBytesUtf8(String string) {\n        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n    }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     * \n     * @param string\n     *            the String to encode\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when the charset is missing, which should be never according the the Java specification.\n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @see #getBytesUnchecked(String, String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(java.lang.String, java.lang.String)",
        "snippet": "    public static byte[] getBytesUnchecked(String string, String charsetName) {\n        if (string == null) {\n            return null;\n        }\n        try {\n            return string.getBytes(charsetName);\n        } catch (UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }",
        "begin_line": 151,
        "end_line": 160,
        "comment": "\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     * \n     * @param string\n     *            the String to encode\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newIllegalStateException(java.lang.String, java.io.UnsupportedEncodingException)",
        "snippet": "    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n        return new IllegalStateException(charsetName + \": \" + e);\n    }",
        "begin_line": 162,
        "end_line": 164,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.lang.String)",
        "snippet": "    public static String newString(byte[] bytes, String charsetName) {\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            return new String(bytes, charsetName);\n        } catch (UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }",
        "begin_line": 184,
        "end_line": 193,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])",
        "snippet": "    public static String newStringIso8859_1(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);\n    }",
        "begin_line": 205,
        "end_line": 207,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
        "snippet": "    public static String newStringUsAscii(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.US_ASCII);\n    }",
        "begin_line": 219,
        "end_line": 221,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])",
        "snippet": "    public static String newStringUtf16(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.UTF_16);\n    }",
        "begin_line": 233,
        "end_line": 235,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])",
        "snippet": "    public static String newStringUtf16Be(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);\n    }",
        "begin_line": 247,
        "end_line": 249,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])",
        "snippet": "    public static String newStringUtf16Le(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);\n    }",
        "begin_line": 261,
        "end_line": 263,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/StringUtils.java",
        "class_name": "org.apache.commons.codec.binary.StringUtils",
        "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
        "snippet": "    public static String newStringUtf8(byte[] bytes) {\n        return StringUtils.newString(bytes, CharEncoding.UTF_8);\n    }",
        "begin_line": 275,
        "end_line": 277,
        "comment": "\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n     * \n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n     *             charset is required.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream)",
        "snippet": "    public Base64InputStream(InputStream in) {\n        this(in, false);\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream, boolean)",
        "snippet": "    public Base64InputStream(InputStream in, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }",
        "begin_line": 73,
        "end_line": 77,
        "comment": "\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.Base64InputStream(java.io.InputStream, boolean, int, byte[])",
        "snippet": "    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(in);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }",
        "begin_line": 95,
        "end_line": 99,
        "comment": "\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.read()",
        "snippet": "    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n            r = read(singleByte, 0, 1);\n        }\n        if (r > 0) {\n            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n        }\n        return -1;\n    }",
        "begin_line": 108,
        "end_line": 117,
        "comment": "\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.read(byte[], int, int)",
        "snippet": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            return base64.readResults(b, offset, len);\n        }\n    }",
        "begin_line": 138,
        "end_line": 164,
        "comment": "\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64InputStream",
        "signature": "org.apache.commons.codec.binary.Base64InputStream.markSupported()",
        "snippet": "    public boolean markSupported() {\n        return false; // not an easy job to support marks\n    }",
        "begin_line": 171,
        "end_line": 173,
        "comment": "\n     * {@inheritDoc}\n     * \n     * @return false\n     ",
        "resolved_comments": {
            "java.io.FilterInputStream": null
        }
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64()",
        "snippet": "    public Base64() {\n        this(0);\n    }",
        "begin_line": 236,
        "end_line": 238,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(boolean)",
        "snippet": "    public Base64(boolean urlSafe) {\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }",
        "begin_line": 255,
        "end_line": 257,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int)",
        "snippet": "    public Base64(int lineLength) {\n        this(lineLength, CHUNK_SEPARATOR);\n    }",
        "begin_line": 277,
        "end_line": 279,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int, byte[])",
        "snippet": "    public Base64(int lineLength, byte[] lineSeparator) {\n        this(lineLength, lineSeparator, false);\n    }",
        "begin_line": 303,
        "end_line": 305,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.Base64(int, byte[], boolean)",
        "snippet": "    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }",
        "begin_line": 332,
        "end_line": 351,
        "comment": "\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isUrlSafe()",
        "snippet": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }",
        "begin_line": 359,
        "end_line": 361,
        "comment": "\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n     * \n     * @return true if we're in URL-SAFE mode, false otherwise.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.hasData()",
        "snippet": "    boolean hasData() {\n        return this.buffer != null;\n    }",
        "begin_line": 368,
        "end_line": 370,
        "comment": "\n     * Returns true if this Base64 object has buffered data for reading.\n     * \n     * @return true if there is Base64 object still available for reading.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.avail()",
        "snippet": "    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }",
        "begin_line": 377,
        "end_line": 379,
        "comment": "\n     * Returns the amount of buffered data available for reading.\n     * \n     * @return The amount of buffered data available for reading.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.resizeBuffer()",
        "snippet": "    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }",
        "begin_line": 382,
        "end_line": 392,
        "comment": " Doubles our buffer. ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.readResults(byte[], int, int)",
        "snippet": "    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }",
        "begin_line": 406,
        "end_line": 423,
        "comment": "\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.setInitialBuffer(byte[], int, int)",
        "snippet": "    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }",
        "begin_line": 436,
        "end_line": 444,
        "comment": "\n     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n     * \n     * @param out\n     *            byte[] array to buffer directly to.\n     * @param outPos\n     *            Position to start buffering into.\n     * @param outAvail\n     *            Amount of bytes available for direct buffering.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encode(byte[], int, int)",
        "snippet": "    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }",
        "begin_line": 464,
        "end_line": 525,
        "comment": "\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decode(byte[], int, int)",
        "snippet": "    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }",
        "begin_line": 550,
        "end_line": 599,
        "comment": "\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte)",
        "snippet": "    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }",
        "begin_line": 609,
        "end_line": 611,
        "comment": "\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n     * \n     * @param octet\n     *            The value to test\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isArrayByteBase64(byte[])",
        "snippet": "    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 622,
        "end_line": 629,
        "comment": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         false, otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.containsBase64Byte(byte[])",
        "snippet": "    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 638,
        "end_line": 645,
        "comment": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n     * \n     * @param arrayOctet\n     *            byte array to test\n     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
        "snippet": "    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }",
        "begin_line": 654,
        "end_line": 656,
        "comment": "\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
        "snippet": "    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }",
        "begin_line": 666,
        "end_line": 668,
        "comment": "\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[])",
        "snippet": "    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }",
        "begin_line": 679,
        "end_line": 681,
        "comment": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[])",
        "snippet": "    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    ",
        "begin_line": 692,
        "end_line": 694,
        "comment": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
        "snippet": "    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }",
        "begin_line": 703,
        "end_line": 705,
        "comment": "\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object pObject) throws DecoderException {        \n        if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n        }\n    }",
        "begin_line": 717,
        "end_line": 725,
        "comment": "\n     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     * \n     * @param pObject\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decode(java.lang.String)",
        "snippet": "    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }",
        "begin_line": 735,
        "end_line": 737,
        "comment": "\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decode(byte[])",
        "snippet": "    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }",
        "begin_line": 746,
        "end_line": 766,
        "comment": "\n     * Decodes a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            A byte array containing Base64 character data\n     * @return a byte array containing binary data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
        "snippet": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }",
        "begin_line": 779,
        "end_line": 781,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean)",
        "snippet": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }",
        "begin_line": 797,
        "end_line": 799,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean, int)",
        "snippet": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }",
        "begin_line": 817,
        "end_line": 832,
        "comment": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
        "snippet": "    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }",
        "begin_line": 842,
        "end_line": 844,
        "comment": "\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
        "snippet": "    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }",
        "begin_line": 853,
        "end_line": 855,
        "comment": "\n     * Decodes Base64 data into octets\n     * \n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.discardWhitespace(byte[])",
        "snippet": "    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }",
        "begin_line": 865,
        "end_line": 882,
        "comment": "\n     * Discards any whitespace from a base-64 encoded block.\n     * \n     * @param data\n     *            The base-64 encoded data to discard the whitespace from.\n     * @return The data, less whitespace (see RFC 2045).\n     * @deprecated This method is no longer needed\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.isWhiteSpace(byte)",
        "snippet": "    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }",
        "begin_line": 891,
        "end_line": 901,
        "comment": "\n     * Checks if a byte value is whitespace or not.\n     * \n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof byte[])) {\n            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n        }\n        return encode((byte[]) pObject);\n    }",
        "begin_line": 915,
        "end_line": 920,
        "comment": "\n     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     * \n     * @param pObject\n     *            Object to encode\n     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeToString(byte[])",
        "snippet": "    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }",
        "begin_line": 930,
        "end_line": 932,
        "comment": "\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base64 character data\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encode(byte[])",
        "snippet": "    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }",
        "begin_line": 941,
        "end_line": 963,
        "comment": "\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n     * \n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only Base64 character data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.getEncodeLength(byte[], int, byte[])",
        "snippet": "    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }",
        "begin_line": 976,
        "end_line": 993,
        "comment": "\n     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n     *        chunkSeparator (e.g. CRLF).\n     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n     *\n     * @return amount of space needed to encoded the supplied array.  Returns\n     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
        "snippet": "    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }",
        "begin_line": 1004,
        "end_line": 1006,
        "comment": "\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
        "snippet": "    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }",
        "begin_line": 1018,
        "end_line": 1023,
        "comment": "\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     * \n     * @param bigInt\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.toIntegerBytes(java.math.BigInteger)",
        "snippet": "    static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if ((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }",
        "begin_line": 1032,
        "end_line": 1054,
        "comment": "\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n     * \n     * @param bigInt\n     *            <code>BigInteger</code> to be converted\n     * @return a byte array representation of the BigInteger parameter\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64.java",
        "class_name": "org.apache.commons.codec.binary.Base64",
        "signature": "org.apache.commons.codec.binary.Base64.reset()",
        "snippet": "    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }",
        "begin_line": 1059,
        "end_line": 1066,
        "comment": "\n     * Resets this Base64 object to its initial newly constructed state.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream)",
        "snippet": "    public Base64OutputStream(OutputStream out) {\n        this(out, true);\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     * \n     * @param out\n     *            OutputStream to wrap.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream, boolean)",
        "snippet": "    public Base64OutputStream(OutputStream out, boolean doEncode) {\n        super(out);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(false);\n    }",
        "begin_line": 72,
        "end_line": 76,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     * \n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.Base64OutputStream(java.io.OutputStream, boolean, int, byte[])",
        "snippet": "    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n        super(out);\n        this.doEncode = doEncode;\n        this.base64 = new Base64(lineLength, lineSeparator);\n    }",
        "begin_line": 94,
        "end_line": 98,
        "comment": "\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     * \n     * @param out\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.write(int)",
        "snippet": "    public void write(int i) throws IOException {\n        singleByte[0] = (byte) i;\n        write(singleByte, 0, 1);\n    }",
        "begin_line": 108,
        "end_line": 111,
        "comment": "\n     * Writes the specified <code>byte</code> to this output stream.\n     * \n     * @param i\n     *            source byte\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.write(byte[], int, int)",
        "snippet": "    public void write(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len > 0) {\n            if (doEncode) {\n                base64.encode(b, offset, len);\n            } else {\n                base64.decode(b, offset, len);\n            }\n            flush(false);\n        }\n    }",
        "begin_line": 131,
        "end_line": 146,
        "comment": "\n     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n     * output stream.\n     * \n     * @param b\n     *            source byte array\n     * @param offset\n     *            where to start reading the bytes\n     * @param len\n     *            maximum number of bytes to write\n     * \n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.flush(boolean)",
        "snippet": "    private void flush(boolean propogate) throws IOException {\n        int avail = base64.avail();\n        if (avail > 0) {\n            byte[] buf = new byte[avail];\n            int c = base64.readResults(buf, 0, avail);\n            if (c > 0) {\n                out.write(buf, 0, c);\n            }\n        }\n        if (propogate) {\n            out.flush();\n        }\n    }",
        "begin_line": 157,
        "end_line": 169,
        "comment": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n     * true, the wrapped stream will also be flushed.\n     * \n     * @param propogate\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.flush()",
        "snippet": "    public void flush() throws IOException {\n        flush(true);\n    }",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n     * \n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Base64OutputStream.java",
        "class_name": "org.apache.commons.codec.binary.Base64OutputStream",
        "signature": "org.apache.commons.codec.binary.Base64OutputStream.close()",
        "snippet": "    public void close() throws IOException {\n        // Notify encoder of EOF (-1).\n        if (doEncode) {\n            base64.encode(singleByte, 0, -1);\n        } else {\n            base64.decode(singleByte, 0, -1);\n        }\n        flush();\n        out.close();\n    }",
        "begin_line": 187,
        "end_line": 196,
        "comment": "\n     * Closes this output stream and releases any system resources associated with the stream.\n     * \n     * @throws IOException\n     *             if an I/O error occurs.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
        "snippet": "    public static byte[] decodeHex(char[] data) throws DecoderException {\n\n        int len = data.length;\n\n        if ((len & 0x01) != 0) {\n            throw new DecoderException(\"Odd number of characters.\");\n        }\n\n        byte[] out = new byte[len >> 1];\n\n        // two characters form the hex value.\n        for (int i = 0, j = 0; j < len; i++) {\n            int f = toDigit(data[j], j) << 4;\n            j++;\n            f = f | toDigit(data[j], j);\n            j++;\n            out[i] = (byte) (f & 0xFF);\n        }\n\n        return out;\n    }",
        "begin_line": 66,
        "end_line": 86,
        "comment": "\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     * \n     * @param data\n     *            An array of characters containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException\n     *             Thrown if an odd number or illegal of characters is supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
        "snippet": "    public static char[] encodeHex(byte[] data) {\n        return encodeHex(data, true);\n    }",
        "begin_line": 97,
        "end_line": 99,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     * \n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A char[] containing hexadecimal characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
        "snippet": "    public static char[] encodeHex(byte[] data, boolean toLowerCase) {\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n    }",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     * \n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toLowerCase\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], char[])",
        "snippet": "    protected static char[] encodeHex(byte[] data, char[] toDigits) {\n        int l = data.length;\n        char[] out = new char[l << 1];\n        // two characters form the hex value.\n        for (int i = 0, j = 0; i < l; i++) {\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n            out[j++] = toDigits[0x0F & data[i]];\n        }\n        return out;\n    }",
        "begin_line": 129,
        "end_line": 138,
        "comment": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     * \n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @param toDigits\n     *            the output alphabet\n     * @return A char[] containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
        "snippet": "    public static String encodeHexString(byte[] data) {\n        return new String(encodeHex(data));\n    }",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     * \n     * @param data\n     *            a byte[] to convert to Hex characters\n     * @return A String containing hexadecimal characters\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.toDigit(char, int)",
        "snippet": "    protected static int toDigit(char ch, int index) throws DecoderException {\n        int digit = Character.digit(ch, 16);\n        if (digit == -1) {\n            throw new DecoderException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n        }\n        return digit;\n    }",
        "begin_line": 164,
        "end_line": 170,
        "comment": "\n     * Converts a hexadecimal character to an integer.\n     * \n     * @param ch\n     *            A character to convert to an integer digit\n     * @param index\n     *            The index of the character in the source\n     * @return An integer\n     * @throws DecoderException\n     *             Thrown if ch is an illegal hex character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.Hex()",
        "snippet": "    public Hex() {\n        // use default encoding\n        this.charsetName = DEFAULT_CHARSET_NAME;\n    }",
        "begin_line": 177,
        "end_line": 180,
        "comment": "\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET_NAME}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.Hex(java.lang.String)",
        "snippet": "    public Hex(String csName) {\n        this.charsetName = csName;\n    }",
        "begin_line": 189,
        "end_line": 191,
        "comment": "\n     * Creates a new codec with the given charset name.\n     * \n     * @param csName\n     *            the charset name.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
        "snippet": "    public byte[] decode(byte[] array) throws DecoderException {\n        try {\n            return decodeHex(new String(array, getCharsetName()).toCharArray());\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 205,
        "end_line": 211,
        "comment": "\n     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     * \n     * @param array\n     *            An array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException\n     *             Thrown if an odd number of characters is supplied to this function\n     * @see #decodeHex(char[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object object) throws DecoderException {\n        try {\n            char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n            return decodeHex(charArray);\n        } catch (ClassCastException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 226,
        "end_line": 233,
        "comment": "\n     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n     * \n     * @param object\n     *            A String or, an array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException\n     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\n     *             char[]\n     * @see #decodeHex(char[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
        "snippet": "    public byte[] encode(byte[] array) {\n        return StringUtils.getBytesUnchecked(encodeHexString(array), getCharsetName());\n    }",
        "begin_line": 252,
        "end_line": 254,
        "comment": "\n     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n     * represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n     * {@link #getCharsetName()}.\n     * </p>\n     * \n     * @param array\n     *            a byte[] to convert to Hex characters\n     * @return A byte[] containing the bytes of the hexadecimal characters\n     * @throws IllegalStateException\n     *             if the charsetName is invalid. This API throws {@link IllegalStateException} instead of\n     *             {@link UnsupportedEncodingException} for backward compatibility.\n     * @see #encodeHex(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object object) throws EncoderException {\n        try {\n            byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object;\n            return encodeHex(byteArray);\n        } catch (ClassCastException e) {\n            throw new EncoderException(e.getMessage(), e);\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 272,
        "end_line": 281,
        "comment": "\n     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n     * characters to represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n     * {@link #getCharsetName()}.\n     * </p>\n     * \n     * @param object\n     *            a String, or byte[] to convert to Hex characters\n     * @return A char[] containing hexadecimal characters\n     * @throws EncoderException\n     *             Thrown if the given object is not a String or byte[]\n     * @see #encodeHex(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.getCharsetName()",
        "snippet": "    public String getCharsetName() {\n        return this.charsetName;\n    }",
        "begin_line": 289,
        "end_line": 291,
        "comment": "\n     * Gets the charset name.\n     * \n     * @return the charset name.\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/Hex.java",
        "class_name": "org.apache.commons.codec.binary.Hex",
        "signature": "org.apache.commons.codec.binary.Hex.toString()",
        "snippet": "    public String toString() {\n        return super.toString() + \"[charsetName=\" + this.charsetName + \"]\";\n    }",
        "begin_line": 298,
        "end_line": 300,
        "comment": "\n     * Returns a string representation of the object, which includes the charset name.\n     * \n     * @return a string representation of the object.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(byte[])",
        "snippet": "    public byte[] encode(byte[] raw) {\n        return toAsciiBytes(raw);\n    }",
        "begin_line": 80,
        "end_line": 82,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     * \n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character bytes one for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object raw) throws EncoderException {\n        if (!(raw instanceof byte[])) {\n            throw new EncoderException(\"argument not a byte array\");\n        }\n        return toAsciiChars((byte[]) raw);\n    }",
        "begin_line": 94,
        "end_line": 99,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\n     * \n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\n     * @throws EncoderException\n     *                  if the argument is not a byte[]\n     * @see org.apache.commons.codec.Encoder#encode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object ascii) throws DecoderException {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        if (ascii instanceof byte[]) {\n            return fromAscii((byte[]) ascii);\n        }\n        if (ascii instanceof char[]) {\n            return fromAscii((char[]) ascii);\n        }\n        if (ascii instanceof String) {\n            return fromAscii(((String) ascii).toCharArray());\n        }\n        throw new DecoderException(\"argument not a byte array\");\n    }",
        "begin_line": 111,
        "end_line": 125,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     * \n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @throws DecoderException\n     *                  if argument is not a byte[], char[] or String\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(byte[])",
        "snippet": "    public byte[] decode(byte[] ascii) {\n        return fromAscii(ascii);\n    }",
        "begin_line": 135,
        "end_line": 137,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     * \n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toByteArray(java.lang.String)",
        "snippet": "    public byte[] toByteArray(String ascii) {\n        if (ascii == null) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        return fromAscii(ascii.toCharArray());\n    }",
        "begin_line": 147,
        "end_line": 152,
        "comment": "\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     * \n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])",
        "snippet": "    public static byte[] fromAscii(char[] ascii) {\n        if (ascii == null || ascii.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get length/8 times bytes with 3 bit shifts to the right of the length\n        byte[] l_raw = new byte[ascii.length >> 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '1') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }",
        "begin_line": 166,
        "end_line": 184,
        "comment": "\n     * Decodes a char array where each char represents an ASCII '0' or '1'.\n     * \n     * @param ascii\n     *                  each char represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])",
        "snippet": "    public static byte[] fromAscii(byte[] ascii) {\n        if (isEmpty(ascii)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get length/8 times bytes with 3 bit shifts to the right of the length\n        byte[] l_raw = new byte[ascii.length >> 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if (ascii[jj - bits] == '1') {\n                    l_raw[ii] |= BITS[bits];\n                }\n            }\n        }\n        return l_raw;\n    }",
        "begin_line": 193,
        "end_line": 211,
        "comment": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     * \n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
        "snippet": "    private static boolean isEmpty(byte[] array) {\n        return array == null || array.length == 0;\n    }",
        "begin_line": 220,
        "end_line": 222,
        "comment": "\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     * \n     * @param array\n     *            the source array\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])",
        "snippet": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '0';\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
        "begin_line": 233,
        "end_line": 253,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     * \n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])",
        "snippet": "    public static char[] toAsciiChars(byte[] raw) {\n        if (isEmpty(raw)) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        char[] l_ascii = new char[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                    l_ascii[jj - bits] = '0';\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
        "begin_line": 263,
        "end_line": 283,
        "comment": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     * \n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/binary/BinaryCodec.java",
        "class_name": "org.apache.commons.codec.binary.BinaryCodec",
        "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[])",
        "snippet": "    public static String toAsciiString(byte[] raw) {\n        return new String(toAsciiChars(raw));\n    }",
        "begin_line": 293,
        "end_line": 295,
        "comment": "\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     * \n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.QuotedPrintableCodec()",
        "snippet": "    public QuotedPrintableCodec() {\n        this(CharEncoding.UTF_8);\n    }",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.QuotedPrintableCodec(java.lang.String)",
        "snippet": "    public QuotedPrintableCodec(String charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 105,
        "end_line": 108,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset\n     *                  the default string charset to use.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int, java.io.ByteArrayOutputStream)",
        "snippet": "    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }",
        "begin_line": 118,
        "end_line": 124,
        "comment": "\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *                  byte to encode\n     * @param buffer\n     *                  the buffer to write to\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[])",
        "snippet": "    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (printable.get(b)) {\n                buffer.write(b);\n            } else {\n                encodeQuotedPrintable(b, buffer);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 140,
        "end_line": 160,
        "comment": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param printable\n     *                  bitset of characters deemed quoted-printable\n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])",
        "snippet": "    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 177,
        "end_line": 197,
        "comment": "\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521.\n     * </p>\n     * \n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
        "snippet": "    public byte[] encode(byte[] bytes) {\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n    }",
        "begin_line": 211,
        "end_line": 213,
        "comment": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])",
        "snippet": "    public byte[] decode(byte[] bytes) throws DecoderException {\n        return decodeQuotedPrintable(bytes);\n    }",
        "begin_line": 230,
        "end_line": 232,
        "comment": "\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521.\n     * </p>\n     * \n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return encode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 251,
        "end_line": 260,
        "comment": "\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @return quoted-printable string\n     * \n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is unsuccessful\n     * \n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.lang.String)",
        "snippet": "    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n    }",
        "begin_line": 276,
        "end_line": 281,
        "comment": "\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n     * are converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @param charset\n     *                  the original string charset\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *                  Thrown if charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
        "snippet": "    public String decode(String pString) throws DecoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return decode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 295,
        "end_line": 304,
        "comment": "\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful.\n     *                  Thrown if charset is not supported.\n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return encode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return encode((String) pObject);\n        } else {\n            throw new EncoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable encoded\");\n        }\n    }",
        "begin_line": 316,
        "end_line": 328,
        "comment": "\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n     * \n     * @param pObject\n     *                  string to convert to a quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *                  Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n     *                  unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object pObject) throws DecoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be quoted-printable decoded\");\n        }\n    }",
        "begin_line": 341,
        "end_line": 353,
        "comment": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pObject\n     *                  quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset;\n    }",
        "begin_line": 360,
        "end_line": 362,
        "comment": "\n     * Returns the default charset used for string decoding and encoding.\n     * \n     * @return the default string charset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "class_name": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n    }",
        "begin_line": 381,
        "end_line": 386,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @param charset\n     *                  the charset for pString\n     * @return quoted-printable string\n     * \n     * @throws UnsupportedEncodingException\n     *                  Thrown if the charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.BCodec()",
        "snippet": "    public BCodec() {\n        this(CharEncoding.UTF_8);\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.BCodec(java.lang.String)",
        "snippet": "    public BCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 69,
        "end_line": 72,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset\n     *                  the default string charset to use.\n     * \n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.getEncoding()",
        "snippet": "    protected String getEncoding() {\n        return \"B\";\n    }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.doEncoding(byte[])",
        "snippet": "    protected byte[] doEncoding(byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        return Base64.encodeBase64(bytes);\n    }",
        "begin_line": 78,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.doDecoding(byte[])",
        "snippet": "    protected byte[] doDecoding(byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        return Base64.decodeBase64(bytes);\n    }",
        "begin_line": 85,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String value, final String charset) throws EncoderException {\n        if (value == null) {\n            return null;\n        }\n        try {\n            return encodeText(value, charset);\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 104,
        "end_line": 113,
        "comment": "\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\n     * \n     * @param value\n     *                  string to convert to Base64 form\n     * @param charset\n     *                  the charset for <code>value</code>\n     * @return Base64 string\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
        "snippet": "    public String encode(String value) throws EncoderException {\n        if (value == null) {\n            return null;\n        }\n        return encode(value, getDefaultCharset());\n    }",
        "begin_line": 125,
        "end_line": 130,
        "comment": "\n     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.\n     * \n     * @param value\n     *                  string to convert to Base64 form\n     * @return Base64 string\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
        "snippet": "    public String decode(String value) throws DecoderException {\n        if (value == null) {\n            return null;\n        }\n        try {\n            return decodeText(value);\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 142,
        "end_line": 151,
        "comment": "\n     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param value\n     *            Base64 string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object value) throws EncoderException {\n        if (value == null) {\n            return null;\n        } else if (value instanceof String) {\n            return encode((String) value);\n        } else {\n            throw new EncoderException(\"Objects of type \" +\n                  value.getClass().getName() +\n                  \" cannot be encoded using BCodec\");\n        }\n    }",
        "begin_line": 163,
        "end_line": 173,
        "comment": "\n     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.\n     * \n     * @param value\n     *                  object to convert to Base64 form\n     * @return Base64 object\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object value) throws DecoderException {\n        if (value == null) {\n            return null;\n        } else if (value instanceof String) {\n            return decode((String) value);\n        } else {\n            throw new DecoderException(\"Objects of type \" +\n                  value.getClass().getName() +\n                  \" cannot be decoded using BCodec\");\n        }\n    }",
        "begin_line": 188,
        "end_line": 198,
        "comment": "\n     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param value\n     *                  Base64 object to convert into its original form\n     * \n     * @return original object\n     * \n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/BCodec.java",
        "class_name": "org.apache.commons.codec.net.BCodec",
        "signature": "org.apache.commons.codec.net.BCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset;\n    }",
        "begin_line": 205,
        "end_line": 207,
        "comment": "\n     * The default charset used for string decoding and encoding.\n     * \n     * @return the default string charset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
        "snippet": "    protected String encodeText(final String text, final String charset)\n     throws EncoderException, UnsupportedEncodingException  \n    {\n        if (text == null) {\n            return null;\n        }\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(PREFIX); \n        buffer.append(charset);\n        buffer.append(SEP);\n        buffer.append(getEncoding());\n        buffer.append(SEP);\n        byte [] rawdata = doEncoding(text.getBytes(charset)); \n        buffer.append(StringUtils.newStringUsAscii(rawdata));\n        buffer.append(POSTFIX); \n        return buffer.toString();\n    }",
        "begin_line": 81,
        "end_line": 97,
        "comment": "\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the \n     * given charset. This method constructs the \"encoded-word\" header common to all the \n     * RFC 1522 codecs and then invokes {@link #doEncoding(byte [])} method of a concrete \n     * class to perform the specific enconding.\n     * \n     * @param text a string to encode\n     * @param charset a charset to be used\n     * \n     * @return RFC 1522 compliant \"encoded-word\"\n     * \n     * @throws EncoderException thrown if there is an error conidition during the Encoding \n     *  process.\n     * @throws UnsupportedEncodingException thrown if charset is not supported \n     * \n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
        "snippet": "    protected String decodeText(final String text)\n     throws DecoderException, UnsupportedEncodingException  \n    {\n        if (text == null) {\n            return null;\n        }\n        if ((!text.startsWith(PREFIX)) || (!text.endsWith(POSTFIX))) {\n            throw new DecoderException(\"RFC 1522 violation: malformed encoded content\");\n        }\n        int terminator = text.length() - 2;\n        int from = 2;\n        int to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"RFC 1522 violation: charset token not found\");\n        }\n        String charset = text.substring(from, to);\n        if (charset.equals(\"\")) {\n            throw new DecoderException(\"RFC 1522 violation: charset not specified\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        if (to == terminator) {\n            throw new DecoderException(\"RFC 1522 violation: encoding token not found\");\n        }\n        String encoding = text.substring(from, to);\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\n            throw new DecoderException(\"This codec cannot decode \" + \n                encoding + \" encoded content\");\n        }\n        from = to + 1;\n        to = text.indexOf(SEP, from);\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n        data = doDecoding(data); \n        return new String(data, charset);\n    }",
        "begin_line": 112,
        "end_line": 146,
        "comment": "\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text. This method \n     * processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes \n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific deconding.\n     * \n     * @param text a string to decode\n     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\n     * \n     * @throws DecoderException thrown if there is an error conidition during the Decoding \n     *  process.\n     * @throws UnsupportedEncodingException thrown if charset specified in the \"encoded-word\" \n     *  header is not supported \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.getEncoding()",
        "snippet": "    protected abstract String getEncoding();",
        "begin_line": 153,
        "end_line": 153,
        "comment": "\n     * Returns the codec name (referred to as encoding in the RFC 1522)\n     * \n     * @return name of the codec\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[])",
        "snippet": "    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;",
        "begin_line": 165,
        "end_line": 165,
        "comment": "\n     * Encodes an array of bytes using the defined encoding scheme\n     * \n     * @param bytes Data to be encoded\n     *\n     * @return A byte array containing the encoded data\n     * \n     * @throws EncoderException thrown if the Encoder encounters a failure condition \n     *  during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/RFC1522Codec.java",
        "class_name": "org.apache.commons.codec.net.RFC1522Codec",
        "signature": "org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[])",
        "snippet": "    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;",
        "begin_line": 177,
        "end_line": 177,
        "comment": "\n     * Decodes an array of bytes using the defined encoding scheme\n     * \n     * @param bytes Data to be decoded\n     *\n     * @return a byte array that contains decoded data\n     * \n     * @throws DecoderException A decoder exception is thrown if a Decoder encounters a \n     *  failure condition during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.URLCodec()",
        "snippet": "    public URLCodec() {\n        this(CharEncoding.UTF_8);\n    }",
        "begin_line": 101,
        "end_line": 103,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.URLCodec(java.lang.String)",
        "snippet": "    public URLCodec(String charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 110,
        "end_line": 113,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset the default string charset to use.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encodeUrl(java.util.BitSet, byte[])",
        "snippet": "    public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        if (urlsafe == null) {\n            urlsafe = WWW_FORM_URL;\n        }\n\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (urlsafe.get(b)) {\n                if (b == ' ') {\n                    b = '+';\n                }\n                buffer.write(b);\n            } else {\n                buffer.write(ESCAPE_CHAR);\n                char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buffer.write(hex1);\n                buffer.write(hex2);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 124,
        "end_line": 152,
        "comment": "\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     * \n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])",
        "snippet": "    public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == '+') {\n                buffer.write(' ');\n            } else if (b == ESCAPE_CHAR) {\n                try {\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "begin_line": 163,
        "end_line": 185,
        "comment": "\n     * Decodes an array of URL safe 7-bit characters into an array of \n     * original bytes. Escaped characters are converted back to their \n     * original representation.\n     *\n     * @param bytes array of URL safe characters\n     * @return array of original bytes \n     * @throws DecoderException Thrown if URL decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(byte[])",
        "snippet": "    public byte[] encode(byte[] bytes) {\n        return encodeUrl(WWW_FORM_URL, bytes);\n    }",
        "begin_line": 194,
        "end_line": 196,
        "comment": "\n     * Encodes an array of bytes into an array of URL safe 7-bit \n     * characters. Unsafe characters are escaped.\n     *\n     * @param bytes array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(byte[])",
        "snippet": "    public byte[] decode(byte[] bytes) throws DecoderException {\n        return decodeUrl(bytes);\n    }",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n     * Decodes an array of URL safe 7-bit characters into an array of \n     * original bytes. Escaped characters are converted back to their \n     * original representation.\n     *\n     * @param bytes array of URL safe characters\n     * @return array of original bytes \n     * @throws DecoderException Thrown if URL decoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n    }",
        "begin_line": 223,
        "end_line": 228,
        "comment": "\n     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\n     * \n     * @param pString\n     *            string to convert to a URL safe form\n     * @param charset\n     *            the charset for pString\n     * @return URL safe string\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return encode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 240,
        "end_line": 249,
        "comment": "\n     * Encodes a string into its URL safe form using the default string \n     * charset. Unsafe characters are escaped.\n     *\n     * @param pString string to convert to a URL safe form\n     * @return URL safe string\n     * @throws EncoderException Thrown if URL encoding is unsuccessful\n     * \n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String, java.lang.String)",
        "snippet": "    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n        if (pString == null) {\n            return null;\n        }\n        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n    }",
        "begin_line": 264,
        "end_line": 269,
        "comment": "\n     * Decodes a URL safe string into its original form using the \n     * specified encoding. Escaped characters are converted back \n     * to their original representation.\n     *\n     * @param pString URL safe string to convert into its original form\n     * @param charset the original string charset\n     * @return original string \n     * @throws DecoderException Thrown if URL decoding is unsuccessful\n     * @throws UnsupportedEncodingException Thrown if charset is not\n     *                                      supported \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
        "snippet": "    public String decode(String pString) throws DecoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return decode(pString, getDefaultCharset());\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 282,
        "end_line": 291,
        "comment": "\n     * Decodes a URL safe string into its original form using the default\n     * string charset. Escaped characters are converted back to their \n     * original representation.\n     *\n     * @param pString URL safe string to convert into its original form\n     * @return original string \n     * @throws DecoderException Thrown if URL decoding is unsuccessful\n     * \n     * @see #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return encode((byte[])pObject);\n        } else if (pObject instanceof String) {\n            return encode((String)pObject);\n        } else {\n            throw new EncoderException(\"Objects of type \" +\n                pObject.getClass().getName() + \" cannot be URL encoded\"); \n              \n        }\n    }",
        "begin_line": 303,
        "end_line": 315,
        "comment": "\n     * Encodes an object into its URL safe form. Unsafe characters are \n     * escaped.\n     *\n     * @param pObject string to convert to a URL safe form\n     * @return URL safe object\n     * @throws EncoderException Thrown if URL encoding is not \n     *                          applicable to objects of this type or\n     *                          if encoding is unsuccessful\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object pObject) throws DecoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof byte[]) {\n            return decode((byte[]) pObject);\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Objects of type \" + pObject.getClass().getName() + \" cannot be URL decoded\");\n\n        }\n    }",
        "begin_line": 328,
        "end_line": 339,
        "comment": "\n     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pObject\n     *                  URL safe object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.getEncoding()",
        "snippet": "    public String getEncoding() {\n        return this.charset;\n    }",
        "begin_line": 348,
        "end_line": 350,
        "comment": "\n     * The <code>String</code> encoding used for decoding and encoding.\n     * \n     * @return Returns the encoding.\n     * \n     * @deprecated use #getDefaultCharset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/URLCodec.java",
        "class_name": "org.apache.commons.codec.net.URLCodec",
        "signature": "org.apache.commons.codec.net.URLCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset;\n    }",
        "begin_line": 357,
        "end_line": 359,
        "comment": "\n     * The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.QCodec()",
        "snippet": "    public QCodec() {\n        this(CharEncoding.UTF_8);\n    }",
        "begin_line": 112,
        "end_line": 114,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.QCodec(java.lang.String)",
        "snippet": "    public QCodec(final String charset) {\n        super();\n        this.charset = charset;\n    }",
        "begin_line": 124,
        "end_line": 127,
        "comment": "\n     * Constructor which allows for the selection of a default charset\n     * \n     * @param charset\n     *                  the default string charset to use.\n     * \n     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.getEncoding()",
        "snippet": "    protected String getEncoding() {\n        return \"Q\";\n    }",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.doEncoding(byte[])",
        "snippet": "    protected byte[] doEncoding(byte[] bytes) {\n        if (bytes == null) {\n            return null;\n        }\n        byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n        if (this.encodeBlanks) {\n            for (int i = 0; i < data.length; i++) {\n                if (data[i] == BLANK) {\n                    data[i] = UNDERSCORE;\n                }\n            }\n        }\n        return data;\n    }",
        "begin_line": 133,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.doDecoding(byte[])",
        "snippet": "    protected byte[] doDecoding(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        boolean hasUnderscores = false;\n        for (int i = 0; i < bytes.length; i++) {\n            if (bytes[i] == UNDERSCORE) {\n                hasUnderscores = true;\n                break;\n            }\n        }\n        if (hasUnderscores) {\n            byte[] tmp = new byte[bytes.length];\n            for (int i = 0; i < bytes.length; i++) {\n                byte b = bytes[i];\n                if (b != UNDERSCORE) {\n                    tmp[i] = b;\n                } else {\n                    tmp[i] = BLANK;\n                }\n            }\n            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\n        } \n        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);       \n    }",
        "begin_line": 148,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String, java.lang.String)",
        "snippet": "    public String encode(final String pString, final String charset) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return encodeText(pString, charset);\n        } catch (UnsupportedEncodingException e) {\n            throw new EncoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 186,
        "end_line": 195,
        "comment": "\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @param charset\n     *                  the charset for pString\n     * @return quoted-printable string\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) throws EncoderException {\n        if (pString == null) {\n            return null;\n        }\n        return encode(pString, getDefaultCharset());\n    }",
        "begin_line": 207,
        "end_line": 212,
        "comment": "\n     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.\n     * \n     * @param pString\n     *                  string to convert to quoted-printable form\n     * @return quoted-printable string\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
        "snippet": "    public String decode(String pString) throws DecoderException {\n        if (pString == null) {\n            return null;\n        }\n        try {\n            return decodeText(pString);\n        } catch (UnsupportedEncodingException e) {\n            throw new DecoderException(e.getMessage(), e);\n        }\n    }",
        "begin_line": 226,
        "end_line": 235,
        "comment": "\n     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pString\n     *                  quoted-printable string to convert into its original form\n     * \n     * @return original string\n     * \n     * @throws DecoderException\n     *                  A decoder exception is thrown if a failure condition is encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof String) {\n            return encode((String) pObject);\n        } else {\n            throw new EncoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be encoded using Q codec\");\n        }\n    }",
        "begin_line": 247,
        "end_line": 257,
        "comment": "\n     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.\n     * \n     * @param pObject\n     *                  object to convert to quoted-printable form\n     * @return quoted-printable object\n     * \n     * @throws EncoderException\n     *                  thrown if a failure condition is encountered during the encoding process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.Object)",
        "snippet": "    public Object decode(Object pObject) throws DecoderException {\n        if (pObject == null) {\n            return null;\n        } else if (pObject instanceof String) {\n            return decode((String) pObject);\n        } else {\n            throw new DecoderException(\"Objects of type \" + \n                  pObject.getClass().getName() + \n                  \" cannot be decoded using Q codec\");\n        }\n    }",
        "begin_line": 272,
        "end_line": 282,
        "comment": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     * \n     * @param pObject\n     *                  quoted-printable object to convert into its original form\n     * \n     * @return original object\n     * \n     * @throws DecoderException\n     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is\n     *                  encountered during the decode process.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.getDefaultCharset()",
        "snippet": "    public String getDefaultCharset() {\n        return this.charset;\n    }",
        "begin_line": 289,
        "end_line": 291,
        "comment": "\n     * The default charset used for string decoding and encoding.\n     * \n     * @return the default string charset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.isEncodeBlanks()",
        "snippet": "    public boolean isEncodeBlanks() {\n        return this.encodeBlanks;\n    }",
        "begin_line": 298,
        "end_line": 300,
        "comment": "\n     * Tests if optional tranformation of SPACE characters is to be used\n     * \n     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/QCodec.java",
        "class_name": "org.apache.commons.codec.net.QCodec",
        "signature": "org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)",
        "snippet": "    public void setEncodeBlanks(boolean b) {\n        this.encodeBlanks = b;\n    }",
        "begin_line": 308,
        "end_line": 310,
        "comment": "\n     * Defines whether optional tranformation of SPACE characters is to be used\n     * \n     * @param b\n     *                  <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/net/Utils.java",
        "class_name": "org.apache.commons.codec.net.Utils",
        "signature": "org.apache.commons.codec.net.Utils.digit16(byte)",
        "snippet": "    static int digit16(byte b) throws DecoderException {\n        int i = Character.digit((char) b, 16);\n        if (i == -1) {\n            throw new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n        }\n        return i;\n    }",
        "begin_line": 41,
        "end_line": 47,
        "comment": "\r\n     * Returns the numeric value of the character <code>b</code> in radix 16.\r\n     * \r\n     * @param b\r\n     *            The byte to be converted.\r\n     * @return The numeric value represented by the character in radix 16.\r\n     * \r\n     * @throws DecoderException\r\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\r\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphone()",
        "snippet": "    public DoubleMetaphone() {\n        super();\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Creates an instance of this DoubleMetaphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
        "snippet": "    public String doubleMetaphone(String value) {\n        return doubleMetaphone(value, false);\n    }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n     * Encode a value with Double Metaphone\n     *\n     * @param value String to encode\n     * @return an encoded string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
        "snippet": "    public String doubleMetaphone(String value, boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n        \n        boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n        \n        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n        \n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(value, result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break; \n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }",
        "begin_line": 86,
        "end_line": 191,
        "comment": "\n     * Encode a value with Double Metaphone, optionally using the alternate\n     * encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object obj) throws EncoderException {\n        if (!(obj instanceof String)) {\n            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\"); \n        } \n        return doubleMetaphone((String) obj);\n    }",
        "begin_line": 201,
        "end_line": 206,
        "comment": "\n     * Encode the value using DoubleMetaphone.  It will only work if \n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.String)",
        "snippet": "    public String encode(String value) {\n        return doubleMetaphone(value);   \n    }",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n        return isDoubleMetaphoneEqual(value1, value2, false);\n    }",
        "begin_line": 228,
        "end_line": 230,
        "comment": "\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
        "snippet": "    public boolean isDoubleMetaphoneEqual(String value1, \n                                          String value2, \n                                          boolean alternate) {\n        return doubleMetaphone(value1, alternate).equals(doubleMetaphone\n                                                         (value2, alternate));\n    }",
        "begin_line": 242,
        "end_line": 247,
        "comment": "\n     * Check if the Double Metaphone values of two <code>String</code> values\n     * are equal, optionally using the alternate value.\n     * \n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if <code>true</code>.\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n     *          <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.getMaxCodeLen()",
        "snippet": "    public int getMaxCodeLen() {\n        return this.maxCodeLen;\n    }",
        "begin_line": 253,
        "end_line": 255,
        "comment": "\n     * Returns the maxCodeLen.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int)",
        "snippet": "    public void setMaxCodeLen(int maxCodeLen) {\n        this.maxCodeLen = maxCodeLen;\n    }",
        "begin_line": 261,
        "end_line": 263,
        "comment": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleAEIOUY(String value, DoubleMetaphoneResult result, int \n                             index) {\n        if (index == 0) {\n            result.append('A');\n        }\n        return index + 1;\n    }",
        "begin_line": 270,
        "end_line": 276,
        "comment": "\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleC(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (conditionC0(value, index)) {  // very confusing, moved out\n            result.append('K');\n            index += 2;\n        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n            result.append('S');\n            index += 2;\n        } else if (contains(value, index, 2, \"CH\")) {\n            index = handleCH(value, result, index);\n        } else if (contains(value, index, 2, \"CZ\") && \n                   !contains(value, index - 2, 4, \"WICZ\")) {\n            //-- \"Czerny\" --//\n            result.append('S', 'X');\n            index += 2;\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\n            //-- \"focaccia\" --//\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"CC\") && \n                   !(index == 1 && charAt(value, 0) == 'M')) {\n            //-- double \"cc\" but not \"McClelland\" --//\n            return handleCC(value, result, index);\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n            result.append('K');\n            index += 2;\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n            //-- Italian vs. English --//\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n                result.append('S', 'X');\n            } else {\n                result.append('S');\n            }\n            index += 2;\n        } else {\n            result.append('K');\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) { \n                //-- Mac Caffrey, Mac Gregor --//\n                index += 3;\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && \n                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n                index += 2;\n            } else {\n                index++;\n            }\n        }\n        \n        return index;\n    }",
        "begin_line": 281,
        "end_line": 330,
        "comment": "\n     * Handles 'C' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleCC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") && \n            !contains(value, index + 2, 2, \"HU\")) {\n            //-- \"bellocchio\" but not \"bacchus\" --//\n            if ((index == 1 && charAt(value, index - 1) == 'A') || \n                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n                //-- \"accident\", \"accede\", \"succeed\" --//\n                result.append(\"KS\");\n            } else {\n                //-- \"bacci\", \"bertucci\", other Italian --//\n                result.append('X');\n            }\n            index += 3;\n        } else {    // Pierce's rule\n            result.append('K');\n            index += 2;\n        }\n        \n        return index;\n    }",
        "begin_line": 335,
        "end_line": 356,
        "comment": "\n     * Handles 'CC' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleCH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n            result.append('K', 'X');\n            return index + 2;\n        } else if (conditionCH0(value, index)) {\n            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n            result.append('K');\n            return index + 2;\n        } else if (conditionCH1(value, index)) {\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n            result.append('K');\n            return index + 2;\n        } else {\n            if (index > 0) {\n                if (contains(value, 0, 2, \"MC\")) {\n                    result.append('K');\n                } else {\n                    result.append('X', 'K');\n                }\n            } else {\n                result.append('X');\n            }\n            return index + 2;\n        }\n    }",
        "begin_line": 361,
        "end_line": 387,
        "comment": "\n     * Handles 'CH' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleD(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleD(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"DG\")) {\n            //-- \"Edge\" --//\n            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n                result.append('J');\n                index += 3;\n                //-- \"Edgar\" --//\n            } else {\n                result.append(\"TK\");\n                index += 2;\n            }\n        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n            result.append('T');\n            index += 2;\n        } else {\n            result.append('T');\n            index++;\n        }\n        return index;\n    }",
        "begin_line": 392,
        "end_line": 413,
        "comment": "\n     * Handles 'D' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleG(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }",
        "begin_line": 418,
        "end_line": 469,
        "comment": "\n     * Handles 'G' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleGH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleGH(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n            result.append('K');\n            index += 2;\n        } else if (index == 0) {\n            if (charAt(value, index + 2) == 'I') {\n                result.append('J');\n            } else {\n                result.append('K');\n            }\n            index += 2;\n        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n            //-- Parker's rule (with some further refinements) - \"hugh\"\n            index += 2;\n        } else {\n            if (index > 2 && charAt(value, index - 1) == 'U' && \n                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n                result.append('F');\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n                result.append('K');\n            }\n            index += 2;\n        }\n        return index;\n    }",
        "begin_line": 474,
        "end_line": 503,
        "comment": "\n     * Handles 'GH' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleH(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        //-- only keep if first & before vowel or between 2 vowels --//\n        if ((index == 0 || isVowel(charAt(value, index - 1))) && \n            isVowel(charAt(value, index + 1))) {\n            result.append('H');\n            index += 2;\n            //-- also takes car of \"HH\" --//\n        } else {\n            index++;\n        }\n        return index;\n    }",
        "begin_line": 508,
        "end_line": 521,
        "comment": "\n     * Handles 'H' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleJ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleJ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                if ((index == 0 && (charAt(value, index + 4) == ' ') || \n                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n                    result.append('H');\n                } else {\n                    result.append('J', 'H');\n                }\n                index++;\n            } else {\n                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n                    result.append('J', 'A');\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && \n                              (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n                    result.append('J', 'H');\n                } else if (index == value.length() - 1) {\n                    result.append('J', ' ');\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n                    result.append('J');\n                }\n\n                if (charAt(value, index + 1) == 'J') {\n                    index += 2;\n                } else {\n                    index++;\n                }\n            }\n        return index;\n    }",
        "begin_line": 526,
        "end_line": 556,
        "comment": "\n     * Handles 'J' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleL(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleL(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'L') {\n            if (conditionL0(value, index)) {\n                result.appendPrimary('L');\n            } else {\n                result.append('L');\n            }\n            index += 2;\n        } else {\n            index++;\n            result.append('L');\n        }\n        return index;\n    }",
        "begin_line": 561,
        "end_line": 576,
        "comment": "\n     * Handles 'L' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleP(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleP(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (charAt(value, index + 1) == 'H') {\n            result.append('F');\n            index += 2;\n        } else {\n            result.append('P');\n            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 581,
        "end_line": 592,
        "comment": "\n     * Handles 'P' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleR(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleR(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (index == value.length() - 1 && !slavoGermanic && \n            contains(value, index - 2, 2, \"IE\") && \n            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n            result.appendAlternate('R');\n        } else {\n            result.append('R');\n        }\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n    }",
        "begin_line": 597,
        "end_line": 609,
        "comment": "\n     * Handles 'R' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleS(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleS(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n            index++;\n        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n            //-- special case \"sugar-\" --//\n            result.append('X', 'S');\n            index++;\n        } else if (contains(value, index, 2, \"SH\")) {\n            if (contains(value, index + 1, 4, \n                         \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n                //-- germanic --//\n                result.append('S');\n            } else {\n                result.append('X');\n            }\n            index += 2;\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n            //-- Italian and Armenian --//\n            if (slavoGermanic) {\n                result.append('S');\n            } else {\n                result.append('S', 'X');\n            }\n            index += 3;\n        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n            // \"snider\" match \"schneider\" --//\n            //-- also, -sz- in slavic language altho in hungarian it //\n            //   is pronounced \"s\" --//\n            result.append('S', 'X');\n            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n        } else if (contains(value, index, 2, \"SC\")) {\n            index = handleSC(value, result, index);\n        } else {\n            if (index == value.length() - 1 && contains(value, index - 2, \n                                                        2, \"AI\", \"OI\")){\n                //-- french e.g. \"resnais\", \"artois\" --//\n                result.appendAlternate('S');\n            } else {\n                result.append('S');\n            }\n            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 614,
        "end_line": 662,
        "comment": "\n     * Handles 'S' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleSC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleSC(String value, \n                         DoubleMetaphoneResult result, \n                         int index) {\n        if (charAt(value, index + 2) == 'H') {\n            //-- Schlesinger's rule --//\n            if (contains(value, index + 3, \n                         2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n                    //-- \"schermerhorn\", \"schenker\" --//\n                    result.append(\"X\", \"SK\");\n                } else {\n                    result.append(\"SK\");\n                }\n            } else {\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n                    result.append('X', 'S');\n                } else {\n                    result.append('X');\n                }\n            }\n        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n            result.append('S');\n        } else {\n            result.append(\"SK\");\n        }\n        return index + 3;\n    }",
        "begin_line": 667,
        "end_line": 694,
        "comment": "\n     * Handles 'SC' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleT(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleT(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 4, \"TION\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n            result.append('X');\n            index += 3;\n        } else if (contains(value, index, 2, \"TH\") || contains(value, index, \n                                                               3, \"TTH\")) {\n            if (contains(value, index + 2, 2, \"OM\", \"AM\") || \n                //-- special case \"thomas\", \"thames\" or germanic --//\n                contains(value, 0, 4, \"VAN \", \"VON \") || \n                contains(value, 0, 3, \"SCH\")) {\n                result.append('T');\n            } else {\n                result.append('0', 'T');\n            }\n            index += 2;\n        } else {\n            result.append('T');\n            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 699,
        "end_line": 724,
        "comment": "\n     * Handles 'T' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleW(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleW(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (contains(value, index, 2, \"WR\")) {\n            //-- can also be in middle of word --//\n            result.append('R');\n            index += 2;\n        } else {\n            if (index == 0 && (isVowel(charAt(value, index + 1)) || \n                               contains(value, index, 2, \"WH\"))) {\n                if (isVowel(charAt(value, index + 1))) {\n                    //-- Wasserman should match Vasserman --//\n                    result.append('A', 'F');\n                } else {\n                    //-- need Uomo to match Womo --//\n                    result.append('A');\n                }\n                index++;\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n                       contains(value, index - 1, \n                                5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n                       contains(value, 0, 3, \"SCH\")) {\n                //-- Arnow should match Arnoff --//\n                result.appendAlternate('F');\n                index++;\n            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n                //-- Polish e.g. \"filipowicz\" --//\n                result.append(\"TS\", \"FX\");\n                index += 4;\n            } else {\n                index++;\n            }\n        }\n        return index;\n    }",
        "begin_line": 729,
        "end_line": 763,
        "comment": "\n     * Handles 'W' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleX(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
        "snippet": "    private int handleX(String value, \n                        DoubleMetaphoneResult result, \n                        int index) {\n        if (index == 0) {\n            result.append('S');\n            index++;\n        } else {\n            if (!((index == value.length() - 1) && \n                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") || \n                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n                //-- French e.g. breaux --//\n                result.append(\"KS\");\n            }\n            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 768,
        "end_line": 784,
        "comment": "\n     * Handles 'X' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleZ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
        "snippet": "    private int handleZ(String value, DoubleMetaphoneResult result, int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n            result.append('J');\n            index += 2;\n        } else {\n            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n                result.append(\"S\", \"TS\");\n            } else {\n                result.append('S');\n            }\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n        }\n        return index;\n    }",
        "begin_line": 789,
        "end_line": 804,
        "comment": "\n     * Handles 'Z' cases\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionC0(java.lang.String, int)",
        "snippet": "    private boolean conditionC0(String value, int index) {\n        if (contains(value, index, 4, \"CHIA\")) {\n            return true;\n        } else if (index <= 1) {\n            return false;\n        } else if (isVowel(charAt(value, index - 2))) {\n            return false;\n        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n            return false;\n        } else {\n            char c = charAt(value, index + 2);\n            return (c != 'I' && c != 'E') ||\n                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n        }\n    }",
        "begin_line": 811,
        "end_line": 825,
        "comment": "\n     * Complex condition 0 for 'C'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(java.lang.String, int)",
        "snippet": "    private boolean conditionCH0(String value, int index) {\n        if (index != 0) {\n            return false;\n        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") && \n                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n            return false;\n        } else if (contains(value, 0, 5, \"CHORE\")) {\n            return false;\n        } else {\n            return true;\n        }\n    }",
        "begin_line": 830,
        "end_line": 841,
        "comment": "\n     * Complex condition 0 for 'CH'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(java.lang.String, int)",
        "snippet": "    private boolean conditionCH1(String value, int index) {\n        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, \n                                                                   3, \"SCH\")) ||\n                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                contains(value, index + 2, 1, \"T\", \"S\") ||\n                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n    }",
        "begin_line": 846,
        "end_line": 853,
        "comment": "\n     * Complex condition 1 for 'CH'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionL0(java.lang.String, int)",
        "snippet": "    private boolean conditionL0(String value, int index) {\n        if (index == value.length() - 3 && \n            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n            return true;\n        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n                   contains(value, index - 1, 4, \"ALLE\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }",
        "begin_line": 858,
        "end_line": 869,
        "comment": "\n     * Complex condition 0 for 'L'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionM0(java.lang.String, int)",
        "snippet": "    private boolean conditionM0(String value, int index) {\n        if (charAt(value, index + 1) == 'M') {\n            return true;\n        }\n        return contains(value, index - 1, 3, \"UMB\") &&\n                ((index + 1) == value.length() - 1 || contains(value,\n                        index + 2, 2, \"ER\"));\n    }",
        "begin_line": 874,
        "end_line": 881,
        "comment": "\n     * Complex condition 0 for 'M'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(java.lang.String)",
        "snippet": "    private boolean isSlavoGermanic(String value) {\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n    }",
        "begin_line": 889,
        "end_line": 892,
        "comment": "\n     * Determines whether or not a value is of slavo-germanic orgin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
        "snippet": "    private boolean isVowel(char ch) {\n        return VOWELS.indexOf(ch) != -1;\n    }",
        "begin_line": 897,
        "end_line": 899,
        "comment": "\n     * Determines whether or not a character is a vowel or not\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(java.lang.String)",
        "snippet": "    private boolean isSilentStart(String value) {\n        boolean result = false;\n        for (int i = 0; i < SILENT_START.length; i++) {\n            if (value.startsWith(SILENT_START[i])) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }",
        "begin_line": 906,
        "end_line": 915,
        "comment": "\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.cleanInput(java.lang.String)",
        "snippet": "    private String cleanInput(String input) {\n        if (input == null) {\n            return null;\n        }\n        input = input.trim();\n        if (input.length() == 0) {\n            return null;\n        }\n        return input.toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "begin_line": 920,
        "end_line": 929,
        "comment": "\n     * Cleans the input\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
        "snippet": "    protected char charAt(String value, int index) {\n        if (index < 0 || index >= value.length()) {\n            return Character.MIN_VALUE;\n        } \n        return value.charAt(index);\n    }",
        "begin_line": 936,
        "end_line": 941,
        "comment": "\n     * Gets the character at index <code>index</code> if available, otherwise\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n     * of a default\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria) {\n        return contains(value, start, length, \n                        new String[] { criteria });\n    }",
        "begin_line": 946,
        "end_line": 950,
        "comment": "\n     * Shortcut method with 1 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2 });\n    }",
        "begin_line": 955,
        "end_line": 959,
        "comment": "\n     * Shortcut method with 2 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3 });\n    }",
        "begin_line": 964,
        "end_line": 969,
        "comment": "\n     * Shortcut method with 3 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4 });\n    }",
        "begin_line": 974,
        "end_line": 980,
        "comment": "\n     * Shortcut method with 4 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5 });\n    }",
        "begin_line": 985,
        "end_line": 992,
        "comment": "\n     * Shortcut method with 5 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    private static boolean contains(String value, int start, int length, \n                                    String criteria1, String criteria2, \n                                    String criteria3, String criteria4, \n                                    String criteria5, String criteria6) {\n        return contains(value, start, length, \n                        new String[] { criteria1, criteria2, criteria3, \n                                       criteria4, criteria5, criteria6 });\n    }",
        "begin_line": 997,
        "end_line": 1004,
        "comment": "\n     * Shortcut method with 6 criteria\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String[])",
        "snippet": "    protected static boolean contains(String value, int start, int length, \n                                      String[] criteria) {\n        boolean result = false;\n        if (start >= 0 && start + length <= value.length()) {\n            String target = value.substring(start, start + length);\n\n            for (int i = 0; i < criteria.length; i++) {\n                if (target.equals(criteria[i])) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }",
        "begin_line": 1010,
        "end_line": 1024,
        "comment": "\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n     * matching up to length <code>length</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.DoubleMetaphoneResult(int)",
        "snippet": "        public DoubleMetaphoneResult(int maxLength) {\n            this.maxLength = maxLength;\n        }",
        "begin_line": 1038,
        "end_line": 1040,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
        "snippet": "        public void append(char value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }",
        "begin_line": 1042,
        "end_line": 1045,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
        "snippet": "        public void append(char primary, char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }",
        "begin_line": 1047,
        "end_line": 1050,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)",
        "snippet": "        public void appendPrimary(char value) {\n            if (this.primary.length() < this.maxLength) {\n                this.primary.append(value);\n            }\n        }",
        "begin_line": 1052,
        "end_line": 1056,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
        "snippet": "        public void appendAlternate(char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }",
        "begin_line": 1058,
        "end_line": 1062,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
        "snippet": "        public void append(String value) {\n            appendPrimary(value);\n            appendAlternate(value);\n        }",
        "begin_line": 1064,
        "end_line": 1067,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
        "snippet": "        public void append(String primary, String alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }",
        "begin_line": 1069,
        "end_line": 1072,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(java.lang.String)",
        "snippet": "        public void appendPrimary(String value) {\n            int addChars = this.maxLength - this.primary.length();\n            if (value.length() <= addChars) {\n                this.primary.append(value);\n            } else {\n                this.primary.append(value.substring(0, addChars));\n            }\n        }",
        "begin_line": 1074,
        "end_line": 1081,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(java.lang.String)",
        "snippet": "        public void appendAlternate(String value) {\n            int addChars = this.maxLength - this.alternate.length();\n            if (value.length() <= addChars) {\n                this.alternate.append(value);\n            } else {\n                this.alternate.append(value.substring(0, addChars));\n            }\n        }",
        "begin_line": 1083,
        "end_line": 1090,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getPrimary()",
        "snippet": "        public String getPrimary() {\n            return this.primary.toString();\n        }",
        "begin_line": 1092,
        "end_line": 1094,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getAlternate()",
        "snippet": "        public String getAlternate() {\n            return this.alternate.toString();\n        }",
        "begin_line": 1096,
        "end_line": 1098,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
        "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.isComplete()",
        "snippet": "        public boolean isComplete() {\n            return this.primary.length() >= this.maxLength && \n                this.alternate.length() >= this.maxLength;\n        }",
        "begin_line": 1100,
        "end_line": 1103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
        "snippet": "    static String clean(String str) {\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        int len = str.length();\n        char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }",
        "begin_line": 40,
        "end_line": 56,
        "comment": "\n     * Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     * \n     * @param str\n     *                  The String to clean.\n     * @return A clean String.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.difference(org.apache.commons.codec.StringEncoder, java.lang.String, java.lang.String)",
        "snippet": "    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n    }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n     * Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     * \n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     * \n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     * \n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/SoundexUtils.java",
        "class_name": "org.apache.commons.codec.language.SoundexUtils",
        "signature": "org.apache.commons.codec.language.SoundexUtils.differenceEncoded(java.lang.String, java.lang.String)",
        "snippet": "    static int differenceEncoded(String es1, String es2) {\n\n        if (es1 == null || es2 == null) {\n            return 0;\n        }\n        int lengthToMatch = Math.min(es1.length(), es2.length());\n        int diff = 0;\n        for (int i = 0; i < lengthToMatch; i++) {\n            if (es1.charAt(i) == es2.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff;\n    }",
        "begin_line": 108,
        "end_line": 121,
        "comment": "\n     * Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     * \n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     * \n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.Metaphone()",
        "snippet": "    public Metaphone() {\n        super();\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Creates an instance of the Metaphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
        "snippet": "    public String metaphone(String txt) {\n        boolean hard = false ;\n        if ((txt == null) || (txt.length() == 0)) {\n            return \"\" ;\n        }\n        // single character is itself\n        if (txt.length() == 1) {\n            return txt.toUpperCase(java.util.Locale.ENGLISH) ;\n        }\n      \n        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n      \n        StringBuffer local = new StringBuffer(40); // manipulate\n        StringBuffer code = new StringBuffer(10) ; //   output\n        // handle initial 2 characters exceptions\n        switch(inwd[0]) {\n        case 'K' : \n        case 'G' : \n        case 'P' : /* looking for KN, etc*/\n            if (inwd[1] == 'N') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'A': /* looking for AE */\n            if (inwd[1] == 'E') {\n                local.append(inwd, 1, inwd.length - 1);\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'W' : /* looking for WR or WH */\n            if (inwd[1] == 'R') {   // WR -> R\n                local.append(inwd, 1, inwd.length - 1); \n                break ;\n            }\n            if (inwd[1] == 'H') {\n                local.append(inwd, 1, inwd.length - 1);\n                local.setCharAt(0, 'W'); // WH -> W\n            } else {\n                local.append(inwd);\n            }\n            break;\n        case 'X' : /* initial X becomes S */\n            inwd[0] = 'S';\n            local.append(inwd);\n            break ;\n        default :\n            local.append(inwd);\n        } // now local has working string with initials fixed\n\n        int wdsz = local.length();\n        int n = 0 ;\n\n        while ((code.length() < this.getMaxCodeLen()) && \n               (n < wdsz) ) { // max code size of 4 works well\n            char symb = local.charAt(n) ;\n            // remove duplicate letters except C\n            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                n++ ;\n            } else { // not dup\n                switch(symb) {\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    if (n == 0) { \n                        code.append(symb);\n                    }\n                    break ; // only use vowel if leading char\n                case 'B' :\n                    if ( isPreviousChar(local, n, 'M') && \n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n                        break;\n                    }\n                    code.append(symb);\n                    break;\n                case 'C' : // lots of C special cases\n                    /* discard if SCI, SCE or SCY */\n                    if ( isPreviousChar(local, n, 'S') && \n                         !isLastChar(wdsz, n) && \n                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n                        break;\n                    }\n                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n                        code.append('X'); \n                        break;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n                        code.append('S');\n                        break; // CI,CE,CY -> S\n                    }\n                    if (isPreviousChar(local, n, 'S') &&\n                        isNextChar(local, n, 'H') ) { // SCH->sk\n                        code.append('K') ; \n                        break ;\n                    }\n                    if (isNextChar(local, n, 'H')) { // detect CH\n                        if ((n == 0) && \n                            (wdsz >= 3) && \n                            isVowel(local,2) ) { // CH consonant -> K consonant\n                            code.append('K');\n                        } else { \n                            code.append('X'); // CHvowel -> X\n                        }\n                    } else { \n                        code.append('K');\n                    }\n                    break ;\n                case 'D' :\n                    if (!isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'G') && \n                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                        code.append('J'); n += 2 ;\n                    } else { \n                        code.append('T');\n                    }\n                    break ;\n                case 'G' : // GH silent at end or before consonant\n                    if (isLastChar(wdsz, n + 1) && \n                        isNextChar(local, n, 'H')) {\n                        break;\n                    }\n                    if (!isLastChar(wdsz, n + 1) &&  \n                        isNextChar(local,n,'H') && \n                        !isVowel(local,n+2)) {\n                        break;\n                    }\n                    if ((n > 0) && \n                        ( regionMatch(local, n, \"GN\") ||\n                          regionMatch(local, n, \"GNED\") ) ) {\n                        break; // silent G\n                    }\n                    if (isPreviousChar(local, n, 'G')) {\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\n                        hard = true ;\n                    } else {\n                        hard = false ;\n                    }\n                    if (!isLastChar(wdsz, n) && \n                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n                        (!hard)) {\n                        code.append('J');\n                    } else {\n                        code.append('K');\n                    }\n                    break ;\n                case 'H':\n                    if (isLastChar(wdsz, n)) {\n                        break ; // terminal H\n                    }\n                    if ((n > 0) && \n                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n                        break;\n                    }\n                    if (isVowel(local,n+1)) {\n                        code.append('H'); // Hvowel\n                    }\n                    break;\n                case 'F': \n                case 'J' : \n                case 'L' :\n                case 'M': \n                case 'N' : \n                case 'R' :\n                    code.append(symb); \n                    break;\n                case 'K' :\n                    if (n > 0) { // not initial\n                        if (!isPreviousChar(local, n, 'C')) {\n                            code.append(symb);\n                        }\n                    } else {\n                        code.append(symb); // initial K\n                    }\n                    break ;\n                case 'P' :\n                    if (isNextChar(local,n,'H')) {\n                        // PH -> F\n                        code.append('F');\n                    } else {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'Q' :\n                    code.append('K');\n                    break;\n                case 'S' :\n                    if (regionMatch(local,n,\"SH\") || \n                        regionMatch(local,n,\"SIO\") || \n                        regionMatch(local,n,\"SIA\")) {\n                        code.append('X');\n                    } else {\n                        code.append('S');\n                    }\n                    break;\n                case 'T' :\n                    if (regionMatch(local,n,\"TIA\") || \n                        regionMatch(local,n,\"TIO\")) {\n                        code.append('X'); \n                        break;\n                    }\n                    if (regionMatch(local,n,\"TCH\")) {\n                        // Silent if in \"TCH\"\n                        break;\n                    }\n                    // substitute numeral 0 for TH (resembles theta after all)\n                    if (regionMatch(local,n,\"TH\")) {\n                        code.append('0');\n                    } else {\n                        code.append('T');\n                    }\n                    break ;\n                case 'V' :\n                    code.append('F'); break ;\n                case 'W' : case 'Y' : // silent if not followed by vowel\n                    if (!isLastChar(wdsz,n) && \n                        isVowel(local,n+1)) {\n                        code.append(symb);\n                    }\n                    break ;\n                case 'X' :\n                    code.append('K'); code.append('S');\n                    break ;\n                case 'Z' :\n                    code.append('S'); break ;\n                } // end switch\n                n++ ;\n            } // end else from symb != 'C'\n            if (code.length() > this.getMaxCodeLen()) { \n                code.setLength(this.getMaxCodeLen()); \n            }\n        }\n        return code.toString();\n    }",
        "begin_line": 82,
        "end_line": 315,
        "comment": "\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isVowel(java.lang.StringBuffer, int)",
        "snippet": "    private boolean isVowel(StringBuffer string, int index) {\n        return VOWELS.indexOf(string.charAt(index)) >= 0;\n    }",
        "begin_line": 317,
        "end_line": 319,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isPreviousChar(java.lang.StringBuffer, int, char)",
        "snippet": "    private boolean isPreviousChar(StringBuffer string, int index, char c) {\n        boolean matches = false;\n        if( index > 0 &&\n            index < string.length() ) {\n            matches = string.charAt(index - 1) == c;\n        }\n        return matches;\n    }",
        "begin_line": 321,
        "end_line": 328,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isNextChar(java.lang.StringBuffer, int, char)",
        "snippet": "    private boolean isNextChar(StringBuffer string, int index, char c) {\n        boolean matches = false;\n        if( index >= 0 &&\n            index < string.length() - 1 ) {\n            matches = string.charAt(index + 1) == c;\n        }\n        return matches;\n    }",
        "begin_line": 330,
        "end_line": 337,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.regionMatch(java.lang.StringBuffer, int, java.lang.String)",
        "snippet": "    private boolean regionMatch(StringBuffer string, int index, String test) {\n        boolean matches = false;\n        if( index >= 0 &&\n            (index + test.length() - 1) < string.length() ) {\n            String substring = string.substring( index, index + test.length());\n            matches = substring.equals( test );\n        }\n        return matches;\n    }",
        "begin_line": 339,
        "end_line": 347,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isLastChar(int, int)",
        "snippet": "    private boolean isLastChar(int wdsz, int n) {\n        return n + 1 == wdsz;\n    } ",
        "begin_line": 349,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\"); \n        }\n        return metaphone((String) pObject);\n    }",
        "begin_line": 366,
        "end_line": 371,
        "comment": "\n     * Encodes an Object using the metaphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         metaphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) {\n        return metaphone(pString);   \n    }",
        "begin_line": 379,
        "end_line": 381,
        "comment": "\n     * Encodes a String using the Metaphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The metaphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isMetaphoneEqual(String str1, String str2) {\n        return metaphone(str1).equals(metaphone(str2));\n    }",
        "begin_line": 391,
        "end_line": 393,
        "comment": "\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the metaphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.getMaxCodeLen()",
        "snippet": "    public int getMaxCodeLen() { return this.maxCodeLen; }",
        "begin_line": 399,
        "end_line": 399,
        "comment": "\n     * Returns the maxCodeLen.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Metaphone.java",
        "class_name": "org.apache.commons.codec.language.Metaphone",
        "signature": "org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int)",
        "snippet": "    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }",
        "begin_line": 405,
        "end_line": 405,
        "comment": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.difference(java.lang.String, java.lang.String)",
        "snippet": "    public int difference(String s1, String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     * \n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     * \n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE </a>\n     * \n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex()",
        "snippet": "    public Soundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n     * Creates an instance using US_ENGLISH_MAPPING\n     * \n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex(char[])",
        "snippet": "    public Soundex(char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }",
        "begin_line": 116,
        "end_line": 119,
        "comment": "\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     * \n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     * \n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.Soundex(java.lang.String)",
        "snippet": "    public Soundex(String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }",
        "begin_line": 129,
        "end_line": 131,
        "comment": "\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     * \n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) pObject);\n    }",
        "begin_line": 146,
        "end_line": 151,
        "comment": "\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n     * \n     * @param pObject\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) {\n        return soundex(pString);\n    }",
        "begin_line": 162,
        "end_line": 164,
        "comment": "\n     * Encodes a String using the soundex algorithm.\n     * \n     * @param pString\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getMappingCode(java.lang.String, int)",
        "snippet": "    private char getMappingCode(String str, int index) {\n        // map() throws IllegalArgumentException\n        char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                char preHWChar = str.charAt(index - 2);\n                char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }",
        "begin_line": 179,
        "end_line": 194,
        "comment": "\n     * Used internally by the SoundEx algorithm.\n     * \n     * Consonants from the same code group separated by W or H are treated as one.\n     * \n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getMaxLength()",
        "snippet": "    public int getMaxLength() {\n        return this.maxLength;\n    }",
        "begin_line": 202,
        "end_line": 204,
        "comment": "\n     * Returns the maxLength. Standard Soundex\n     * \n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.getSoundexMapping()",
        "snippet": "    private char[] getSoundexMapping() {\n        return this.soundexMapping;\n    }",
        "begin_line": 211,
        "end_line": 213,
        "comment": "\n     * Returns the soundex mapping.\n     * \n     * @return soundexMapping.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.map(char)",
        "snippet": "    private char map(char ch) {\n        int index = ch - 'A';\n        if (index < 0 || index >= this.getSoundexMapping().length) {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n        return this.getSoundexMapping()[index];\n    }",
        "begin_line": 224,
        "end_line": 230,
        "comment": "\n     * Maps the given upper-case character to its Soundex code.\n     * \n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if <code>ch</code> is not mapped.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.setMaxLength(int)",
        "snippet": "    public void setMaxLength(int maxLength) {\n        this.maxLength = maxLength;\n    }",
        "begin_line": 239,
        "end_line": 241,
        "comment": "\n     * Sets the maxLength.\n     * \n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Soundex.java",
        "class_name": "org.apache.commons.codec.language.Soundex",
        "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
        "snippet": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        char out[] = {'0', '0', '0', '0'};\n        char last, mapped;\n        int incount = 1, count = 1;\n        out[0] = str.charAt(0);\n        // getMappingCode() throws IllegalArgumentException\n        last = getMappingCode(str, 0);\n        while ((incount < str.length()) && (count < out.length)) {\n            mapped = getMappingCode(str, incount++);\n            if (mapped != 0) {\n                if ((mapped != '0') && (mapped != last)) {\n                    out[count++] = mapped;\n                }\n                last = mapped;\n            }\n        }\n        return new String(out);\n    }",
        "begin_line": 252,
        "end_line": 276,
        "comment": "\n     * Retrieves the Soundex code for a given String object.\n     * \n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex()",
        "snippet": "    public RefinedSoundex() {\n        this.soundexMapping = US_ENGLISH_MAPPING;\n    }",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n     * Creates an instance of the RefinedSoundex object using the default US\n     * English mapping.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex(char[])",
        "snippet": "    public RefinedSoundex(char[] mapping) {\n        this.soundexMapping = new char[mapping.length];\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n    }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "\n     * Creates a refined soundex instance using a custom mapping. This\n     * constructor can be used to customize the mapping, and/or possibly\n     * provide an internationalized mapping for a non-Western character set.\n     * \n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for\n     *                  a given character\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.RefinedSoundex(java.lang.String)",
        "snippet": "    public RefinedSoundex(String mapping) {\n        this.soundexMapping = mapping.toCharArray();\n    }",
        "begin_line": 88,
        "end_line": 90,
        "comment": "\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     * \n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.difference(java.lang.String, java.lang.String)",
        "snippet": "    public int difference(String s1, String s2) throws EncoderException {\n        return SoundexUtils.difference(this, s1, s2);\n    }",
        "begin_line": 114,
        "end_line": 116,
        "comment": "\n     * Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     * \n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to to the length of the shortest encoded String.\n     * \n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     * \n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\");\n        }\n        return soundex((String) pObject);\n    }",
        "begin_line": 131,
        "end_line": 136,
        "comment": "\n     * Encodes an Object using the refined soundex algorithm. This method is\n     * provided in order to satisfy the requirements of the Encoder interface,\n     * and will throw an EncoderException if the supplied object is not of type\n     * java.lang.String.\n     * \n     * @param pObject\n     *                  Object to encode\n     * @return An object (or type java.lang.String) containing the refined\n     *             soundex code which corresponds to the String supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) {\n        return soundex(pString);\n    }",
        "begin_line": 145,
        "end_line": 147,
        "comment": "\n     * Encodes a String using the refined soundex algorithm.\n     * \n     * @param pString\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)",
        "snippet": "    char getMappingCode(char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\n    }",
        "begin_line": 158,
        "end_line": 163,
        "comment": "\n     * Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     * \n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/RefinedSoundex.java",
        "class_name": "org.apache.commons.codec.language.RefinedSoundex",
        "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
        "snippet": "    public String soundex(String str) {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        StringBuffer sBuf = new StringBuffer();\n        sBuf.append(str.charAt(0));\n\n        char last, current;\n        last = '*';\n\n        for (int i = 0; i < str.length(); i++) {\n\n            current = getMappingCode(str.charAt(i));\n            if (current == last) {\n                continue;\n            } else if (current != 0) {\n                sBuf.append(current);\n            }\n\n            last = current;\n\n        }\n\n        return sBuf.toString();\n    }",
        "begin_line": 172,
        "end_line": 201,
        "comment": "\n     * Retreives the Refined Soundex code for a given String object.\n     * \n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.Caverphone()",
        "snippet": "    public Caverphone() {\n        super();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Creates an instance of the Caverphone encoder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.caverphone(java.lang.String)",
        "snippet": "    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }",
        "begin_line": 50,
        "end_line": 140,
        "comment": "\n     * Find the caverphone value of a String. \n     *\n     * @param txt String to find the caverphone code for\n     * @return A caverphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.encode(java.lang.Object)",
        "snippet": "    public Object encode(Object pObject) throws EncoderException {\n        if (!(pObject instanceof String)) {\n            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\"); \n        }\n        return caverphone((String) pObject);\n    }",
        "begin_line": 154,
        "end_line": 159,
        "comment": "\n     * Encodes an Object using the caverphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type java.lang.String.\n     *\n     * @param pObject Object to encode\n     * @return An object (or type java.lang.String) containing the \n     *         caverphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type java.lang.String\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.encode(java.lang.String)",
        "snippet": "    public String encode(String pString) {\n        return caverphone(pString);   \n    }",
        "begin_line": 167,
        "end_line": 169,
        "comment": "\n     * Encodes a String using the Caverphone algorithm. \n     *\n     * @param pString String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/java/org/apache/commons/codec/language/Caverphone.java",
        "class_name": "org.apache.commons.codec.language.Caverphone",
        "signature": "org.apache.commons.codec.language.Caverphone.isCaverphoneEqual(java.lang.String, java.lang.String)",
        "snippet": "    public boolean isCaverphoneEqual(String str1, String str2) {\n        return caverphone(str1).equals(caverphone(str2));\n    }",
        "begin_line": 179,
        "end_line": 181,
        "comment": "\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return <code>true</code> if the caverphones of these strings are identical, \n     *        <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    }
]