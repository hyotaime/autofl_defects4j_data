[
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.extraInterfaces(java.lang.Class<?>...)",
        "snippet": "    MockSettings extraInterfaces(Class<?>... interfaces);",
        "begin_line": 61,
        "end_line": 61,
        "comment": "\n     * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n     * <p>\n     * This mysterious feature should be used very occasionally.\n     * The object under test should know exactly its collaborators & dependencies.\n     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n     * <p>\n     * Examples:\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n     *\n     *   //now, the mock implements extra interfaces, so following casting is possible:\n     *   Bar bar = (Bar) foo;\n     *   Baz baz = (Baz) foo;\n     * </code></pre>\n     *\n     * @param interfaces extra interfaces the should implement.\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.name(java.lang.String)",
        "snippet": "    MockSettings name(String name);",
        "begin_line": 81,
        "end_line": 81,
        "comment": "\n     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n     * <p>\n     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n     * <p>\n     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n     * <p>\n     * Examples:\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n     *\n     *   //Below does exactly the same:\n     *   Foo foo = mock(Foo.class, \"foo\");\n     * </code></pre>\n     * @param name the name of the mock, later used in all verification errors\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.spiedInstance(java.lang.Object)",
        "snippet": "    MockSettings spiedInstance(Object instance);",
        "begin_line": 123,
        "end_line": 123,
        "comment": "\n     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n     *\n     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't...\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy:\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n     *\n     *   //Below does exactly the same:\n     *   Foo foo = spy(fooInstance);\n     * </code></pre>\n     *\n     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *\n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </code>\n     *\n     * @param instance to spy on\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.defaultAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    MockSettings defaultAnswer(Answer defaultAnswer);",
        "begin_line": 143,
        "end_line": 144,
        "comment": "\n     * Specifies default answers to interactions.\n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n     *\n     *   //Below does exactly the same:\n     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n     * </code></pre>\n     *\n     * @param defaultAnswer default answer to be used by mock when not stubbed\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.serializable()",
        "snippet": "    MockSettings serializable();",
        "begin_line": 162,
        "end_line": 162,
        "comment": "\n     * Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n     * <p>\n     * WARNING: This should be rarely used in unit testing.\n     * <p>\n     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   List serializableMock = mock(List.class, withSettings().serializable());\n     * </code></pre>\n     *\n     * @return settings instance so that you can fluently specify other settings\n     * @since 1.8.1\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.serializable(org.mockito.mock.SerializableMode)",
        "snippet": "    MockSettings serializable(SerializableMode mode);",
        "begin_line": 181,
        "end_line": 181,
        "comment": "\n     * Configures the mock to be serializable with a specific serializable mode.\n     * With this feature you can use a mock in a place that requires dependencies to be serializable.\n     * <p>\n     * WARNING: This should be rarely used in unit testing.\n     * <p>\n     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List serializableMock = mock(List.class, withSettings().serializable(SerializableMode.ACROSS_CLASSLOADERS));\n     * </code></pre>\n     *\n     * @param mode serialization mode\n     * @return settings instance so that you can fluently specify other settings\n     * @since 1.10.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.verboseLogging()",
        "snippet": "    MockSettings verboseLogging();",
        "begin_line": 198,
        "end_line": 198,
        "comment": "\n     * Enables real-time logging of method invocations on this mock. Can be used\n     * during test debugging in order to find wrong interactions with this mock.\n     * <p>\n     * Invocations are logged as they happen to the standard output stream.\n     * <p>\n     * Calling this method multiple times makes no difference.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n     * </code></pre>\n     *\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.invocationListeners(org.mockito.listeners.InvocationListener...)",
        "snippet": "    MockSettings invocationListeners(InvocationListener... listeners);",
        "begin_line": 218,
        "end_line": 218,
        "comment": "\n     * Registers a listener for method invocations on this mock. The listener is\n     * notified every time a method on this mock is called.\n     * <p>\n     * Multiple listeners may be added, but the same object is only added once.\n     * The order, in which the listeners are added, is not guaranteed to be the\n     * order in which the listeners are notified.\n     *\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n     * </code></pre>\n     *\n     * See the {@link InvocationListener listener interface} for more details.\n     *\n     * @param listeners The invocation listeners to add. May not be null.\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.stubOnly()",
        "snippet": "    MockSettings stubOnly();",
        "begin_line": 232,
        "end_line": 232,
        "comment": "\n     * A stub-only mock does not record method\n     * invocations, thus saving memory but\n     * disallowing verification of invocations.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * List stubOnly = mock(List.class, withSettings().stubOnly());\n     * </code></pre>\n     *\n     * @return settings instance so that you can fluently specify other settings\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.useConstructor()",
        "snippet": "    @Incubating\n    MockSettings useConstructor();",
        "begin_line": 252,
        "end_line": 253,
        "comment": "\n     * Mockito attempts to use constructor when creating instance of the mock.\n     * This is particularly useful for spying on abstract classes. See also {@link Mockito#spy(Class)}.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * //Robust API, via settings builder:\n     * OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n     *   .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n     *\n     * //Mocking a non-static inner abstract class:\n     * InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n     *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n     * </code></pre>\n     *\n     * @return settings instance so that you can fluently specify other settings\n     * @since 1.10.12\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockSettings.java",
        "class_name": "org.mockito.MockSettings",
        "signature": "org.mockito.MockSettings.outerInstance(java.lang.Object)",
        "snippet": "    @Incubating\n    MockSettings outerInstance(Object outerClassInstance);",
        "begin_line": 267,
        "end_line": 268,
        "comment": "\n     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * InnerClass mock = mock(InnerClass.class, withSettings()\n     *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n     * </code></pre>\n     *\n     * @return settings instance so that you can fluently specify other settings\n     * @since 1.10.12\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.ArgumentCaptor()",
        "snippet": "    @Deprecated\n    public ArgumentCaptor() {\n        this.clazz = null;\n    }",
        "begin_line": 85,
        "end_line": 88,
        "comment": "\n     * @deprecated\n     * \n     * <b>Please use factory method {@link ArgumentCaptor#forClass(Class)} to create captors</b>\n     * <p>\n     * This is required to avoid NullPointerExceptions when autoUnboxing primitive types.\n     * See issue 99.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n     *   verify(mock).doSomething(argument.capture());\n     *   assertEquals(\"John\", argument.getValue().getName());\n     * </code></pre>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.ArgumentCaptor(java.lang.Class<? extends T>)",
        "snippet": "    private ArgumentCaptor(Class<? extends T> clazz) {\n        this.clazz = clazz;\n    }",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.capture()",
        "snippet": "    public T capture() {\n        Mockito.argThat(capturingMatcher);\n        return handyReturnValues.returnFor(clazz);\n    }",
        "begin_line": 104,
        "end_line": 107,
        "comment": "\n     * Use it to capture the argument. This method <b>must be used inside of verification</b>.\n     * <p>\n     * Internally, this method registers a special implementation of an {@link ArgumentMatcher}.\n     * This argument matcher stores the argument value so that you can use it later to perform assertions.  \n     * <p>\n     * See examples in javadoc for {@link ArgumentCaptor} class.\n     * \n     * @return null or default values\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.getValue()",
        "snippet": "    public T getValue() {\n        return this.capturingMatcher.getLastValue();\n    }",
        "begin_line": 118,
        "end_line": 120,
        "comment": "\n     * Returns the captured value of the argument. When capturing varargs use {@link #getAllValues()}.\n     * <p>\n     * If verified method was called multiple times then this method it returns the latest captured value.\n     * <p>\n     * See examples in javadoc for {@link ArgumentCaptor} class.\n     * \n     * @return captured argument value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.getAllValues()",
        "snippet": "    public List<T> getAllValues() {\n        return this.capturingMatcher.getAllValues();\n    }",
        "begin_line": 154,
        "end_line": 156,
        "comment": "\n     * Returns all captured values. Use it when capturing varargs or when the verified method was called multiple times.\n     * When varargs method was called multiple times, this method returns merged list of all values from all invocations.\n     * <p>\n     * Example: \n     * <pre class=\"code\"><code class=\"java\">\n     *   mock.doSomething(new Person(\"John\");\n     *   mock.doSomething(new Person(\"Jane\");\n     *\n     *   ArgumentCaptor&lt;Person&gt; peopleCaptor = ArgumentCaptor.forClass(Person.class);\n     *   verify(mock, times(2)).doSomething(peopleCaptor.capture());\n     *   \n     *   List&lt;Person&gt; capturedPeople = peopleCaptor.getAllValues();\n     *   assertEquals(\"John\", capturedPeople.get(0).getName());\n     *   assertEquals(\"Jane\", capturedPeople.get(1).getName());\n     * </pre>\n     *\n     * Example of capturing varargs:\n     * <pre class=\"code\"><code class=\"java\">\n     *   mock.countPeople(new Person(\"John\"), new Person(\"Jane\"); //vararg method\n     *\n     *   ArgumentCaptor&lt;Person&gt; peopleCaptor = ArgumentCaptor.forClass(Person.class);\n     *\n     *   verify(mock).countPeople(peopleCaptor.capture());\n     *\n     *   List expected = asList(new Person(\"John\"), new Person(\"Jane\"));\n     *   assertEquals(expected, peopleCaptor.getAllValues());\n     * </code></pre>\n     * See more examples in javadoc for {@link ArgumentCaptor} class.\n     * \n     * @return captured argument value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentCaptor.java",
        "class_name": "org.mockito.ArgumentCaptor",
        "signature": "org.mockito.ArgumentCaptor.forClass(java.lang.Class<S>)",
        "snippet": "    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {\n        return new ArgumentCaptor<U>(clazz);\n    }",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n     * Build a new <code>ArgumentCaptor</code>.\n     * <p>\n     * Note that an <code>ArgumentCaptor</code> <b>*don't do any type checks*</b>, it is only there to avoid casting\n     * in your code. This might however change (type checks could be added) in a\n     * future major release.\n     *\n     * @param clazz Type matching the parameter to be captured.\n     * @param <S> Type of clazz\n     * @param <U> Type of object captured by the newly built ArgumentCaptor\n     * @return A new ArgumentCaptor\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "        BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer);",
        "begin_line": 79,
        "end_line": 79,
        "comment": "\n         * See original {@link OngoingStubbing#thenAnswer(Answer)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.will(org.mockito.stubbing.Answer<?>)",
        "snippet": "        BDDMyOngoingStubbing<T> will(Answer<?> answer);",
        "begin_line": 85,
        "end_line": 85,
        "comment": "\n         * See original {@link OngoingStubbing#then(Answer)}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willReturn(T)",
        "snippet": "        BDDMyOngoingStubbing<T> willReturn(T value);",
        "begin_line": 91,
        "end_line": 91,
        "comment": "\n         * See original {@link OngoingStubbing#thenReturn(Object)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willReturn(T, T...)",
        "snippet": "        BDDMyOngoingStubbing<T> willReturn(T value, T... values);",
        "begin_line": 97,
        "end_line": 97,
        "comment": "\n         * See original {@link OngoingStubbing#thenReturn(Object, Object[])}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willThrow(java.lang.Throwable...)",
        "snippet": "        BDDMyOngoingStubbing<T> willThrow(Throwable... throwables);",
        "begin_line": 103,
        "end_line": 103,
        "comment": "\n         * See original {@link OngoingStubbing#thenThrow(Throwable...)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willThrow(java.lang.Class<? extends java.lang.Throwable>...)",
        "snippet": "        BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses);",
        "begin_line": 109,
        "end_line": 109,
        "comment": "\n         * See original {@link OngoingStubbing#thenThrow(Class[])}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.willCallRealMethod()",
        "snippet": "        BDDMyOngoingStubbing<T> willCallRealMethod();",
        "begin_line": 115,
        "end_line": 115,
        "comment": "\n         * See original {@link OngoingStubbing#thenCallRealMethod()}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDMyOngoingStubbing.getMock()",
        "snippet": "        <M> M getMock();",
        "begin_line": 121,
        "end_line": 121,
        "comment": "\n         * See original {@link OngoingStubbing#getMock()}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.BDDOngoingStubbingImpl(org.mockito.stubbing.OngoingStubbing<T>)",
        "snippet": "        public BDDOngoingStubbingImpl(OngoingStubbing<T> ongoingStubbing) {\n            this.mockitoOngoingStubbing = ongoingStubbing;\n        }",
        "begin_line": 132,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "        public BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenAnswer(answer));\n        }",
        "begin_line": 139,
        "end_line": 141,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#willAnswer(Answer)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.will(org.mockito.stubbing.Answer<?>)",
        "snippet": "        public BDDMyOngoingStubbing<T> will(Answer<?> answer) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.then(answer));\n        }",
        "begin_line": 146,
        "end_line": 148,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#will(Answer)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willReturn(T)",
        "snippet": "        public BDDMyOngoingStubbing<T> willReturn(T value) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value));\n        }",
        "begin_line": 153,
        "end_line": 155,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willReturn(T, T...)",
        "snippet": "        public BDDMyOngoingStubbing<T> willReturn(T value, T... values) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value, values));\n        }",
        "begin_line": 160,
        "end_line": 162,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object, T[])\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willThrow(java.lang.Throwable...)",
        "snippet": "        public BDDMyOngoingStubbing<T> willThrow(Throwable... throwables) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwables));\n        }",
        "begin_line": 167,
        "end_line": 169,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#willThrow(java.lang.Throwable[])\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willThrow(java.lang.Class<? extends java.lang.Throwable>...)",
        "snippet": "        public BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses) {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableClasses));\n        }",
        "begin_line": 173,
        "end_line": 175,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDMyOngoingStubbing#willThrow(java.lang.Class[])\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.willCallRealMethod()",
        "snippet": "        public BDDMyOngoingStubbing<T> willCallRealMethod() {\n            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenCallRealMethod());\n        }",
        "begin_line": 177,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDOngoingStubbingImpl.getMock()",
        "snippet": "        public <M> M getMock() {\n            return (M) mockitoOngoingStubbing.getMock();\n        }",
        "begin_line": 181,
        "end_line": 183,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.given(T)",
        "snippet": "    public static <T> BDDMyOngoingStubbing<T> given(T methodCall) {\n        return new BDDOngoingStubbingImpl<T>(Mockito.when(methodCall));\n    }",
        "begin_line": 190,
        "end_line": 192,
        "comment": "\n     * see original {@link Mockito#when(Object)}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.then(T)",
        "snippet": "    public static <T> Then<T> then(T mock) {\n        return new ThenImpl<T>(mock);\n    }",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n     * Bdd style verification of mock behavior.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   person.ride(bike);\n     *   person.ride(bike);\n     *\n     *   then(person).should(times(2)).ride(bike);\n     * </code></pre>\n     *\n     * @see #verify(Object)\n     * @see #verify(Object, VerificationMode)\n     * @since 1.10.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.Then.should()",
        "snippet": "        T should();",
        "begin_line": 225,
        "end_line": 225,
        "comment": "\n         * @see #verify(Object)\n         * @since 1.10.5\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.Then.should(org.mockito.verification.VerificationMode)",
        "snippet": "        T should(VerificationMode mode);",
        "begin_line": 231,
        "end_line": 231,
        "comment": "\n         * @see #verify(Object, VerificationMode)\n         * @since 1.10.5\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.ThenImpl.ThenImpl(T)",
        "snippet": "        ThenImpl(T mock) {\n            this.mock = mock;\n        }",
        "begin_line": 238,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.ThenImpl.should()",
        "snippet": "        public T should() {\n            return verify(mock);\n        }",
        "begin_line": 246,
        "end_line": 248,
        "comment": "\n         * @see #verify(Object)\n         * @since 1.10.5\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.ThenImpl.should(org.mockito.verification.VerificationMode)",
        "snippet": "        public T should(VerificationMode mode) {\n            return verify(mock, mode);\n        }",
        "begin_line": 254,
        "end_line": 256,
        "comment": "\n         * @see #verify(Object, VerificationMode)\n         * @since 1.10.5\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willAnswer(org.mockito.stubbing.Answer)",
        "snippet": "        BDDStubber willAnswer(Answer answer);",
        "begin_line": 268,
        "end_line": 268,
        "comment": "\n         * See original {@link Stubber#doAnswer(Answer)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willNothing()",
        "snippet": "        BDDStubber willNothing();",
        "begin_line": 274,
        "end_line": 274,
        "comment": "\n         * See original {@link Stubber#doNothing()}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willReturn(java.lang.Object)",
        "snippet": "        BDDStubber willReturn(Object toBeReturned);",
        "begin_line": 280,
        "end_line": 280,
        "comment": "\n         * See original {@link Stubber#doReturn(Object)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willThrow(java.lang.Throwable)",
        "snippet": "        BDDStubber willThrow(Throwable toBeThrown);",
        "begin_line": 286,
        "end_line": 286,
        "comment": "\n         * See original {@link Stubber#doThrow(Throwable)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "        BDDStubber willThrow(Class<? extends Throwable> toBeThrown);",
        "begin_line": 292,
        "end_line": 292,
        "comment": "\n         * See original {@link Stubber#doThrow(Class)}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.willCallRealMethod()",
        "snippet": "        BDDStubber willCallRealMethod();",
        "begin_line": 298,
        "end_line": 298,
        "comment": "\n         * See original {@link Stubber#doCallRealMethod()}\n         * @since 1.9.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubber.given(T)",
        "snippet": "        <T> T given(T mock);",
        "begin_line": 304,
        "end_line": 304,
        "comment": "\n         * See original {@link Stubber#when(Object)}\n         * @since 1.8.0\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.BDDStubberImpl(org.mockito.stubbing.Stubber)",
        "snippet": "        public BDDStubberImpl(Stubber mockitoStubber) {\n            this.mockitoStubber = mockitoStubber;\n        }",
        "begin_line": 315,
        "end_line": 317,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.given(T)",
        "snippet": "        public <T> T given(T mock) {\n            return mockitoStubber.when(mock);\n        }",
        "begin_line": 322,
        "end_line": 324,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#given(java.lang.Object)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willAnswer(org.mockito.stubbing.Answer)",
        "snippet": "        public BDDStubber willAnswer(Answer answer) {\n            return new BDDStubberImpl(mockitoStubber.doAnswer(answer));\n        }",
        "begin_line": 329,
        "end_line": 331,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willAnswer(Answer)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willNothing()",
        "snippet": "        public BDDStubber willNothing() {\n            return new BDDStubberImpl(mockitoStubber.doNothing());\n        }",
        "begin_line": 336,
        "end_line": 338,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willNothing()\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willReturn(java.lang.Object)",
        "snippet": "        public BDDStubber willReturn(Object toBeReturned) {\n            return new BDDStubberImpl(mockitoStubber.doReturn(toBeReturned));\n        }",
        "begin_line": 343,
        "end_line": 345,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willReturn(java.lang.Object)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willThrow(java.lang.Throwable)",
        "snippet": "        public BDDStubber willThrow(Throwable toBeThrown) {\n            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));\n        }",
        "begin_line": 350,
        "end_line": 352,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willThrow(java.lang.Throwable)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "        public BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));\n        }",
        "begin_line": 357,
        "end_line": 359,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willThrow(Class)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.BDDStubberImpl.willCallRealMethod()",
        "snippet": "        public BDDStubber willCallRealMethod() {\n            return new BDDStubberImpl(mockitoStubber.doCallRealMethod());\n        }",
        "begin_line": 364,
        "end_line": 366,
        "comment": " (non-Javadoc)\n         * @see BDDMockito.BDDStubber#willCallRealMethod()\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willThrow(java.lang.Throwable)",
        "snippet": "    public static BDDStubber willThrow(Throwable toBeThrown) {\n        return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n    }",
        "begin_line": 373,
        "end_line": 375,
        "comment": "\n     * see original {@link Mockito#doThrow(Throwable)}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    public static BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n        return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n    }",
        "begin_line": 381,
        "end_line": 383,
        "comment": "\n     * see original {@link Mockito#doThrow(Throwable)}\n     * @since 1.9.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public static BDDStubber willAnswer(Answer answer) {\n        return new BDDStubberImpl(Mockito.doAnswer(answer));\n    }",
        "begin_line": 389,
        "end_line": 391,
        "comment": "\n     * see original {@link Mockito#doAnswer(Answer)}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willDoNothing()",
        "snippet": "    public static BDDStubber willDoNothing() {\n        return new BDDStubberImpl(Mockito.doNothing());\n    }",
        "begin_line": 397,
        "end_line": 399,
        "comment": "\n     * see original {@link Mockito#doNothing()}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willReturn(java.lang.Object)",
        "snippet": "    public static BDDStubber willReturn(Object toBeReturned) {\n        return new BDDStubberImpl(Mockito.doReturn(toBeReturned));\n    }",
        "begin_line": 405,
        "end_line": 407,
        "comment": "\n     * see original {@link Mockito#doReturn(Object)}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/BDDMockito.java",
        "class_name": "org.mockito.BDDMockito",
        "signature": "org.mockito.BDDMockito.willCallRealMethod()",
        "snippet": "    public static BDDStubber willCallRealMethod() {\n        return new BDDStubberImpl(Mockito.doCallRealMethod());\n    }",
        "begin_line": 413,
        "end_line": 415,
        "comment": "\n     * see original {@link Mockito#doCallRealMethod()}\n     * @since 1.8.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(java.lang.Comparable<T>)",
        "snippet": "    public static <T extends Comparable<T>> T geq(Comparable<T> value) {\n        return reportMatcher(new GreaterOrEqual<T>(value)).<T>returnNull();\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * argument greater than or equal the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(byte)",
        "snippet": "    public static byte geq(byte value) {\n        return reportMatcher(new GreaterOrEqual<Byte>(value)).returnZero();\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * byte argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(double)",
        "snippet": "    public static double geq(double value) {\n        return reportMatcher(new GreaterOrEqual<Double>(value)).returnZero();\n    }",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * double argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(float)",
        "snippet": "    public static float geq(float value) {\n        return reportMatcher(new GreaterOrEqual<Float>(value)).returnZero();\n    }",
        "begin_line": 94,
        "end_line": 96,
        "comment": "\n     * float argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(int)",
        "snippet": "    public static int geq(int value) {\n        return reportMatcher(new GreaterOrEqual<Integer>(value)).returnZero();\n    }",
        "begin_line": 107,
        "end_line": 109,
        "comment": "\n     * int argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(long)",
        "snippet": "    public static long geq(long value) {\n        return reportMatcher(new GreaterOrEqual<Long>(value)).returnZero();\n    }",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n     * long argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.geq(short)",
        "snippet": "    public static short geq(short value) {\n        return reportMatcher(new GreaterOrEqual<Short>(value)).returnZero();\n    }",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * short argument greater than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(java.lang.Comparable<T>)",
        "snippet": "    public static <T extends Comparable<T>> T leq(Comparable<T> value) {\n        return reportMatcher(new LessOrEqual<T>(value)).<T>returnNull();\n    }",
        "begin_line": 146,
        "end_line": 148,
        "comment": "\n     * comparable argument less than or equal the given value details.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(byte)",
        "snippet": "    public static byte leq(byte value) {\n        return reportMatcher(new LessOrEqual<Byte>(value)).returnZero();\n    }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n     * byte argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(double)",
        "snippet": "    public static double leq(double value) {\n        return reportMatcher(new LessOrEqual<Double>(value)).returnZero();\n    }",
        "begin_line": 172,
        "end_line": 174,
        "comment": "\n     * double argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(float)",
        "snippet": "    public static float leq(float value) {\n        return reportMatcher(new LessOrEqual<Float>(value)).returnZero();\n    }",
        "begin_line": 185,
        "end_line": 187,
        "comment": "\n     * float argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(int)",
        "snippet": "    public static int leq(int value) {\n        return reportMatcher(new LessOrEqual<Integer>(value)).returnZero();\n    }",
        "begin_line": 198,
        "end_line": 200,
        "comment": "\n     * int argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(long)",
        "snippet": "    public static long leq(long value) {\n        return reportMatcher(new LessOrEqual<Long>(value)).returnZero();\n    }",
        "begin_line": 211,
        "end_line": 213,
        "comment": "\n     * long argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.leq(short)",
        "snippet": "    public static short leq(short value) {\n        return reportMatcher(new LessOrEqual<Short>(value)).returnZero();\n    }",
        "begin_line": 224,
        "end_line": 226,
        "comment": "\n     * short argument less than or equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class \n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(java.lang.Comparable<T>)",
        "snippet": "    public static <T extends Comparable<T>> T gt(Comparable<T> value) {\n        return reportMatcher(new GreaterThan<T>(value)).<T>returnNull();\n    }",
        "begin_line": 237,
        "end_line": 239,
        "comment": "\n     * comparable argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(byte)",
        "snippet": "    public static byte gt(byte value) {\n        return reportMatcher(new GreaterThan<Byte>(value)).returnZero();\n    }",
        "begin_line": 250,
        "end_line": 252,
        "comment": "\n     * byte argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(double)",
        "snippet": "    public static double gt(double value) {\n        return reportMatcher(new GreaterThan<Double>(value)).returnZero();\n    }",
        "begin_line": 263,
        "end_line": 265,
        "comment": "\n     * double argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(float)",
        "snippet": "    public static float gt(float value) {\n        return reportMatcher(new GreaterThan<Float>(value)).returnZero();\n    }",
        "begin_line": 276,
        "end_line": 278,
        "comment": "\n     * float argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(int)",
        "snippet": "    public static int gt(int value) {\n        return reportMatcher(new GreaterThan<Integer>(value)).returnZero();\n    }",
        "begin_line": 289,
        "end_line": 291,
        "comment": "\n     * int argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(long)",
        "snippet": "    public static long gt(long value) {\n        return reportMatcher(new GreaterThan<Long>(value)).returnZero();\n    }",
        "begin_line": 302,
        "end_line": 304,
        "comment": "\n     * long argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.gt(short)",
        "snippet": "    public static short gt(short value) {\n        return reportMatcher(new GreaterThan<Short>(value)).returnZero();\n    }",
        "begin_line": 315,
        "end_line": 317,
        "comment": "\n     * short argument greater than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(java.lang.Comparable<T>)",
        "snippet": "    public static <T extends Comparable<T>> T lt(Comparable<T> value) {\n        return reportMatcher(new LessThan<T>(value)).<T>returnNull();\n    }",
        "begin_line": 328,
        "end_line": 330,
        "comment": "\n     * comparable argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(byte)",
        "snippet": "    public static byte lt(byte value) {\n        return reportMatcher(new LessThan<Byte>(value)).returnZero();\n    }",
        "begin_line": 341,
        "end_line": 343,
        "comment": "\n     * byte argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(double)",
        "snippet": "    public static double lt(double value) {\n        return reportMatcher(new LessThan<Double>(value)).returnZero();\n    }",
        "begin_line": 354,
        "end_line": 356,
        "comment": "\n     * double argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(float)",
        "snippet": "    public static float lt(float value) {\n        return reportMatcher(new LessThan<Float>(value)).returnZero();\n    }",
        "begin_line": 367,
        "end_line": 369,
        "comment": "\n     * float argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(int)",
        "snippet": "    public static int lt(int value) {\n        return reportMatcher(new LessThan<Integer>(value)).returnZero();\n    }",
        "begin_line": 380,
        "end_line": 382,
        "comment": "\n     * int argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(long)",
        "snippet": "    public static long lt(long value) {\n        return reportMatcher(new LessThan<Long>(value)).returnZero();\n    }",
        "begin_line": 393,
        "end_line": 395,
        "comment": "\n     * long argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.lt(short)",
        "snippet": "    public static short lt(short value) {\n        return reportMatcher(new LessThan<Short>(value)).returnZero();\n    }",
        "begin_line": 406,
        "end_line": 408,
        "comment": "\n     * short argument less than the given value.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.cmpEq(java.lang.Comparable<T>)",
        "snippet": "    public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {\n        return reportMatcher(new CompareEqual<T>(value)).<T>returnNull();\n    }",
        "begin_line": 420,
        "end_line": 422,
        "comment": "\n     * comparable argument equals to the given value according to their\n     * compareTo method.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.find(java.lang.String)",
        "snippet": "    public static String find(String regex) {\n        return reportMatcher(new Find(regex)).<String>returnNull();\n    }",
        "begin_line": 432,
        "end_line": 434,
        "comment": "\n     * String argument that contains a substring that matches the given regular\n     * expression.\n     * \n     * @param regex\n     *            the regular expression.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(T[])",
        "snippet": "    public static <T> T[] aryEq(T[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 448,
        "end_line": 450,
        "comment": "\n     * Object array argument that is equal to the given array, i.e. it has to\n     * have the same type, length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param <T>\n     *            the type of the array, it is passed through to prevent casts.\n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(short[])",
        "snippet": "    public static short[] aryEq(short[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 462,
        "end_line": 464,
        "comment": "\n     * short array argument that is equal to the given array, i.e. it has to\n     * have the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(long[])",
        "snippet": "    public static long[] aryEq(long[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 476,
        "end_line": 478,
        "comment": "\n     * long array argument that is equal to the given array, i.e. it has to have\n     * the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(int[])",
        "snippet": "    public static int[] aryEq(int[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();       \n    }",
        "begin_line": 490,
        "end_line": 492,
        "comment": "\n     * int array argument that is equal to the given array, i.e. it has to have\n     * the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(float[])",
        "snippet": "    public static float[] aryEq(float[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 504,
        "end_line": 506,
        "comment": "\n     * float array argument that is equal to the given array, i.e. it has to\n     * have the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(double[])",
        "snippet": "    public static double[] aryEq(double[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 518,
        "end_line": 520,
        "comment": "\n     * double array argument that is equal to the given array, i.e. it has to\n     * have the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(char[])",
        "snippet": "    public static char[] aryEq(char[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 532,
        "end_line": 534,
        "comment": "\n     * char array argument that is equal to the given array, i.e. it has to have\n     * the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(byte[])",
        "snippet": "    public static byte[] aryEq(byte[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 546,
        "end_line": 548,
        "comment": "\n     * byte array argument that is equal to the given array, i.e. it has to have\n     * the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.aryEq(boolean[])",
        "snippet": "    public static boolean[] aryEq(boolean[] value) {\n        return reportMatcher(new ArrayEquals(value)).returnNull();\n    }",
        "begin_line": 560,
        "end_line": 562,
        "comment": "\n     * boolean array argument that is equal to the given array, i.e. it has to\n     * have the same length, and each element has to be equal.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given array.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(boolean, boolean)",
        "snippet": "    public static boolean and(boolean first, boolean second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnFalse();\n    }",
        "begin_line": 575,
        "end_line": 577,
        "comment": "\n     * boolean argument that matches both given matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(byte, byte)",
        "snippet": "    public static byte and(byte first, byte second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 590,
        "end_line": 592,
        "comment": "\n     * byte argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(char, char)",
        "snippet": "    public static char and(char first, char second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnChar();\n    }",
        "begin_line": 605,
        "end_line": 607,
        "comment": "\n     * char argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(double, double)",
        "snippet": "    public static double and(double first, double second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 620,
        "end_line": 622,
        "comment": "\n     * double argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(float, float)",
        "snippet": "    public static float and(float first, float second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 635,
        "end_line": 637,
        "comment": "\n     * float argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(int, int)",
        "snippet": "    public static int and(int first, int second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 650,
        "end_line": 652,
        "comment": "\n     * int argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(long, long)",
        "snippet": "    public static long and(long first, long second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 665,
        "end_line": 667,
        "comment": "\n     * long argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(short, short)",
        "snippet": "    public static short and(short first, short second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n    }",
        "begin_line": 680,
        "end_line": 682,
        "comment": "\n     * short argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.and(T, T)",
        "snippet": "    public static <T> T and(T first, T second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().<T>returnNull();\n    }",
        "begin_line": 697,
        "end_line": 699,
        "comment": "\n     * Object argument that matches both given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(boolean, boolean)",
        "snippet": "    public static boolean or(boolean first, boolean second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnFalse();\n    }",
        "begin_line": 712,
        "end_line": 714,
        "comment": "\n     * boolean argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(T, T)",
        "snippet": "    public static <T> T or(T first, T second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().<T>returnNull();\n    }",
        "begin_line": 729,
        "end_line": 731,
        "comment": "\n     * Object argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(short, short)",
        "snippet": "    public static short or(short first, short second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 744,
        "end_line": 746,
        "comment": "\n     * short argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(long, long)",
        "snippet": "    public static long or(long first, long second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 759,
        "end_line": 761,
        "comment": "\n     * long argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(int, int)",
        "snippet": "    public static int or(int first, int second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 774,
        "end_line": 776,
        "comment": "\n     * int argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(float, float)",
        "snippet": "    public static float or(float first, float second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 789,
        "end_line": 791,
        "comment": "\n     * float argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(double, double)",
        "snippet": "    public static double or(double first, double second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 804,
        "end_line": 806,
        "comment": "\n     * double argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(char, char)",
        "snippet": "    public static char or(char first, char second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnChar();\n    }",
        "begin_line": 819,
        "end_line": 821,
        "comment": "\n     * char argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.or(byte, byte)",
        "snippet": "    public static byte or(byte first, byte second) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n    }",
        "begin_line": 834,
        "end_line": 836,
        "comment": "\n     * byte argument that matches any of the given argument matchers.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the first argument matcher.\n     * @param second\n     *            placeholder for the second argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(T)",
        "snippet": "    public static <T> T not(T first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().<T>returnNull();\n    }",
        "begin_line": 849,
        "end_line": 851,
        "comment": "\n     * Object argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(short)",
        "snippet": "    public static short not(short first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 862,
        "end_line": 864,
        "comment": "\n     * short argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(int)",
        "snippet": "    public static int not(int first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 875,
        "end_line": 877,
        "comment": "\n     * int argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(long)",
        "snippet": "    public static long not(long first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 888,
        "end_line": 890,
        "comment": "\n     * long argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(float)",
        "snippet": "    public static float not(float first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 901,
        "end_line": 903,
        "comment": "\n     * float argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(double)",
        "snippet": "    public static double not(double first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 914,
        "end_line": 916,
        "comment": "\n     * double argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(char)",
        "snippet": "    public static char not(char first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnChar();\n    }",
        "begin_line": 927,
        "end_line": 929,
        "comment": "\n     * char argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(boolean)",
        "snippet": "    public static boolean not(boolean first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnFalse();\n    }",
        "begin_line": 940,
        "end_line": 942,
        "comment": "\n     * boolean argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.not(byte)",
        "snippet": "    public static byte not(byte first) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n    }",
        "begin_line": 953,
        "end_line": 955,
        "comment": "\n     * byte argument that does not match the given argument matcher.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param first\n     *            placeholder for the argument matcher.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.eq(double, double)",
        "snippet": "    public static double eq(double value, double delta) {\n        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();\n    }",
        "begin_line": 969,
        "end_line": 971,
        "comment": "\n     * double argument that has an absolute difference to the given value that\n     * is less than the given delta details.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param delta\n     *            the given delta.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.eq(float, float)",
        "snippet": "    public static float eq(float value, float delta) {\n        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();\n    }",
        "begin_line": 985,
        "end_line": 987,
        "comment": "\n     * float argument that has an absolute difference to the given value that is\n     * less than the given delta details.\n     * <p>\n     * See examples in javadoc for {@link AdditionalMatchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param delta\n     *            the given delta.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalMatchers.java",
        "class_name": "org.mockito.AdditionalMatchers",
        "signature": "org.mockito.AdditionalMatchers.reportMatcher(org.mockito.ArgumentMatcher<?>)",
        "snippet": "    private static HandyReturnValues reportMatcher(ArgumentMatcher<?> matcher) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n    }",
        "begin_line": 989,
        "end_line": 991,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockitoAnnotations.java",
        "class_name": "org.mockito.MockitoAnnotations",
        "signature": "org.mockito.MockitoAnnotations.initMocks(java.lang.Object)",
        "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Class<?> clazz = testClass.getClass();\n\n        //below can be removed later, when we get read rid of deprecated stuff\n        if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n            //this means user has his own annotation engine and we have to respect that.\n            //we will do annotation processing the old way so that we are backwards compatible\n            while (clazz != Object.class) {\n                scanDeprecatedWay(annotationEngine, testClass, clazz);\n                clazz = clazz.getSuperclass();\n            }\n        }\n\n        //anyway act 'the new' way\n        annotationEngine.process(testClass.getClass(), testClass);\n    }",
        "begin_line": 89,
        "end_line": 109,
        "comment": "\n     * Initializes objects annotated with Mockito annotations for given testClass:\n     *  &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks} \n     * <p>\n     * See examples in javadoc for {@link MockitoAnnotations} class.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockitoAnnotations.java",
        "class_name": "org.mockito.MockitoAnnotations",
        "signature": "org.mockito.MockitoAnnotations.scanDeprecatedWay(org.mockito.configuration.AnnotationEngine, java.lang.Object, java.lang.Class<?>)",
        "snippet": "    static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class<?> clazz) {\n        Field[] fields = clazz.getDeclaredFields();\n\n        for (Field field : fields) {\n            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n        }\n    }",
        "begin_line": 111,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockitoAnnotations.java",
        "class_name": "org.mockito.MockitoAnnotations",
        "signature": "org.mockito.MockitoAnnotations.processAnnotationDeprecatedWay(org.mockito.configuration.AnnotationEngine, java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    @SuppressWarnings(\"deprecation\")\n    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n        boolean alreadyAssigned = false;\n        for(Annotation annotation : field.getAnnotations()) {\n            Object mock = annotationEngine.createMockFor(annotation, field);\n            if (mock != null) {\n                throwIfAlreadyAssigned(field, alreadyAssigned);\n                alreadyAssigned = true;                \n                try {\n                    new FieldSetter(testClass, field).set(mock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                            + annotation, e);\n                }\n            }\n        }\n    }",
        "begin_line": 119,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockitoAnnotations.java",
        "class_name": "org.mockito.MockitoAnnotations",
        "signature": "org.mockito.MockitoAnnotations.throwIfAlreadyAssigned(java.lang.reflect.Field, boolean)",
        "snippet": "    static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
        "begin_line": 137,
        "end_line": 141,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ReturnValues.java",
        "class_name": "org.mockito.ReturnValues",
        "signature": "org.mockito.ReturnValues.valueFor(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    Object valueFor(InvocationOnMock invocation) throws Throwable;",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * return value for an unstubbed invocation\n     * \n     * @param invocation placeholder for mock and a method\n     * @return the return value\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mock(java.lang.Class<T>)",
        "snippet": "    public static <T> T mock(Class<T> classToMock) {\n        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n    }",
        "begin_line": 1255,
        "end_line": 1257,
        "comment": "\n     * Creates mock object of given class or interface.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param classToMock class or interface to mock\n     * @return mock object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mock(java.lang.Class<T>, java.lang.String)",
        "snippet": "    public static <T> T mock(Class<T> classToMock, String name) {\n        return mock(classToMock, withSettings()\n                .name(name)\n                .defaultAnswer(RETURNS_DEFAULTS));\n    }",
        "begin_line": 1274,
        "end_line": 1278,
        "comment": "\n     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n     * <p>\n     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n     * <p>\n     * <b>If you use <code>&#064;Mock</code> annotation then you've got naming mocks for free!</b> <code>&#064;Mock</code> uses field name as mock name. {@link Mock Read more.}\n     * <p>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param classToMock class or interface to mock\n     * @param name of the mock\n     * @return mock object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mockingDetails(java.lang.Object)",
        "snippet": "    public static MockingDetails mockingDetails(Object toInspect) {\n        return MOCKITO_CORE.mockingDetails(toInspect);\n    }",
        "begin_line": 1292,
        "end_line": 1294,
        "comment": "\n     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.\n     * Can be used to find out if given object is a Mockito mock\n     * or to find out if a given mock is a spy or mock.\n     * <p>\n     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,\n     * e.g. invocations, stubbing info, etc.\n     *\n     * @param toInspect - object to inspect. null input is allowed.\n     * @return A {@link org.mockito.MockingDetails} instance.\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mock(java.lang.Class<T>, org.mockito.ReturnValues)",
        "snippet": "    @Deprecated\n    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n        return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));\n    }",
        "begin_line": 1326,
        "end_line": 1329,
        "comment": "\n     * <b>Deprecated : Please use mock(Foo.class, defaultAnswer);</b>\n     * <p>\n     * See {@link Mockito#mock(Class, Answer)}\n     * <p>\n     * Why it is deprecated? ReturnValues is being replaced by Answer\n     * for better consistency & interoperability of the framework.\n     * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\n     * There's no point in mainting exactly the same interfaces.\n     * <p>\n     * Creates mock with a specified strategy for its return values.\n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * Obviously return values are used only when you don't stub the method call.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues());\n     * </code></pre>\n     *\n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     *\n     * @param classToMock class or interface to mock\n     * @param returnValues default return values for unstubbed methods\n     *\n     * @return mock object\n     *\n     * @deprecated <b>Please use mock(Foo.class, defaultAnswer);</b>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mock(java.lang.Class<T>, org.mockito.stubbing.Answer)",
        "snippet": "    public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\n        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\n    }",
        "begin_line": 1350,
        "end_line": 1352,
        "comment": "\n     * Creates mock with a specified strategy for its answers to interactions.\n     * It's quite advanced feature and typically you don't need it to write decent tests.\n     * However it can be helpful when working with legacy systems.\n     * <p>\n     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n     * </code></pre>\n     *\n     * <p>See examples in javadoc for {@link Mockito} class</p>\n     *\n     * @param classToMock class or interface to mock\n     * @param defaultAnswer default answer for unstubbed methods\n     *\n     * @return mock object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.mock(java.lang.Class<T>, org.mockito.MockSettings)",
        "snippet": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
        "begin_line": 1377,
        "end_line": 1379,
        "comment": "\n     * Creates a mock with some non-standard settings.\n     * <p>\n     * The number of configuration points for a mock grows\n     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.\n     * Hence {@link MockSettings}.\n     * <pre class=\"code\"><code class=\"java\">\n     *   Listener mock = mock(Listener.class, withSettings()\n     *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n     *   );\n     * </code></pre>\n     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?\n     * Is the code under test so complicated that it requires non-standard mocks?\n     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n     * <p>\n     * See also {@link Mockito#withSettings()}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param classToMock class or interface to mock\n     * @param mockSettings additional mock settings\n     * @return mock object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.spy(T)",
        "snippet": "    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS));\n    }",
        "begin_line": 1460,
        "end_line": 1464,
        "comment": "\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't...\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy:\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     *\n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     *\n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     *\n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     *\n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </code></pre>\n     *\n     * <h4>Important gotcha on spying real objects!</h4>\n     * <ol>\n     * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n     * Therefore for spies it is recommended to always use <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n     * family of methods for stubbing. Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *\n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </code></pre>\n     * </li>\n     *\n     * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n     * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction\n     * and their effect on real instance state.\n     * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,\n     * you won't see any effects on the real instance.</li>\n     *\n     * <li>Watch out for final methods.\n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * Also you won't be able to verify those method as well.\n     * </li>\n     * </ol>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.\n     * It may troublesome for code that rely on the spy to have these annotations.</p>\n     *\n     *\n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.spy(java.lang.Class<T>)",
        "snippet": "    @Incubating\n    public static <T> T spy(Class<T> classToSpy) {\n        return MOCKITO_CORE.mock(classToSpy, withSettings()\n                .useConstructor()\n                .defaultAnswer(CALLS_REAL_METHODS));\n    }",
        "begin_line": 1493,
        "end_line": 1498,
        "comment": "\n     * Please refer to the documentation of {@link #spy(Object)}.\n     * Overusing spies hints at code design smells.\n     * <p>\n     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.\n     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.\n     * This is particularly useful for spying on abstract classes because they cannot be instantiated.\n     * See also {@link MockSettings#useConstructor()}.\n     * <p>\n     * Examples:\n     * <pre class=\"code\"><code class=\"java\">\n     *   SomeAbstract spy = spy(SomeAbstract.class);\n     *\n     *   //Robust API, via settings builder:\n     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n     *\n     *   //Mocking a non-static inner abstract class:\n     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n     * </code></pre>\n     *\n     * @param classToSpy the class to spy\n     * @param <T> type of the spy\n     * @return a spy of the provided class\n     * @since 1.10.12\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.stub(T)",
        "snippet": "    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        return MOCKITO_CORE.stub(methodCall);\n    }",
        "begin_line": 1549,
        "end_line": 1551,
        "comment": "\n     * Stubs a method call with return value or an exception. E.g:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * stub(mock.someMethod()).toReturn(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n     *\n     * //setting exception to be thrown:\n     * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n     *\n     * //you can stub with different behavior for consecutive method calls.\n     * //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.\n     * stub(mock.someMethod(\"some arg\"))\n     *  .toThrow(new RuntimeException())\n     *  .toReturn(\"foo\");\n     * </code></pre>\n     * <p>\n     * Some users find stub() confusing therefore {@link Mockito#when(Object)} is recommended over stub()\n     * <pre class=\"code\"><code class=\"java\">\n     *   //Instead of:\n     *   stub(mock.count()).toReturn(10);\n     *\n     *   //You can do:\n     *   when(mock.count()).thenReturn(10);\n     * </code></pre>\n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed foo.bar().\n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n     * If your code doesn't care what get(0) returns then it should not be stubbed.\n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     *\n     * @param methodCall\n     *            method call\n     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.when(T)",
        "snippet": "    public static <T> OngoingStubbing<T> when(T methodCall) {\n        return MOCKITO_CORE.when(methodCall);\n    }",
        "begin_line": 1615,
        "end_line": 1617,
        "comment": "\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.\n     * <p>\n     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n     * <p>\n     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n     * <p>\n     * Examples:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n     *\n     * //you can use flexible argument matchers, e.g:\n     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n     *\n     * //setting exception to be thrown:\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n     *\n     * //you can set different behavior for consecutive method calls.\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException())\n     *  .thenReturn(\"foo\");\n     *\n     * //Alternative, shorter version for consecutive stubbing:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\", \"two\");\n     * //is the same as:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenReturn(\"one\")\n     *  .thenReturn(\"two\");\n     *\n     * //shorter version for consecutive method calls throwing exceptions:\n     * when(mock.someMethod(\"some arg\"))\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\n     *\n     * </code></pre>\n     *\n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * Stubbing can be overridden: for example common stubbing can go to fixture\n     * setup but the test methods can override it.\n     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * Once stubbed, the method will always return stubbed value regardless\n     * of how many times it is called.\n     * <p>\n     * Last stubbing is more important - when you stubbed the same method with\n     * the same arguments many times.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed <code>foo.bar()</code>.\n     * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).\n     * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.\n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     *\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * @param methodCall method to be stubbed\n     * @return OngoingStubbing object used to stub fluently.\n     *         <strong>Do not</strong> create a reference to this returned object.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.verify(T)",
        "snippet": "    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }",
        "begin_line": 1646,
        "end_line": 1648,
        "comment": "\n     * Verifies certain behavior <b>happened once</b>.\n     * <p>\n     * Alias to <code>verify(mock, times(1))</code> E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock).someMethod(\"some arg\");\n     * </code></pre>\n     * Above is equivalent to:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, times(1)).someMethod(\"some arg\");\n     * </code></pre>\n     * <p>\n     * Arguments passed are compared using <code>equals()</code> method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n     * Let's say you've stubbed <code>foo.bar()</code>.\n     * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).\n     * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.\n     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n     *\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param mock to be verified\n     * @return mock object itself\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.verify(T, org.mockito.verification.VerificationMode)",
        "snippet": "    public static <T> T verify(T mock, VerificationMode mode) {\n        return MOCKITO_CORE.verify(mock, mode);\n    }",
        "begin_line": 1672,
        "end_line": 1674,
        "comment": "\n     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, times(5)).someMethod(\"was called five times\");\n     *\n     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n     *\n     *   //you can use flexible argument matchers, e.g:\n     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n     * </code></pre>\n     *\n     * <b>times(1) is the default</b> and can be omitted\n     * <p>\n     * Arguments passed are compared using <code>equals()</code> method.\n     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n     * <p>\n     *\n     * @param mock to be verified\n     * @param mode times(x), atLeastOnce() or never()\n     *\n     * @return mock object itself\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.reset(T...)",
        "snippet": "    public static <T> void reset(T ... mocks) {\n        MOCKITO_CORE.reset(mocks);\n    }",
        "begin_line": 1703,
        "end_line": 1705,
        "comment": "\n     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n     * Normally, you don't need to reset your mocks, just create new mocks for each test method.\n     * <p>\n     * Instead of <code>#reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n     * <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.\n     * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\".\n     * There are several threads about it on mockito mailing list.\n     * <p>\n     * The only reason we added <code>reset()</code> method is to\n     * make it possible to work with container-injected mocks.\n     * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n     * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n     * <p>\n     * <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).\n     * <pre class=\"code\"><code class=\"java\">\n     *   List mock = mock(List.class);\n     *   when(mock.size()).thenReturn(10);\n     *   mock.add(1);\n     *\n     *   reset(mock);\n     *   //at this point the mock forgot any interactions & stubbing\n     * </code></pre>\n     *\n     * @param <T> The Type of the mocks\n     * @param mocks to be reset\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.verifyNoMoreInteractions(java.lang.Object...)",
        "snippet": "    public static void verifyNoMoreInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }",
        "begin_line": 1748,
        "end_line": 1750,
        "comment": "\n     * Checks if any of given mocks has any unverified interaction.\n     * <p>\n     * You can use this method after you verified your mocks - to make sure that nothing\n     * else was invoked on your mocks.\n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * Stubbed invocations (if called) are also treated as interactions.\n     * <p>\n     * A word of <b>warning</b>:\n     * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.\n     * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.\n     * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n     * Abusing it leads to overspecified, less maintainable tests. You can find further reading\n     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n     * <p>\n     * This method will also detect unverified invocations that occurred before the test method,\n     * for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.\n     *\n     * <p>\n     * Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * //interactions\n     * mock.doSomething();\n     * mock.doSomethingUnexpected();\n     *\n     * //verification\n     * verify(mock).doSomething();\n     *\n     * //following will fail because 'doSomethingUnexpected()' is unexpected\n     * verifyNoMoreInteractions(mock);\n     *\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param mocks to be verified\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.verifyZeroInteractions(java.lang.Object...)",
        "snippet": "    public static void verifyZeroInteractions(Object... mocks) {\n        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n    }",
        "begin_line": 1767,
        "end_line": 1769,
        "comment": "\n     * Verifies that no interactions happened on given mocks.\n     * <pre class=\"code\"><code class=\"java\">\n     *   verifyZeroInteractions(mockOne, mockTwo);\n     * </code></pre>\n     * This method will also detect invocations\n     * that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.\n     * Consider writing nice code that makes interactions only in test methods.\n     * <p>\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param mocks to be verified\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.stubVoid(T)",
        "snippet": "    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        return MOCKITO_CORE.stubVoid(mock);\n    }",
        "begin_line": 1803,
        "end_line": 1805,
        "comment": "\n     * <pre class=\"code\"><code class=\"java\">\n     *   //Instead of:\n     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n     *\n     *   //Please do:\n     *   doThrow(e).when(mock).someVoidMethod();\n     * </code></pre>\n     *\n     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods.\n     * <p>\n     * Originally, <code>stubVoid()</code> was used for stubbing void methods with exceptions. E.g:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n     *\n     * //you can stub with different behavior for consecutive calls.\n     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.\n     * stubVoid(mock)\n     *   .toThrow(new RuntimeException())\n     *   .toReturn()\n     *   .on().someMethod();\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n     *\n     * @param mock\n     *            to stub\n     * @return stubbable object that allows stubbing with throwable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doThrow(java.lang.Throwable)",
        "snippet": "    public static Stubber doThrow(Throwable toBeThrown) {\n        return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));\n    }",
        "begin_line": 1821,
        "end_line": 1823,
        "comment": "\n     * Use <code>doThrow()</code> when you want to stub the void method with an exception.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n     * </code></pre>\n     *\n     * @param toBeThrown to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n        return MOCKITO_CORE.doAnswer(new ThrowsExceptionClass(toBeThrown));\n    }",
        "begin_line": 1842,
        "end_line": 1844,
        "comment": "\n     * Use <code>doThrow()</code> when you want to stub the void method to throw exception of specified class.\n     * <p>\n     * A new exception instance will be created for each method invocation.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();\n     * </code></pre>\n     *\n     * @param toBeThrown to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     * @since 1.9.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doCallRealMethod()",
        "snippet": "    public static Stubber doCallRealMethod() {\n        return MOCKITO_CORE.doAnswer(new CallsRealMethods());\n    }",
        "begin_line": 1878,
        "end_line": 1880,
        "comment": "\n     * Use <code>doCallRealMethod()</code> when you want to call the real implementation of a method.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't...\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy:\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.\n     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b>\n     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   Foo mock = mock(Foo.class);\n     *   doCallRealMethod().when(mock).someVoidMethod();\n     *\n     *   // this will call the real implementation of Foo.someVoidMethod()\n     *   mock.someVoidMethod();\n     * </code></pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return stubber - to select a method for stubbing\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public static Stubber doAnswer(Answer answer) {\n        return MOCKITO_CORE.doAnswer(answer);\n    }",
        "begin_line": 1904,
        "end_line": 1906,
        "comment": "\n     * Use <code>doAnswer()</code> when you want to stub a void method with generic {@link Answer}.\n     * <p>\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n     * <p>\n     * Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *  doAnswer(new Answer() {\n     *      public Object answer(InvocationOnMock invocation) {\n     *          Object[] args = invocation.getArguments();\n     *          Mock mock = invocation.getMock();\n     *          return null;\n     *      }})\n     *  .when(mock).someMethod();\n     * </code></pre>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param answer to answer when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doNothing()",
        "snippet": "    public static Stubber doNothing() {\n        return MOCKITO_CORE.doAnswer(new DoesNothing());\n    }",
        "begin_line": 1946,
        "end_line": 1948,
        "comment": "\n     * Use <code>doNothing()</code> for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b>\n     * However, there are rare situations when doNothing() comes handy:\n     * <p>\n     * <ol>\n     * <li>Stubbing consecutive calls on a void method:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doNothing().\n     *   doThrow(new RuntimeException())\n     *   .when(mock).someVoidMethod();\n     *\n     *   //does nothing the first time:\n     *   mock.someVoidMethod();\n     *\n     *   //throws RuntimeException the next time:\n     *   mock.someVoidMethod();\n     * </code></pre>\n     * </li>\n     * <li>When you spy real objects and you want the void method to do nothing:\n     * <pre class=\"code\"><code class=\"java\">\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //let's make clear() do nothing\n     *   doNothing().when(spy).clear();\n     *\n     *   spy.add(\"one\");\n     *\n     *   //clear() does nothing, so the list still contains \"one\"\n     *   spy.clear();\n     * </code></pre>\n     * </li>\n     * </ol>\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.doReturn(java.lang.Object)",
        "snippet": "    public static Stubber doReturn(Object toBeReturned) {\n        return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));\n    }",
        "begin_line": 1996,
        "end_line": 1998,
        "comment": "\n     * Use <code>doReturn()</code> in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n     * <p>\n     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe\n     * and more readable</b> (especially when stubbing consecutive calls).\n     * <p>\n     * Here are those rare occasions when doReturn() comes handy:\n     * <p>\n     *\n     * <ol>\n     * <li>When spying real objects and calling real methods on a spy brings side effects\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *\n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </code></pre>\n     * </li>\n     *\n     * <li>Overriding a previous exception-stubbing:\n     * <pre class=\"code\"><code class=\"java\">\n     *   when(mock.foo()).thenThrow(new RuntimeException());\n     *\n     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.\n     *   when(mock.foo()).thenReturn(\"bar\");\n     *\n     *   //You have to use doReturn() for stubbing:\n     *   doReturn(\"bar\").when(mock).foo();\n     * </code></pre>\n     * </li>\n     * </ol>\n     *\n     * Above scenarios shows a tradeoff of Mockito's elegant syntax. Note that the scenarios are very rare, though.\n     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general\n     * overridding stubbing is a potential code smell that points out too much stubbing.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param toBeReturned to be returned when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.inOrder(java.lang.Object...)",
        "snippet": "    public static InOrder inOrder(Object... mocks) {\n        return MOCKITO_CORE.inOrder(mocks);\n    }",
        "begin_line": 2027,
        "end_line": 2029,
        "comment": "\n     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   InOrder inOrder = inOrder(firstMock, secondMock);\n     *\n     *   inOrder.verify(firstMock).add(\"was called first\");\n     *   inOrder.verify(secondMock).add(\"was called second\");\n     * </code></pre>\n     *\n     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n     * but only those that you are interested in testing in order.\n     * <p>\n     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.\n     * <p>\n     * <code>InOrder</code> verification is 'greedy'. You will hardly every notice it but\n     * if you want to find out more search for 'greedy' on the Mockito\n     * <a href=\"http://code.google.com/p/mockito/w/list\">wiki pages</a>.\n     * <p>\n     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param mocks to be verified in order\n     *\n     * @return InOrder object to be used to verify in order\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.ignoreStubs(java.lang.Object...)",
        "snippet": "    public static Object[] ignoreStubs(Object... mocks) {\n        return MOCKITO_CORE.ignoreStubs(mocks);\n    }",
        "begin_line": 2094,
        "end_line": 2096,
        "comment": "\n     * Ignores stubbed methods of given mocks for the sake of verification.\n     * Sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.\n     * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.\n     * <p>\n     * <b>Warning</b>, <code>ignoreStubs()</code> might lead to overuse of <code>verifyNoMoreInteractions(ignoreStubs(...));</code>\n     * Bear in mind that Mockito does not recommend bombarding every test with <code>verifyNoMoreInteractions()</code>\n     * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * Other words: all <b>*stubbed*</b> methods of given mocks are marked <b>*verified*</b> so that they don't get in a way during verifyNoMoreInteractions().\n     * <p>\n     * This method <b>changes the input mocks</b>! This method returns input mocks just for convenience.\n     * <p>\n     * Ignored stubs will also be ignored for verification inOrder, including {@link org.mockito.InOrder#verifyNoMoreInteractions()}.\n     * See the second example.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)\n     *  List mock1 = mock(List.class), mock2 = mock(List.class);\n     *\n     *  //stubbing mocks:\n     *  when(mock1.get(0)).thenReturn(10);\n     *  when(mock2.get(0)).thenReturn(20);\n     *\n     *  //using mocks by calling stubbed get(0) methods:\n     *  System.out.println(mock1.get(0)); //prints 10\n     *  System.out.println(mock2.get(0)); //prints 20\n     *\n     *  //using mocks by calling clear() methods:\n     *  mock1.clear();\n     *  mock2.clear();\n     *\n     *  //verification:\n     *  verify(mock1).clear();\n     *  verify(mock2).clear();\n     *\n     *  //verifyNoMoreInteractions() fails because get() methods were not accounted for.\n     *  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);\n     *\n     *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()\n     *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));\n     *\n     *  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.\n     * </code></pre>\n     * Ignoring stubs can be used with <b>verification in order</b>:\n     * <pre class=\"code\"><code class=\"java\">\n     *  List list = mock(List.class);\n     *  when(mock.get(0)).thenReturn(\"foo\");\n     *\n     *  list.add(0);\n     *  System.out.println(list.get(0)); //we don't want to verify this\n     *  list.clear();\n     *\n     *  InOrder inOrder = inOrder(ignoreStubs(list));\n     *  inOrder.verify(list).add(0);\n     *  inOrder.verify(list).clear();\n     *  inOrder.verifyNoMoreInteractions();\n     * </code></pre>\n     *\n     * @since 1.9.0\n     * @param mocks input mocks that will be changed\n     * @return the same mocks that were passed in as parameters\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.times(int)",
        "snippet": "    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }",
        "begin_line": 2110,
        "end_line": 2112,
        "comment": "\n     * Allows verifying exact number of invocations. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, times(2)).someMethod(\"some arg\");\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param wantedNumberOfInvocations wanted number of invocations\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.never()",
        "snippet": "    public static VerificationMode never() {\n        return times(0);\n    }",
        "begin_line": 2131,
        "end_line": 2133,
        "comment": "\n     * Alias to <code>times(0)</code>, see {@link Mockito#times(int)}\n     * <p>\n     * Verifies that interaction did not happen. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, never()).someMethod();\n     * </code></pre>\n     *\n     * <p>\n     * If you want to verify there were NO interactions with the mock\n     * check out {@link Mockito#verifyZeroInteractions(Object...)}\n     * or {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.atLeastOnce()",
        "snippet": "    public static VerificationMode atLeastOnce() {\n        return VerificationModeFactory.atLeastOnce();\n    }",
        "begin_line": 2146,
        "end_line": 2148,
        "comment": "\n     * Allows at-least-once verification. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n     * </code></pre>\n     * Alias to <code>atLeast(1)</code>.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.atLeast(int)",
        "snippet": "    public static VerificationMode atLeast(int minNumberOfInvocations) {\n        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n    }",
        "begin_line": 2162,
        "end_line": 2164,
        "comment": "\n     * Allows at-least-x verification. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param minNumberOfInvocations minimum number of invocations\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.atMost(int)",
        "snippet": "    public static VerificationMode atMost(int maxNumberOfInvocations) {\n        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n    }",
        "begin_line": 2178,
        "end_line": 2180,
        "comment": "\n     * Allows at-most-x verification. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param maxNumberOfInvocations max number of invocations\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.calls(int)",
        "snippet": "    public static VerificationMode calls( int wantedNumberOfInvocations ){\n        return VerificationModeFactory.calls( wantedNumberOfInvocations );\n    }",
        "begin_line": 2195,
        "end_line": 2197,
        "comment": "\n     * Allows non-greedy verification in order.  For example\n     * <pre class=\"code\"><code class=\"java\">\n     *   inOrder.verify( mock, calls( 2 )).someMethod( \"some arg\" );\n     * </code></pre>\n     * <ul>\n     * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>\n     * <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>\n     * </ul>\n     * This verification mode can only be used with in order verification.\n     * @param wantedNumberOfInvocations number of invocations to verify\n     * @return  verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.only()",
        "snippet": "    public static VerificationMode only() {\n        return VerificationModeFactory.only();\n    }",
        "begin_line": 2215,
        "end_line": 2217,
        "comment": "\n     * Allows checking if given method was the only one invoked. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, only()).someMethod();\n     *   //above is a shorthand for following 2 lines of code:\n     *   verify(mock).someMethod();\n     *   verifyNoMoreInvocations(mock);\n     * </code></pre>\n     *\n     * <p>\n     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.timeout(long)",
        "snippet": "    public static VerificationWithTimeout timeout(long millis) {\n        return new Timeout(millis, VerificationModeFactory.times(1));\n    }",
        "begin_line": 2256,
        "end_line": 2258,
        "comment": "\n     * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n     * interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent\n     * conditions.\n     * <p>\n     * This differs from {@link Mockito#after after()} in that after() will wait the full period, unless\n     * the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon\n     * as verification passes, producing different behaviour when used with times(2), for example, which can pass\n     * and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until\n     * times(2) failed, and then fail.\n     * <p>\n     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n     * <p>\n     * Not yet implemented to work with InOrder verification.\n     * <pre class=\"code\"><code class=\"java\">\n     *   //passes when someMethod() is called within given time span\n     *   verify(mock, timeout(100)).someMethod();\n     *   //above is an alias to:\n     *   verify(mock, timeout(100).times(1)).someMethod();\n     *\n     *   //passes as soon as someMethod() has been called 2 times before the given timeout\n     *   verify(mock, timeout(100).times(2)).someMethod();\n     *\n     *   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout\n     *   verify(mock, timeout(100).atLeast(2)).someMethod();\n     *\n     *   //verifies someMethod() within given time span using given verification mode\n     *   //useful only if you have your own custom verification modes.\n     *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param millis - time span in milliseconds\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.after(long)",
        "snippet": "    public static VerificationAfterDelay after(long millis) {\n        return new After(millis, VerificationModeFactory.times(1));\n    }",
        "begin_line": 2296,
        "end_line": 2298,
        "comment": "\n     * Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired\n     * interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent\n     * conditions.\n     * <p>\n     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout()\n     * will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,\n     * which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would\n     * run the full time, which point it will fail, as times(2) has failed.\n     * <p>\n     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n     * <p>\n     * Not yet implemented to work with InOrder verification.\n     * <pre class=\"code\"><code class=\"java\">\n     *   //passes after 100ms, if someMethod() has only been called once at that time.\n     *   verify(mock, after(100)).someMethod();\n     *   //above is an alias to:\n     *   verify(mock, after(100).times(1)).someMethod();\n     *\n     *   //passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan\n     *   verify(mock, after(100).times(2)).someMethod();\n     *\n     *   //passes if someMethod() has not been called after the given timespan\n     *   verify(mock, after(100).never()).someMethod();\n     *\n     *   //verifies someMethod() after a given time span using given verification mode\n     *   //useful only if you have your own custom verification modes.\n     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param millis - time span in milliseconds\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.validateMockitoUsage()",
        "snippet": "    public static void validateMockitoUsage() {\n        MOCKITO_CORE.validateMockitoUsage();\n    }",
        "begin_line": 2345,
        "end_line": 2347,
        "comment": "\n     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n     * <p>\n     * In case of questions you may also post to mockito mailing list: <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n     * <p>\n     * <code>validateMockitoUsage()</code> <b>explicitly validates</b> the framework state to detect invalid use of Mockito.\n     * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.\n     * <p>\n     * Examples of incorrect use:\n     * <pre class=\"code\"><code class=\"java\">\n     * //Oops, thenReturn() part is missing:\n     * when(mock.get());\n     *\n     * //Oops, verified method call is inside verify() where it should be on the outside:\n     * verify(mock.execute());\n     *\n     * //Oops, missing method to verify:\n     * verify(mock);\n     * </code></pre>\n     *\n     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.\n     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.).\n     * But even though the exception might be thrown in the next test,\n     * the exception <b>message contains a navigable stack trace element</b> with location of the defect.\n     * Hence you can click and find the place where Mockito was misused.\n     * <p>\n     * Sometimes though, you might want to validate the framework usage explicitly.\n     * For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method\n     * so that he knows immediately when he misused Mockito.\n     * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner and rule will always fail in the test method with defect\n     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.\n     * But even though JUnit might report next test as red, don't worry about it\n     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.\n     * <p>\n     * <b>Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoRule}</b> do validateMockitoUsage() after each test method.\n     * <p>\n     * Bear in mind that <b>usually you don't have to <code>validateMockitoUsage()</code></b>\n     * and framework validation triggered on next-time basis should be just enough,\n     * mainly because of enhanced exception message with clickable location of defect.\n     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure\n     * (like your own runner or base class for all tests) because adding a special action to <code>&#064;After</code> has zero cost.\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.withSettings()",
        "snippet": "    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }",
        "begin_line": 2379,
        "end_line": 2381,
        "comment": "\n     * Allows mock creation with additional mock settings.\n     * <p>\n     * Don't use it too often.\n     * Consider writing simple tests that use simple mocks.\n     * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n     * If you cannot write a test in a simple way - refactor the code under test.\n     * <p>\n     * Examples of mock settings:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //Creates mock with different default answer & name\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\"));\n     *\n     *   //Creates mock with different default answer, descriptive name and extra interfaces\n     *   Foo mock = mock(Foo.class, withSettings()\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\n     *       .name(\"cool mockie\")\n     *       .extraInterfaces(Bar.class));\n     * </code></pre>\n     * {@link MockSettings} has been introduced for two reasons.\n     * Firstly, to make it easy to add another mock settings when the demand comes.\n     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\n     * <p>\n     * See javadoc for {@link MockSettings} to learn about possible mock settings.\n     * <p>\n     *\n     * @return mock settings instance with defaults.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Mockito.java",
        "class_name": "org.mockito.Mockito",
        "signature": "org.mockito.Mockito.debug()",
        "snippet": "    @Deprecated\n    static MockitoDebugger debug() {\n        return new MockitoDebuggerImpl();\n    }",
        "begin_line": 2386,
        "end_line": 2389,
        "comment": "\n     * Helps debugging failing tests. Experimental - use at your own risk. We're not sure if this method will stay in public api.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/InOrder.java",
        "class_name": "org.mockito.InOrder",
        "signature": "org.mockito.InOrder.verify(T)",
        "snippet": "    <T> T verify(T mock);",
        "begin_line": 45,
        "end_line": 45,
        "comment": "\n     * Verifies interaction <b>happened once</b> in order.\n     * <p>\n     * Alias to <code>inOrder.verify(mock, times(1))</code>\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * InOrder inOrder = inOrder(firstMock, secondMock);\n     * \n     * inOrder.verify(firstMock).someMethod(\"was called first\");\n     * inOrder.verify(secondMock).someMethod(\"was called second\");\n     * </code></pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mock to be verified\n     * \n     * @return mock object itself\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/InOrder.java",
        "class_name": "org.mockito.InOrder",
        "signature": "org.mockito.InOrder.verify(T, org.mockito.verification.VerificationMode)",
        "snippet": "    <T> T verify(T mock, VerificationMode mode);",
        "begin_line": 64,
        "end_line": 64,
        "comment": "\n     * Verifies interaction in order. E.g:\n     * \n     * <pre class=\"code\"><code class=\"java\">\n     * InOrder inOrder = inOrder(firstMock, secondMock);\n     * \n     * inOrder.verify(firstMock, times(2)).someMethod(\"was called first two times\");\n     * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"was called second at least once\");\n     * </code></pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param mock to be verified\n     * @param mode for example times(x) or atLeastOnce()\n     * \n     * @return mock object itself\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/InOrder.java",
        "class_name": "org.mockito.InOrder",
        "signature": "org.mockito.InOrder.verifyNoMoreInteractions()",
        "snippet": "    void verifyNoMoreInteractions();",
        "begin_line": 89,
        "end_line": 89,
        "comment": "\n     * Verifies that no more interactions happened <b>in order</b>. \n     * Different from {@link Mockito#verifyNoMoreInteractions(Object...)} because the order of verification matters.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * mock.foo(); //1st\n     * mock.bar(); //2nd\n     * mock.baz(); //3rd\n     * \n     * InOrder inOrder = inOrder(mock);\n     * \n     * inOrder.verify(mock).bar(); //2n\n     * inOrder.verify(mock).baz(); //3rd (last method)\n     * \n     * //passes because there are no more interactions after last method:\n     * inOrder.verifyNoMoreInteractions();\n     * \n     * //however this fails because 1st method was not verified:\n     * Mockito.verifyNoMoreInteractions(mock);\n     * </code></pre>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentMatcher.java",
        "class_name": "org.mockito.ArgumentMatcher",
        "signature": "org.mockito.ArgumentMatcher.matches(java.lang.Object)",
        "snippet": "    public abstract boolean matches(Object argument);",
        "begin_line": 74,
        "end_line": 74,
        "comment": "\n     * Returns whether this matcher accepts the given argument.\n     * <p>\n     * The method should <b>never</b> assert if the argument doesn't match. It\n     * should only return false.\n     * \n     * @param argument\n     *            the argument\n     * @return whether this matcher accepts the given argument.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/ArgumentMatcher.java",
        "class_name": "org.mockito.ArgumentMatcher",
        "signature": "org.mockito.ArgumentMatcher.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        String className = getClass().getSimpleName();\n        description.appendText(Decamelizer.decamelizeMatcher(className));\n    }",
        "begin_line": 88,
        "end_line": 91,
        "comment": "\n     * By default this method decamelizes matchers name to promote meaningful names for matchers.\n     * <p>\n     * For example <b>StringWithStrongLanguage</b> matcher will generate 'String with strong language' description in case of failure.\n     * <p>\n     * You might want to override this method to\n     * provide more specific description of the matcher (useful when\n     * verification failures are reported).\n     * \n     * @param description the description to which the matcher description is\n     * appended.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.returnsFirstArg()",
        "snippet": "    public static <T> Answer<T> returnsFirstArg() {\n        return (Answer<T>) RETURNS_FIRST_ARGUMENT;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Returns the first parameter of an invocation.\n     *\n     * <p>\n     *     This additional answer could be used at stub time using the\n     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n     * </p>\n     *\n     * <pre class=\"code\"><code class=\"java\">given(carKeyFob.authenticate(carKey)).will(returnsFirstArg());\n     * doAnswer(returnsFirstArg()).when(carKeyFob).authenticate(carKey)</code></pre>\n     *\n     * @param <T> Return type of the invocation.\n     * @return Answer that will return the first argument of the invocation.\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.returnsSecondArg()",
        "snippet": "    public static <T> Answer<T> returnsSecondArg() {\n        return (Answer<T>) RETURNS_SECOND_ARGUMENT;\n    }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "\n     * Returns the second parameter of an invocation.\n     *\n     * <p>\n     *     This additional answer could be used at stub time using the\n     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n     * </p>\n     *\n     * <pre class=\"code\"><code class=\"java\">given(trader.apply(leesFormula, onCreditDefaultSwap)).will(returnsSecondArg());\n     * doAnswer(returnsSecondArg()).when(trader).apply(leesFormula, onCreditDefaultSwap)</code></pre>\n     *\n     * @param <T> Return type of the invocation.\n     * @return Answer that will return the second argument of the invocation.\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.returnsLastArg()",
        "snippet": "    public static <T> Answer<T> returnsLastArg() {\n        return (Answer<T>) RETURNS_LAST_ARGUMENT;\n    }",
        "begin_line": 86,
        "end_line": 88,
        "comment": "\n     * Returns the last parameter of an invocation.\n     *\n     * <p>\n     *     This additional answer could be used at stub time using the\n     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n     * </p>\n     *\n     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsLastArg());\n     * doAnswer(returnsLastArg()).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n     *\n     * @param <T> Return type of the invocation.\n     * @return Answer that will return the last argument of the invocation.\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.returnsArgAt(int)",
        "snippet": "    public static <T> Answer<T> returnsArgAt(int position) {\n        return (Answer<T>) new ReturnsArgumentAt(position);\n    }",
        "begin_line": 107,
        "end_line": 109,
        "comment": "\n     * Returns the parameter of an invocation at the given position.\n     *\n     * <p>\n     * This additional answer could be used at stub time using the\n     * <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n     * </p>\n     *\n     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsArgAt(3));\n     * doAnswer(returnsArgAt(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n     *\n     * @param <T> Return type of the invocation.\n     * @param position index of the argument from the list of arguments.\n     * @return Answer that will return the argument from the given position in the argument's list\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.delegatesTo(java.lang.Object)",
        "snippet": "    public static <T> Answer<T> delegatesTo(Object delegate) {\n        return (Answer<T>) new ForwardsInvocations(delegate);\n    }",
        "begin_line": 174,
        "end_line": 176,
        "comment": "\n     * An answer that directly forwards the calls to the delegate. The delegate may or may not be of the same type as the mock.\n     * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.\n     * <p>\n     * Useful for spies or partial mocks of objects that are difficult to mock\n     * or spy using the usual spy API. Possible use cases:\n     * <ul>\n     *     <li>Final classes but with an interface</li>\n     *     <li>Already custom proxied object</li>\n     *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n     * </ul>\n     * For more details including the use cases reported by users take a look at\n     * <a link=\"http://code.google.com/p/mockito/issues/detail?id=145\">issue 145</a>.\n     * <p>\n     * The difference with the regular spy:\n     * <ul>\n     *   <li>\n     *     The regular spy ({@link Mockito#spy(Object)}) contains <strong>all</strong> state from the spied instance\n     *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.\n     *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered\n     *     for verifications, and they can be effectively stubbed.\n     *   </li>\n     *   <li>\n     *     The mock that delegates simply delegates all methods to the delegate.\n     *     The delegate is used all the time as methods are delegated onto it.\n     *     If you call a method on a mock that delegates and it internally calls other methods on this mock,\n     *     those calls are <strong>not</strong> remembered for verifications, stubbing does not have effect on them, too.\n     *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.\n     *   </li>\n     * </ul>\n     * An example with a final class that we want to delegate to:\n     * <p>\n     * <pre class=\"code\"><code class=\"java\">\n     *   final class DontYouDareToMockMe implements list { ... }\n     *\n     *   DontYouDareToMockMe awesomeList = new DontYouDareToMockMe();\n     *\n     *   List mock = mock(List.class, delegatesTo(awesomeList));\n     * </code></pre>\n     *\n     * <p>\n     * This feature suffers from the same drawback as the spy.\n     * The mock will call the delegate if you use regular when().then() stubbing style.\n     * Since the real implementation is called this might have some side effects.\n     * Therefore you should to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     *   List listWithDelegate = mock(List.class, AdditionalAnswers.delegatesTo(awesomeList));\n     *\n     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n     *\n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n     * </code></pre>\n     *\n     * @param delegate The delegate to forward calls to. It does not have to be of the same type as the mock (although it usually is).\n     *                 The only requirement is that the instance should have compatible method signatures including the return values.\n     *                 Only the methods that were actually executed on the mock need to be present on the delegate type.\n     * @return the answer\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/AdditionalAnswers.java",
        "class_name": "org.mockito.AdditionalAnswers",
        "signature": "org.mockito.AdditionalAnswers.returnsElementsOf(java.util.Collection<?>)",
        "snippet": "    public static <T> Answer<T> returnsElementsOf(Collection<?> elements) {\n        return (Answer<T>) new ReturnsElementsOf(elements);\n    }",
        "begin_line": 195,
        "end_line": 197,
        "comment": "\n     * Returns elements of the collection. Keeps returning the last element forever.\n     * Might be useful on occasion when you have a collection of elements to return.\n     * <p>\n     * <pre class=\"code\"><code class=\"java\">\n     *   //this:\n     *   when(mock.foo()).thenReturn(1, 2, 3);\n     *\n     *   //is equivalent to:\n     *   when(mock.foo()).thenAnswer(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n     * </code></pre>\n     *\n     * @param elements The collection of elements to return.\n     * @return the answer\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockingDetails.java",
        "class_name": "org.mockito.MockingDetails",
        "signature": "org.mockito.MockingDetails.isMock()",
        "snippet": "    boolean isMock();",
        "begin_line": 25,
        "end_line": 25,
        "comment": "\n     * Informs if the object is a mock. isMock() for null input returns false.\n     * @return true if the object is a mock or a spy.\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockingDetails.java",
        "class_name": "org.mockito.MockingDetails",
        "signature": "org.mockito.MockingDetails.isSpy()",
        "snippet": "    boolean isSpy();",
        "begin_line": 33,
        "end_line": 33,
        "comment": "\n     * Informs if the object is a spy. isSpy() for null input returns false.\n     * @return true if the object is a spy.\n     *\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockingDetails.java",
        "class_name": "org.mockito.MockingDetails",
        "signature": "org.mockito.MockingDetails.getInvocations()",
        "snippet": "    Collection<Invocation> getInvocations();",
        "begin_line": 42,
        "end_line": 42,
        "comment": "\n     * Provides a collection of methods indicating the invocations of the object\n     * @return collection of Invocation representing the invocations \n     * for the object.\n     *\n     * @since 1.10.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/MockitoDebugger.java",
        "class_name": "org.mockito.MockitoDebugger",
        "signature": "org.mockito.MockitoDebugger.printInvocations(java.lang.Object...)",
        "snippet": "    String printInvocations(Object ... mocks);",
        "begin_line": 11,
        "end_line": 11,
        "comment": "You can put it in your 'tearDown' method",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Answers.java",
        "class_name": "org.mockito.Answers",
        "signature": "org.mockito.Answers.Answers(org.mockito.stubbing.Answer<java.lang.Object>)",
        "snippet": "    private Answers(Answer<Object> implementation) {\n        this.implementation = implementation;\n    }",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Answers.java",
        "class_name": "org.mockito.Answers",
        "signature": "org.mockito.Answers.get()",
        "snippet": "    @Deprecated\n    public Answer<Object> get() {\n        return this;\n    }",
        "begin_line": 84,
        "end_line": 87,
        "comment": "\n     * @deprecated Use the enum-constant directly, instead of this getter. This method will be removed in a future release<br> \n     * E.g. instead of <code>Answers.CALLS_REAL_METHODS.get()</code> use <code>Answers.CALLS_REAL_METHODS</code> .\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Answers.java",
        "class_name": "org.mockito.Answers",
        "signature": "org.mockito.Answers.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return implementation.answer(invocation);\n    }",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/Answers.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.Answers",
        "signature": "org.mockito.internal.stubbing.defaultanswers.Answers.Answers(org.mockito.stubbing.Answer<java.lang.Object>)",
        "snippet": "    private Answers(Answer<Object> implementation) {\n        this.implementation = implementation;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/Answers.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.Answers",
        "signature": "org.mockito.internal.stubbing.defaultanswers.Answers.get()",
        "snippet": "    public Answer<Object> get() {\n        return implementation;\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyBoolean()",
        "snippet": "    public static boolean anyBoolean() {\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     * Any <code>boolean</code> or non-null <code>Boolean</code>\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyByte()",
        "snippet": "    public static byte anyByte() {\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\n    }",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n     * Any <code>byte</code> or non-null <code>Byte</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyChar()",
        "snippet": "    public static char anyChar() {\n        return reportMatcher(new InstanceOf(Character.class)).returnChar();\n    }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     * Any <code>char</code> or non-null <code>Character</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyInt()",
        "snippet": "    public static int anyInt() {\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\n    }",
        "begin_line": 142,
        "end_line": 144,
        "comment": "\n     * Any int or non-null Integer.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyLong()",
        "snippet": "    public static long anyLong() {\n        return reportMatcher(new InstanceOf(Long.class)).returnZero();\n    }",
        "begin_line": 153,
        "end_line": 155,
        "comment": "\n     * Any <code>long</code> or non-null <code>Long</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyFloat()",
        "snippet": "    public static float anyFloat() {\n        return reportMatcher(new InstanceOf(Float.class)).returnZero();\n    }",
        "begin_line": 164,
        "end_line": 166,
        "comment": "\n     * Any <code>float</code> or non-null <code>Float</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyDouble()",
        "snippet": "    public static double anyDouble() {\n        return reportMatcher(new InstanceOf(Double.class)).returnZero();\n    }",
        "begin_line": 175,
        "end_line": 177,
        "comment": "\n     * Any <code>double</code> or non-null <code>Double</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyShort()",
        "snippet": "    public static short anyShort() {\n        return reportMatcher(new InstanceOf(Short.class)).returnZero();\n    }",
        "begin_line": 186,
        "end_line": 188,
        "comment": "\n     * Any <code>short</code> or non-null <code>Short</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyObject()",
        "snippet": "    public static <T> T anyObject() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }",
        "begin_line": 199,
        "end_line": 201,
        "comment": "\n     * Matches anything, including null.\n     * <p>\n     * This is an alias of: {@link #any()} and {@link #any(java.lang.Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyVararg()",
        "snippet": "    public static <T> T anyVararg() {\n        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n    }",
        "begin_line": 226,
        "end_line": 228,
        "comment": "\n     * Any vararg, meaning any number and values of arguments.\n     * <p>\n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   //verification:\n     *   mock.foo(1, 2);\n     *   mock.foo(1, 2, 3, 4);\n     *\n     *   verify(mock, times(2)).foo(anyVararg());\n     *\n     *   //stubbing:\n     *   when(mock.foo(anyVararg()).thenReturn(100);\n     *\n     *   //prints 100\n     *   System.out.println(mock.foo(1, 2));\n     *   //also prints 100\n     *   System.out.println(mock.foo(1, 2, 3, 4));\n     * </code></pre>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.any(java.lang.Class<T>)",
        "snippet": "    public static <T> T any(Class<T> clazz) {\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\n    }",
        "begin_line": 243,
        "end_line": 245,
        "comment": "\n     * Matches any object, including nulls\n     * <p>\n     * This method doesn't do type checks with the given parameter, it is only there\n     * to avoid casting in your code. This might however change (type checks could\n     * be added) in a future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * <p>\n     * This is an alias of: {@link #any()} and {@link #anyObject()}\n     * <p>\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.any()",
        "snippet": "    public static <T> T any() {\n        return anyObject();\n    }",
        "begin_line": 258,
        "end_line": 260,
        "comment": "\n     * Matches anything, including nulls\n     * <p>\n     * Shorter alias to {@link Matchers#anyObject()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * <p>\n     * This is an alias of: {@link #anyObject()} and {@link #any(java.lang.Class)}\n     * <p>\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyString()",
        "snippet": "    public static String anyString() {\n        return reportMatcher(new InstanceOf(String.class)).returnString();\n    }",
        "begin_line": 269,
        "end_line": 271,
        "comment": "\n     * Any non-null <code>String</code>\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty String (\"\")\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyList()",
        "snippet": "    public static List anyList() {\n        return reportMatcher(new InstanceOf(List.class)).returnList();\n    }",
        "begin_line": 280,
        "end_line": 282,
        "comment": "\n     * Any non-null <code>List</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty List.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyListOf(java.lang.Class<T>)",
        "snippet": "    public static <T> List<T> anyListOf(Class<T> clazz) {\n        return anyList();\n    }",
        "begin_line": 299,
        "end_line": 301,
        "comment": "\n     * Generic friendly alias to {@link Matchers#anyList()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any non-null <code>List</code>.\n     * <p>\n     * This method doesn't do type checks with the given parameter, it is only there\n     * to avoid casting in your code. This might however change (type checks could\n     * be added) in a future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the list to avoid casting\n     * @return empty List.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anySet()",
        "snippet": "    public static Set anySet() {\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\n    }",
        "begin_line": 310,
        "end_line": 312,
        "comment": "\n     * Any non-null <code>Set</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @return empty Set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anySetOf(java.lang.Class<T>)",
        "snippet": "    public static <T> Set<T> anySetOf(Class<T> clazz) {\n        return anySet();\n    }",
        "begin_line": 329,
        "end_line": 331,
        "comment": "\n     * Generic friendly alias to {@link Matchers#anySet()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any non-null <code>Set</code>.\n     * <p>\n     * This method doesn't do type checks with the given parameter, it is only there\n     * to avoid casting in your code. This might however change (type checks could\n     * be added) in a future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type owned by the Set to avoid casting\n     * @return empty Set\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyMap()",
        "snippet": "    public static Map anyMap() {\n        return reportMatcher(new InstanceOf(Map.class)).returnMap();\n    }",
        "begin_line": 340,
        "end_line": 342,
        "comment": "\n     * Any non-null <code>Map</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Map.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyMapOf(java.lang.Class<K>, java.lang.Class<V>)",
        "snippet": "    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\n        return anyMap();\n    }",
        "begin_line": 360,
        "end_line": 362,
        "comment": "\n     * Generic friendly alias to {@link Matchers#anyMap()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any non-null <code>Map</code>.\n     * <p>\n     * This method doesn't do type checks with the given parameter, it is only there\n     * to avoid casting in your code. This might however change (type checks could\n     * be added) in a future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param keyClazz Type of the map key to avoid casting\n     * @param valueClazz Type of the value to avoid casting\n     * @return empty Map.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyCollection()",
        "snippet": "    public static Collection anyCollection() {\n        return reportMatcher(new InstanceOf(Collection.class)).returnList();\n    }    ",
        "begin_line": 371,
        "end_line": 373,
        "comment": "\n     * Any non-null <code>Collection</code>.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return empty Collection.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.anyCollectionOf(java.lang.Class<T>)",
        "snippet": "    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n        return anyCollection();\n    }    ",
        "begin_line": 390,
        "end_line": 392,
        "comment": "\n     * Generic friendly alias to {@link Matchers#anyCollection()}.\n     * It's an alternative to &#064;SuppressWarnings(\"unchecked\") to keep code clean of compiler warnings.\n     * <p>\n     * Any non-null <code>Collection</code>.\n     * <p>\n     * This method doesn't do type checks with the given parameter, it is only there\n     * to avoid casting in your code. This might however change (type checks could\n     * be added) in a future major release.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param clazz Type owned by the collection to avoid casting\n     * @return empty Collection.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.isA(java.lang.Class<T>)",
        "snippet": "    public static <T> T isA(Class<T> clazz) {\n        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\n    }",
        "begin_line": 405,
        "end_line": 407,
        "comment": "\n     * <code>Object</code> argument that implements the given class.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the accepted type.\n     * @param clazz\n     *            the class of the accepted type.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(boolean)",
        "snippet": "    public static boolean eq(boolean value) {\n        return reportMatcher(new Equals(value)).returnFalse();\n    }",
        "begin_line": 418,
        "end_line": 420,
        "comment": "\n     * <code>boolean</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(byte)",
        "snippet": "    public static byte eq(byte value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 431,
        "end_line": 433,
        "comment": "\n     * <code>byte</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(char)",
        "snippet": "    public static char eq(char value) {\n        return reportMatcher(new Equals(value)).returnChar();\n    }",
        "begin_line": 444,
        "end_line": 446,
        "comment": "\n     * <code>char</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(double)",
        "snippet": "    public static double eq(double value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 457,
        "end_line": 459,
        "comment": "\n     * <code>double</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(float)",
        "snippet": "    public static float eq(float value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 470,
        "end_line": 472,
        "comment": "\n     * <code>float</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(int)",
        "snippet": "    public static int eq(int value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 483,
        "end_line": 485,
        "comment": "\n     * <code>int</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(long)",
        "snippet": "    public static long eq(long value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 496,
        "end_line": 498,
        "comment": "\n     * <code>long</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(short)",
        "snippet": "    public static short eq(short value) {\n        return reportMatcher(new Equals(value)).returnZero();\n    }",
        "begin_line": 509,
        "end_line": 511,
        "comment": "\n     * <code>short</code> argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.eq(T)",
        "snippet": "    public static <T> T eq(T value) {\n        return (T) reportMatcher(new Equals(value)).<T>returnFor(value);\n    }",
        "begin_line": 522,
        "end_line": 524,
        "comment": "\n     * Object argument that is equal to the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.refEq(T, java.lang.String...)",
        "snippet": "    public static <T> T refEq(T value, String... excludeFields) {\n        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();\n    }",
        "begin_line": 546,
        "end_line": 548,
        "comment": "\n     * Object argument that is reflection-equal to the given value with support for excluding\n     * selected fields from a class.\n     * <p>\n     * This matcher can be used when equals() is not implemented on compared objects.\n     * Matcher uses java reflection API to compare fields of wanted and actual object.\n     * <p>\n     * Works similarly to EqualsBuilder.reflectionEquals(this, other, exlucdeFields) from\n     * apache commons library.\n     * <p>\n     * <b>Warning</b> The equality check is shallow!\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param value\n     *            the given value.\n     * @param excludeFields\n     *            fields to exclude, if field does not exist it is ignored.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.same(T)",
        "snippet": "    public static <T> T same(T value) {\n        return (T) reportMatcher(new Same(value)).<T>returnFor(value);\n    }",
        "begin_line": 561,
        "end_line": 563,
        "comment": "\n     * Object argument that is the same as the given value.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param <T>\n     *            the type of the object, it is passed through to prevent casts.\n     * @param value\n     *            the given value.\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.isNull()",
        "snippet": "    public static Object isNull() {\n        return reportMatcher(Null.NULL).returnNull();\n    }",
        "begin_line": 572,
        "end_line": 574,
        "comment": "\n     * <code>null</code> argument.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.isNull(java.lang.Class<T>)",
        "snippet": "    public static <T> T isNull(Class<T> clazz) {\n        return (T) reportMatcher(Null.NULL).returnNull();\n    }",
        "begin_line": 585,
        "end_line": 587,
        "comment": "\n     * <code>null</code> argument.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.notNull()",
        "snippet": "    public static Object notNull() {\n        return reportMatcher(NotNull.NOT_NULL).returnNull();\n    }",
        "begin_line": 598,
        "end_line": 600,
        "comment": "\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#isNotNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.notNull(java.lang.Class<T>)",
        "snippet": "    public static <T> T notNull(Class<T> clazz) {\n        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();\n    }",
        "begin_line": 613,
        "end_line": 615,
        "comment": "\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#isNotNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.isNotNull()",
        "snippet": "    public static Object isNotNull() {\n        return notNull();\n    }",
        "begin_line": 626,
        "end_line": 628,
        "comment": "\n     * Not <code>null</code> argument.\n     * <p>\n     * alias to {@link Matchers#notNull()}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.isNotNull(java.lang.Class<T>)",
        "snippet": "    public static <T> T isNotNull(Class<T> clazz) {\n        return notNull(clazz);\n    }",
        "begin_line": 641,
        "end_line": 643,
        "comment": "\n     * Not <code>null</code> argument, not necessary of the given class.\n     * The class argument is provided to avoid casting.\n     * <p>\n     * alias to {@link Matchers#notNull(Class)}\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     *\n     * @param clazz Type to avoid casting\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.contains(java.lang.String)",
        "snippet": "    public static String contains(String substring) {\n        return reportMatcher(new Contains(substring)).returnString();\n    }",
        "begin_line": 654,
        "end_line": 656,
        "comment": "\n     * <code>String</code> argument that contains the given substring.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param substring\n     *            the substring.\n     * @return empty String (\"\").\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.matches(java.lang.String)",
        "snippet": "    public static String matches(String regex) {\n        return reportMatcher(new Matches(regex)).returnString();\n    }",
        "begin_line": 667,
        "end_line": 669,
        "comment": "\n     * <code>String</code> argument that matches the given regular expression.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param regex\n     *            the regular expression.\n     * @return empty String (\"\").\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.endsWith(java.lang.String)",
        "snippet": "    public static String endsWith(String suffix) {\n        return reportMatcher(new EndsWith(suffix)).returnString();\n    }",
        "begin_line": 680,
        "end_line": 682,
        "comment": "\n     * <code>String</code> argument that ends with the given suffix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param suffix\n     *            the suffix.\n     * @return empty String (\"\").\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.startsWith(java.lang.String)",
        "snippet": "    public static String startsWith(String prefix) {\n        return reportMatcher(new StartsWith(prefix)).returnString();\n    }",
        "begin_line": 693,
        "end_line": 695,
        "comment": "\n     * <code>String</code> argument that starts with the given prefix.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param prefix\n     *            the prefix.\n     * @return empty String (\"\").\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.argThat(org.hamcrest.Matcher<T>)",
        "snippet": "    public static <T> T argThat(Matcher<T> matcher) {\n        return reportMatcher(matcher).<T>returnNull();\n    }",
        "begin_line": 708,
        "end_line": 710,
        "comment": "\n     * Allows creating custom argument matchers.\n     * <p>\n     * In rare cases when the parameter is a primitive then you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n     * This way you will avoid <code>NullPointerException</code> during auto-unboxing.\n     * <p>\n     * See examples in javadoc for {@link ArgumentMatcher} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>null</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.charThat(org.hamcrest.Matcher<java.lang.Character>)",
        "snippet": "    public static char charThat(Matcher<Character> matcher) {\n        return reportMatcher(matcher).returnChar();\n    }",
        "begin_line": 720,
        "end_line": 722,
        "comment": "\n     * Allows creating custom <code>Character</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.booleanThat(org.hamcrest.Matcher<java.lang.Boolean>)",
        "snippet": "    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        return reportMatcher(matcher).returnFalse();\n    }",
        "begin_line": 732,
        "end_line": 734,
        "comment": "\n     * Allows creating custom <code>Boolean</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.byteThat(org.hamcrest.Matcher<java.lang.Byte>)",
        "snippet": "    public static byte byteThat(Matcher<Byte> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 744,
        "end_line": 746,
        "comment": "\n     * Allows creating custom <code>Byte</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.shortThat(org.hamcrest.Matcher<java.lang.Short>)",
        "snippet": "    public static short shortThat(Matcher<Short> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 756,
        "end_line": 758,
        "comment": "\n     * Allows creating custom <code>Short</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.intThat(org.hamcrest.Matcher<java.lang.Integer>)",
        "snippet": "    public static int intThat(Matcher<Integer> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 768,
        "end_line": 770,
        "comment": "\n     * Allows creating custom <code>Integer</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.longThat(org.hamcrest.Matcher<java.lang.Long>)",
        "snippet": "    public static long longThat(Matcher<Long> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 780,
        "end_line": 782,
        "comment": "\n     * Allows creating custom <code>Long</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.floatThat(org.hamcrest.Matcher<java.lang.Float>)",
        "snippet": "    public static float floatThat(Matcher<Float> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 792,
        "end_line": 794,
        "comment": "\n     * Allows creating custom <code>Float</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.doubleThat(org.hamcrest.Matcher<java.lang.Double>)",
        "snippet": "    public static double doubleThat(Matcher<Double> matcher) {\n        return reportMatcher(matcher).returnZero();\n    }",
        "begin_line": 804,
        "end_line": 806,
        "comment": "\n     * Allows creating custom <code>Double</code> argument matchers.\n     * <p>\n     * See examples in javadoc for {@link Matchers} class\n     * \n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/Matchers.java",
        "class_name": "org.mockito.Matchers",
        "signature": "org.mockito.Matchers.reportMatcher(org.hamcrest.Matcher<?>)",
        "snippet": "    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n    }",
        "begin_line": 808,
        "end_line": 810,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.getMocksToBeVerifiedInOrder()",
        "snippet": "    public List<Object> getMocksToBeVerifiedInOrder() {\n        return mocksToBeVerifiedInOrder;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.InOrderImpl(java.util.List<java.lang.Object>)",
        "snippet": "    public InOrderImpl(List<Object> mocksToBeVerifiedInOrder) {\n        this.mocksToBeVerifiedInOrder.addAll(mocksToBeVerifiedInOrder);\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.verify(T)",
        "snippet": "    public <T> T verify(T mock) {\n        return this.verify(mock, VerificationModeFactory.times(1));\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.verify(T, org.mockito.verification.VerificationMode)",
        "snippet": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (!mocksToBeVerifiedInOrder.contains(mock)) {\n            reporter.inOrderRequiresFamiliarMock();\n        } else if (!(mode instanceof VerificationInOrderMode)) {\n            throw new MockitoException(mode.getClass().getSimpleName() + \" is not implemented to work with InOrder\");\n        }\n        return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));\n    }",
        "begin_line": 44,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.isVerified(org.mockito.invocation.Invocation)",
        "snippet": "    public boolean isVerified(Invocation i) {\n        return inOrderContext.isVerified(i);\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.markVerified(org.mockito.invocation.Invocation)",
        "snippet": "    public void markVerified(Invocation i) {\n        inOrderContext.markVerified(i);\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InOrderImpl.java",
        "class_name": "org.mockito.internal.InOrderImpl",
        "signature": "org.mockito.internal.InOrderImpl.verifyNoMoreInteractions()",
        "snippet": "    public void verifyNoMoreInteractions() {\n        mockitoCore.verifyNoMoreInteractionsInOrder(mocksToBeVerifiedInOrder, this);\n    }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.isTypeMockable(java.lang.Class<?>)",
        "snippet": "    public boolean isTypeMockable(Class<?> typeToMock) {\n        return mockUtil.isTypeMockable(typeToMock);\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.mock(java.lang.Class<T>, org.mockito.MockSettings)",
        "snippet": "    public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n        if (!MockSettingsImpl.class.isInstance(settings)) {\n            throw new IllegalArgumentException(\n                    \"Unexpected implementation of '\" + settings.getClass().getCanonicalName() + \"'\\n\"\n                    + \"At the moment, you cannot provide your own implementations that class.\");\n        }\n        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);\n        MockCreationSettings<T> creationSettings = impl.confirm(typeToMock);\n        T mock = mockUtil.createMock(creationSettings);\n        mockingProgress.mockingStarted(mock, typeToMock);\n        return mock;\n    }",
        "begin_line": 51,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.stub()",
        "snippet": "    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }",
        "begin_line": 64,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.stub(T)",
        "snippet": "    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (DeprecatedOngoingStubbing) stub();\n    }",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.when(T)",
        "snippet": "    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }",
        "begin_line": 78,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.verify(T, org.mockito.verification.VerificationMode)",
        "snippet": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify(mock.getClass());\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }",
        "begin_line": 83,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.reset(T...)",
        "snippet": "    public <T> void reset(T ... mocks) {\n        mockingProgress.validateState();\n        mockingProgress.reset();\n        mockingProgress.resetOngoingStubbing();\n        \n        for (T m : mocks) {\n            mockUtil.resetMock(m);\n        }\n    }",
        "begin_line": 93,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.verifyNoMoreInteractions(java.lang.Object...)",
        "snippet": "    public void verifyNoMoreInteractions(Object... mocks) {\n        assertMocksNotEmpty(mocks);\n        mockingProgress.validateState();\n        for (Object mock : mocks) {\n            try {\n                if (mock == null) {\n                    reporter.nullPassedToVerifyNoMoreInteractions();\n                }\n                InvocationContainer invocations = mockUtil.getMockHandler(mock).getInvocationContainer();\n                VerificationDataImpl data = new VerificationDataImpl(invocations, null);\n                VerificationModeFactory.noMoreInteractions().verify(data);\n            } catch (NotAMockException e) {\n                reporter.notAMockPassedToVerifyNoMoreInteractions();\n            }\n        }\n    }",
        "begin_line": 103,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.verifyNoMoreInteractionsInOrder(java.util.List<java.lang.Object>, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public void verifyNoMoreInteractionsInOrder(List<Object> mocks, InOrderContext inOrderContext) {\n        mockingProgress.validateState();\n        VerifiableInvocationsFinder finder = new VerifiableInvocationsFinder();\n        VerificationDataInOrder data = new VerificationDataInOrderImpl(inOrderContext, finder.find(mocks), null);\n        VerificationModeFactory.noMoreInteractions().verifyInOrder(data);\n    }    ",
        "begin_line": 120,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.assertMocksNotEmpty(java.lang.Object[])",
        "snippet": "    private void assertMocksNotEmpty(Object[] mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n        }\n    }",
        "begin_line": 127,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.inOrder(java.lang.Object...)",
        "snippet": "    public InOrder inOrder(Object... mocks) {\n        if (mocks == null || mocks.length == 0) {\n            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n        }\n        for (Object mock : mocks) {\n            if (mock == null) {\n                reporter.nullPassedWhenCreatingInOrder();\n            } else if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedWhenCreatingInOrder();\n            }\n        }\n        return new InOrderImpl(Arrays.asList(mocks));\n    }",
        "begin_line": 133,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.doAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public Stubber doAnswer(Answer answer) {\n        mockingProgress.stubbingStarted();\n        mockingProgress.resetOngoingStubbing();\n        return new StubberImpl().doAnswer(answer);\n    }",
        "begin_line": 147,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.stubVoid(T)",
        "snippet": "    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n        InternalMockHandler<T> handler = mockUtil.getMockHandler(mock);\n        mockingProgress.stubbingStarted();\n        return handler.voidMethodStubbable(mock);\n    }",
        "begin_line": 153,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.validateMockitoUsage()",
        "snippet": "    public void validateMockitoUsage() {\n        mockingProgress.validateState();\n    }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.getLastInvocation()",
        "snippet": "    public Invocation getLastInvocation() {\n        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n        return allInvocations.get(allInvocations.size()-1);\n    }",
        "begin_line": 167,
        "end_line": 171,
        "comment": "\n     * For testing purposes only. Is not the part of main API.\n     * @return last invocation\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.ignoreStubs(java.lang.Object...)",
        "snippet": "    public Object[] ignoreStubs(Object... mocks) {\n        for (Object m : mocks) {\n            InvocationContainer invocationContainer = new MockUtil().getMockHandler(m).getInvocationContainer();\n            List<Invocation> ins = invocationContainer.getInvocations();\n            for (Invocation in : ins) {\n                if (in.stubInfo() != null) {\n                    in.ignoreForVerification();\n                }\n            }\n        }\n        return mocks;\n    }",
        "begin_line": 173,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/MockitoCore.java",
        "class_name": "org.mockito.internal.MockitoCore",
        "signature": "org.mockito.internal.MockitoCore.mockingDetails(java.lang.Object)",
        "snippet": "    public MockingDetails mockingDetails(Object toInspect) {\n        return new DefaultMockingDetails(toInspect, new MockUtil());\n    }",
        "begin_line": 186,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InternalMockHandler.java",
        "class_name": "org.mockito.internal.InternalMockHandler",
        "signature": "org.mockito.internal.InternalMockHandler.getMockSettings()",
        "snippet": "    MockCreationSettings getMockSettings();",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InternalMockHandler.java",
        "class_name": "org.mockito.internal.InternalMockHandler",
        "signature": "org.mockito.internal.InternalMockHandler.voidMethodStubbable(T)",
        "snippet": "    VoidMethodStubbable<T> voidMethodStubbable(T mock);",
        "begin_line": 20,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InternalMockHandler.java",
        "class_name": "org.mockito.internal.InternalMockHandler",
        "signature": "org.mockito.internal.InternalMockHandler.setAnswersForStubbing(java.util.List<org.mockito.stubbing.Answer>)",
        "snippet": "    void setAnswersForStubbing(List<Answer> answers);",
        "begin_line": 22,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/InternalMockHandler.java",
        "class_name": "org.mockito.internal.InternalMockHandler",
        "signature": "org.mockito.internal.InternalMockHandler.getInvocationContainer()",
        "snippet": "    InvocationContainer getInvocationContainer();",
        "begin_line": 24,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Pluralizer.java",
        "class_name": "org.mockito.internal.reporting.Pluralizer",
        "signature": "org.mockito.internal.reporting.Pluralizer.pluralize(int)",
        "snippet": "    public static String pluralize(int number) {\n        return number == 1 ? \"1 time\" : number + \" times\";\n    }",
        "begin_line": 9,
        "end_line": 11,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/SmartPrinter.java",
        "class_name": "org.mockito.internal.reporting.SmartPrinter",
        "signature": "org.mockito.internal.reporting.SmartPrinter.SmartPrinter(org.mockito.internal.invocation.InvocationMatcher, org.mockito.invocation.Invocation, java.lang.Integer...)",
        "snippet": "    public SmartPrinter(InvocationMatcher wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n        PrintSettings printSettings = new PrintSettings();\n        printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n        printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n        \n        this.wanted = printSettings.print(wanted);\n        this.actual = printSettings.print(actual);\n    }",
        "begin_line": 21,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/SmartPrinter.java",
        "class_name": "org.mockito.internal.reporting.SmartPrinter",
        "signature": "org.mockito.internal.reporting.SmartPrinter.getWanted()",
        "snippet": "    public String getWanted() {\n        return wanted;\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/SmartPrinter.java",
        "class_name": "org.mockito.internal.reporting.SmartPrinter",
        "signature": "org.mockito.internal.reporting.SmartPrinter.getActual()",
        "snippet": "    public String getActual() {\n        return actual;\n    }",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Discrepancy.java",
        "class_name": "org.mockito.internal.reporting.Discrepancy",
        "signature": "org.mockito.internal.reporting.Discrepancy.Discrepancy(int, int)",
        "snippet": "    public Discrepancy(int wantedCount, int actualCount) {\n        this.wantedCount = wantedCount;\n        this.actualCount = actualCount;\n    }",
        "begin_line": 12,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Discrepancy.java",
        "class_name": "org.mockito.internal.reporting.Discrepancy",
        "signature": "org.mockito.internal.reporting.Discrepancy.getWantedCount()",
        "snippet": "    public int getWantedCount() {\n        return wantedCount;\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Discrepancy.java",
        "class_name": "org.mockito.internal.reporting.Discrepancy",
        "signature": "org.mockito.internal.reporting.Discrepancy.getPluralizedWantedCount()",
        "snippet": "    public String getPluralizedWantedCount() {\n        return Pluralizer.pluralize(wantedCount);\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Discrepancy.java",
        "class_name": "org.mockito.internal.reporting.Discrepancy",
        "signature": "org.mockito.internal.reporting.Discrepancy.getActualCount()",
        "snippet": "    public int getActualCount() {\n        return actualCount;\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/Discrepancy.java",
        "class_name": "org.mockito.internal.reporting.Discrepancy",
        "signature": "org.mockito.internal.reporting.Discrepancy.getPluralizedActualCount()",
        "snippet": "    public String getPluralizedActualCount() {\n        return Pluralizer.pluralize(actualCount);\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Discrepancy.java",
        "class_name": "org.mockito.exceptions.Discrepancy",
        "signature": "org.mockito.exceptions.Discrepancy.Discrepancy(int, int)",
        "snippet": "    public Discrepancy(int wantedCount, int actualCount) {\n        super(wantedCount, actualCount);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.setMultiline(boolean)",
        "snippet": "    public void setMultiline(boolean multiline) {\n        this.multiline = multiline;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.isMultiline()",
        "snippet": "    public boolean isMultiline() {\n        return multiline;\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.verboseMatchers(java.lang.Integer...)",
        "snippet": "    public static PrintSettings verboseMatchers(Integer ... indexesOfMatchers) {\n        PrintSettings settings = new PrintSettings();\n        settings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchers);\n        return settings;\n    }",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.extraTypeInfoFor(int)",
        "snippet": "    public boolean extraTypeInfoFor(int argumentIndex) {\n        return withTypeInfo.contains(argumentIndex);\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.setMatchersToBeDescribedWithExtraTypeInfo(java.lang.Integer[])",
        "snippet": "    public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {\n        this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.print(java.util.List<org.hamcrest.Matcher>, org.mockito.invocation.Invocation)",
        "snippet": "    public String print(List<Matcher> matchers, Invocation invocation) {\n        MatchersPrinter matchersPrinter = new MatchersPrinter();\n        String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName();\n        String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);\n        if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > MAX_LINE_LENGTH)) {\n            return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);\n        } else {\n            return invocationString;\n        }\n    }",
        "begin_line": 46,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.print(org.mockito.invocation.Invocation)",
        "snippet": "    public String print(Invocation invocation) {\n        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/reporting/PrintSettings.java",
        "class_name": "org.mockito.internal.reporting.PrintSettings",
        "signature": "org.mockito.internal.reporting.PrintSettings.print(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public String print(InvocationMatcher invocationMatcher) {\n        return print(invocationMatcher.getMatchers(), invocationMatcher.getInvocation());\n    }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.InvocationNotifierHandler(org.mockito.internal.InternalMockHandler<T>, org.mockito.mock.MockCreationSettings)",
        "snippet": "    public InvocationNotifierHandler(InternalMockHandler<T> mockHandler, MockCreationSettings settings) {\n        this.mockHandler = mockHandler;\n        this.invocationListeners = settings.getInvocationListeners();\n    }",
        "begin_line": 30,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.handle(org.mockito.invocation.Invocation)",
        "snippet": "    public Object handle(Invocation invocation) throws Throwable {\n        try {\n            Object returnedValue = mockHandler.handle(invocation);\n            notifyMethodCall(invocation, returnedValue);\n            return returnedValue;\n        } catch (Throwable t){\n            notifyMethodCallException(invocation, t);\n            throw t;\n        }\n    }",
        "begin_line": 35,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.notifyMethodCall(org.mockito.invocation.Invocation, java.lang.Object)",
        "snippet": "    private void notifyMethodCall(Invocation invocation, Object returnValue) {\n        for (InvocationListener listener : invocationListeners) {\n            try {\n                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n            } catch(Throwable listenerThrowable) {\n                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n            }\n        }\n    }",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.notifyMethodCallException(org.mockito.invocation.Invocation, java.lang.Throwable)",
        "snippet": "    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n        for (InvocationListener listener : invocationListeners) {\n            try {\n                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n            } catch(Throwable listenerThrowable) {\n                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n            }\n        }\n    }",
        "begin_line": 57,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.getMockSettings()",
        "snippet": "    public MockCreationSettings getMockSettings() {\n        return mockHandler.getMockSettings();\n    }",
        "begin_line": 67,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.voidMethodStubbable(T)",
        "snippet": "    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return mockHandler.voidMethodStubbable(mock);\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.setAnswersForStubbing(java.util.List<org.mockito.stubbing.Answer>)",
        "snippet": "    public void setAnswersForStubbing(List<Answer> answers) {\n        mockHandler.setAnswersForStubbing(answers);\n    }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/InvocationNotifierHandler.java",
        "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
        "signature": "org.mockito.internal.handler.InvocationNotifierHandler.getInvocationContainer()",
        "snippet": "    public InvocationContainer getInvocationContainer() {\n        return mockHandler.getInvocationContainer();\n    }",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerFactory.java",
        "class_name": "org.mockito.internal.handler.MockHandlerFactory",
        "signature": "org.mockito.internal.handler.MockHandlerFactory.create(org.mockito.mock.MockCreationSettings)",
        "snippet": "    public InternalMockHandler create(MockCreationSettings settings) {\n        InternalMockHandler handler = new MockHandlerImpl(settings);\n        InternalMockHandler nullResultGuardian = new NullResultGuardian(handler);\n        InternalMockHandler notifier = new InvocationNotifierHandler(nullResultGuardian, settings);\n\n        return notifier;\n    }",
        "begin_line": 15,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.MockHandlerImpl(org.mockito.mock.MockCreationSettings)",
        "snippet": "    public MockHandlerImpl(MockCreationSettings mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress, mockSettings);\n    }",
        "begin_line": 44,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.handle(org.mockito.invocation.Invocation)",
        "snippet": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n                    mockingProgress.getArgumentMatcherStorage(),\n                    invocation\n            );\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n                mockingProgress.getArgumentMatcherStorage(),\n                invocation\n        );\n\n        mockingProgress.validateState();\n\n        // if verificationMode is not null then someone is doing verify()\n        if (verificationMode != null) {\n            // We need to check if verification was started on the correct mock\n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                VerificationDataImpl data = createVerificationData(invocationContainerImpl, invocationMatcher);\n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode\n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n\n        // prepare invocation for stubbing\n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        // look for existing answer for this invocation\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n            new AnswersValidator().validateDefaultAnswerReturnedValue(invocation, ret);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
        "begin_line": 51,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.voidMethodStubbable(T)",
        "snippet": "    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n    }",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.getMockSettings()",
        "snippet": "    public MockCreationSettings getMockSettings() {\n        return mockSettings;\n    }",
        "begin_line": 114,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.setAnswersForStubbing(java.util.List<org.mockito.stubbing.Answer>)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n        invocationContainerImpl.setAnswersForStubbing(answers);\n    }",
        "begin_line": 118,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.getInvocationContainer()",
        "snippet": "    public InvocationContainer getInvocationContainer() {\n        return invocationContainerImpl;\n    }",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/MockHandlerImpl.java",
        "class_name": "org.mockito.internal.handler.MockHandlerImpl",
        "signature": "org.mockito.internal.handler.MockHandlerImpl.createVerificationData(org.mockito.internal.stubbing.InvocationContainerImpl, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    private VerificationDataImpl createVerificationData(InvocationContainerImpl invocationContainerImpl, InvocationMatcher invocationMatcher) {\n        if (mockSettings.isStubOnly()) {\n            new Reporter().stubPassedToVerify();     // this throws an exception\n        }\n\n        return new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n    }",
        "begin_line": 127,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.NullResultGuardian(org.mockito.internal.InternalMockHandler)",
        "snippet": "    public NullResultGuardian(InternalMockHandler delegate) {\n        this.delegate = delegate;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.handle(org.mockito.invocation.Invocation)",
        "snippet": "    public Object handle(Invocation invocation) throws Throwable {\n        Object result = delegate.handle(invocation);\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        if(result == null && returnType.isPrimitive()) {\n            //primitive values cannot be null\n            return new HandyReturnValues().returnFor(returnType);\n        } else {\n            return result;\n        }\n    }",
        "begin_line": 28,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.getMockSettings()",
        "snippet": "    public MockCreationSettings getMockSettings() {\n        return delegate.getMockSettings();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.voidMethodStubbable(java.lang.Object)",
        "snippet": "    public VoidMethodStubbable voidMethodStubbable(Object mock) {\n        return delegate.voidMethodStubbable(mock);\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.setAnswersForStubbing(java.util.List)",
        "snippet": "    public void setAnswersForStubbing(List answers) {\n        delegate.setAnswersForStubbing(answers);\n    }",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/handler/NullResultGuardian.java",
        "class_name": "org.mockito.internal.handler.NullResultGuardian",
        "signature": "org.mockito.internal.handler.NullResultGuardian.getInvocationContainer()",
        "snippet": "    public InvocationContainer getInvocationContainer() {\n        return delegate.getInvocationContainer();\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.JUnit45AndHigherRunnerImpl(java.lang.Class<?>)",
        "snippet": "    public JUnit45AndHigherRunnerImpl(Class<?> klass) throws InitializationError {\n        runner = new BlockJUnit4ClassRunner(klass) {\n            protected Statement withBefores(FrameworkMethod method, Object target,\n                    Statement statement) {\n                // init annotated mocks before tests\n                MockitoAnnotations.initMocks(target);\n                return super.withBefores(method, target, statement);\n            }\n        };\n    }",
        "begin_line": 22,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.Anonymous-39c2bafc-6f31-4aaa-8f75-b45a775b531f.withBefores(org.junit.runners.model.FrameworkMethod, java.lang.Object, org.junit.runners.model.Statement)",
        "snippet": "            protected Statement withBefores(FrameworkMethod method, Object target,\n                    Statement statement) {\n                // init annotated mocks before tests\n                MockitoAnnotations.initMocks(target);\n                return super.withBefores(method, target, statement);\n            }",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    public void run(final RunNotifier notifier) {\n        // add listener that validates framework usage at the end of each test\n        notifier.addListener(new FrameworkUsageValidator(notifier));\n\n        runner.run(notifier);\n    }",
        "begin_line": 33,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.getDescription()",
        "snippet": "    public Description getDescription() {\n        return runner.getDescription();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.filter(org.junit.runner.manipulation.Filter)",
        "snippet": "    public void filter(Filter filter) throws NoTestsRemainException {\n        runner.filter(filter);\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/RunnerFactory.java",
        "class_name": "org.mockito.internal.runners.RunnerFactory",
        "signature": "org.mockito.internal.runners.RunnerFactory.RunnerFactory(org.mockito.internal.runners.util.RunnerProvider)",
        "snippet": "    RunnerFactory(RunnerProvider runnerProvider) {\n        this.runnerProvider = runnerProvider;\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/RunnerFactory.java",
        "class_name": "org.mockito.internal.runners.RunnerFactory",
        "signature": "org.mockito.internal.runners.RunnerFactory.RunnerFactory()",
        "snippet": "    public RunnerFactory() {\n        this(new RunnerProvider());\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/RunnerFactory.java",
        "class_name": "org.mockito.internal.runners.RunnerFactory",
        "signature": "org.mockito.internal.runners.RunnerFactory.create(java.lang.Class<?>)",
        "snippet": "    public RunnerImpl create(Class<?> klass) throws InvocationTargetException {\n        try {\n            if (runnerProvider.isJUnit45OrHigherAvailable()) {\n                return runnerProvider.newInstance(\"org.mockito.internal.runners.JUnit45AndHigherRunnerImpl\", klass);\n            } else {\n                return runnerProvider.newInstance(\"org.mockito.internal.runners.JUnit44RunnerImpl\", klass);\n            }\n        } catch (InvocationTargetException e) {\n            if (!new TestMethodsFinder().hasTestMethods(klass)) {\n                throw new MockitoException(\n                    \"\\n\" +\n                    \"\\n\" +\n                    \"No tests found in \" + klass.getSimpleName() + \"\\n\" +\n                    \"Haven't you forgot @Test annotation?\\n\"\n                    , e);\n            }\n            throw e;\n        } catch (Throwable t) {\n            throw new MockitoException(\n                    \"\\n\" +\n                    \"\\n\" +\n                    \"MockitoRunner can only be used with JUnit 4.4 or higher.\\n\" +\n                    \"You can upgrade your JUnit version or write your own Runner (please consider contributing your runner to the Mockito community).\\n\" +\n                    \"Bear in mind that you can still enjoy all features of the framework without using runners (they are completely optional).\\n\" +\n                    \"If you get this error despite using JUnit 4.4 or higher then please report this error to the mockito mailing list.\\n\"\n                    , t);\n        }\n    }",
        "begin_line": 25,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.RunnerImpl",
        "signature": "org.mockito.internal.runners.RunnerImpl.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    void run(RunNotifier notifier);",
        "begin_line": 17,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.RunnerImpl",
        "signature": "org.mockito.internal.runners.RunnerImpl.getDescription()",
        "snippet": "    Description getDescription();",
        "begin_line": 19,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit44RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit44RunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit44RunnerImpl.JUnit44RunnerImpl(java.lang.Class<?>)",
        "snippet": "    public JUnit44RunnerImpl(Class<?> klass) throws InitializationError {\n        this.runner = new JUnit4ClassRunner(klass) {\n            @Override\n            protected Object createTest() throws Exception {\n                Object test = super.createTest();\n                MockitoAnnotations.initMocks(test);\n                return test;\n            }\n        };\n    }",
        "begin_line": 22,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit44RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit44RunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit44RunnerImpl.Anonymous-9b263fe1-95e1-4d58-a656-7e351bf6acfc.createTest()",
        "snippet": "            @Override\n            protected Object createTest() throws Exception {\n                Object test = super.createTest();\n                MockitoAnnotations.initMocks(test);\n                return test;\n            }",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit44RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit44RunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit44RunnerImpl.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    public void run(RunNotifier notifier) {\n        // add listener that validates framework usage at the end of each test\n        notifier.addListener(new FrameworkUsageValidator(notifier));\n\n        runner.run(notifier);\n    }",
        "begin_line": 33,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit44RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit44RunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit44RunnerImpl.getDescription()",
        "snippet": "    public Description getDescription() {\n        return runner.getDescription();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/JUnit44RunnerImpl.java",
        "class_name": "org.mockito.internal.runners.JUnit44RunnerImpl",
        "signature": "org.mockito.internal.runners.JUnit44RunnerImpl.filter(org.junit.runner.manipulation.Filter)",
        "snippet": "    public void filter(Filter filter) throws NoTestsRemainException {\n        runner.filter(filter);\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/util/RunnerProvider.java",
        "class_name": "org.mockito.internal.runners.util.RunnerProvider",
        "signature": "org.mockito.internal.runners.util.RunnerProvider.isJUnit45OrHigherAvailable()",
        "snippet": "    public boolean isJUnit45OrHigherAvailable() {\n        return hasJUnit45OrHigher;\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/util/RunnerProvider.java",
        "class_name": "org.mockito.internal.runners.util.RunnerProvider",
        "signature": "org.mockito.internal.runners.util.RunnerProvider.newInstance(java.lang.String, java.lang.Class<?>)",
        "snippet": "    public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {\n        Constructor<?> constructor;\n        try {\n            Class<?> runnerClass = Class.forName(runnerClassName);\n            constructor = runnerClass.getConstructor(Class.class.getClass());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        \n        try {\n            return (RunnerImpl) constructor.newInstance(constructorParam);\n        } catch (InvocationTargetException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);        \n        }\n    }",
        "begin_line": 29,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/util/TestMethodsFinder.java",
        "class_name": "org.mockito.internal.runners.util.TestMethodsFinder",
        "signature": "org.mockito.internal.runners.util.TestMethodsFinder.hasTestMethods(java.lang.Class<?>)",
        "snippet": "    public boolean hasTestMethods(Class<?> klass) {\n        Method[] methods = klass.getMethods();\n        for(Method m:methods) {\n            if (m.isAnnotationPresent(Test.class)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 12,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/util/FrameworkUsageValidator.java",
        "class_name": "org.mockito.internal.runners.util.FrameworkUsageValidator",
        "signature": "org.mockito.internal.runners.util.FrameworkUsageValidator.FrameworkUsageValidator(org.junit.runner.notification.RunNotifier)",
        "snippet": "    public FrameworkUsageValidator(RunNotifier notifier) {\n        this.notifier = notifier;\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/runners/util/FrameworkUsageValidator.java",
        "class_name": "org.mockito.internal.runners.util.FrameworkUsageValidator",
        "signature": "org.mockito.internal.runners.util.FrameworkUsageValidator.testFinished(org.junit.runner.Description)",
        "snippet": "    @Override\n    public void testFinished(Description description) throws Exception {\n        super.testFinished(description);\n        try {\n            Mockito.validateMockitoUsage();\n        } catch(Throwable t) {\n            notifier.fireTestFailure(new Failure(description, t));\n        }\n    }",
        "begin_line": 21,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/Localized.java",
        "class_name": "org.mockito.internal.debugging.Localized",
        "signature": "org.mockito.internal.debugging.Localized.Localized(T)",
        "snippet": "    public Localized(T object) {\n        this.object = object;\n        location = new LocationImpl();\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/Localized.java",
        "class_name": "org.mockito.internal.debugging.Localized",
        "signature": "org.mockito.internal.debugging.Localized.getObject()",
        "snippet": "    public T getObject() {\n        return object;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/Localized.java",
        "class_name": "org.mockito.internal.debugging.Localized",
        "signature": "org.mockito.internal.debugging.Localized.getLocation()",
        "snippet": "    public Location getLocation() {\n        return location;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsFinder.java",
        "class_name": "org.mockito.internal.debugging.WarningsFinder",
        "signature": "org.mockito.internal.debugging.WarningsFinder.WarningsFinder(java.util.List<org.mockito.invocation.Invocation>, java.util.List<org.mockito.internal.invocation.InvocationMatcher>)",
        "snippet": "    public WarningsFinder(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations) {\n        this.baseUnusedStubs = unusedStubs;\n        this.baseAllInvocations = allInvocations;\n    }",
        "begin_line": 19,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsFinder.java",
        "class_name": "org.mockito.internal.debugging.WarningsFinder",
        "signature": "org.mockito.internal.debugging.WarningsFinder.find(org.mockito.internal.debugging.FindingsListener)",
        "snippet": "    public void find(FindingsListener findingsListener) {\n        List<Invocation> unusedStubs = new LinkedList(this.baseUnusedStubs);\n        List<InvocationMatcher> allInvocations = new LinkedList(this.baseAllInvocations);\n\n        Iterator<Invocation> unusedIterator = unusedStubs.iterator();\n        while(unusedIterator.hasNext()) {\n            Invocation unused = unusedIterator.next();\n            Iterator<InvocationMatcher> unstubbedIterator = allInvocations.iterator();\n            while(unstubbedIterator.hasNext()) {\n                InvocationMatcher unstubbed = unstubbedIterator.next();\n                if(unstubbed.hasSimilarMethod(unused)) {\n                    findingsListener.foundStubCalledWithDifferentArgs(unused, unstubbed);\n                    unusedIterator.remove();\n                    unstubbedIterator.remove();\n                }\n            }\n        }\n\n        for (Invocation i : unusedStubs) {\n            findingsListener.foundUnusedStub(i);\n        }\n\n        for (InvocationMatcher i : allInvocations) {\n            findingsListener.foundUnstubbed(i);\n        }\n    }",
        "begin_line": 24,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LocationImpl.java",
        "class_name": "org.mockito.internal.debugging.LocationImpl",
        "signature": "org.mockito.internal.debugging.LocationImpl.LocationImpl()",
        "snippet": "    public LocationImpl() {\n        this(new StackTraceFilter());\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LocationImpl.java",
        "class_name": "org.mockito.internal.debugging.LocationImpl",
        "signature": "org.mockito.internal.debugging.LocationImpl.LocationImpl(org.mockito.internal.exceptions.stacktrace.StackTraceFilter)",
        "snippet": "    public LocationImpl(StackTraceFilter stackTraceFilter) {\n        this.stackTraceFilter = stackTraceFilter;\n        stackTraceHolder = new Throwable();\n    }",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LocationImpl.java",
        "class_name": "org.mockito.internal.debugging.LocationImpl",
        "signature": "org.mockito.internal.debugging.LocationImpl.toString()",
        "snippet": "    @Override\n    public String toString() {\n        StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);\n        if (filtered.length == 0) {\n            return \"-> at <<unknown line>>\";\n        }\n        return \"-> at \" + filtered[0].toString();\n    }",
        "begin_line": 26,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/FindingsListener.java",
        "class_name": "org.mockito.internal.debugging.FindingsListener",
        "signature": "org.mockito.internal.debugging.FindingsListener.foundStubCalledWithDifferentArgs(org.mockito.invocation.Invocation, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed);",
        "begin_line": 11,
        "end_line": 11,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/FindingsListener.java",
        "class_name": "org.mockito.internal.debugging.FindingsListener",
        "signature": "org.mockito.internal.debugging.FindingsListener.foundUnusedStub(org.mockito.invocation.Invocation)",
        "snippet": "    void foundUnusedStub(Invocation unused);",
        "begin_line": 13,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/FindingsListener.java",
        "class_name": "org.mockito.internal.debugging.FindingsListener",
        "signature": "org.mockito.internal.debugging.FindingsListener.foundUnstubbed(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    void foundUnstubbed(InvocationMatcher unstubbed);",
        "begin_line": 15,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/MockitoDebuggerImpl.java",
        "class_name": "org.mockito.internal.debugging.MockitoDebuggerImpl",
        "signature": "org.mockito.internal.debugging.MockitoDebuggerImpl.printInvocations(java.lang.Object...)",
        "snippet": "    public String printInvocations(Object ... mocks) {\n        String out = \"\";\n        List<Invocation> invocations = allInvocationsFinder.find(asList(mocks));\n        out += line(\"********************************\");\n        out += line(\"*** Mockito interactions log ***\");\n        out += line(\"********************************\");\n        for(Invocation i:invocations) {\n            out += line(i.toString());\n            out += line(\" invoked: \" + i.getLocation());\n            if (i.stubInfo() != null) {\n                out += line(\" stubbed: \" + i.stubInfo().stubbedAt().toString());\n            }\n        }\n\n        invocations = unusedStubsFinder.find(asList(mocks));\n        if (invocations.isEmpty()) {\n            return print(out);\n        }\n        out += line(\"********************************\");\n        out += line(\"***       Unused stubs       ***\");\n        out += line(\"********************************\");\n        \n        for(Invocation i:invocations) {\n            out += line(i.toString());\n            out += line(\" stubbed: \" + i.getLocation());\n        }\n        return print(out);\n    }",
        "begin_line": 21,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/MockitoDebuggerImpl.java",
        "class_name": "org.mockito.internal.debugging.MockitoDebuggerImpl",
        "signature": "org.mockito.internal.debugging.MockitoDebuggerImpl.line(java.lang.String)",
        "snippet": "    private String line(String text) {\n        return text + \"\\n\";\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/MockitoDebuggerImpl.java",
        "class_name": "org.mockito.internal.debugging.MockitoDebuggerImpl",
        "signature": "org.mockito.internal.debugging.MockitoDebuggerImpl.print(java.lang.String)",
        "snippet": "    private String print(String out) {\n        System.out.println(out);\n        return out;\n    }",
        "begin_line": 54,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsCollector.java",
        "class_name": "org.mockito.internal.debugging.WarningsCollector",
        "signature": "org.mockito.internal.debugging.WarningsCollector.WarningsCollector()",
        "snippet": "    public WarningsCollector() {\n        createdMocks = new LinkedList();\n        MockingProgress progress = new ThreadSafeMockingProgress();\n        progress.setListener(new CollectCreatedMocks(createdMocks));\n    }",
        "begin_line": 23,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsCollector.java",
        "class_name": "org.mockito.internal.debugging.WarningsCollector",
        "signature": "org.mockito.internal.debugging.WarningsCollector.getWarnings()",
        "snippet": "    public String getWarnings() {\n        List<Invocation> unused = new UnusedStubsFinder().find(createdMocks);\n        List<Invocation> all = new AllInvocationsFinder().find(createdMocks);\n        List<InvocationMatcher> allInvocationMatchers = InvocationMatcher.createFrom(all);\n\n        String warnings = new WarningsPrinterImpl(unused, allInvocationMatchers, false).print();\n\n        return warnings;\n    }",
        "begin_line": 29,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.VerboseMockInvocationLogger()",
        "snippet": "    public VerboseMockInvocationLogger() {\n        this(System.out);\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.VerboseMockInvocationLogger(java.io.PrintStream)",
        "snippet": "    public VerboseMockInvocationLogger(PrintStream printStream) {\n        this.printStream = printStream;\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.reportInvocation(org.mockito.listeners.MethodInvocationReport)",
        "snippet": "    public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n        printHeader();\n        printStubInfo(methodInvocationReport);\n        printInvocation(methodInvocationReport.getInvocation());\n        printReturnedValueOrThrowable(methodInvocationReport);\n        printFooter();\n    }",
        "begin_line": 33,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printReturnedValueOrThrowable(org.mockito.listeners.MethodInvocationReport)",
        "snippet": "    private void printReturnedValueOrThrowable(MethodInvocationReport methodInvocationReport) {\n        if (methodInvocationReport.threwException()) {\n            String message = methodInvocationReport.getThrowable().getMessage() == null ? \"\" : \" with message \" + methodInvocationReport.getThrowable().getMessage();\n            printlnIndented(\"has thrown: \" + methodInvocationReport.getThrowable().getClass() + message);\n        } else {\n            String type = (methodInvocationReport.getReturnedValue() == null) ? \"\" : \" (\" + methodInvocationReport.getReturnedValue().getClass().getName() + \")\";\n            printlnIndented(\"has returned: \\\"\" + methodInvocationReport.getReturnedValue() + \"\\\"\" + type);\n        }\n    }",
        "begin_line": 41,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printStubInfo(org.mockito.listeners.MethodInvocationReport)",
        "snippet": "    private void printStubInfo(MethodInvocationReport methodInvocationReport) {\n        if (methodInvocationReport.getLocationOfStubbing() != null) {\n            printlnIndented(\"stubbed: \" + methodInvocationReport.getLocationOfStubbing());\n        }\n    }",
        "begin_line": 51,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printHeader()",
        "snippet": "    private void printHeader() {\n        mockInvocationsCounter++;\n        printStream.println(\"############ Logging method invocation #\" + mockInvocationsCounter + \" on mock/spy ########\");\n    }",
        "begin_line": 57,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printInvocation(org.mockito.invocation.DescribedInvocation)",
        "snippet": "    private void printInvocation(DescribedInvocation invocation) {\n        printStream.println(invocation.toString());\n//        printStream.println(\"Handling method call on a mock/spy.\");\n        printlnIndented(\"invoked: \" + invocation.getLocation().toString());\n    }",
        "begin_line": 62,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printFooter()",
        "snippet": "    private void printFooter() {\n        printStream.println(\"\");\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java",
        "class_name": "org.mockito.internal.debugging.VerboseMockInvocationLogger",
        "signature": "org.mockito.internal.debugging.VerboseMockInvocationLogger.printlnIndented(java.lang.String)",
        "snippet": "    private void printlnIndented(String message) {\n        printStream.println(\"   \" + message);\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.LoggingListener(boolean, org.mockito.internal.util.MockitoLogger)",
        "snippet": "    public LoggingListener(boolean warnAboutUnstubbed, MockitoLogger logger) {\n        this.warnAboutUnstubbed = warnAboutUnstubbed;\n        this.logger = logger;\n    }",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.foundStubCalledWithDifferentArgs(org.mockito.invocation.Invocation, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed) {\n        logger.log(join(\n                \" *** Stubbing warnings from Mockito: *** \",\n                \"\",\n                \"stubbed with those args here   \" + unused.getLocation(),\n                \"BUT called with different args \" + unstubbed.getInvocation().getLocation(),\n                \"\"));\n    }",
        "begin_line": 22,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.foundUnusedStub(org.mockito.invocation.Invocation)",
        "snippet": "    public void foundUnusedStub(Invocation unused) {\n        logger.log(\"This stubbing was never used   \" + unused.getLocation() + \"\\n\");\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.foundUnstubbed(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void foundUnstubbed(InvocationMatcher unstubbed) {\n        if (warnAboutUnstubbed) {\n            logger.log(join(\n                    \"This method was not stubbed \",\n                    unstubbed,\n                    unstubbed.getInvocation().getLocation(),\n                    \"\"));\n        }\n    }",
        "begin_line": 35,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.isWarnAboutUnstubbed()",
        "snippet": "    public boolean isWarnAboutUnstubbed() {\n        return warnAboutUnstubbed;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/LoggingListener.java",
        "class_name": "org.mockito.internal.debugging.LoggingListener",
        "signature": "org.mockito.internal.debugging.LoggingListener.getLogger()",
        "snippet": "    public MockitoLogger getLogger() {\n        return logger;\n    }",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsPrinterImpl.java",
        "class_name": "org.mockito.internal.debugging.WarningsPrinterImpl",
        "signature": "org.mockito.internal.debugging.WarningsPrinterImpl.WarningsPrinterImpl(java.util.List<org.mockito.invocation.Invocation>, java.util.List<org.mockito.internal.invocation.InvocationMatcher>)",
        "snippet": "    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n        this(unusedStubs, unstubbedInvocations, false);\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsPrinterImpl.java",
        "class_name": "org.mockito.internal.debugging.WarningsPrinterImpl",
        "signature": "org.mockito.internal.debugging.WarningsPrinterImpl.WarningsPrinterImpl(java.util.List<org.mockito.invocation.Invocation>, java.util.List<org.mockito.internal.invocation.InvocationMatcher>, boolean)",
        "snippet": "    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {\n        this(warnAboutUnstubbed, new WarningsFinder(unusedStubs, allInvocations));\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsPrinterImpl.java",
        "class_name": "org.mockito.internal.debugging.WarningsPrinterImpl",
        "signature": "org.mockito.internal.debugging.WarningsPrinterImpl.WarningsPrinterImpl(boolean, org.mockito.internal.debugging.WarningsFinder)",
        "snippet": "    WarningsPrinterImpl(boolean warnAboutUnstubbed, WarningsFinder finder) {\n        this.warnAboutUnstubbed = warnAboutUnstubbed;\n        this.finder = finder;\n    }",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsPrinterImpl.java",
        "class_name": "org.mockito.internal.debugging.WarningsPrinterImpl",
        "signature": "org.mockito.internal.debugging.WarningsPrinterImpl.print(org.mockito.internal.util.MockitoLogger)",
        "snippet": "    public void print(final MockitoLogger logger) {\n        finder.find(new LoggingListener(warnAboutUnstubbed, logger));\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/debugging/WarningsPrinterImpl.java",
        "class_name": "org.mockito.internal.debugging.WarningsPrinterImpl",
        "signature": "org.mockito.internal.debugging.WarningsPrinterImpl.print()",
        "snippet": "    public String print() {\n        SimpleMockitoLogger logger = new SimpleMockitoLogger();\n        this.print(logger);\n        return logger.getLoggedInfo();\n    }",
        "begin_line": 36,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/InOrderContextImpl.java",
        "class_name": "org.mockito.internal.verification.InOrderContextImpl",
        "signature": "org.mockito.internal.verification.InOrderContextImpl.isVerified(org.mockito.invocation.Invocation)",
        "snippet": "    public boolean isVerified(Invocation invocation) {\n        return verified.contains(invocation);\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/InOrderContextImpl.java",
        "class_name": "org.mockito.internal.verification.InOrderContextImpl",
        "signature": "org.mockito.internal.verification.InOrderContextImpl.markVerified(org.mockito.invocation.Invocation)",
        "snippet": "    public void markVerified(Invocation i) {\n        verified.add(i);\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/InOrderWrapper.java",
        "class_name": "org.mockito.internal.verification.InOrderWrapper",
        "signature": "org.mockito.internal.verification.InOrderWrapper.InOrderWrapper(org.mockito.internal.verification.api.VerificationInOrderMode, org.mockito.internal.InOrderImpl)",
        "snippet": "    public InOrderWrapper(VerificationInOrderMode mode, InOrderImpl inOrder) {\n        this.mode = mode;\n        this.inOrder = inOrder;        \n    }",
        "begin_line": 22,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/InOrderWrapper.java",
        "class_name": "org.mockito.internal.verification.InOrderWrapper",
        "signature": "org.mockito.internal.verification.InOrderWrapper.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        List<Invocation> invocations = new VerifiableInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n        VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl(inOrder, invocations, data.getWanted());\n        mode.verifyInOrder(dataInOrder);\n    }",
        "begin_line": 27,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtMost.java",
        "class_name": "org.mockito.internal.verification.AtMost",
        "signature": "org.mockito.internal.verification.AtMost.AtMost(int)",
        "snippet": "    public AtMost(int maxNumberOfInvocations) {\n        if (maxNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.maxNumberOfInvocations = maxNumberOfInvocations;\n    }",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtMost.java",
        "class_name": "org.mockito.internal.verification.AtMost",
        "signature": "org.mockito.internal.verification.AtMost.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        List<Invocation> invocations = data.getAllInvocations();\n        InvocationMatcher wanted = data.getWanted();\n        \n        InvocationsFinder finder = new InvocationsFinder();\n        List<Invocation> found = finder.findInvocations(invocations, wanted);\n        int foundSize = found.size();\n        if (foundSize > maxNumberOfInvocations) {\n            new Reporter().wantedAtMostX(maxNumberOfInvocations, foundSize);\n        }\n        \n        invocationMarker.markVerified(found, wanted);\n    }",
        "begin_line": 31,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Calls.java",
        "class_name": "org.mockito.internal.verification.Calls",
        "signature": "org.mockito.internal.verification.Calls.Calls(int)",
        "snippet": "    public Calls(int wantedNumberOfInvocations) {\n        if( wantedNumberOfInvocations <= 0 ) {\n            throw new MockitoException( \"Negative and zero values are not allowed here\" );\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
        "begin_line": 23,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Calls.java",
        "class_name": "org.mockito.internal.verification.Calls",
        "signature": "org.mockito.internal.verification.Calls.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        throw new MockitoException( \"calls is only intended to work with InOrder\" );\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Calls.java",
        "class_name": "org.mockito.internal.verification.Calls",
        "signature": "org.mockito.internal.verification.Calls.verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder)",
        "snippet": "    public void verifyInOrder(VerificationDataInOrder data) {\n        List<Invocation> allInvocations = data.getAllInvocations();\n        InvocationMatcher wanted = data.getWanted();\n        \n        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n        missingInvocation.check( allInvocations, wanted, this, data.getOrderingContext());\n        NonGreedyNumberOfInvocationsInOrderChecker numberOfCalls = new NonGreedyNumberOfInvocationsInOrderChecker();\n        numberOfCalls.check( allInvocations, wanted, wantedCount, data.getOrderingContext());\n    }    ",
        "begin_line": 34,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Calls.java",
        "class_name": "org.mockito.internal.verification.Calls",
        "signature": "org.mockito.internal.verification.Calls.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"Wanted invocations count (non-greedy): \" + wantedCount;\n    }",
        "begin_line": 44,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.atLeastOnce()",
        "snippet": "    public static VerificationMode atLeastOnce() {\n        return atLeast(1);\n    }",
        "begin_line": 12,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.atLeast(int)",
        "snippet": "    public static VerificationMode atLeast(int minNumberOfInvocations) {\n        return new AtLeast(minNumberOfInvocations);\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.only()",
        "snippet": "    public static VerificationMode only() {\n        return new Only(); //TODO make exception message nicer\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.times(int)",
        "snippet": "    public static Times times(int wantedNumberOfInvocations) {\n        return new Times(wantedNumberOfInvocations);\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.calls(int)",
        "snippet": "    public static Calls calls(int wantedNumberOfInvocations) {\n        return new Calls( wantedNumberOfInvocations );\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.noMoreInteractions()",
        "snippet": "    public static NoMoreInteractions noMoreInteractions() {\n        return new NoMoreInteractions();\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationModeFactory.java",
        "class_name": "org.mockito.internal.verification.VerificationModeFactory",
        "signature": "org.mockito.internal.verification.VerificationModeFactory.atMost(int)",
        "snippet": "    public static VerificationMode atMost(int maxNumberOfInvocations) {\n        return new AtMost(maxNumberOfInvocations);\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/MockAwareVerificationMode.java",
        "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
        "signature": "org.mockito.internal.verification.MockAwareVerificationMode.MockAwareVerificationMode(java.lang.Object, org.mockito.verification.VerificationMode)",
        "snippet": "    public MockAwareVerificationMode(Object mock, VerificationMode mode) {\n        this.mock = mock;\n        this.mode = mode;\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/MockAwareVerificationMode.java",
        "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
        "signature": "org.mockito.internal.verification.MockAwareVerificationMode.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        mode.verify(data);\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/MockAwareVerificationMode.java",
        "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
        "signature": "org.mockito.internal.verification.MockAwareVerificationMode.getMock()",
        "snippet": "    public Object getMock() {\n        return mock;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationDataImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationDataImpl",
        "signature": "org.mockito.internal.verification.VerificationDataImpl.VerificationDataImpl(org.mockito.internal.stubbing.InvocationContainer, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public VerificationDataImpl(InvocationContainer invocations, InvocationMatcher wanted) {\n        this.invocations = invocations;\n        this.wanted = wanted;\n        this.assertWantedIsVerifiable();\n    }",
        "begin_line": 21,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationDataImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationDataImpl",
        "signature": "org.mockito.internal.verification.VerificationDataImpl.getAllInvocations()",
        "snippet": "    public List<Invocation> getAllInvocations() {\n        return invocations.getInvocations();\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationDataImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationDataImpl",
        "signature": "org.mockito.internal.verification.VerificationDataImpl.getWanted()",
        "snippet": "    public InvocationMatcher getWanted() {\n        return wanted;\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationDataImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationDataImpl",
        "signature": "org.mockito.internal.verification.VerificationDataImpl.assertWantedIsVerifiable()",
        "snippet": "    private void assertWantedIsVerifiable() {\n        if (wanted == null) {\n            return;\n        }\n        ObjectMethodsGuru o =  new ObjectMethodsGuru();\n        if (o.isToString(wanted.getMethod())) {\n            new Reporter().cannotVerifyToString();\n        }\n    }",
        "begin_line": 35,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.DefaultRegisteredInvocations",
        "signature": "org.mockito.internal.verification.DefaultRegisteredInvocations.add(org.mockito.invocation.Invocation)",
        "snippet": "    public void add(Invocation invocation) {\n        synchronized (invocations) {\n            invocations.add(invocation);\n        }\n    }",
        "begin_line": 23,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.DefaultRegisteredInvocations",
        "signature": "org.mockito.internal.verification.DefaultRegisteredInvocations.removeLast()",
        "snippet": "    public void removeLast() {\n        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)\n        synchronized (invocations) {\n            if (! invocations.isEmpty()) {\n                invocations.removeLast();\n            }\n        }\n    }",
        "begin_line": 29,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.DefaultRegisteredInvocations",
        "signature": "org.mockito.internal.verification.DefaultRegisteredInvocations.getAll()",
        "snippet": "    public List<Invocation> getAll() {\n        List<Invocation> copiedList;\n        synchronized (invocations) {\n            copiedList = new LinkedList<Invocation>(invocations) ;\n        }\n\n        return ListUtil.filter(copiedList, new RemoveToString());\n    }",
        "begin_line": 38,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.DefaultRegisteredInvocations",
        "signature": "org.mockito.internal.verification.DefaultRegisteredInvocations.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        synchronized (invocations) {\n            return invocations.isEmpty();\n        }\n    }",
        "begin_line": 47,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/DefaultRegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.DefaultRegisteredInvocations",
        "signature": "org.mockito.internal.verification.DefaultRegisteredInvocations.RemoveToString.isOut(org.mockito.invocation.Invocation)",
        "snippet": "        public boolean isOut(Invocation invocation) {\n            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n        }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/RegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.RegisteredInvocations",
        "signature": "org.mockito.internal.verification.RegisteredInvocations.add(org.mockito.invocation.Invocation)",
        "snippet": "    void add(Invocation invocation);",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/RegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.RegisteredInvocations",
        "signature": "org.mockito.internal.verification.RegisteredInvocations.removeLast()",
        "snippet": "    void removeLast();",
        "begin_line": 20,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/RegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.RegisteredInvocations",
        "signature": "org.mockito.internal.verification.RegisteredInvocations.getAll()",
        "snippet": "    List<Invocation> getAll();",
        "begin_line": 22,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/RegisteredInvocations.java",
        "class_name": "org.mockito.internal.verification.RegisteredInvocations",
        "signature": "org.mockito.internal.verification.RegisteredInvocations.isEmpty()",
        "snippet": "    boolean isEmpty();",
        "begin_line": 24,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Only.java",
        "class_name": "org.mockito.internal.verification.Only",
        "signature": "org.mockito.internal.verification.Only.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public void verify(VerificationData data) {\n        InvocationMatcher wantedMatcher = data.getWanted();\n        List<Invocation> invocations = data.getAllInvocations();\n        List<Invocation> chunk = finder.findInvocations(invocations,wantedMatcher);\n        if (invocations.size() != 1 && chunk.size() > 0) {            \n            Invocation unverified = finder.findFirstUnverified(invocations);\n            reporter.noMoreInteractionsWanted(unverified, (List) invocations);\n        } else if (invocations.size() != 1 || chunk.size() == 0) {\n            reporter.wantedButNotInvoked(wantedMatcher);\n        }\n        marker.markVerified(chunk.get(0), wantedMatcher);\n    }",
        "begin_line": 23,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtLeast.java",
        "class_name": "org.mockito.internal.verification.AtLeast",
        "signature": "org.mockito.internal.verification.AtLeast.AtLeast(int)",
        "snippet": "    public AtLeast(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
        "begin_line": 26,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtLeast.java",
        "class_name": "org.mockito.internal.verification.AtLeast",
        "signature": "org.mockito.internal.verification.AtLeast.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n        AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker();\n        \n        if (wantedCount == 1) {\n            missingInvocation.check(data.getAllInvocations(), data.getWanted());\n        }\n        numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n    }",
        "begin_line": 33,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtLeast.java",
        "class_name": "org.mockito.internal.verification.AtLeast",
        "signature": "org.mockito.internal.verification.AtLeast.verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder)",
        "snippet": "    public void verifyInOrder(VerificationDataInOrder data) {\n        List<Invocation> allInvocations = data.getAllInvocations();\n        InvocationMatcher wanted = data.getWanted();\n        \n        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n        AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker(data.getOrderingContext());\n        \n        if (wantedCount == 1) {\n            missingInvocation.check(allInvocations, wanted, this, data.getOrderingContext());\n        }\n        \n        numberOfCalls.check(allInvocations, wanted, wantedCount);\n    }",
        "begin_line": 43,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/AtLeast.java",
        "class_name": "org.mockito.internal.verification.AtLeast",
        "signature": "org.mockito.internal.verification.AtLeast.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"Wanted invocations count: at least \" + wantedCount;\n    }",
        "begin_line": 57,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/SingleRegisteredInvocation.java",
        "class_name": "org.mockito.internal.verification.SingleRegisteredInvocation",
        "signature": "org.mockito.internal.verification.SingleRegisteredInvocation.add(org.mockito.invocation.Invocation)",
        "snippet": "    public void add(Invocation invocation) {\n        this.invocation = invocation;\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/SingleRegisteredInvocation.java",
        "class_name": "org.mockito.internal.verification.SingleRegisteredInvocation",
        "signature": "org.mockito.internal.verification.SingleRegisteredInvocation.removeLast()",
        "snippet": "    public void removeLast() {\n        invocation = null;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/SingleRegisteredInvocation.java",
        "class_name": "org.mockito.internal.verification.SingleRegisteredInvocation",
        "signature": "org.mockito.internal.verification.SingleRegisteredInvocation.getAll()",
        "snippet": "    public List<Invocation> getAll() {\n        return Collections.emptyList();\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/SingleRegisteredInvocation.java",
        "class_name": "org.mockito.internal.verification.SingleRegisteredInvocation",
        "signature": "org.mockito.internal.verification.SingleRegisteredInvocation.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return invocation == null;\n    }",
        "begin_line": 30,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.VerificationOverTimeImpl(long, long, org.mockito.verification.VerificationMode, boolean)",
        "snippet": "    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess) {\n        this(pollingPeriodMillis, delegate, returnOnSuccess, new Timer(durationMillis));\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.VerificationOverTimeImpl(long, org.mockito.verification.VerificationMode, boolean, org.mockito.internal.util.Timer)",
        "snippet": "    public VerificationOverTimeImpl(long pollingPeriodMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {\n        this.pollingPeriodMillis = pollingPeriodMillis;\n        this.delegate = delegate;\n        this.returnOnSuccess = returnOnSuccess;\n        this.timer = timer;\n    }",
        "begin_line": 50,
        "end_line": 55,
        "comment": "\n     * Create this verification mode, to be used to verify invocation ongoing data later.\n     *\n     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n     * @param delegate The verification mode to delegate overall success or failure to\n     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n     *                        the delegate is satisfied and the full duration has passed (as in\n     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n     * @param timer Checker of whether the duration of the verification is still acceptable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (AssertionError e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }",
        "begin_line": 72,
        "end_line": 96,
        "comment": "\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.handleVerifyException(java.lang.AssertionError)",
        "snippet": "    private AssertionError handleVerifyException(AssertionError e) {\n        if (canRecoverFromFailure(delegate)) {\n            sleep(pollingPeriodMillis);\n            return e;\n        } else {\n            throw e;\n        }\n    }",
        "begin_line": 98,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.canRecoverFromFailure(org.mockito.verification.VerificationMode)",
        "snippet": "    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n    }",
        "begin_line": 107,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.copyWithVerificationMode(org.mockito.verification.VerificationMode)",
        "snippet": "    public VerificationOverTimeImpl copyWithVerificationMode(VerificationMode verificationMode) {\n        return new VerificationOverTimeImpl(pollingPeriodMillis, timer.duration(), verificationMode, returnOnSuccess);\n    }",
        "begin_line": 111,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java",
        "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
        "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.sleep(long)",
        "snippet": "    private void sleep(long sleep) {\n        try {\n            Thread.sleep(sleep);\n        } catch (InterruptedException ie) {\n            throw new RuntimeException(\"Thread sleep has been interrupted\", ie);\n        }\n    }",
        "begin_line": 115,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/NoMoreInteractions.java",
        "class_name": "org.mockito.internal.verification.NoMoreInteractions",
        "signature": "org.mockito.internal.verification.NoMoreInteractions.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public void verify(VerificationData data) {\n        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n        if (unverified != null) {\n            new Reporter().noMoreInteractionsWanted(unverified, (List) data.getAllInvocations());\n        }\n    }",
        "begin_line": 20,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/NoMoreInteractions.java",
        "class_name": "org.mockito.internal.verification.NoMoreInteractions",
        "signature": "org.mockito.internal.verification.NoMoreInteractions.verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder)",
        "snippet": "    public void verifyInOrder(VerificationDataInOrder data) {\n        List<Invocation> invocations = data.getAllInvocations();\n        Invocation unverified = new InvocationsFinder().findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);\n        \n        if (unverified != null) {\n            new Reporter().noMoreInteractionsWantedInOrder(unverified);\n        }\n    }",
        "begin_line": 28,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Times.java",
        "class_name": "org.mockito.internal.verification.Times",
        "signature": "org.mockito.internal.verification.Times.Times(int)",
        "snippet": "    public Times(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
        "begin_line": 26,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Times.java",
        "class_name": "org.mockito.internal.verification.Times",
        "signature": "org.mockito.internal.verification.Times.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        if (wantedCount > 0) {\n            MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n            missingInvocation.check(data.getAllInvocations(), data.getWanted());\n        }\n        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n        numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n    }",
        "begin_line": 33,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Times.java",
        "class_name": "org.mockito.internal.verification.Times",
        "signature": "org.mockito.internal.verification.Times.verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder)",
        "snippet": "    public void verifyInOrder(VerificationDataInOrder data) {\n        List<Invocation> allInvocations = data.getAllInvocations();\n        InvocationMatcher wanted = data.getWanted();\n        \n        if (wantedCount > 0) {\n            MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n            missingInvocation.check(allInvocations, wanted, this, data.getOrderingContext());\n        }\n        NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n        numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());\n    }    ",
        "begin_line": 42,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/Times.java",
        "class_name": "org.mockito.internal.verification.Times",
        "signature": "org.mockito.internal.verification.Times.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"Wanted invocations count: \" + wantedCount;\n    }",
        "begin_line": 54,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrderImpl",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrderImpl.VerificationDataInOrderImpl(org.mockito.internal.verification.api.InOrderContext, java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, InvocationMatcher wanted) {\n        this.inOrder = inOrder;\n        this.allInvocations = allInvocations;\n        this.wanted = wanted;        \n    }",
        "begin_line": 18,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrderImpl",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrderImpl.getAllInvocations()",
        "snippet": "    public List<Invocation> getAllInvocations() {\n        return allInvocations;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrderImpl",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrderImpl.getOrderingContext()",
        "snippet": "    public InOrderContext getOrderingContext() {\n        return inOrder;\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrderImpl",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrderImpl.getWanted()",
        "snippet": "    public InvocationMatcher getWanted() {\n        return wanted;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationInOrderMode.java",
        "class_name": "org.mockito.internal.verification.api.VerificationInOrderMode",
        "signature": "org.mockito.internal.verification.api.VerificationInOrderMode.verifyInOrder(org.mockito.internal.verification.api.VerificationDataInOrder)",
        "snippet": "    void verifyInOrder(VerificationDataInOrder data);    ",
        "begin_line": 9,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/InOrderContext.java",
        "class_name": "org.mockito.internal.verification.api.InOrderContext",
        "signature": "org.mockito.internal.verification.api.InOrderContext.isVerified(org.mockito.invocation.Invocation)",
        "snippet": "    boolean isVerified(Invocation invocation);",
        "begin_line": 11,
        "end_line": 11,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/InOrderContext.java",
        "class_name": "org.mockito.internal.verification.api.InOrderContext",
        "signature": "org.mockito.internal.verification.api.InOrderContext.markVerified(org.mockito.invocation.Invocation)",
        "snippet": "    void markVerified(Invocation i);",
        "begin_line": 13,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationData.java",
        "class_name": "org.mockito.internal.verification.api.VerificationData",
        "signature": "org.mockito.internal.verification.api.VerificationData.getAllInvocations()",
        "snippet": "    List<Invocation> getAllInvocations();",
        "begin_line": 14,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationData.java",
        "class_name": "org.mockito.internal.verification.api.VerificationData",
        "signature": "org.mockito.internal.verification.api.VerificationData.getWanted()",
        "snippet": "    InvocationMatcher getWanted();   ",
        "begin_line": 16,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrder.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrder",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrder.getAllInvocations()",
        "snippet": "    List<Invocation> getAllInvocations();",
        "begin_line": 14,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrder.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrder",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrder.getWanted()",
        "snippet": "    InvocationMatcher getWanted();   ",
        "begin_line": 16,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/api/VerificationDataInOrder.java",
        "class_name": "org.mockito.internal.verification.api.VerificationDataInOrder",
        "signature": "org.mockito.internal.verification.api.VerificationDataInOrder.getOrderingContext()",
        "snippet": "    InOrderContext getOrderingContext(); ",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
        "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
        "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(java.util.List<org.hamcrest.Matcher>, java.lang.Object[])",
        "snippet": "    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }",
        "begin_line": 20,
        "end_line": 37,
        "comment": "\n     * Suspiciously not matching arguments are those that don't match, the toString() representation is the same but types are different.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
        "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
        "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.safelyMatches(org.hamcrest.Matcher, java.lang.Object)",
        "snippet": "    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
        "begin_line": 39,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java",
        "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
        "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(org.hamcrest.Matcher, java.lang.Object)",
        "snippet": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker.MissingInvocationInOrderChecker()",
        "snippet": "    public MissingInvocationInOrderChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker.MissingInvocationInOrderChecker(org.mockito.internal.invocation.InvocationsFinder, org.mockito.exceptions.Reporter)",
        "snippet": "    MissingInvocationInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, org.mockito.verification.VerificationMode, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n        \n        if (!chunk.isEmpty()) {\n            return;\n        }\n        \n        Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations, context);\n        if (previousInOrder == null) {\n            /**\n             * It is of course possible to have an issue where the arguments are different\n             * rather that not invoked in order. Issue related to\n             * http://code.google.com/p/mockito/issues/detail?id=27. If the previous order\n             * is missing, then this method checks if the arguments are different or if the order\n             * is not invoked.\n             */\n             List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n             if (actualInvocations == null || actualInvocations.isEmpty())  {\n                 Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n                 if (similar != null) {\n                     Integer[] indicesOfSimilarMatchingArguments =\n                             new ArgumentMatchingTool().getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(),\n                                     similar.getArguments());\n                     SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indicesOfSimilarMatchingArguments);\n                     reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n                 } else {\n                     reporter.wantedButNotInvoked(wanted);\n                 }\n             }\n        } else {\n            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder);\n        }\n    }",
        "begin_line": 33,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java",
        "class_name": "org.mockito.internal.verification.checkers.AtLeastDiscrepancy",
        "signature": "org.mockito.internal.verification.checkers.AtLeastDiscrepancy.AtLeastDiscrepancy(int, int)",
        "snippet": "    public AtLeastDiscrepancy(int wantedCount, int actualCount) {\n        super(wantedCount, actualCount);\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java",
        "class_name": "org.mockito.internal.verification.checkers.AtLeastDiscrepancy",
        "signature": "org.mockito.internal.verification.checkers.AtLeastDiscrepancy.getPluralizedWantedCount()",
        "snippet": "    @Override\n    public String getPluralizedWantedCount() {\n        return \"*at least* \" + super.getPluralizedWantedCount();\n    }",
        "begin_line": 15,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker.AtLeastXNumberOfInvocationsInOrderChecker(org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public AtLeastXNumberOfInvocationsInOrderChecker(InOrderContext orderingContext) {\n        this.orderingContext = orderingContext;\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n        \n        int actualCount = chunk.size();\n        \n        if (wantedCount > actualCount) {\n            Location lastLocation = finder.getLastLocation(chunk);\n            reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n        }\n        \n        invocationMarker.markVerifiedInOrder(chunk, wanted, orderingContext);\n    }",
        "begin_line": 29,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker",
        "signature": "org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        int actualCount = actualInvocations.size();\n        if (wantedCount > actualCount) {\n            Location lastLocation = finder.getLastLocation(actualInvocations);\n            reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n        }\n        \n        invocationMarker.markVerified(actualInvocations, wanted);\n    }",
        "begin_line": 23,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker.NumberOfInvocationsInOrderChecker()",
        "snippet": "    public NumberOfInvocationsInOrderChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker.NumberOfInvocationsInOrderChecker(org.mockito.internal.invocation.InvocationsFinder, org.mockito.exceptions.Reporter)",
        "snippet": "    NumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n        \n        int actualCount = chunk.size();\n        \n        if (wantedCount > actualCount) {\n            Location lastInvocation = finder.getLastLocation(chunk);\n            reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n        } else if (wantedCount < actualCount) {\n            Location firstUndesired = chunk.get(wantedCount).getLocation();\n            reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n        }\n        \n        invocationMarker.markVerifiedInOrder(chunk, wanted, context);\n    }",
        "begin_line": 34,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker()",
        "snippet": "    public MissingInvocationChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker(org.mockito.internal.invocation.InvocationsFinder, org.mockito.exceptions.Reporter)",
        "snippet": "    MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
        "begin_line": 26,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
        "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        if (actualInvocations.isEmpty()) {\n            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n            if (similar != null) {\n                ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\n                reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n            } else {\n                reporter.wantedButNotInvoked(wanted, invocations);\n            }\n        }\n    }",
        "begin_line": 31,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.NumberOfInvocationsChecker()",
        "snippet": "    public NumberOfInvocationsChecker() {\n        this(new Reporter(), new InvocationsFinder());\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.NumberOfInvocationsChecker(org.mockito.exceptions.Reporter, org.mockito.internal.invocation.InvocationsFinder)",
        "snippet": "    NumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n        this.reporter = reporter;\n        this.finder = finder;\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker",
        "signature": "org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        int actualCount = actualInvocations.size();\n        if (wantedCount > actualCount) {\n            Location lastInvocation = finder.getLastLocation(actualInvocations);\n            reporter.tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n        } else if (wantedCount == 0 && actualCount > 0) {\n            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n            reporter.neverWantedButInvoked(wanted, firstUndesired); \n        } else if (wantedCount < actualCount) {\n            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n            reporter.tooManyActualInvocations(wantedCount, actualCount, wanted, firstUndesired);\n        }\n        \n        invocationMarker.markVerified(actualInvocations, wanted);\n    }",
        "begin_line": 33,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.NonGreedyNumberOfInvocationsInOrderChecker()",
        "snippet": "    public NonGreedyNumberOfInvocationsInOrderChecker() {\n        this(new InvocationsFinder(), new Reporter(), new InvocationMarker());\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.NonGreedyNumberOfInvocationsInOrderChecker(org.mockito.internal.invocation.InvocationsFinder, org.mockito.exceptions.Reporter, org.mockito.internal.invocation.InvocationMarker)",
        "snippet": "    NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter, InvocationMarker marker ) {\n        this.finder = finder;\n        this.reporter = reporter;\n        this.marker = marker;\n    }",
        "begin_line": 29,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java",
        "class_name": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker",
        "signature": "org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.check(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n        int actualCount = 0;\n        Location lastLocation = null;\n        while( actualCount < wantedCount ){\n            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n            if( next == null ){\n                reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n            }\n            marker.markVerified( next, wanted );\n            context.markVerified( next );\n            lastLocation = next.getLocation();\n            actualCount++;\n        }\n    }",
        "begin_line": 35,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/VerificationAwareInvocation.java",
        "class_name": "org.mockito.internal.exceptions.VerificationAwareInvocation",
        "signature": "org.mockito.internal.exceptions.VerificationAwareInvocation.isVerified()",
        "snippet": "    boolean isVerified();",
        "begin_line": 12,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/ExceptionIncludingMockitoWarnings.java",
        "class_name": "org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings",
        "signature": "org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings.ExceptionIncludingMockitoWarnings(java.lang.String, java.lang.Throwable)",
        "snippet": "    public ExceptionIncludingMockitoWarnings(String message, Throwable throwable) {\n        super(message, throwable);\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/util/ScenarioPrinter.java",
        "class_name": "org.mockito.internal.exceptions.util.ScenarioPrinter",
        "signature": "org.mockito.internal.exceptions.util.ScenarioPrinter.print(java.util.List<org.mockito.internal.exceptions.VerificationAwareInvocation>)",
        "snippet": "    public String print(List<VerificationAwareInvocation> invocations) {\n        if (invocations.size() == 1) {\n            return \"Actually, above is the only interaction with this mock.\";\n        }\n        StringBuilder sb = new StringBuilder(\n                \"***\\n\" +\n                \"For your reference, here is the list of all invocations ([?] - means unverified).\\n\");\n        \n        int counter = 0;\n        for (VerificationAwareInvocation i : invocations) {\n            sb.append(++counter + \". \");\n            if (!i.isVerified()) {\n                sb.append(\"[?]\");\n            }\n            sb.append(i.getLocation() + \"\\n\");\n        }\n        String scenario = sb.toString();\n        return scenario;\n    }",
        "begin_line": 13,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java",
        "class_name": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleaner",
        "signature": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleaner.isOut(java.lang.StackTraceElement)",
        "snippet": "    public boolean isOut(StackTraceElement e) {\n        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n        boolean fromByteBuddyMockObject = e.getClassName().contains(\"$MockitoMock$\");\n        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n        return (fromMockObject || fromByteBuddyMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n    }",
        "begin_line": 9,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java",
        "class_name": "org.mockito.internal.exceptions.stacktrace.StackTraceFilter",
        "signature": "org.mockito.internal.exceptions.stacktrace.StackTraceFilter.filter(java.lang.StackTraceElement[], boolean)",
        "snippet": "    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n        //TODO: profile\n        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n        \n        int lastBad = -1;\n        int firstBad = -1;\n        for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n            if (!CLEANER.isOut(unfilteredStackTrace.get(i))) {\n                continue;\n            }\n            lastBad = i;\n            if (firstBad == -1) {\n                firstBad = i;\n            }\n        }\n        \n        List<StackTraceElement> top;\n        if (keepTop && firstBad != -1) {\n            top = unfilteredStackTrace.subList(0, firstBad);\n        } else {\n            top = new LinkedList<StackTraceElement>();\n        }\n        \n        List<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\n        List<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\n        filtered.addAll(bottom);\n        return filtered.toArray(new StackTraceElement[]{});\n    }",
        "begin_line": 29,
        "end_line": 56,
        "comment": "\n     * Example how the filter works (+/- means good/bad):\n     * [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]\n     * Basically removes all bad from the middle. If any good are in the middle of bad those are also removed. \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java",
        "class_name": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider",
        "signature": "org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider.getStackTraceCleaner(org.mockito.exceptions.stacktrace.StackTraceCleaner)",
        "snippet": "    public StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner) {\n        return defaultCleaner;\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java",
        "class_name": "org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter",
        "signature": "org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter.filter(java.lang.Throwable)",
        "snippet": "    public void filter(Throwable throwable) {\n        if (!config.cleansStackTrace()) {\n            return;\n        }\n        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), true);\n        throwable.setStackTrace(filtered);\n    }",
        "begin_line": 19,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitRule.java",
        "class_name": "org.mockito.internal.junit.JUnitRule",
        "signature": "org.mockito.internal.junit.JUnitRule.apply(org.junit.runners.model.Statement, java.lang.Object)",
        "snippet": "    public Statement apply(final Statement base, final Object target) {\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                MockitoAnnotations.initMocks(target);\n                base.evaluate();\n                Mockito.validateMockitoUsage();\n            }\n        };\n    }",
        "begin_line": 11,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitRule.java",
        "class_name": "org.mockito.internal.junit.JUnitRule",
        "signature": "org.mockito.internal.junit.JUnitRule.Anonymous-939039d1-1753-4df3-a239-bb48fab20be6.evaluate()",
        "snippet": "            @Override\n            public void evaluate() throws Throwable {\n                MockitoAnnotations.initMocks(target);\n                base.evaluate();\n                Mockito.validateMockitoUsage();\n            }",
        "begin_line": 13,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitTool.java",
        "class_name": "org.mockito.internal.junit.JUnitTool",
        "signature": "org.mockito.internal.junit.JUnitTool.hasJUnit()",
        "snippet": "    public static boolean hasJUnit() {\n        return detecter.hasJUnit();\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitTool.java",
        "class_name": "org.mockito.internal.junit.JUnitTool",
        "signature": "org.mockito.internal.junit.JUnitTool.createArgumentsAreDifferentException(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n        return new FriendlyExceptionMaker(detecter).createArgumentsAreDifferentException(message, wanted, actual);\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/JUnitTool.java",
        "class_name": "org.mockito.exceptions.verification.junit.JUnitTool",
        "signature": "org.mockito.exceptions.verification.junit.JUnitTool.hasJUnit()",
        "snippet": "    public static boolean hasJUnit() {\n        return org.mockito.internal.junit.JUnitTool.hasJUnit();\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/JUnitTool.java",
        "class_name": "org.mockito.exceptions.verification.junit.JUnitTool",
        "signature": "org.mockito.exceptions.verification.junit.JUnitTool.createArgumentsAreDifferentException(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n        return org.mockito.internal.junit.JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/FriendlyExceptionMaker.java",
        "class_name": "org.mockito.internal.junit.FriendlyExceptionMaker",
        "signature": "org.mockito.internal.junit.FriendlyExceptionMaker.FriendlyExceptionMaker(org.mockito.internal.junit.JUnitDetecter)",
        "snippet": "    FriendlyExceptionMaker(JUnitDetecter detecter) {\n        this.detecter = detecter;\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/FriendlyExceptionMaker.java",
        "class_name": "org.mockito.internal.junit.FriendlyExceptionMaker",
        "signature": "org.mockito.internal.junit.FriendlyExceptionMaker.createArgumentsAreDifferentException(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n        if (!detecter.hasJUnit()) {\n            return new ArgumentsAreDifferent(message);\n        }\n\n        try {\n            Class<?> clazz = Class.forName(\"org.mockito.exceptions.verification.junit.ArgumentsAreDifferent\");\n            AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);\n            return throwable;\n        } catch (Throwable t) {\n//            throw the default exception in case of problems\n            return new ArgumentsAreDifferent(message);\n        }\n    }",
        "begin_line": 18,
        "end_line": 31,
        "comment": "TODO SF this can be now unit tested",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitDetecter.java",
        "class_name": "org.mockito.internal.junit.JUnitDetecter",
        "signature": "org.mockito.internal.junit.JUnitDetecter.JUnitDetecter()",
        "snippet": "    JUnitDetecter() {\n        try {\n            Class.forName(\"junit.framework.ComparisonFailure\");\n            hasJUnit = true;\n        } catch (Throwable t) {\n            hasJUnit = false;\n        }\n    }",
        "begin_line": 7,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/junit/JUnitDetecter.java",
        "class_name": "org.mockito.internal.junit.JUnitDetecter",
        "signature": "org.mockito.internal.junit.JUnitDetecter.hasJUnit()",
        "snippet": "    public boolean hasJUnit() {\n        return hasJUnit;\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/CollectCreatedMocks.java",
        "class_name": "org.mockito.internal.listeners.CollectCreatedMocks",
        "signature": "org.mockito.internal.listeners.CollectCreatedMocks.CollectCreatedMocks(java.util.List)",
        "snippet": "    public CollectCreatedMocks(List toBeFilled) {\n        this.toBeFilled = toBeFilled;\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/CollectCreatedMocks.java",
        "class_name": "org.mockito.internal.listeners.CollectCreatedMocks",
        "signature": "org.mockito.internal.listeners.CollectCreatedMocks.mockingStarted(java.lang.Object, java.lang.Class)",
        "snippet": "    public void mockingStarted(Object mock, Class classToMock) {\n        toBeFilled.add(mock);\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.NotifiedMethodInvocationReport(org.mockito.invocation.Invocation, java.lang.Object)",
        "snippet": "    public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n        this.invocation = invocation;\n        this.returnedValue = returnedValue;\n        this.throwable = null;\n    }",
        "begin_line": 29,
        "end_line": 33,
        "comment": "\n     * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n     *\n     *\n     * @param invocation Information on the method call\n     * @param returnedValue The value returned by the method invocation\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.NotifiedMethodInvocationReport(org.mockito.invocation.Invocation, java.lang.Throwable)",
        "snippet": "    public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n        this.invocation = invocation;\n        this.returnedValue = null;\n        this.throwable = throwable;\n    }",
        "begin_line": 42,
        "end_line": 46,
        "comment": "\n     * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n     *\n     *\n     * @param invocation Information on the method call\n     * @param throwable Tha throwable raised by the method invocation\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.getInvocation()",
        "snippet": "    public DescribedInvocation getInvocation() {\n        return invocation;\n    }",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.getReturnedValue()",
        "snippet": "    public Object getReturnedValue() {\n        return returnedValue;\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.getThrowable()",
        "snippet": "    public Throwable getThrowable() {\n        return throwable;\n    }",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.threwException()",
        "snippet": "    public boolean threwException() {\n        return throwable != null;\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.getLocationOfStubbing()",
        "snippet": "    public String getLocationOfStubbing() {\n        return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt().toString();\n    }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n\n        return areEqual(invocation, that.invocation) &&\n               areEqual(returnedValue, that.returnedValue) &&\n               areEqual(throwable, that.throwable);\n    }",
        "begin_line": 69,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java",
        "class_name": "org.mockito.internal.listeners.NotifiedMethodInvocationReport",
        "signature": "org.mockito.internal.listeners.NotifiedMethodInvocationReport.hashCode()",
        "snippet": "    public int hashCode() {\n        int result = invocation != null ? invocation.hashCode() : 0;\n        result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n        result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n        return result;\n    }",
        "begin_line": 80,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/listeners/MockingStartedListener.java",
        "class_name": "org.mockito.internal.listeners.MockingStartedListener",
        "signature": "org.mockito.internal.listeners.MockingStartedListener.mockingStarted(java.lang.Object, java.lang.Class)",
        "snippet": "    void mockingStarted(Object mock, Class classToMock);",
        "begin_line": 12,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Decamelizer.java",
        "class_name": "org.mockito.internal.util.Decamelizer",
        "signature": "org.mockito.internal.util.Decamelizer.decamelizeMatcher(java.lang.String)",
        "snippet": "    public static String decamelizeMatcher(String className) {\n        if (className.length() == 0) {\n            return \"<custom argument matcher>\";\n        }\n        \n        String decamelized = decamelizeClassName(className);\n        \n        if (decamelized.length() == 0) {\n            return \"<\" + className + \">\";\n        }\n        \n        return \"<\" + decamelized + \">\";\n    }",
        "begin_line": 15,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Decamelizer.java",
        "class_name": "org.mockito.internal.util.Decamelizer",
        "signature": "org.mockito.internal.util.Decamelizer.decamelizeClassName(java.lang.String)",
        "snippet": "    private static String decamelizeClassName(String className) {\n        Matcher match = CAPS.matcher(className);\n        StringBuilder deCameled = new StringBuilder();\n        while(match.find()) {\n            if (deCameled.length() == 0) {\n                deCameled.append(match.group());\n            } else {\n                deCameled.append(\" \");\n                deCameled.append(match.group().toLowerCase());\n            }\n        }\n        return deCameled.toString();\n    }",
        "begin_line": 29,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/StringJoiner.java",
        "class_name": "org.mockito.internal.util.StringJoiner",
        "signature": "org.mockito.internal.util.StringJoiner.join(java.lang.Object...)",
        "snippet": "    public static String join(Object ... linesToBreak) {\n        StringBuilder out = new StringBuilder(\"\\n\");\n        return join(out, linesToBreak);\n    }",
        "begin_line": 10,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/StringJoiner.java",
        "class_name": "org.mockito.internal.util.StringJoiner",
        "signature": "org.mockito.internal.util.StringJoiner.join(java.lang.StringBuilder, java.lang.Object[])",
        "snippet": "    private static String join(StringBuilder out, Object[] linesToBreak) {\n        for (Object line : linesToBreak) {\n            out.append(line.toString()).append(\"\\n\");\n        }\n        int lastBreak = out.lastIndexOf(\"\\n\");\n        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n    }",
        "begin_line": 15,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateType(java.lang.Class)",
        "snippet": "    public void validateType(Class classToMock) {\n        if (!mockUtil.isTypeMockable(classToMock)) {\n            new Reporter().cannotMockFinalClass(classToMock);\n        }\n    }",
        "begin_line": 19,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateExtraInterfaces(java.lang.Class, java.util.Collection<java.lang.Class>)",
        "snippet": "    public void validateExtraInterfaces(Class classToMock, Collection<Class> extraInterfaces) {\n        if (extraInterfaces == null) {\n            return;\n        }\n\n        for (Class i : extraInterfaces) {\n            if (classToMock == i) {\n                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n            }\n        }\n    }",
        "begin_line": 25,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateMockedType(java.lang.Class, java.lang.Object)",
        "snippet": "    public void validateMockedType(Class classToMock, Object spiedInstance) {\n        if (classToMock == null || spiedInstance == null) {\n            return;\n        }\n        if (!classToMock.equals(spiedInstance.getClass())) {\n            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n        }\n    }",
        "begin_line": 37,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateDelegatedInstance(java.lang.Class, java.lang.Object)",
        "snippet": "    public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n        if (classToMock == null || delegatedInstance == null) {\n            return;\n        }\n        if (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n            new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n        }\n    }",
        "begin_line": 46,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateSerializable(java.lang.Class, boolean)",
        "snippet": "    public void validateSerializable(Class classToMock, boolean serializable) {\n        // We can't catch all the errors with this piece of code\n        // Having a **superclass that do not implements Serializable** might fail as well when serialized\n        // Though it might prevent issues when mockito is mocking a class without superclass.\n        if(serializable\n                && !classToMock.isInterface()\n                && !(Serializable.class.isAssignableFrom(classToMock))\n                && Constructors.noArgConstructorOf(classToMock) == null\n                ) {\n            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n        }\n    }",
        "begin_line": 55,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockCreationValidator.java",
        "class_name": "org.mockito.internal.util.MockCreationValidator",
        "signature": "org.mockito.internal.util.MockCreationValidator.validateConstructorUse(boolean, org.mockito.mock.SerializableMode)",
        "snippet": "    public void validateConstructorUse(boolean usingConstructor, SerializableMode mode) {\n        if (usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS) {\n            new Reporter().usingConstructorWithFancySerializable(mode);\n        }\n    }",
        "begin_line": 68,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/DefaultMockingDetails.java",
        "class_name": "org.mockito.internal.util.DefaultMockingDetails",
        "signature": "org.mockito.internal.util.DefaultMockingDetails.DefaultMockingDetails(java.lang.Object, org.mockito.internal.util.MockUtil)",
        "snippet": "    public DefaultMockingDetails(Object toInspect, MockUtil delegate){\n        this.toInspect = toInspect;\n        this.delegate = delegate;\n    }",
        "begin_line": 20,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/DefaultMockingDetails.java",
        "class_name": "org.mockito.internal.util.DefaultMockingDetails",
        "signature": "org.mockito.internal.util.DefaultMockingDetails.isMock()",
        "snippet": "    public boolean isMock(){\n        return delegate.isMock( toInspect );\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "\n     * Find out whether the object is a mock.\n     * @return true if the object is a mock or a spy.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/DefaultMockingDetails.java",
        "class_name": "org.mockito.internal.util.DefaultMockingDetails",
        "signature": "org.mockito.internal.util.DefaultMockingDetails.isSpy()",
        "snippet": "    public boolean isSpy(){\n        return delegate.isSpy( toInspect );\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Find out whether the object is a spy.\n     * @return true if the object is a spy.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/DefaultMockingDetails.java",
        "class_name": "org.mockito.internal.util.DefaultMockingDetails",
        "signature": "org.mockito.internal.util.DefaultMockingDetails.getInvocations()",
        "snippet": "    public Collection<Invocation> getInvocations() {\n        return delegate.getMockHandler(toInspect).getInvocationContainer().getInvocations();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/SimpleMockitoLogger.java",
        "class_name": "org.mockito.internal.util.SimpleMockitoLogger",
        "signature": "org.mockito.internal.util.SimpleMockitoLogger.log(java.lang.Object)",
        "snippet": "    public void log(Object what) {\n//            can be uncommented when debugging this test\n//            super.log(what);\n        loggedInfo.append(what);\n    }",
        "begin_line": 11,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/SimpleMockitoLogger.java",
        "class_name": "org.mockito.internal.util.SimpleMockitoLogger",
        "signature": "org.mockito.internal.util.SimpleMockitoLogger.getLoggedInfo()",
        "snippet": "    public String getLoggedInfo() {\n        return loggedInfo.toString();\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Primitives.java",
        "class_name": "org.mockito.internal.util.Primitives",
        "signature": "org.mockito.internal.util.Primitives.primitiveTypeOf(java.lang.Class<T>)",
        "snippet": "    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n        if (clazz.isPrimitive()) {\n            return clazz;\n        }\n        return (Class<T>) PRIMITIVE_TYPES.get(clazz);\n    }",
        "begin_line": 28,
        "end_line": 33,
        "comment": "\n     * Returns the primitive type of the given class.\n     * <p/>\n     * The passed class can be any class : <code>boolean.class</code>, <code>Integer.class</code>\n     * in witch case this method will return <code>boolean.class</code>, even <code>SomeObject.class</code>\n     * in which case <code>null</code> will be returned.\n     *\n     * @param clazz The class from which primitive type has to be retrieved\n     * @param <T>   The type\n     * @return The primitive type if relevant, otherwise <code>null</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Primitives.java",
        "class_name": "org.mockito.internal.util.Primitives",
        "signature": "org.mockito.internal.util.Primitives.isPrimitiveOrWrapper(java.lang.Class<?>)",
        "snippet": "    public static boolean isPrimitiveOrWrapper(Class<?> type) {\n        return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.containsKey(type);\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     * Indicates if the given class is primitive type or a primitive wrapper.\n     *\n     * @param type The type to check\n     * @return <code>true</code> if primitive or wrapper, <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Primitives.java",
        "class_name": "org.mockito.internal.util.Primitives",
        "signature": "org.mockito.internal.util.Primitives.defaultValueForPrimitiveOrWrapper(java.lang.Class<T>)",
        "snippet": "    public static <T> T defaultValueForPrimitiveOrWrapper(Class<T> primitiveOrWrapperType) {\n        return (T) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.get(primitiveOrWrapperType);\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Returns the boxed default value for a primitive or a primitive wrapper.\n     *\n     * @param primitiveOrWrapperType The type to lookup the default value\n     * @return The boxed default values as defined in Java Language Specification,\n     *         <code>null</code> if the type is neither a primitive nor a wrapper\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockitoLogger.java",
        "class_name": "org.mockito.internal.util.MockitoLogger",
        "signature": "org.mockito.internal.util.MockitoLogger.log(java.lang.Object)",
        "snippet": "    void log(Object what);",
        "begin_line": 9,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/RemoveFirstLine.java",
        "class_name": "org.mockito.internal.util.RemoveFirstLine",
        "signature": "org.mockito.internal.util.RemoveFirstLine.of(java.lang.String)",
        "snippet": "    public String of(String text) {\n        return text.replaceFirst(\".*?\\n\", \"\");\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "\n     * @param text to have the first line removed\n     * @return less first line\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ObjectMethodsGuru.java",
        "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
        "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(java.lang.reflect.Method)",
        "snippet": "    public boolean isToString(Method method) {\n        return isToString(new DelegatingMethod(method));\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ObjectMethodsGuru.java",
        "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
        "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(org.mockito.internal.invocation.MockitoMethod)",
        "snippet": "    public boolean isToString(MockitoMethod method) {\n        return method.getReturnType() == String.class\n                && method.getParameterTypes().length == 0\n                && method.getName().equals(\"toString\");\n    }",
        "begin_line": 21,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ObjectMethodsGuru.java",
        "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
        "signature": "org.mockito.internal.util.ObjectMethodsGuru.isEqualsMethod(java.lang.reflect.Method)",
        "snippet": "    public boolean isEqualsMethod(Method method) {\n        return method.getName().equals(\"equals\")\n                && method.getParameterTypes().length == 1\n                && method.getParameterTypes()[0] == Object.class;\n    }",
        "begin_line": 27,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ObjectMethodsGuru.java",
        "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
        "signature": "org.mockito.internal.util.ObjectMethodsGuru.isHashCodeMethod(java.lang.reflect.Method)",
        "snippet": "    public boolean isHashCodeMethod(Method method) {\n        return method.getName().equals(\"hashCode\")\n                && method.getParameterTypes().length == 0;\n    }",
        "begin_line": 33,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ObjectMethodsGuru.java",
        "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
        "signature": "org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod(java.lang.reflect.Method)",
        "snippet": "    public boolean isCompareToMethod(Method method) {\n        return Comparable.class.isAssignableFrom(method.getDeclaringClass())\n                && method.getName().equals(\"compareTo\")\n                && method.getParameterTypes().length == 1\n                && method.getParameterTypes()[0] == method.getDeclaringClass();\n    }",
        "begin_line": 38,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Checks.java",
        "class_name": "org.mockito.internal.util.Checks",
        "signature": "org.mockito.internal.util.Checks.checkNotNull(T, java.lang.String)",
        "snippet": "    public static <T> T checkNotNull(T value, String checkedValue) {\n        if(value == null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }",
        "begin_line": 13,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Checks.java",
        "class_name": "org.mockito.internal.util.Checks",
        "signature": "org.mockito.internal.util.Checks.checkItemsNotNull(T, java.lang.String)",
        "snippet": "    public static <T extends Iterable> T checkItemsNotNull(T iterable, String checkedIterable) {\n        checkNotNull(iterable, checkedIterable);\n        for (Object item : iterable) {\n            checkNotNull(item, \"item in \" + checkedIterable);\n        }\n        return iterable;\n    }",
        "begin_line": 20,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Timer.java",
        "class_name": "org.mockito.internal.util.Timer",
        "signature": "org.mockito.internal.util.Timer.Timer(long)",
        "snippet": "    public Timer(long durationMillis) {\n        validateInput(durationMillis);\n        this.durationMillis = durationMillis;\n    }",
        "begin_line": 10,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Timer.java",
        "class_name": "org.mockito.internal.util.Timer",
        "signature": "org.mockito.internal.util.Timer.isCounting()",
        "snippet": "    public boolean isCounting() {\n        assert startTime != -1;\n        return System.currentTimeMillis() - startTime <= durationMillis;\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "\n     * Informs whether the timer is still counting down.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Timer.java",
        "class_name": "org.mockito.internal.util.Timer",
        "signature": "org.mockito.internal.util.Timer.start()",
        "snippet": "    public void start() {\n        startTime = System.currentTimeMillis();\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "\n     * Starts the timer count down.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Timer.java",
        "class_name": "org.mockito.internal.util.Timer",
        "signature": "org.mockito.internal.util.Timer.validateInput(long)",
        "snippet": "    private void validateInput(long durationMillis) {\n        if (durationMillis < 0) {\n            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n        }\n    }",
        "begin_line": 30,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/Timer.java",
        "class_name": "org.mockito.internal.util.Timer",
        "signature": "org.mockito.internal.util.Timer.duration()",
        "snippet": "    public long duration() {\n        return durationMillis;\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockNameImpl.java",
        "class_name": "org.mockito.internal.util.MockNameImpl",
        "signature": "org.mockito.internal.util.MockNameImpl.MockNameImpl(java.lang.String, java.lang.Class)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockNameImpl(String mockName, Class classToMock) {\n        if (mockName == null) {\n            this.mockName = toInstanceName(classToMock);\n            this.defaultName = true;\n        } else {\n            this.mockName = mockName;\n        }\n    }",
        "begin_line": 17,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockNameImpl.java",
        "class_name": "org.mockito.internal.util.MockNameImpl",
        "signature": "org.mockito.internal.util.MockNameImpl.MockNameImpl(java.lang.String)",
        "snippet": "    public MockNameImpl(String mockName) {\n        this.mockName = mockName;\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockNameImpl.java",
        "class_name": "org.mockito.internal.util.MockNameImpl",
        "signature": "org.mockito.internal.util.MockNameImpl.toInstanceName(java.lang.Class<?>)",
        "snippet": "    private static String toInstanceName(Class<?> clazz) {\n        String className = clazz.getSimpleName();\n        if (className.length() == 0) {\n            //it's an anonymous class, let's get name from the parent\n            className = clazz.getSuperclass().getSimpleName();\n        }\n        //lower case first letter\n        return className.substring(0, 1).toLowerCase() + className.substring(1);\n    }",
        "begin_line": 31,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockNameImpl.java",
        "class_name": "org.mockito.internal.util.MockNameImpl",
        "signature": "org.mockito.internal.util.MockNameImpl.isDefault()",
        "snippet": "    public boolean isDefault() {\n        return defaultName;\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockNameImpl.java",
        "class_name": "org.mockito.internal.util.MockNameImpl",
        "signature": "org.mockito.internal.util.MockNameImpl.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return mockName;\n    }",
        "begin_line": 45,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/ConsoleMockitoLogger.java",
        "class_name": "org.mockito.internal.util.ConsoleMockitoLogger",
        "signature": "org.mockito.internal.util.ConsoleMockitoLogger.log(java.lang.Object)",
        "snippet": "    public void log(Object what) {\n        System.out.println(what);\n    }",
        "begin_line": 12,
        "end_line": 14,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.isTypeMockable(java.lang.Class<?>)",
        "snippet": "    public boolean isTypeMockable(Class<?> type) {\n      return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.createMock(org.mockito.mock.MockCreationSettings<T>)",
        "snippet": "    public <T> T createMock(MockCreationSettings<T> settings) {\n        MockHandler mockHandler = new MockHandlerFactory().create(settings);\n\n        T mock = mockMaker.createMock(settings, mockHandler);\n\n        Object spiedInstance = settings.getSpiedInstance();\n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n\n        return mock;\n    }",
        "begin_line": 30,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.resetMock(T)",
        "snippet": "    public <T> void resetMock(T mock) {\n        InternalMockHandler oldHandler = (InternalMockHandler) getMockHandler(mock);\n        MockCreationSettings settings = oldHandler.getMockSettings();\n        MockHandler newHandler = new MockHandlerFactory().create(settings);\n\n        mockMaker.resetMock(mock, newHandler, settings);\n    }",
        "begin_line": 43,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.getMockHandler(T)",
        "snippet": "    public <T> InternalMockHandler<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            MockHandler handler = mockMaker.getHandler(mock);\n            return (InternalMockHandler) handler;\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }",
        "begin_line": 51,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.isMock(java.lang.Object)",
        "snippet": "    public boolean isMock(Object mock) {\n        // double check to avoid classes that have the same interfaces, could be great to have a custom mockito field in the proxy instead of relying on instance fields\n        return isMockitoMock(mock);\n    }",
        "begin_line": 64,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.isSpy(java.lang.Object)",
        "snippet": "    public boolean isSpy(Object mock) {\n        return isMockitoMock(mock) && getMockSettings(mock).getDefaultAnswer() == Mockito.CALLS_REAL_METHODS;\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
        "snippet": "    private <T> boolean isMockitoMock(T mock) {\n        return mockMaker.getHandler(mock) != null;\n    }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.getMockName(java.lang.Object)",
        "snippet": "    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.maybeRedefineMockName(java.lang.Object, java.lang.String)",
        "snippet": "    public void maybeRedefineMockName(Object mock, String newName) {\n        MockName mockName = getMockName(mock);\n        //TODO SF hacky...\n        if (mockName.isDefault() && getMockHandler(mock).getMockSettings() instanceof CreationSettings) {\n            ((CreationSettings) getMockHandler(mock).getMockSettings()).setMockName(new MockNameImpl(newName));\n        }\n    }",
        "begin_line": 81,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/MockUtil.java",
        "class_name": "org.mockito.internal.util.MockUtil",
        "signature": "org.mockito.internal.util.MockUtil.getMockSettings(java.lang.Object)",
        "snippet": "    public MockCreationSettings getMockSettings(Object mock) {\n        return getMockHandler(mock).getMockSettings();\n    }",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/ArrayUtils.java",
        "class_name": "org.mockito.internal.util.collections.ArrayUtils",
        "signature": "org.mockito.internal.util.collections.ArrayUtils.isEmpty(T[])",
        "snippet": "    public <T> boolean isEmpty(T[] array) {\n        return array == null || array.length == 0;\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/Iterables.java",
        "class_name": "org.mockito.internal.util.collections.Iterables",
        "signature": "org.mockito.internal.util.collections.Iterables.toIterable(java.util.Enumeration<T>)",
        "snippet": "    public static <T> Iterable<T> toIterable(Enumeration<T> in) {\n        List<T> out = new LinkedList<T>();\n        while(in.hasMoreElements()) {\n            out.add(in.nextElement());\n        }\n        return out;\n    }",
        "begin_line": 15,
        "end_line": 21,
        "comment": "\n     * Converts enumeration into iterable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/Sets.java",
        "class_name": "org.mockito.internal.util.collections.Sets",
        "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(java.lang.Iterable<java.lang.Object>)",
        "snippet": "    public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/Sets.java",
        "class_name": "org.mockito.internal.util.collections.Sets",
        "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(java.lang.Object...)",
        "snippet": "    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/Sets.java",
        "class_name": "org.mockito.internal.util.collections.Sets",
        "signature": "org.mockito.internal.util.collections.Sets.newIdentitySet()",
        "snippet": "    public static IdentitySet newIdentitySet() {\n        return new IdentitySet();\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/Sets.java",
        "class_name": "org.mockito.internal.util.collections.Sets",
        "signature": "org.mockito.internal.util.collections.Sets.newSet(T...)",
        "snippet": "    public static <T> Set<T> newSet(T ... elements) {\n        if (elements == null) {\n            throw new IllegalArgumentException(\"Expected an array of elements (or empty array) but received a null.\");\n        }\n        return new LinkedHashSet<T>(asList(elements));\n    }",
        "begin_line": 27,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.iterator()",
        "snippet": "    public Iterator<Object> iterator() {\n        return new Iterator<Object>() {\n            private final Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            public Object next() {\n                return iterator.next().get();\n            }\n\n            public void remove() {\n                iterator.remove();\n            }\n        };\n    }",
        "begin_line": 36,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.Anonymous-f02ce482-6f1b-4919-b89a-14ada9848b3d.hasNext()",
        "snippet": "            public boolean hasNext() {\n                return iterator.hasNext();\n            }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.Anonymous-e2ed5a0b-b325-4f5e-906f-88f45643c1a6.next()",
        "snippet": "            public Object next() {\n                return iterator.next().get();\n            }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.Anonymous-01f77d52-09a5-42f0-9989-df7d806c177f.remove()",
        "snippet": "            public void remove() {\n                iterator.remove();\n            }",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.size()",
        "snippet": "    public int size() {\n        return backingHashSet.size();\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return backingHashSet.isEmpty();\n    }",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.contains(java.lang.Object)",
        "snippet": "    public boolean contains(Object mock) {\n        return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.add(java.lang.Object)",
        "snippet": "    public boolean add(Object mock) {\n        return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.remove(java.lang.Object)",
        "snippet": "    public boolean remove(Object mock) {\n        return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));\n    }",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.clear()",
        "snippet": "    public void clear() {\n        backingHashSet.clear();\n    }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.clone()",
        "snippet": "    @Override public Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n    }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.equals(java.lang.Object)",
        "snippet": "    @Override public boolean equals(Object o) {\n        if (!(o instanceof HashCodeAndEqualsSafeSet)) {\n            return false;\n        }\n        HashCodeAndEqualsSafeSet that = (HashCodeAndEqualsSafeSet) o;\n        return backingHashSet.equals(that.backingHashSet);\n    }",
        "begin_line": 82,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.hashCode()",
        "snippet": "    @Override public int hashCode() {\n        return backingHashSet.hashCode();\n    }",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toArray()",
        "snippet": "    public Object[] toArray() {\n        return unwrapTo(new Object[size()]);\n    }",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.unwrapTo(T[])",
        "snippet": "    private <T> T[] unwrapTo(T[] array) {\n        Iterator<Object> iterator = iterator();\n        for (int i = 0, objectsLength = array.length; i < objectsLength; i++) {\n            if (iterator.hasNext()) {\n                array[i] = (T) iterator.next();\n            }\n        }\n        return array;\n    }",
        "begin_line": 98,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toArray(T[])",
        "snippet": "    public <T> T[] toArray(T[] typedArray) {\n        T[] array = typedArray.length >= size() ? typedArray :\n                (T[]) newInstance(typedArray.getClass().getComponentType(), size());\n        return unwrapTo(array);\n    }",
        "begin_line": 109,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.removeAll(java.util.Collection<?>)",
        "snippet": "    public boolean removeAll(Collection<?> mocks) {\n        return backingHashSet.removeAll(asWrappedMocks(mocks));\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.containsAll(java.util.Collection<?>)",
        "snippet": "    public boolean containsAll(Collection<?> mocks) {\n        return backingHashSet.containsAll(asWrappedMocks(mocks));\n    }",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.addAll(java.util.Collection<?>)",
        "snippet": "    public boolean addAll(Collection<?> mocks) {\n        return backingHashSet.addAll(asWrappedMocks(mocks));\n    }",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.retainAll(java.util.Collection<?>)",
        "snippet": "    public boolean retainAll(Collection<?> mocks) {\n        return backingHashSet.retainAll(asWrappedMocks(mocks));\n    }",
        "begin_line": 127,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.asWrappedMocks(java.util.Collection<?>)",
        "snippet": "    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n        for (Object mock : mocks) {\n            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n        }\n        return hashSet;\n    }",
        "begin_line": 131,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.toString()",
        "snippet": "    @Override public String toString() {\n        return backingHashSet.toString();\n    }",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(java.lang.Object...)",
        "snippet": "    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n        return of(Arrays.asList(mocks));\n    }",
        "begin_line": 145,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(java.lang.Iterable<java.lang.Object>)",
        "snippet": "    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n        if (objects != null) {\n            for (Object mock : objects) {\n                hashCodeAndEqualsSafeSet.add(mock);\n            }\n        }\n        return hashCodeAndEqualsSafeSet;\n    }",
        "begin_line": 149,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/ListUtil.java",
        "class_name": "org.mockito.internal.util.collections.ListUtil",
        "signature": "org.mockito.internal.util.collections.ListUtil.filter(java.util.Collection<T>, org.mockito.internal.util.collections.ListUtil.Filter<T>)",
        "snippet": "    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n        LinkedList<T> filtered = new LinkedList<T>();\n        for (T t : collection) {\n            if (!filter.isOut(t)) {\n                filtered.add(t);\n            }\n        }\n        return filtered;\n    }",
        "begin_line": 13,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/ListUtil.java",
        "class_name": "org.mockito.internal.util.collections.ListUtil",
        "signature": "org.mockito.internal.util.collections.ListUtil.Filter.isOut(T)",
        "snippet": "        boolean isOut(T object);",
        "begin_line": 24,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.HashCodeAndEqualsMockWrapper(java.lang.Object)",
        "snippet": "    public HashCodeAndEqualsMockWrapper(Object mockInstance) {\n        this.mockInstance = mockInstance;\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.get()",
        "snippet": "    public Object get() {\n        return mockInstance;\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof HashCodeAndEqualsMockWrapper)) return false;\n\n        HashCodeAndEqualsMockWrapper that = (HashCodeAndEqualsMockWrapper) o;\n\n        return mockInstance == that.mockInstance;\n    }",
        "begin_line": 39,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        return System.identityHashCode(mockInstance);\n    }",
        "begin_line": 49,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.of(java.lang.Object)",
        "snippet": "    public static HashCodeAndEqualsMockWrapper of(Object mock) {\n        return new HashCodeAndEqualsMockWrapper(mock);\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.toString()",
        "snippet": "    @Override public String toString() {\n        MockUtil mockUtil = new MockUtil();\n        return \"HashCodeAndEqualsMockWrapper{\" +\n                \"mockInstance=\" + (mockUtil.isMock(mockInstance) ? mockUtil.getMockName(mockInstance) : typeInstanceString()) +\n                '}';\n    }",
        "begin_line": 58,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java",
        "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper",
        "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsMockWrapper.typeInstanceString()",
        "snippet": "    private String typeInstanceString() {\n        return mockInstance.getClass().getSimpleName() + \"(\" + System.identityHashCode(mockInstance) + \")\";\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/IdentitySet.java",
        "class_name": "org.mockito.internal.util.collections.IdentitySet",
        "signature": "org.mockito.internal.util.collections.IdentitySet.contains(java.lang.Object)",
        "snippet": "    public boolean contains(Object o) {\n        for(Object existing:list) {\n            if (existing == o) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 14,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/collections/IdentitySet.java",
        "class_name": "org.mockito.internal.util.collections.IdentitySet",
        "signature": "org.mockito.internal.util.collections.IdentitySet.add(java.lang.Object)",
        "snippet": "    public void add(Object o) {\n        list.add(o);        \n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/junit/JUnitFailureHacker.java",
        "class_name": "org.mockito.internal.util.junit.JUnitFailureHacker",
        "signature": "org.mockito.internal.util.junit.JUnitFailureHacker.appendWarnings(org.junit.runner.notification.Failure, java.lang.String)",
        "snippet": "    public void appendWarnings(Failure failure, String warnings) {\n        if (isEmpty(warnings)) {\n            return;\n        }\n        //TODO: this has to protect the use in case jUnit changes and this internal state logic fails\n        Throwable throwable = (Throwable) Whitebox.getInternalState(failure, \"fThrownException\");\n\n        String newMessage = \"contains both: actual test failure *and* Mockito warnings.\\n\" +\n                warnings + \"\\n *** The actual failure is because of: ***\\n\";\n\n        ExceptionIncludingMockitoWarnings e = new ExceptionIncludingMockitoWarnings(newMessage, throwable);\n        e.setStackTrace(throwable.getStackTrace());\n        Whitebox.setInternalState(failure, \"fThrownException\", e);\n    }",
        "begin_line": 13,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/junit/JUnitFailureHacker.java",
        "class_name": "org.mockito.internal.util.junit.JUnitFailureHacker",
        "signature": "org.mockito.internal.util.junit.JUnitFailureHacker.isEmpty(java.lang.String)",
        "snippet": "    private boolean isEmpty(String warnings) {\n        return warnings == null || \"\".equals(warnings); // isEmpty() is in JDK 6+ \n    }   ",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/io/IOUtil.java",
        "class_name": "org.mockito.internal.util.io.IOUtil",
        "signature": "org.mockito.internal.util.io.IOUtil.writeText(java.lang.String, java.io.File)",
        "snippet": "    public static void writeText(String text, File output) {\n        PrintWriter pw = null;\n        try {\n            pw = new PrintWriter(new FileWriter(output));\n            pw.write(text);\n        } catch (Exception e) {\n            throw new MockitoException(\"Problems writing text to file: \" + output, e);\n        } finally {\n            close(pw);\n        }\n    }",
        "begin_line": 18,
        "end_line": 28,
        "comment": "\n     * Writes text to file\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/io/IOUtil.java",
        "class_name": "org.mockito.internal.util.io.IOUtil",
        "signature": "org.mockito.internal.util.io.IOUtil.readLines(java.io.InputStream)",
        "snippet": "    public static Collection<String> readLines(InputStream is) {\n        List<String> out = new LinkedList<String>();\n        BufferedReader r = new BufferedReader(new InputStreamReader(is));\n        String line;\n        try {\n            while((line = r.readLine()) != null) {\n                out.add(line);\n            }\n        } catch (IOException e) {\n            throw new MockitoException(\"Problems reading from: \" + is, e);\n        }\n        return out;\n    }",
        "begin_line": 30,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/io/IOUtil.java",
        "class_name": "org.mockito.internal.util.io.IOUtil",
        "signature": "org.mockito.internal.util.io.IOUtil.closeQuietly(java.io.Closeable)",
        "snippet": "    public static void closeQuietly(Closeable closeable) {\n        try {\n            close(closeable);\n        } catch (MockitoException ignored) {\n            //ignore, for backwards compatibility\n        }\n    }",
        "begin_line": 49,
        "end_line": 55,
        "comment": "\n     * Closes the target. Does nothing when target is null. Is silent.\n     *\n     * @param closeable the target, may be null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/io/IOUtil.java",
        "class_name": "org.mockito.internal.util.io.IOUtil",
        "signature": "org.mockito.internal.util.io.IOUtil.close(java.io.Closeable)",
        "snippet": "    public static void close(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                throw new MockitoException(\"Problems closing stream: \" + closeable, e);\n            }\n        }\n    }",
        "begin_line": 62,
        "end_line": 70,
        "comment": "\n     * Closes the target. Does nothing when target is null. Is not silent and exceptions are rethrown.\n     *\n     * @param closeable the target, may be null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Whitebox.java",
        "class_name": "org.mockito.internal.util.reflection.Whitebox",
        "signature": "org.mockito.internal.util.reflection.Whitebox.getInternalState(java.lang.Object, java.lang.String)",
        "snippet": "    public static Object getInternalState(Object target, String field) {\n        Class<?> c = target.getClass();\n        try {\n            Field f = getFieldFromHierarchy(c, field);\n            f.setAccessible(true);\n            return f.get(target);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to get internal state on a private field. Please report to mockito mailing list.\", e);\n        }\n    }",
        "begin_line": 11,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Whitebox.java",
        "class_name": "org.mockito.internal.util.reflection.Whitebox",
        "signature": "org.mockito.internal.util.reflection.Whitebox.setInternalState(java.lang.Object, java.lang.String, java.lang.Object)",
        "snippet": "    public static void setInternalState(Object target, String field, Object value) {\n        Class<?> c = target.getClass();\n        try {\n            Field f = getFieldFromHierarchy(c, field);\n            f.setAccessible(true);\n            f.set(target, value);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to set internal state on a private field. Please report to mockito mailing list.\", e);\n        }\n    }",
        "begin_line": 22,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Whitebox.java",
        "class_name": "org.mockito.internal.util.reflection.Whitebox",
        "signature": "org.mockito.internal.util.reflection.Whitebox.getFieldFromHierarchy(java.lang.Class<?>, java.lang.String)",
        "snippet": "    private static Field getFieldFromHierarchy(Class<?> clazz, String field) {\n        Field f = getField(clazz, field);\n        while (f == null && clazz != Object.class) {\n            clazz = clazz.getSuperclass();\n            f = getField(clazz, field);\n        }\n        if (f == null) {\n            throw new RuntimeException(\n                    \"You want me to get this field: '\" + field +\n                    \"' on this class: '\" + clazz.getSimpleName() + \n                    \"' but this field is not declared withing hierarchy of this class!\");\n        }\n        return f;\n    }",
        "begin_line": 33,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Whitebox.java",
        "class_name": "org.mockito.internal.util.reflection.Whitebox",
        "signature": "org.mockito.internal.util.reflection.Whitebox.getField(java.lang.Class<?>, java.lang.String)",
        "snippet": "    private static Field getField(Class<?> clazz, String field) {\n        try {\n            return clazz.getDeclaredField(field);\n        } catch (NoSuchFieldException e) {\n            return null;\n        }\n    }",
        "begin_line": 48,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldSetter.java",
        "class_name": "org.mockito.internal.util.reflection.FieldSetter",
        "signature": "org.mockito.internal.util.reflection.FieldSetter.FieldSetter(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    public FieldSetter(Object target, Field field) {\n        this.target = target;\n        this.field = field;\n    }",
        "begin_line": 14,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldSetter.java",
        "class_name": "org.mockito.internal.util.reflection.FieldSetter",
        "signature": "org.mockito.internal.util.reflection.FieldSetter.set(java.lang.Object)",
        "snippet": "    public void set(Object value) {\n        AccessibilityChanger changer = new AccessibilityChanger();\n        changer.enableAccess(field);\n        try {\n            field.set(target, value);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Access not authorized on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"'\", e);\n        } catch (IllegalArgumentException e) {\n            throw new RuntimeException(\"Wrong argument on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"', \\n\" +\n                    \"reason : \" + e.getMessage(), e);\n        }\n        changer.safelyDisableAccess(field);\n    }",
        "begin_line": 19,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/AccessibilityChanger.java",
        "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
        "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.safelyDisableAccess(java.lang.reflect.AccessibleObject)",
        "snippet": "    public void safelyDisableAccess(AccessibleObject accessibleObject) {\n        assert wasAccessible != null : \"accessibility info shall not be null\";\n        try {\n            accessibleObject.setAccessible(wasAccessible);\n        } catch (Throwable t) {\n            //ignore\n        }\n    }",
        "begin_line": 16,
        "end_line": 23,
        "comment": "\n     * safely disables access\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/AccessibilityChanger.java",
        "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
        "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess(java.lang.reflect.AccessibleObject)",
        "snippet": "    public void enableAccess(AccessibleObject accessibleObject) {\n        wasAccessible = accessibleObject.isAccessible();\n        accessibleObject.setAccessible(true);\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": "\n     * changes the accessibleObject accessibility and returns true if accessibility was changed\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/BeanPropertySetter.java",
        "class_name": "org.mockito.internal.util.reflection.BeanPropertySetter",
        "signature": "org.mockito.internal.util.reflection.BeanPropertySetter.BeanPropertySetter(java.lang.Object, java.lang.reflect.Field, boolean)",
        "snippet": "    public BeanPropertySetter(final Object target, final Field propertyField, boolean reportNoSetterFound) {\n        this.field = propertyField;\n        this.target = target;\n        this.reportNoSetterFound = reportNoSetterFound;\n    }",
        "begin_line": 29,
        "end_line": 33,
        "comment": "\n     * New BeanPropertySetter\n     * @param target The target on which the setter must be invoked\n     * @param propertyField The field that should be accessed with the setter\n     * @param reportNoSetterFound Allow the set method to raise an Exception if the setter cannot be found\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/BeanPropertySetter.java",
        "class_name": "org.mockito.internal.util.reflection.BeanPropertySetter",
        "signature": "org.mockito.internal.util.reflection.BeanPropertySetter.BeanPropertySetter(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    public BeanPropertySetter(final Object target, final Field propertyField) {\n        this(target, propertyField, false);\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * New BeanPropertySetter that don't report failure\n     * @param target The target on which the setter must be invoked\n     * @param propertyField The propertyField that must be accessed through a setter\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/BeanPropertySetter.java",
        "class_name": "org.mockito.internal.util.reflection.BeanPropertySetter",
        "signature": "org.mockito.internal.util.reflection.BeanPropertySetter.set(java.lang.Object)",
        "snippet": "    public boolean set(final Object value) {\n\n        AccessibilityChanger changer = new AccessibilityChanger();\n        Method writeMethod = null;\n        try {\n            writeMethod = target.getClass().getMethod(setterName(field.getName()), field.getType());\n\n            changer.enableAccess(writeMethod);\n            writeMethod.invoke(target, value);\n            return true;\n        } catch (InvocationTargetException e) {\n            throw new RuntimeException(\"Setter '\" + writeMethod + \"' of '\" + target + \"' with value '\" + value + \"' threw exception : '\" + e.getTargetException() + \"'\", e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Access not authorized on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"'\", e);\n        } catch (NoSuchMethodException e) {\n            reportNoSetterFound();\n        } finally {\n            if(writeMethod != null) {\n                changer.safelyDisableAccess(writeMethod);\n            }\n        }\n\n        reportNoSetterFound();\n        return false;\n    }",
        "begin_line": 51,
        "end_line": 75,
        "comment": "\n     * Set the value to the property represented by this {@link BeanPropertySetter}\n     * @param value the new value to pass to the property setter\n     * @return <code>true</code> if the value has been injected, <code>false</code> otherwise\n     * @throws RuntimeException Can be thrown if the setter threw an exception, if the setter is not accessible\n     *          or, if <code>reportNoSetterFound</code> and setter could not be found.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/BeanPropertySetter.java",
        "class_name": "org.mockito.internal.util.reflection.BeanPropertySetter",
        "signature": "org.mockito.internal.util.reflection.BeanPropertySetter.setterName(java.lang.String)",
        "snippet": "    private String setterName(String fieldName) {\n        return new StringBuilder(SET_PREFIX)\n                .append(fieldName.substring(0, 1).toUpperCase(Locale.ENGLISH))\n                .append(fieldName.substring(1))\n                .toString();\n    }",
        "begin_line": 85,
        "end_line": 90,
        "comment": "\n     * Retrieve the setter name from the field name.\n     *\n     * <p>Implementation is based on the code of {@link java.beans.Introspector}.</p>\n     *\n     * @param fieldName the Field name\n     * @return Setter name.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/BeanPropertySetter.java",
        "class_name": "org.mockito.internal.util.reflection.BeanPropertySetter",
        "signature": "org.mockito.internal.util.reflection.BeanPropertySetter.reportNoSetterFound()",
        "snippet": "    private void reportNoSetterFound() {\n        if(reportNoSetterFound) {\n            throw new RuntimeException(\"Problems setting value on object: [\" + target + \"] for property : [\" + field.getName() + \"], setter not found\");\n        }\n    }",
        "begin_line": 92,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMaster.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMaster",
        "signature": "org.mockito.internal.util.reflection.GenericMaster.getGenericType(java.lang.reflect.Field)",
        "snippet": "    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                //in case of nested generics we don't go deep\n                return (Class) ((ParameterizedType) actual).getRawType();\n            }\n        }\n        \n        return Object.class;\n    }",
        "begin_line": 19,
        "end_line": 32,
        "comment": "\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.allDeclaredFieldsOf(java.lang.Object)",
        "snippet": "    public static InstanceFields allDeclaredFieldsOf(Object instance) {\n        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n        for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));\n        }\n        return new InstanceFields(instance, instanceFields);\n    }",
        "begin_line": 29,
        "end_line": 35,
        "comment": "\n     * Instance fields declared in the class and superclasses of the given instance.\n     *\n     * @param instance Instance from which declared fields will be retrieved.\n     * @return InstanceFields of this object instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.declaredFieldsOf(java.lang.Object)",
        "snippet": "    public static InstanceFields declaredFieldsOf(Object instance) {\n        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));\n        return new InstanceFields(instance, instanceFields);\n    }",
        "begin_line": 43,
        "end_line": 47,
        "comment": "\n     * Instance fields declared in the class of the given instance.\n     *\n     * @param instance Instance from which declared fields will be retrieved.\n     * @return InstanceFields of this object instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.instanceFieldsIn(java.lang.Object, java.lang.reflect.Field[])",
        "snippet": "    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {\n        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n        for (Field field : fields) {\n            InstanceField instanceField = new InstanceField(field, instance);\n            instanceDeclaredFields.add(instanceField);\n        }\n        return instanceDeclaredFields;\n    }",
        "begin_line": 49,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.annotatedBy(java.lang.Class<? extends java.lang.annotation.Annotation>...)",
        "snippet": "    public static Filter<InstanceField> annotatedBy(final Class<? extends Annotation>... annotations) {\n        return new Filter<InstanceField>() {\n            public boolean isOut(InstanceField instanceField) {\n                Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n\n                for (Class<? extends Annotation> annotation : annotations) {\n                    if(instanceField.isAnnotatedBy(annotation)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n    }",
        "begin_line": 64,
        "end_line": 77,
        "comment": "\n     * Accept fields annotated by the given annotations.\n     *\n     * @param annotations Annotation types to check.\n     * @return The filter.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.Anonymous-5d6158ae-7b73-4dda-ace1-a42d186cb85a.isOut(org.mockito.internal.util.reflection.InstanceField)",
        "snippet": "            public boolean isOut(InstanceField instanceField) {\n                Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n\n                for (Class<? extends Annotation> annotation : annotations) {\n                    if(instanceField.isAnnotatedBy(annotation)) {\n                        return false;\n                    }\n                }\n                return true;\n            }",
        "begin_line": 66,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.nullField()",
        "snippet": "    private static Filter<InstanceField> nullField() {\n        return new Filter<InstanceField>() {\n            public boolean isOut(InstanceField instanceField) {\n                return instanceField.isNull();\n            }\n        };\n    }",
        "begin_line": 84,
        "end_line": 90,
        "comment": "\n     * Accept fields with non null value.\n     *\n     * @return The filter.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.Anonymous-02effa61-de15-4116-9bba-a8f1f5c620c3.isOut(org.mockito.internal.util.reflection.InstanceField)",
        "snippet": "            public boolean isOut(InstanceField instanceField) {\n                return instanceField.isNull();\n            }",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.InstanceFields(java.lang.Object, java.util.List<org.mockito.internal.util.reflection.InstanceField>)",
        "snippet": "        public InstanceFields(Object instance, List<InstanceField> instanceFields) {\n            this.instance = instance;\n            this.instanceFields = instanceFields;\n        }",
        "begin_line": 97,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.filter(org.mockito.internal.util.collections.ListUtil.Filter<org.mockito.internal.util.reflection.InstanceField>)",
        "snippet": "        public InstanceFields filter(Filter<InstanceField> withFilter) {\n            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));\n        }",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.notNull()",
        "snippet": "        public InstanceFields notNull() {\n            return filter(nullField());\n        }",
        "begin_line": 106,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.instanceFields()",
        "snippet": "        public List<InstanceField> instanceFields() {\n            return new ArrayList<InstanceField>(instanceFields);\n        }",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.assignedValues()",
        "snippet": "        public List<Object> assignedValues() {\n            List<Object> values = new ArrayList<Object>(instanceFields.size());\n            for (InstanceField instanceField : instanceFields) {\n                values.add(instanceField.read());\n            }\n            return values;\n        }",
        "begin_line": 114,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Fields.java",
        "class_name": "org.mockito.internal.util.reflection.Fields",
        "signature": "org.mockito.internal.util.reflection.Fields.InstanceFields.names()",
        "snippet": "        public List<String> names() {\n            List<String> fieldNames = new ArrayList<String>(instanceFields.size());\n            for (InstanceField instanceField : instanceFields) {\n                fieldNames.add(instanceField.name());\n            }\n            return fieldNames;\n        }",
        "begin_line": 122,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/SuperTypesLastSorter.java",
        "class_name": "org.mockito.internal.util.reflection.SuperTypesLastSorter",
        "signature": "org.mockito.internal.util.reflection.SuperTypesLastSorter.sort(java.util.Collection<? extends java.lang.reflect.Field>)",
        "snippet": "    public List<Field> sort(Collection<? extends Field> unsortedFields)\n    {\n        List<Field> fields = new ArrayList<Field>(unsortedFields);\n\n        Collections.sort(fields, compareFieldsByName);\n\n        int i = 0;\n\n        while (i < fields.size() - 1) {\n            Field f = fields.get(i);\n            Class<?> ft = f.getType();\n            int newPos = i;\n            for (int j = i + 1; j < fields.size(); j++) {\n                Class<?> t = fields.get(j).getType();\n\n                if (ft != t && ft.isAssignableFrom(t)) {\n                    newPos = j;\n                }\n            }\n\n            if (newPos == i) {\n                i++;\n            } else {\n                fields.remove(i);\n                fields.add(newPos, f);\n            }\n        }\n\n        return fields;\n    }",
        "begin_line": 25,
        "end_line": 54,
        "comment": "\n     * Return a new collection with the fields sorted first by name,\n     * then with any fields moved after their supertypes.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/SuperTypesLastSorter.java",
        "class_name": "org.mockito.internal.util.reflection.SuperTypesLastSorter",
        "signature": "org.mockito.internal.util.reflection.SuperTypesLastSorter.Anonymous-b05accb0-1e6c-46ec-b3e0-652064238040.compare(java.lang.reflect.Field, java.lang.reflect.Field)",
        "snippet": "        public int compare(Field o1, Field o2)\n        {\n            return o1.getName().compareTo(o2.getName());\n        }",
        "begin_line": 59,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldReader.java",
        "class_name": "org.mockito.internal.util.reflection.FieldReader",
        "signature": "org.mockito.internal.util.reflection.FieldReader.FieldReader(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    public FieldReader(Object target, Field field) {\n        this.target = target;\n        this.field = field;\n        changer.enableAccess(field);\n    }",
        "begin_line": 17,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldReader.java",
        "class_name": "org.mockito.internal.util.reflection.FieldReader",
        "signature": "org.mockito.internal.util.reflection.FieldReader.isNull()",
        "snippet": "    public boolean isNull() {\n            return read() == null;\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldReader.java",
        "class_name": "org.mockito.internal.util.reflection.FieldReader",
        "signature": "org.mockito.internal.util.reflection.FieldReader.read()",
        "snippet": "    public Object read() {\n        try {\n            return field.get(target);\n        } catch (Exception e) {\n            throw new MockitoException(\"Cannot read state from field: \" + field + \", on instance: \" + target);\n        }\n    }",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/Constructors.java",
        "class_name": "org.mockito.internal.util.reflection.Constructors",
        "signature": "org.mockito.internal.util.reflection.Constructors.noArgConstructorOf(java.lang.Class<?>)",
        "snippet": "    public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {\n        try {\n            return classToMock.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }",
        "begin_line": 13,
        "end_line": 19,
        "comment": "\n     * Returns the no arg constructor of the type if any.\n     *\n     * @param classToMock The type to look for a no-arg constructor\n     * @return The no-arg constructor or null if none is declared.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.registerTypeVariablesOn(java.lang.reflect.Type)",
        "snippet": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }",
        "begin_line": 66,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.registerTypeParametersOn(java.lang.reflect.TypeVariable[])",
        "snippet": "    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n        for (TypeVariable type : typeParameters) {\n            registerTypeVariableIfNotPresent(type);\n        }\n    }",
        "begin_line": 86,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.registerTypeVariableIfNotPresent(java.lang.reflect.TypeVariable)",
        "snippet": "    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }",
        "begin_line": 92,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.boundsOf(java.lang.reflect.TypeVariable)",
        "snippet": "    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }",
        "begin_line": 104,
        "end_line": 109,
        "comment": "\n     * @param typeParameter The TypeVariable parameter\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.boundsOf(java.lang.reflect.WildcardType)",
        "snippet": "    private BoundedType boundsOf(WildcardType wildCard) {\n        /*\n         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n         */\n\n        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n        }\n\n        return wildCardBoundedType;\n    }",
        "begin_line": 116,
        "end_line": 129,
        "comment": "\n     * @param wildCard The WildCard type\n     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n     *         then retrieve BoundedType of this TypeVariable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.rawType()",
        "snippet": "    public abstract Class<?> rawType();",
        "begin_line": 136,
        "end_line": 136,
        "comment": "\n     * @return Raw type of the current instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.extraInterfaces()",
        "snippet": "    public List<Type> extraInterfaces() {\n        return Collections.emptyList();\n    }",
        "begin_line": 143,
        "end_line": 145,
        "comment": "\n     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.rawExtraInterfaces()",
        "snippet": "    public Class<?>[] rawExtraInterfaces() {\n        return new Class[0];\n    }",
        "begin_line": 150,
        "end_line": 152,
        "comment": "\n     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.hasRawExtraInterfaces()",
        "snippet": "    public boolean hasRawExtraInterfaces() {\n        return rawExtraInterfaces().length > 0;\n    }",
        "begin_line": 157,
        "end_line": 159,
        "comment": "\n     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.actualTypeArguments()",
        "snippet": "    public Map<TypeVariable, Type> actualTypeArguments() {\n        TypeVariable[] typeParameters = rawType().getTypeParameters();\n        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n\n        for (TypeVariable typeParameter : typeParameters) {\n\n            Type actualType = getActualTypeArgumentFor(typeParameter);\n\n            actualTypeArguments.put(typeParameter, actualType);\n            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n        }\n\n        return actualTypeArguments;\n    }",
        "begin_line": 166,
        "end_line": 179,
        "comment": "\n     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(java.lang.reflect.TypeVariable)",
        "snippet": "    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }",
        "begin_line": 181,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.resolveGenericReturnType(java.lang.reflect.Method)",
        "snippet": "    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }",
        "begin_line": 199,
        "end_line": 214,
        "comment": "\n     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n     *\n     * @param method Method to resolve the return type.\n     * @return {@link GenericMetadataSupport} representing this generic return type.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom(java.lang.reflect.Type)",
        "snippet": "    public static GenericMetadataSupport inferFrom(Type type) {\n        Checks.checkNotNull(type, \"type\");\n        if (type instanceof Class) {\n            return new FromClassGenericMetadataSupport((Class<?>) type);\n        }\n        if (type instanceof ParameterizedType) {\n            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n        }\n\n        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n    }",
        "begin_line": 228,
        "end_line": 238,
        "comment": "\n     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n     *\n     * <p>\n     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n     *     it'll throw a {@link MockitoException}.\n     * </p>\n     *\n     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n     * @return The new {@link GenericMetadataSupport}.\n     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromClassGenericMetadataSupport.FromClassGenericMetadataSupport(java.lang.Class<?>)",
        "snippet": "        public FromClassGenericMetadataSupport(Class<?> clazz) {\n            this.clazz = clazz;\n\n            for (Class currentExploredClass = clazz;\n                 currentExploredClass != null && currentExploredClass != Object.class;\n                 currentExploredClass = superClassOf(currentExploredClass)\n                ) {\n                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n            }\n        }",
        "begin_line": 254,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromClassGenericMetadataSupport.superClassOf(java.lang.Class)",
        "snippet": "        private Class superClassOf(Class currentExploredClass) {\n            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n            if (genericSuperclass instanceof ParameterizedType) {\n                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n                return (Class) rawType;\n            }\n            return (Class) genericSuperclass;\n        }",
        "begin_line": 265,
        "end_line": 272,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromClassGenericMetadataSupport.readActualTypeParametersOnDeclaringClass(java.lang.Class<?>)",
        "snippet": "        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n            registerTypeParametersOn(clazz.getTypeParameters());\n            registerTypeVariablesOn(clazz.getGenericSuperclass());\n            for (Type genericInterface : clazz.getGenericInterfaces()) {\n                registerTypeVariablesOn(genericInterface);\n            }\n        }",
        "begin_line": 274,
        "end_line": 280,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromClassGenericMetadataSupport.rawType()",
        "snippet": "        @Override\n        public Class<?> rawType() {\n            return clazz;\n        }",
        "begin_line": 282,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromParameterizedTypeGenericMetadataSupport.FromParameterizedTypeGenericMetadataSupport(java.lang.reflect.ParameterizedType)",
        "snippet": "        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            readActualTypeParameters();\n        }",
        "begin_line": 303,
        "end_line": 306,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromParameterizedTypeGenericMetadataSupport.readActualTypeParameters()",
        "snippet": "        private void readActualTypeParameters() {\n            registerTypeVariablesOn(parameterizedType.getRawType());\n            registerTypeVariablesOn(parameterizedType);\n        }",
        "begin_line": 308,
        "end_line": 311,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.FromParameterizedTypeGenericMetadataSupport.rawType()",
        "snippet": "        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }",
        "begin_line": 313,
        "end_line": 316,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.ParameterizedReturnType.ParameterizedReturnType(org.mockito.internal.util.reflection.GenericMetadataSupport, java.lang.reflect.TypeVariable[], java.lang.reflect.ParameterizedType)",
        "snippet": "        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n            this.parameterizedType = parameterizedType;\n            this.typeParameters = typeParameters;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }",
        "begin_line": 327,
        "end_line": 334,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.ParameterizedReturnType.readTypeParameters()",
        "snippet": "        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }",
        "begin_line": 336,
        "end_line": 338,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.ParameterizedReturnType.readTypeVariables()",
        "snippet": "        private void readTypeVariables() {\n            registerTypeVariablesOn(parameterizedType);\n        }",
        "begin_line": 340,
        "end_line": 342,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.ParameterizedReturnType.rawType()",
        "snippet": "        @Override\n        public Class<?> rawType() {\n            return (Class<?>) parameterizedType.getRawType();\n        }",
        "begin_line": 344,
        "end_line": 347,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.TypeVariableReturnType(org.mockito.internal.util.reflection.GenericMetadataSupport, java.lang.reflect.TypeVariable[], java.lang.reflect.TypeVariable)",
        "snippet": "        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n            this.typeParameters = typeParameters;\n            this.typeVariable = typeVariable;\n            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n\n            readTypeParameters();\n            readTypeVariables();\n        }",
        "begin_line": 362,
        "end_line": 369,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.readTypeParameters()",
        "snippet": "        private void readTypeParameters() {\n            registerTypeParametersOn(typeParameters);\n        }",
        "begin_line": 371,
        "end_line": 373,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.readTypeVariables()",
        "snippet": "        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }",
        "begin_line": 375,
        "end_line": 381,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.rawType()",
        "snippet": "        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }",
        "begin_line": 383,
        "end_line": 389,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.extractRawTypeOf(java.lang.reflect.Type)",
        "snippet": "        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }",
        "begin_line": 391,
        "end_line": 409,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.extraInterfaces()",
        "snippet": "        @Override\n        public List<Type> extraInterfaces() {\n            Type type = extractActualBoundedTypeOf(typeVariable);\n            if (type instanceof BoundedType) {\n                return Arrays.asList(((BoundedType) type).interfaceBounds());\n            }\n            if (type instanceof ParameterizedType) {\n                return Collections.singletonList(type);\n            }\n            if (type instanceof Class) {\n                return Collections.emptyList();\n            }\n            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n        }",
        "begin_line": 411,
        "end_line": 424,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.rawExtraInterfaces()",
        "snippet": "        public Class<?>[] rawExtraInterfaces() {\n            List<Type> extraInterfaces = extraInterfaces();\n            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n            for (Type extraInterface : extraInterfaces) {\n                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n                if(!rawType().equals(rawInterface)) {\n                    rawExtraInterfaces.add(rawInterface);\n                }\n            }\n            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n        }",
        "begin_line": 430,
        "end_line": 441,
        "comment": "\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVariableReturnType.extractActualBoundedTypeOf(java.lang.reflect.Type)",
        "snippet": "        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }",
        "begin_line": 443,
        "end_line": 459,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.NotGenericReturnTypeSupport.NotGenericReturnTypeSupport(java.lang.reflect.Type)",
        "snippet": "        public NotGenericReturnTypeSupport(Type genericReturnType) {\n            returnType = (Class<?>) genericReturnType;\n        }",
        "begin_line": 470,
        "end_line": 472,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.NotGenericReturnTypeSupport.rawType()",
        "snippet": "        @Override\n        public Class<?> rawType() {\n            return returnType;\n        }",
        "begin_line": 474,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.BoundedType.firstBound()",
        "snippet": "        Type firstBound();",
        "begin_line": 491,
        "end_line": 491,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.BoundedType.interfaceBounds()",
        "snippet": "        Type[] interfaceBounds();",
        "begin_line": 493,
        "end_line": 493,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.TypeVarBoundedType(java.lang.reflect.TypeVariable)",
        "snippet": "        public TypeVarBoundedType(TypeVariable typeVariable) {\n            this.typeVariable = typeVariable;\n        }",
        "begin_line": 520,
        "end_line": 522,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.firstBound()",
        "snippet": "        public Type firstBound() {\n            return typeVariable.getBounds()[0]; //\n        }",
        "begin_line": 527,
        "end_line": 529,
        "comment": "\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.interfaceBounds()",
        "snippet": "        public Type[] interfaceBounds() {\n            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n            return interfaceBounds;\n        }",
        "begin_line": 538,
        "end_line": 542,
        "comment": "\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.equals(java.lang.Object)",
        "snippet": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }",
        "begin_line": 544,
        "end_line": 551,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.hashCode()",
        "snippet": "        @Override\n        public int hashCode() {\n            return typeVariable.hashCode();\n        }",
        "begin_line": 553,
        "end_line": 556,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n        }",
        "begin_line": 558,
        "end_line": 561,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.TypeVarBoundedType.typeVariable()",
        "snippet": "        public TypeVariable typeVariable() {\n            return typeVariable;\n        }",
        "begin_line": 563,
        "end_line": 565,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.WildCardBoundedType(java.lang.reflect.WildcardType)",
        "snippet": "        public WildCardBoundedType(WildcardType wildcard) {\n            this.wildcard = wildcard;\n        }",
        "begin_line": 580,
        "end_line": 582,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.firstBound()",
        "snippet": "        public Type firstBound() {\n            Type[] lowerBounds = wildcard.getLowerBounds();\n            Type[] upperBounds = wildcard.getUpperBounds();\n\n            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n        }",
        "begin_line": 587,
        "end_line": 592,
        "comment": "\n         * @return The first bound, either a type or a reference to a TypeVariable\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.interfaceBounds()",
        "snippet": "        public Type[] interfaceBounds() {\n            return new Type[0];\n        }",
        "begin_line": 597,
        "end_line": 599,
        "comment": "\n         * @return An empty array as, wildcard don't support multiple bounds.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.equals(java.lang.Object)",
        "snippet": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n\n        }",
        "begin_line": 601,
        "end_line": 608,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.hashCode()",
        "snippet": "        @Override\n        public int hashCode() {\n            return wildcard.hashCode();\n        }",
        "begin_line": 610,
        "end_line": 613,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.toString()",
        "snippet": "        @Override\n        public String toString() {\n            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n        }",
        "begin_line": 615,
        "end_line": 618,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java",
        "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
        "signature": "org.mockito.internal.util.reflection.GenericMetadataSupport.WildCardBoundedType.wildCard()",
        "snippet": "        public WildcardType wildCard() {\n            return wildcard;\n        }",
        "begin_line": 620,
        "end_line": 622,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializationReport.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializationReport",
        "signature": "org.mockito.internal.util.reflection.FieldInitializationReport.FieldInitializationReport(java.lang.Object, boolean, boolean)",
        "snippet": "    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized, boolean wasInitializedUsingConstructorArgs) {\n        this.fieldInstance = fieldInstance;\n        this.wasInitialized = wasInitialized;\n        this.wasInitializedUsingConstructorArgs = wasInitializedUsingConstructorArgs;\n    }",
        "begin_line": 16,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializationReport.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializationReport",
        "signature": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldInstance()",
        "snippet": "    public Object fieldInstance() {\n        return fieldInstance;\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "\n     * Returns the actual field instance.\n     *\n     * @return the actual instance\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializationReport.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializationReport",
        "signature": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldWasInitialized()",
        "snippet": "    public boolean fieldWasInitialized() {\n        return wasInitialized;\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Indicate wether the field was created during the process or not.\n     *\n     * @return <code>true</code> if created, <code>false</code> if the field did already hold an instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializationReport.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializationReport",
        "signature": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldWasInitializedUsingContructorArgs()",
        "snippet": "    public boolean fieldWasInitializedUsingContructorArgs() {\n        return wasInitializedUsingConstructorArgs;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Indicate wether the field was created using constructor args.\n     *\n     * @return <code>true</code> if field was created using constructor parameters.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializationReport.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializationReport",
        "signature": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldClass()",
        "snippet": "    public Class<?> fieldClass() {\n        return fieldInstance != null ? fieldInstance.getClass() : null;\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "\n     * Returns the class of the actual instance in the field.\n     *\n     * @return Class of the instance\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.FieldInitializer(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    public FieldInitializer(Object fieldOwner, Field field) {\n        this(fieldOwner, field, new NoArgConstructorInstantiator(fieldOwner, field));\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Prepare initializer with the given field on the given instance.\n     *\n     * <p>\n     * This constructor fail fast if the field type cannot be handled.\n     * </p>\n     *\n     * @param fieldOwner Instance of the test.\n     * @param field Field to be initialize.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.FieldInitializer(java.lang.Object, java.lang.reflect.Field, org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver)",
        "snippet": "    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {\n        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Prepare initializer with the given field on the given instance.\n     *\n     * <p>\n     * This constructor fail fast if the field type cannot be handled.\n     * </p>\n     *\n     * @param fieldOwner Instance of the test.\n     * @param field Field to be initialize.\n     * @param argResolver Constructor parameters resolver\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.FieldInitializer(java.lang.Object, java.lang.reflect.Field, org.mockito.internal.util.reflection.FieldInitializer.ConstructorInstantiator)",
        "snippet": "    private FieldInitializer(Object fieldOwner, Field field, ConstructorInstantiator instantiator) {\n        if(new FieldReader(fieldOwner, field).isNull()) {\n            checkNotLocal(field);\n            checkNotInner(field);\n            checkNotInterface(field);\n            checkNotAbstract(field);\n        }\n        this.fieldOwner = fieldOwner;\n        this.field = field;\n        this.instantiator = instantiator;\n    }",
        "begin_line": 64,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.initialize()",
        "snippet": "    public FieldInitializationReport initialize() {\n        final AccessibilityChanger changer = new AccessibilityChanger();\n        changer.enableAccess(field);\n\n        try {\n            return acquireFieldInstance();\n        } catch(IllegalAccessException e) {\n            throw new MockitoException(\"Problems initializing field '\" + field.getName() + \"' of type '\" + field.getType().getSimpleName() + \"'\", e);\n        } finally {\n            changer.safelyDisableAccess(field);\n        }\n    }",
        "begin_line": 81,
        "end_line": 92,
        "comment": "\n     * Initialize field if not initialized and return the actual instance.\n     *\n     * @return Actual field instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.checkNotLocal(java.lang.reflect.Field)",
        "snippet": "    private void checkNotLocal(Field field) {\n        if(field.getType().isLocalClass()) {\n            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is a local class.\");\n        }\n    }",
        "begin_line": 94,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.checkNotInner(java.lang.reflect.Field)",
        "snippet": "    private void checkNotInner(Field field) {\n        if(field.getType().isMemberClass() && !Modifier.isStatic(field.getType().getModifiers())) {\n            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is an inner class.\");\n        }\n    }",
        "begin_line": 100,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.checkNotInterface(java.lang.reflect.Field)",
        "snippet": "    private void checkNotInterface(Field field) {\n        if(field.getType().isInterface()) {\n            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is an interface.\");\n        }\n    }",
        "begin_line": 106,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.checkNotAbstract(java.lang.reflect.Field)",
        "snippet": "    private void checkNotAbstract(Field field) {\n        if(Modifier.isAbstract(field.getType().getModifiers())) {\n            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \" is an abstract class.\");\n        }\n    }",
        "begin_line": 112,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.acquireFieldInstance()",
        "snippet": "    private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {\n        Object fieldInstance = field.get(fieldOwner);\n        if(fieldInstance != null) {\n            return new FieldInitializationReport(fieldInstance, false, false);\n        }\n\n        return instantiator.instantiate();\n    }",
        "begin_line": 118,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver.resolveTypeInstances(java.lang.Class<?>...)",
        "snippet": "        Object[] resolveTypeInstances(Class<?>... argTypes);",
        "begin_line": 145,
        "end_line": 145,
        "comment": "\n         * Try to resolve instances from types.\n         *\n         * <p>\n         * Checks on the real argument type or on the correct argument number\n         * will happen during the field initialization {@link FieldInitializer#initialize()}.\n         * I.e the only responsibility of this method, is to provide instances <strong>if possible</strong>.\n         * </p>\n         *\n         * @param argTypes Constructor argument types, should not be null.\n         * @return The argument instances to be given to the constructor, should not be null.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ConstructorInstantiator.instantiate()",
        "snippet": "        FieldInitializationReport instantiate();",
        "begin_line": 149,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.NoArgConstructorInstantiator.NoArgConstructorInstantiator(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "        NoArgConstructorInstantiator(Object testClass, Field field) {\n            this.testClass = testClass;\n            this.field = field;\n        }",
        "begin_line": 169,
        "end_line": 172,
        "comment": "\n         * Internal, checks are done by FieldInitializer.\n         * Fields are assumed to be accessible.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.NoArgConstructorInstantiator.instantiate()",
        "snippet": "        public FieldInitializationReport instantiate() {\n            final AccessibilityChanger changer = new AccessibilityChanger();\n            Constructor<?> constructor = null;\n            try {\n                constructor = field.getType().getDeclaredConstructor();\n                changer.enableAccess(constructor);\n\n                final Object[] noArg = new Object[0];\n                Object newFieldInstance = constructor.newInstance(noArg);\n                new FieldSetter(testClass, field).set(newFieldInstance);\n\n                return new FieldInitializationReport(field.get(testClass), true, false);\n            } catch (NoSuchMethodException e) {\n                throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n            } catch (InvocationTargetException e) {\n                throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n            } catch (InstantiationException e) {\n                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n            } catch (IllegalAccessException e) {\n                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n            } finally {\n                if(constructor != null) {\n                    changer.safelyDisableAccess(constructor);\n                }\n            }\n        }",
        "begin_line": 174,
        "end_line": 199,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.Anonymous-579b8c2e-96a0-478c-beb5-363fc34efe9b.compare(java.lang.reflect.Constructor<?>, java.lang.reflect.Constructor<?>)",
        "snippet": "            public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n                int argLengths = constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n                if (argLengths == 0) {\n                    int constructorAMockableParamsSize = countMockableParams(constructorA);\n                    int constructorBMockableParamsSize = countMockableParams(constructorB);\n                    return constructorBMockableParamsSize - constructorAMockableParamsSize;\n                }\n                return argLengths;\n            }",
        "begin_line": 218,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.Anonymous-471487ff-93cc-41e7-a3dd-47386060871b.countMockableParams(java.lang.reflect.Constructor<?>)",
        "snippet": "            private int countMockableParams(Constructor<?> constructor) {\n                int constructorMockableParamsSize = 0;\n                for (Class<?> aClass : constructor.getParameterTypes()) {\n                    if(mockUtil.isTypeMockable(aClass)){\n                        constructorMockableParamsSize++;\n                    }\n                }\n                return constructorMockableParamsSize;\n            }",
        "begin_line": 228,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.ParameterizedConstructorInstantiator(java.lang.Object, java.lang.reflect.Field, org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver)",
        "snippet": "        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver argumentResolver) {\n            this.testClass = testClass;\n            this.field = field;\n            this.argResolver = argumentResolver;\n        }",
        "begin_line": 243,
        "end_line": 247,
        "comment": "\n         * Internal, checks are done by FieldInitializer.\n         * Fields are assumed to be accessible.\n         ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.instantiate()",
        "snippet": "        public FieldInitializationReport instantiate() {\n            final AccessibilityChanger changer = new AccessibilityChanger();\n            Constructor<?> constructor = null;\n            try {\n                constructor = biggestConstructor(field.getType());\n                changer.enableAccess(constructor);\n\n                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());\n                Object newFieldInstance = constructor.newInstance(args);\n                new FieldSetter(testClass, field).set(newFieldInstance);\n\n                return new FieldInitializationReport(field.get(testClass), false, true);\n            } catch (IllegalArgumentException e) {\n                throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n            } catch (InvocationTargetException e) {\n                throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n            } catch (InstantiationException e) {\n                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n            } catch (IllegalAccessException e) {\n                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n            } finally {\n                if(constructor != null) {\n                    changer.safelyDisableAccess(constructor);\n                }\n            }\n        }",
        "begin_line": 249,
        "end_line": 274,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.checkParameterized(java.lang.reflect.Constructor<?>, java.lang.reflect.Field)",
        "snippet": "        private void checkParameterized(Constructor<?> constructor, Field field) {\n            if(constructor.getParameterTypes().length == 0) {\n                throw new MockitoException(\"the field \" + field.getName() + \" of type \" + field.getType() + \" has no parameterized constructor\");\n            }\n        }",
        "begin_line": 276,
        "end_line": 280,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldInitializer.java",
        "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
        "signature": "org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator.biggestConstructor(java.lang.Class<?>)",
        "snippet": "        private Constructor<?> biggestConstructor(Class<?> clazz) {\n            final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n            Collections.sort(constructors, byParameterNumber);\n            \n            Constructor<?> constructor = constructors.get(0);\n            checkParameterized(constructor, field);\n            return constructor;\n        }",
        "begin_line": 282,
        "end_line": 289,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.InstanceField(java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    public InstanceField(Field field, Object instance) {\n        this.field = Checks.checkNotNull(field, \"field\");\n        this.instance = Checks.checkNotNull(instance, \"instance\");\n    }",
        "begin_line": 29,
        "end_line": 32,
        "comment": "\n     * Create a new InstanceField.\n     *\n     * @param field The field that should be accessed, note that no checks are performed to ensure\n     *              the field belong to this instance class.\n     * @param instance The instance from which the field shall be accessed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.read()",
        "snippet": "    public Object read() {\n        return reader().read();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Safely read the field.\n     *\n     * @return the field value.\n     * @see FieldReader\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.set(java.lang.Object)",
        "snippet": "    public void set(Object value) {\n        new FieldSetter(instance, field).set(value);\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "\n     * Set the given value to the field of this instance.\n     *\n     * @param value The value that should be written to the field.\n     * @see FieldSetter\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.isNull()",
        "snippet": "    public boolean isNull() {\n        return reader().isNull();\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Check that the field is not null.\n     *\n     * @return <code>true</code> if <code>null</code>, else <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.isAnnotatedBy(java.lang.Class<? extends java.lang.annotation.Annotation>)",
        "snippet": "    public boolean isAnnotatedBy(Class<? extends Annotation> annotationClass) {\n        return field.isAnnotationPresent(annotationClass);\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n     * Check if the field is annotated by the given annotation.\n     *\n     * @param annotationClass The annotation type to check.\n     * @return <code>true</code> if the field is annotated by this annotation, else <code>false</code>.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.annotation(java.lang.Class<A>)",
        "snippet": "    public <A extends Annotation> A annotation(Class<A> annotationClass) {\n        return field.getAnnotation(annotationClass);\n    }",
        "begin_line": 80,
        "end_line": 82,
        "comment": "\n     * Returns the annotation instance for the given annotation type.\n     *\n     * @param annotationClass Tha annotation type to retrieve.\n     * @param <A> Type of the annotation.\n     * @return The annotation instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.jdkField()",
        "snippet": "    public Field jdkField() {\n        return field;\n    }",
        "begin_line": 89,
        "end_line": 91,
        "comment": "\n     * Returns the JDK {@link Field} instance.\n     *\n     * @return The actual {@link Field} instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.reader()",
        "snippet": "    private FieldReader reader() {\n        if (fieldReader == null) {\n            fieldReader = new FieldReader(instance, field);\n        }\n        return fieldReader;\n    }",
        "begin_line": 93,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.name()",
        "snippet": "    public String name() {\n        return field.getName();\n    }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "\n     * Returns the name of the field.\n     *\n     * @return Name of the field.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        InstanceField that = (InstanceField) o;\n        return field.equals(that.field) && instance.equals(that.instance);\n    }",
        "begin_line": 109,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/InstanceField.java",
        "class_name": "org.mockito.internal.util.reflection.InstanceField",
        "signature": "org.mockito.internal.util.reflection.InstanceField.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        int result = field.hashCode();\n        result = 31 * result + instance.hashCode();\n        return result;\n    }",
        "begin_line": 118,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/LenientCopyTool.java",
        "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
        "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copyToMock(T, T)",
        "snippet": "    public <T> void copyToMock(T from, T mock) {\n        copy(from, mock, from.getClass(), mock.getClass().getSuperclass());\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/LenientCopyTool.java",
        "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
        "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copyToRealObject(T, T)",
        "snippet": "    public <T> void copyToRealObject(T from, T to) {\n        copy(from, to, from.getClass(), to.getClass());\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/LenientCopyTool.java",
        "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
        "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copy(T, T, java.lang.Class, java.lang.Class)",
        "snippet": "    private <T> void copy(T from, T to, Class fromClazz, Class toClass) {\n        while (fromClazz != Object.class) {\n            copyValues(from, to, fromClazz);\n            fromClazz = fromClazz.getSuperclass();\n        }\n    }",
        "begin_line": 23,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/LenientCopyTool.java",
        "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
        "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copyValues(T, T, java.lang.Class)",
        "snippet": "    private <T> void copyValues(T from, T mock, Class classFrom) {\n        Field[] fields = classFrom.getDeclaredFields();\n\n        for (int i = 0; i < fields.length; i++) {\n            // ignore static fields\n            Field field = fields[i];\n            if (Modifier.isStatic(field.getModifiers())) {\n                continue;\n            }\n            AccessibilityChanger accessibilityChanger = new AccessibilityChanger();\n            try {\n                accessibilityChanger.enableAccess(field);\n                fieldCopier.copyValue(from, mock, field);\n            } catch (Throwable t) {\n                //Ignore - be lenient - if some field cannot be copied then let's be it\n            } finally {\n                accessibilityChanger.safelyDisableAccess(field);\n            }\n        }\n    }",
        "begin_line": 30,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/util/reflection/FieldCopier.java",
        "class_name": "org.mockito.internal.util.reflection.FieldCopier",
        "signature": "org.mockito.internal.util.reflection.FieldCopier.copyValue(T, T, java.lang.reflect.Field)",
        "snippet": "    public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\n        Object value = field.get(from);\n        field.set(to, value);\n    }",
        "begin_line": 11,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing)",
        "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        this.iOngoingStubbing = iOngoingStubbing;\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.pullOngoingStubbing()",
        "snippet": "    public IOngoingStubbing pullOngoingStubbing() {\n        IOngoingStubbing temp = iOngoingStubbing;\n        iOngoingStubbing = null;\n        return temp;\n    }",
        "begin_line": 33,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.verificationStarted(org.mockito.verification.VerificationMode)",
        "snippet": "    public void verificationStarted(VerificationMode verify) {\n        validateState();\n        resetOngoingStubbing();\n        verificationMode = new Localized(verify);\n    }",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.resetOngoingStubbing()",
        "snippet": "    public void resetOngoingStubbing() {\n        iOngoingStubbing = null;\n    }",
        "begin_line": 48,
        "end_line": 50,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.pullVerificationMode()",
        "snippet": "    public VerificationMode pullVerificationMode() {\n        if (verificationMode == null) {\n            return null;\n        }\n        \n        VerificationMode temp = verificationMode.getObject();\n        verificationMode = null;\n        return temp;\n    }",
        "begin_line": 52,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.stubbingStarted()",
        "snippet": "    public void stubbingStarted() {\n        validateState();\n        stubbingInProgress = new LocationImpl();\n    }",
        "begin_line": 62,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
        "snippet": "    public void validateState() {\n        validateMostStuff();\n        \n        //validate stubbing:\n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n    }",
        "begin_line": 67,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.validateMostStuff()",
        "snippet": "    private void validateMostStuff() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class\n        GlobalConfiguration.validate();\n\n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n\n        getArgumentMatcherStorage().validateState();\n    }",
        "begin_line": 78,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.stubbingCompleted(org.mockito.invocation.Invocation)",
        "snippet": "    public void stubbingCompleted(Invocation invocation) {\n        stubbingInProgress = null;\n    }",
        "begin_line": 92,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.toString()",
        "snippet": "    public String toString() {\n        return  \"iOngoingStubbing: \" + iOngoingStubbing + \n        \", verificationMode: \" + verificationMode +\n        \", stubbingInProgress: \" + stubbingInProgress;\n    }",
        "begin_line": 96,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.reset()",
        "snippet": "    public void reset() {\n        stubbingInProgress = null;\n        verificationMode = null;\n        getArgumentMatcherStorage().reset();\n    }",
        "begin_line": 102,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
        "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.mockingStarted(java.lang.Object, java.lang.Class)",
        "snippet": "    public void mockingStarted(Object mock, Class classToMock) {\n        if (listener instanceof MockingStartedListener) {\n            ((MockingStartedListener) listener).mockingStarted(mock, classToMock);\n        }\n        validateMostStuff();\n    }",
        "begin_line": 112,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgressImpl.java",
        "class_name": "org.mockito.internal.progress.MockingProgressImpl",
        "signature": "org.mockito.internal.progress.MockingProgressImpl.setListener(org.mockito.internal.listeners.MockingProgressListener)",
        "snippet": "    public void setListener(MockingProgressListener listener) {\n        this.listener = listener;\n    }",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportMatcher(org.hamcrest.Matcher)",
        "snippet": "    public HandyReturnValues reportMatcher(Matcher matcher) {\n        matcherStack.push(new LocalizedMatcher(matcher));\n        return new HandyReturnValues();\n    }",
        "begin_line": 31,
        "end_line": 34,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportMatcher(org.hamcrest.Matcher)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.pullLocalizedMatchers()",
        "snippet": "    public List<LocalizedMatcher> pullLocalizedMatchers() {\n        if (matcherStack.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher>(matcherStack);\n        matcherStack.clear();\n        return (List) matchers;\n    }",
        "begin_line": 39,
        "end_line": 47,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#pullLocalizedMatchers()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportAnd()",
        "snippet": "    public HandyReturnValues reportAnd() {\n        assertStateFor(\"And(?)\", TWO_SUB_MATCHERS);\n        And and = new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n        matcherStack.push(new LocalizedMatcher(and));\n        return new HandyReturnValues();\n    }",
        "begin_line": 52,
        "end_line": 57,
        "comment": " (non-Javadoc)\n    * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n    ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportOr()",
        "snippet": "    public HandyReturnValues reportOr() {\n        assertStateFor(\"Or(?)\", TWO_SUB_MATCHERS);\n        Or or = new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n        matcherStack.push(new LocalizedMatcher(or));\n        return new HandyReturnValues();\n    }",
        "begin_line": 62,
        "end_line": 67,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportNot()",
        "snippet": "    public HandyReturnValues reportNot() {\n        assertStateFor(\"Not(?)\", ONE_SUB_MATCHER);\n        Not not = new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));\n        matcherStack.push(new LocalizedMatcher(not));\n        return new HandyReturnValues();\n    }",
        "begin_line": 72,
        "end_line": 77,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportNot()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertStateFor(java.lang.String, int)",
        "snippet": "    private void assertStateFor(String additionalMatcherName, int subMatchersCount) {\n        assertMatchersFoundFor(additionalMatcherName);\n        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);\n    }",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.popLastArgumentMatchers(int)",
        "snippet": "    private List<Matcher> popLastArgumentMatchers(int count) {\n        List<Matcher> result = new LinkedList<Matcher>();\n        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n        for (int i = 0; i < count; i++) {\n            matcherStack.pop();\n        }\n        return result;\n    }",
        "begin_line": 84,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertMatchersFoundFor(java.lang.String)",
        "snippet": "    private void assertMatchersFoundFor(String additionalMatcherName) {\n        if (matcherStack.isEmpty()) {\n            matcherStack.clear();\n            new Reporter().reportNoSubMatchersFound(additionalMatcherName);\n        }\n    }",
        "begin_line": 93,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.assertIncorrectUseOfAdditionalMatchers(java.lang.String, int)",
        "snippet": "    private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {\n        if(matcherStack.size() < count) {\n            ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n            matcherStack.clear();\n            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);\n        }\n    }",
        "begin_line": 100,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
        "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatchers);\n        }\n    }",
        "begin_line": 111,
        "end_line": 117,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reset()",
        "snippet": "    public void reset() {\n        matcherStack.clear();\n    }",
        "begin_line": 122,
        "end_line": 124,
        "comment": " (non-Javadoc)\n     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reset()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/SequenceNumber.java",
        "class_name": "org.mockito.internal.progress.SequenceNumber",
        "signature": "org.mockito.internal.progress.SequenceNumber.next()",
        "snippet": "    public static synchronized int next() {\n        return sequenceNumber++;\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
        "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
        "begin_line": 20,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing)",
        "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        threadSafely().reportOngoingStubbing(iOngoingStubbing);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullOngoingStubbing()",
        "snippet": "    public IOngoingStubbing pullOngoingStubbing() {\n        return threadSafely().pullOngoingStubbing();\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.verificationStarted(org.mockito.verification.VerificationMode)",
        "snippet": "    public void verificationStarted(VerificationMode verify) {\n        threadSafely().verificationStarted(verify);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullVerificationMode()",
        "snippet": "    public VerificationMode pullVerificationMode() {\n        return threadSafely().pullVerificationMode();\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.stubbingStarted()",
        "snippet": "    public void stubbingStarted() {\n        threadSafely().stubbingStarted();\n    }",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
        "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.stubbingCompleted(org.mockito.invocation.Invocation)",
        "snippet": "    public void stubbingCompleted(Invocation invocation) {\n        threadSafely().stubbingCompleted(invocation);\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.toString()",
        "snippet": "    public String toString() {\n        return threadSafely().toString();\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reset()",
        "snippet": "    public void reset() {\n        threadSafely().reset();\n    }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.resetOngoingStubbing()",
        "snippet": "    public void resetOngoingStubbing() {\n        threadSafely().resetOngoingStubbing();\n    }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.getArgumentMatcherStorage()",
        "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return threadSafely().getArgumentMatcherStorage();\n    }",
        "begin_line": 67,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.mockingStarted(java.lang.Object, java.lang.Class)",
        "snippet": "    public void mockingStarted(Object mock, Class classToMock) {\n        threadSafely().mockingStarted(mock, classToMock);\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ThreadSafeMockingProgress.java",
        "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
        "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.setListener(org.mockito.internal.listeners.MockingProgressListener)",
        "snippet": "    public void setListener(MockingProgressListener listener) {\n        threadSafely().setListener(listener);\n    }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnZero()",
        "snippet": "    public byte returnZero() {\n        return 0;\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnChar()",
        "snippet": "    public char returnChar() {\n        return 0;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnNull()",
        "snippet": "    public <T> T returnNull() {\n        return null;\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnFalse()",
        "snippet": "    public boolean returnFalse() {\n        return false;\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnString()",
        "snippet": "    public String returnString() {\n        return \"\";\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnFor(java.lang.Class<T>)",
        "snippet": "    public <T> T returnFor(Class<T> clazz) {\n        // explicitly return null if type is not a primitive or a wrapper\n        if (isPrimitiveOrWrapper(clazz)) {\n            return defaultValueForPrimitiveOrWrapper(clazz);\n        } \n        return null;\n    }",
        "begin_line": 35,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnMap()",
        "snippet": "    public Map returnMap() {\n        return new HashMap();\n    }",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnList()",
        "snippet": "    public List returnList() {\n        return new LinkedList();\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnSet()",
        "snippet": "    public Set returnSet() {\n        return new HashSet();\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/HandyReturnValues.java",
        "class_name": "org.mockito.internal.progress.HandyReturnValues",
        "signature": "org.mockito.internal.progress.HandyReturnValues.returnFor(T)",
        "snippet": "    public <T> T returnFor(T instance) {\n        return instance == null ? null : (T) returnFor(instance.getClass());\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.reportOngoingStubbing(org.mockito.internal.progress.IOngoingStubbing)",
        "snippet": "    void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing);",
        "begin_line": 16,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.pullOngoingStubbing()",
        "snippet": "    IOngoingStubbing pullOngoingStubbing();",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.verificationStarted(org.mockito.verification.VerificationMode)",
        "snippet": "    void verificationStarted(VerificationMode verificationMode);",
        "begin_line": 20,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.pullVerificationMode()",
        "snippet": "    VerificationMode pullVerificationMode();",
        "begin_line": 22,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.stubbingStarted()",
        "snippet": "    void stubbingStarted();",
        "begin_line": 24,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.stubbingCompleted(org.mockito.invocation.Invocation)",
        "snippet": "    void stubbingCompleted(Invocation invocation);",
        "begin_line": 26,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.validateState()",
        "snippet": "    void validateState();",
        "begin_line": 28,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.reset()",
        "snippet": "    void reset();",
        "begin_line": 30,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.resetOngoingStubbing()",
        "snippet": "    void resetOngoingStubbing();",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n     * Removes ongoing stubbing so that in case the framework is misused\n     * state validation errors are more accurate\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.getArgumentMatcherStorage()",
        "snippet": "    ArgumentMatcherStorage getArgumentMatcherStorage();",
        "begin_line": 38,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.mockingStarted(java.lang.Object, java.lang.Class)",
        "snippet": "    void mockingStarted(Object mock, Class classToMock);",
        "begin_line": 40,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/MockingProgress.java",
        "class_name": "org.mockito.internal.progress.MockingProgress",
        "signature": "org.mockito.internal.progress.MockingProgress.setListener(org.mockito.internal.listeners.MockingProgressListener)",
        "snippet": "    void setListener(MockingProgressListener listener);",
        "begin_line": 42,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.reportMatcher(org.hamcrest.Matcher)",
        "snippet": "    HandyReturnValues reportMatcher(Matcher matcher);",
        "begin_line": 15,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.pullLocalizedMatchers()",
        "snippet": "    List<LocalizedMatcher> pullLocalizedMatchers();",
        "begin_line": 17,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.reportAnd()",
        "snippet": "    HandyReturnValues reportAnd();",
        "begin_line": 19,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.reportNot()",
        "snippet": "    HandyReturnValues reportNot();",
        "begin_line": 21,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.reportOr()",
        "snippet": "    HandyReturnValues reportOr();",
        "begin_line": 23,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.validateState()",
        "snippet": "    void validateState();",
        "begin_line": 25,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/progress/ArgumentMatcherStorage.java",
        "class_name": "org.mockito.internal.progress.ArgumentMatcherStorage",
        "signature": "org.mockito.internal.progress.ArgumentMatcherStorage.reset()",
        "snippet": "    void reset();",
        "begin_line": 27,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessOrEqual.java",
        "class_name": "org.mockito.internal.matchers.LessOrEqual",
        "signature": "org.mockito.internal.matchers.LessOrEqual.LessOrEqual(java.lang.Comparable<T>)",
        "snippet": "    public LessOrEqual(Comparable<T> value) {\n        super(value);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessOrEqual.java",
        "class_name": "org.mockito.internal.matchers.LessOrEqual",
        "signature": "org.mockito.internal.matchers.LessOrEqual.getName()",
        "snippet": "    @Override\n    protected String getName() {\n        return \"leq\";\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessOrEqual.java",
        "class_name": "org.mockito.internal.matchers.LessOrEqual",
        "signature": "org.mockito.internal.matchers.LessOrEqual.matchResult(int)",
        "snippet": "    @Override\n    protected boolean matchResult(int result) {\n        return result <= 0;\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturesArguments.java",
        "class_name": "org.mockito.internal.matchers.CapturesArguments",
        "signature": "org.mockito.internal.matchers.CapturesArguments.captureFrom(java.lang.Object)",
        "snippet": "    void captureFrom(Object argument);",
        "begin_line": 10,
        "end_line": 10,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/InstanceOf.java",
        "class_name": "org.mockito.internal.matchers.InstanceOf",
        "signature": "org.mockito.internal.matchers.InstanceOf.InstanceOf(java.lang.Class<?>)",
        "snippet": "    public InstanceOf(Class<?> clazz) {\n        this.clazz = clazz;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/InstanceOf.java",
        "class_name": "org.mockito.internal.matchers.InstanceOf",
        "signature": "org.mockito.internal.matchers.InstanceOf.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return (actual != null) && clazz.isAssignableFrom(actual.getClass());\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/InstanceOf.java",
        "class_name": "org.mockito.internal.matchers.InstanceOf",
        "signature": "org.mockito.internal.matchers.InstanceOf.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"isA(\" + clazz.getName() + \")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Find.java",
        "class_name": "org.mockito.internal.matchers.Find",
        "signature": "org.mockito.internal.matchers.Find.Find(java.lang.String)",
        "snippet": "    public Find(String regex) {\n        this.regex = regex;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Find.java",
        "class_name": "org.mockito.internal.matchers.Find",
        "signature": "org.mockito.internal.matchers.Find.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual != null && Pattern.compile(regex).matcher((String) actual).find();\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Find.java",
        "class_name": "org.mockito.internal.matchers.Find",
        "signature": "org.mockito.internal.matchers.Find.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"find(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareEqual.java",
        "class_name": "org.mockito.internal.matchers.CompareEqual",
        "signature": "org.mockito.internal.matchers.CompareEqual.CompareEqual(java.lang.Comparable<T>)",
        "snippet": "    public CompareEqual(Comparable<T> value) {\n        super(value);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareEqual.java",
        "class_name": "org.mockito.internal.matchers.CompareEqual",
        "signature": "org.mockito.internal.matchers.CompareEqual.getName()",
        "snippet": "    @Override\n    protected String getName() {\n        return \"cmpEq\";\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareEqual.java",
        "class_name": "org.mockito.internal.matchers.CompareEqual",
        "signature": "org.mockito.internal.matchers.CompareEqual.matchResult(int)",
        "snippet": "    @Override\n    protected boolean matchResult(int result) {\n        return result == 0;\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Same.java",
        "class_name": "org.mockito.internal.matchers.Same",
        "signature": "org.mockito.internal.matchers.Same.Same(java.lang.Object)",
        "snippet": "    public Same(Object wanted) {\n        this.wanted = wanted;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Same.java",
        "class_name": "org.mockito.internal.matchers.Same",
        "signature": "org.mockito.internal.matchers.Same.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return wanted == actual;\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Same.java",
        "class_name": "org.mockito.internal.matchers.Same",
        "signature": "org.mockito.internal.matchers.Same.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(\"\" + wanted);\n        appendQuoting(description);\n        description.appendText(\")\");\n    }",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Same.java",
        "class_name": "org.mockito.internal.matchers.Same",
        "signature": "org.mockito.internal.matchers.Same.appendQuoting(org.hamcrest.Description)",
        "snippet": "    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }",
        "begin_line": 35,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Matches.java",
        "class_name": "org.mockito.internal.matchers.Matches",
        "signature": "org.mockito.internal.matchers.Matches.Matches(java.lang.String)",
        "snippet": "    public Matches(String regex) {\n        this.regex = regex;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Matches.java",
        "class_name": "org.mockito.internal.matchers.Matches",
        "signature": "org.mockito.internal.matchers.Matches.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return (actual instanceof String) && ((String) actual).matches(regex);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Matches.java",
        "class_name": "org.mockito.internal.matchers.Matches",
        "signature": "org.mockito.internal.matchers.Matches.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"matches(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")\n                + \"\\\")\");\n    }",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ArrayEquals.java",
        "class_name": "org.mockito.internal.matchers.ArrayEquals",
        "signature": "org.mockito.internal.matchers.ArrayEquals.ArrayEquals(java.lang.Object)",
        "snippet": "    public ArrayEquals(Object wanted) {\n        super(wanted);\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ArrayEquals.java",
        "class_name": "org.mockito.internal.matchers.ArrayEquals",
        "signature": "org.mockito.internal.matchers.ArrayEquals.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        Object wanted = getWanted();\n        if (wanted == null || actual == null) {\n            return super.matches(actual);\n        } else if (wanted instanceof boolean[] && actual instanceof boolean[]) {\n            return Arrays.equals((boolean[]) wanted, (boolean[]) actual);\n        } else if (wanted instanceof byte[] && actual instanceof byte[]) {\n            return Arrays.equals((byte[]) wanted, (byte[]) actual);\n        } else if (wanted instanceof char[] && actual instanceof char[]) {\n            return Arrays.equals((char[]) wanted, (char[]) actual);\n        } else if (wanted instanceof double[] && actual instanceof double[]) {\n            return Arrays.equals((double[]) wanted, (double[]) actual);\n        } else if (wanted instanceof float[] && actual instanceof float[]) {\n            return Arrays.equals((float[]) wanted, (float[]) actual);\n        } else if (wanted instanceof int[] && actual instanceof int[]) {\n            return Arrays.equals((int[]) wanted, (int[]) actual);\n        } else if (wanted instanceof long[] && actual instanceof long[]) {\n            return Arrays.equals((long[]) wanted, (long[]) actual);\n        } else if (wanted instanceof short[] && actual instanceof short[]) {\n            return Arrays.equals((short[]) wanted, (short[]) actual);\n        } else if (wanted instanceof Object[] && actual instanceof Object[]) {\n            return Arrays.equals((Object[]) wanted, (Object[]) actual);\n        }\n        return false;\n    }",
        "begin_line": 21,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ArrayEquals.java",
        "class_name": "org.mockito.internal.matchers.ArrayEquals",
        "signature": "org.mockito.internal.matchers.ArrayEquals.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        if (getWanted() != null && getWanted().getClass().isArray()) {\n            appendArray(createObjectArray(getWanted()), description);\n        } else {\n            super.describeTo(description);\n        }\n    }",
        "begin_line": 47,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ArrayEquals.java",
        "class_name": "org.mockito.internal.matchers.ArrayEquals",
        "signature": "org.mockito.internal.matchers.ArrayEquals.appendArray(java.lang.Object[], org.hamcrest.Description)",
        "snippet": "    private void appendArray(Object[] array, Description description) {\n        description.appendText(\"[\");\n        for (int i = 0; i < array.length; i++) {\n            new Equals(array[i]).describeTo(description);\n            if (i != array.length - 1) {\n                description.appendText(\", \");\n            }\n        }\n        description.appendText(\"]\");\n    }",
        "begin_line": 55,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ArrayEquals.java",
        "class_name": "org.mockito.internal.matchers.ArrayEquals",
        "signature": "org.mockito.internal.matchers.ArrayEquals.createObjectArray(java.lang.Object)",
        "snippet": "    public static Object[] createObjectArray(Object array) {\n        if (array instanceof Object[]) {\n            return (Object[]) array;\n        }\n        Object[] result = new Object[Array.getLength(array)];\n        for (int i = 0; i < Array.getLength(array); i++) {\n            result[i] = Array.get(array, i);\n        }\n        return result;\n    }",
        "begin_line": 66,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.CapturingMatcher",
        "signature": "org.mockito.internal.matchers.CapturingMatcher.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object argument) {\n        return true;\n    }    ",
        "begin_line": 24,
        "end_line": 26,
        "comment": " (non-Javadoc)\n     * @see org.mockito.ArgumentMatcher#matches(java.lang.Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.CapturingMatcher",
        "signature": "org.mockito.internal.matchers.CapturingMatcher.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"<Capturing argument>\");\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": " (non-Javadoc)\n     * @see org.mockito.ArgumentMatcher#describeTo(org.hamcrest.Description)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.CapturingMatcher",
        "signature": "org.mockito.internal.matchers.CapturingMatcher.getLastValue()",
        "snippet": "    public T getLastValue() {\n        if (arguments.isEmpty()) {\n            new Reporter().noArgumentValueWasCaptured();\n            return null;\n        } else {\n            return (T) arguments.getLast();\n        }\n    }",
        "begin_line": 35,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.CapturingMatcher",
        "signature": "org.mockito.internal.matchers.CapturingMatcher.getAllValues()",
        "snippet": "    public List<T> getAllValues() {\n        return (List) arguments;\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.CapturingMatcher",
        "signature": "org.mockito.internal.matchers.CapturingMatcher.captureFrom(java.lang.Object)",
        "snippet": "    public void captureFrom(Object argument) {\n        this.arguments.add(argument);\n    }",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterThan.java",
        "class_name": "org.mockito.internal.matchers.GreaterThan",
        "signature": "org.mockito.internal.matchers.GreaterThan.GreaterThan(java.lang.Comparable<T>)",
        "snippet": "    public GreaterThan(Comparable<T> value) {\n        super(value);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterThan.java",
        "class_name": "org.mockito.internal.matchers.GreaterThan",
        "signature": "org.mockito.internal.matchers.GreaterThan.getName()",
        "snippet": "    @Override\n    protected String getName() {\n        return \"gt\";\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterThan.java",
        "class_name": "org.mockito.internal.matchers.GreaterThan",
        "signature": "org.mockito.internal.matchers.GreaterThan.matchResult(int)",
        "snippet": "    @Override\n    protected boolean matchResult(int result) {\n        return result > 0;\n    }    ",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Not.java",
        "class_name": "org.mockito.internal.matchers.Not",
        "signature": "org.mockito.internal.matchers.Not.Not(org.hamcrest.Matcher)",
        "snippet": "    public Not(Matcher first) {\n        this.first = first;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Not.java",
        "class_name": "org.mockito.internal.matchers.Not",
        "signature": "org.mockito.internal.matchers.Not.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return !first.matches(actual);\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Not.java",
        "class_name": "org.mockito.internal.matchers.Not",
        "signature": "org.mockito.internal.matchers.Not.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"not(\");\n        first.describeTo(description);\n        description.appendText(\")\");\n    }",
        "begin_line": 28,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Any.java",
        "class_name": "org.mockito.internal.matchers.Any",
        "signature": "org.mockito.internal.matchers.Any.Any()",
        "snippet": "    private Any() {}",
        "begin_line": 19,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Any.java",
        "class_name": "org.mockito.internal.matchers.Any",
        "signature": "org.mockito.internal.matchers.Any.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return true;\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Any.java",
        "class_name": "org.mockito.internal.matchers.Any",
        "signature": "org.mockito.internal.matchers.Any.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"<any>\");\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.LocalizedMatcher(org.hamcrest.Matcher)",
        "snippet": "    public LocalizedMatcher(Matcher actualMatcher) {\n        this.actualMatcher = actualMatcher;\n        this.location = new LocationImpl();\n    }",
        "begin_line": 22,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher._dont_implement_Matcher___instead_extend_BaseMatcher_()",
        "snippet": "    public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {\n        // yeah right\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object item) {\n        return actualMatcher.matches(item);\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        actualMatcher.describeTo(description);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.getLocation()",
        "snippet": "    public Location getLocation() {\n        return location;\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"Localized: \" + this.actualMatcher;\n    }",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.withExtraTypeInfo()",
        "snippet": "    public SelfDescribing withExtraTypeInfo() {\n        if (actualMatcher instanceof ContainsExtraTypeInformation) {\n            return ((ContainsExtraTypeInformation) actualMatcher).withExtraTypeInfo();\n        } else {\n            return this;\n        }\n    }",
        "begin_line": 48,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.typeMatches(java.lang.Object)",
        "snippet": "    public boolean typeMatches(Object object) {\n        return actualMatcher instanceof ContainsExtraTypeInformation\n                && ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);\n    }",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.captureFrom(java.lang.Object)",
        "snippet": "    public void captureFrom(Object argument) {\n        if (actualMatcher instanceof CapturesArguments) {\n            ((CapturesArguments) actualMatcher).captureFrom(argument);\n        }\n    }",
        "begin_line": 61,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LocalizedMatcher.java",
        "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
        "signature": "org.mockito.internal.matchers.LocalizedMatcher.getActualMatcher()",
        "snippet": "    public Matcher getActualMatcher() {\n        return actualMatcher;\n    }",
        "begin_line": 68,
        "end_line": 70,
        "comment": "TODO: refactor other 'delegated interfaces' to use the MatcherDecorator feature",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/MatchersPrinter.java",
        "class_name": "org.mockito.internal.matchers.MatchersPrinter",
        "signature": "org.mockito.internal.matchers.MatchersPrinter.getArgumentsLine(java.util.List<org.hamcrest.Matcher>, org.mockito.internal.reporting.PrintSettings)",
        "snippet": "    public String getArgumentsLine(List<Matcher> matchers, PrintSettings printSettings) {\n        Description result = new StringDescription();\n        result.appendList(\"(\", \", \", \");\", applyPrintSettings(matchers, printSettings));\n        return result.toString();\n    }",
        "begin_line": 19,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/MatchersPrinter.java",
        "class_name": "org.mockito.internal.matchers.MatchersPrinter",
        "signature": "org.mockito.internal.matchers.MatchersPrinter.getArgumentsBlock(java.util.List<org.hamcrest.Matcher>, org.mockito.internal.reporting.PrintSettings)",
        "snippet": "    public String getArgumentsBlock(List<Matcher> matchers, PrintSettings printSettings) {\n        Description result = new StringDescription();\n        result.appendList(\"(\\n    \", \",\\n    \", \"\\n);\", applyPrintSettings(matchers, printSettings));\n        return result.toString();\n    }",
        "begin_line": 25,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/MatchersPrinter.java",
        "class_name": "org.mockito.internal.matchers.MatchersPrinter",
        "signature": "org.mockito.internal.matchers.MatchersPrinter.applyPrintSettings(java.util.List<org.hamcrest.Matcher>, org.mockito.internal.reporting.PrintSettings)",
        "snippet": "    private List<SelfDescribing> applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {\n        List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();\n        int i = 0;\n        for (final Matcher matcher : matchers) {\n            if (matcher instanceof ContainsExtraTypeInformation && printSettings.extraTypeInfoFor(i)) {\n                withPrintSettings.add(((ContainsExtraTypeInformation) matcher).withExtraTypeInfo());\n            } else {\n                withPrintSettings.add(matcher);\n            }\n            i++;\n        }\n        return withPrintSettings;\n    }",
        "begin_line": 31,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Or.java",
        "class_name": "org.mockito.internal.matchers.Or",
        "signature": "org.mockito.internal.matchers.Or.Or(java.util.List<org.hamcrest.Matcher>)",
        "snippet": "    public Or(List<Matcher> matchers) {\n        this.matchers = matchers;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Or.java",
        "class_name": "org.mockito.internal.matchers.Or",
        "signature": "org.mockito.internal.matchers.Or.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        for (Matcher matcher : matchers) {\n            if (matcher.matches(actual)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 26,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Or.java",
        "class_name": "org.mockito.internal.matchers.Or",
        "signature": "org.mockito.internal.matchers.Or.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"or(\");\n        for (Iterator<Matcher> it = matchers.iterator(); it.hasNext();) {\n            it.next().describeTo(description);\n            if (it.hasNext()) {\n                description.appendText(\", \");\n            }\n        }\n        description.appendText(\")\");\n    }",
        "begin_line": 35,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Contains.java",
        "class_name": "org.mockito.internal.matchers.Contains",
        "signature": "org.mockito.internal.matchers.Contains.Contains(java.lang.String)",
        "snippet": "    public Contains(String substring) {\n        this.substring = substring;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Contains.java",
        "class_name": "org.mockito.internal.matchers.Contains",
        "signature": "org.mockito.internal.matchers.Contains.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual != null && ((String) actual).contains(substring);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Contains.java",
        "class_name": "org.mockito.internal.matchers.Contains",
        "signature": "org.mockito.internal.matchers.Contains.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"contains(\\\"\" + substring + \"\\\")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/AnyVararg.java",
        "class_name": "org.mockito.internal.matchers.AnyVararg",
        "signature": "org.mockito.internal.matchers.AnyVararg.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object arg) {\n        return true;\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareTo.java",
        "class_name": "org.mockito.internal.matchers.CompareTo",
        "signature": "org.mockito.internal.matchers.CompareTo.CompareTo(java.lang.Comparable<T>)",
        "snippet": "    public CompareTo(Comparable<T> value) {\n        this.wanted = value;\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareTo.java",
        "class_name": "org.mockito.internal.matchers.CompareTo",
        "signature": "org.mockito.internal.matchers.CompareTo.matches(java.lang.Object)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public boolean matches(Object actual) {\n        \n        if(!(actual instanceof Comparable)) {\n            return false;\n        }\n        \n        return matchResult(((Comparable) actual).compareTo(wanted));\n    }",
        "begin_line": 19,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareTo.java",
        "class_name": "org.mockito.internal.matchers.CompareTo",
        "signature": "org.mockito.internal.matchers.CompareTo.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(getName() + \"(\" + wanted + \")\");\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareTo.java",
        "class_name": "org.mockito.internal.matchers.CompareTo",
        "signature": "org.mockito.internal.matchers.CompareTo.getName()",
        "snippet": "    protected abstract String getName();",
        "begin_line": 33,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/CompareTo.java",
        "class_name": "org.mockito.internal.matchers.CompareTo",
        "signature": "org.mockito.internal.matchers.CompareTo.matchResult(int)",
        "snippet": "    protected abstract boolean matchResult(int result);",
        "begin_line": 35,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Null.java",
        "class_name": "org.mockito.internal.matchers.Null",
        "signature": "org.mockito.internal.matchers.Null.Null()",
        "snippet": "    private Null() {\n    }",
        "begin_line": 19,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Null.java",
        "class_name": "org.mockito.internal.matchers.Null",
        "signature": "org.mockito.internal.matchers.Null.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual == null;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Null.java",
        "class_name": "org.mockito.internal.matchers.Null",
        "signature": "org.mockito.internal.matchers.Null.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"isNull()\");\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/StartsWith.java",
        "class_name": "org.mockito.internal.matchers.StartsWith",
        "signature": "org.mockito.internal.matchers.StartsWith.StartsWith(java.lang.String)",
        "snippet": "    public StartsWith(String prefix) {\n        this.prefix = prefix;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/StartsWith.java",
        "class_name": "org.mockito.internal.matchers.StartsWith",
        "signature": "org.mockito.internal.matchers.StartsWith.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual != null && ((String) actual).startsWith(prefix);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/StartsWith.java",
        "class_name": "org.mockito.internal.matchers.StartsWith",
        "signature": "org.mockito.internal.matchers.StartsWith.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"startsWith(\\\"\" + prefix + \"\\\")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterOrEqual.java",
        "class_name": "org.mockito.internal.matchers.GreaterOrEqual",
        "signature": "org.mockito.internal.matchers.GreaterOrEqual.GreaterOrEqual(java.lang.Comparable<T>)",
        "snippet": "    public GreaterOrEqual(Comparable<T> value) {\n        super(value);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterOrEqual.java",
        "class_name": "org.mockito.internal.matchers.GreaterOrEqual",
        "signature": "org.mockito.internal.matchers.GreaterOrEqual.getName()",
        "snippet": "    @Override\n    protected String getName() {\n        return \"geq\";\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/GreaterOrEqual.java",
        "class_name": "org.mockito.internal.matchers.GreaterOrEqual",
        "signature": "org.mockito.internal.matchers.GreaterOrEqual.matchResult(int)",
        "snippet": "    @Override\n    protected boolean matchResult(int result) {\n        return result >= 0;\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equality.java",
        "class_name": "org.mockito.internal.matchers.Equality",
        "signature": "org.mockito.internal.matchers.Equality.areEqual(java.lang.Object, java.lang.Object)",
        "snippet": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2 ) {\n            return true;\n    } else if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equality.java",
        "class_name": "org.mockito.internal.matchers.Equality",
        "signature": "org.mockito.internal.matchers.Equality.areArraysEqual(java.lang.Object, java.lang.Object)",
        "snippet": "    static boolean areArraysEqual(Object o1, Object o2) {\n        return areArrayLengthsEqual(o1, o2)\n                && areArrayElementsEqual(o1, o2);\n    }",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equality.java",
        "class_name": "org.mockito.internal.matchers.Equality",
        "signature": "org.mockito.internal.matchers.Equality.areArrayLengthsEqual(java.lang.Object, java.lang.Object)",
        "snippet": "    static boolean areArrayLengthsEqual(Object o1, Object o2) {\n        return Array.getLength(o1) == Array.getLength(o2);\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equality.java",
        "class_name": "org.mockito.internal.matchers.Equality",
        "signature": "org.mockito.internal.matchers.Equality.areArrayElementsEqual(java.lang.Object, java.lang.Object)",
        "snippet": "    static boolean areArrayElementsEqual(Object o1, Object o2) {\n        for (int i = 0; i < Array.getLength(o1); i++) {\n            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;\n        }\n        return true;\n    }",
        "begin_line": 33,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equality.java",
        "class_name": "org.mockito.internal.matchers.Equality",
        "signature": "org.mockito.internal.matchers.Equality.isArray(java.lang.Object)",
        "snippet": "    static boolean isArray(Object o) {\n        return o.getClass().isArray();\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/And.java",
        "class_name": "org.mockito.internal.matchers.And",
        "signature": "org.mockito.internal.matchers.And.And(java.util.List<org.hamcrest.Matcher>)",
        "snippet": "    public And(List<Matcher> matchers) {\n        this.matchers = matchers;\n    }",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/And.java",
        "class_name": "org.mockito.internal.matchers.And",
        "signature": "org.mockito.internal.matchers.And.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        for (Matcher matcher : matchers) {\n            if (!matcher.matches(actual)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 26,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/And.java",
        "class_name": "org.mockito.internal.matchers.And",
        "signature": "org.mockito.internal.matchers.And.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"and(\");\n        for (Iterator<Matcher> it = matchers.iterator(); it.hasNext();) {\n            it.next().describeTo(description);\n            if (it.hasNext()) {\n                description.appendText(\", \");\n            }\n        }\n        description.appendText(\")\");\n    }",
        "begin_line": 35,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ContainsExtraTypeInformation.java",
        "class_name": "org.mockito.internal.matchers.ContainsExtraTypeInformation",
        "signature": "org.mockito.internal.matchers.ContainsExtraTypeInformation.withExtraTypeInfo()",
        "snippet": "    SelfDescribing withExtraTypeInfo();",
        "begin_line": 12,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/ContainsExtraTypeInformation.java",
        "class_name": "org.mockito.internal.matchers.ContainsExtraTypeInformation",
        "signature": "org.mockito.internal.matchers.ContainsExtraTypeInformation.typeMatches(java.lang.Object)",
        "snippet": "    boolean typeMatches(Object object);",
        "begin_line": 14,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/MatcherDecorator.java",
        "class_name": "org.mockito.internal.matchers.MatcherDecorator",
        "signature": "org.mockito.internal.matchers.MatcherDecorator.getActualMatcher()",
        "snippet": "    Matcher getActualMatcher();",
        "begin_line": 13,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessThan.java",
        "class_name": "org.mockito.internal.matchers.LessThan",
        "signature": "org.mockito.internal.matchers.LessThan.LessThan(java.lang.Comparable<T>)",
        "snippet": "    public LessThan(Comparable<T> value) {\n        super(value);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessThan.java",
        "class_name": "org.mockito.internal.matchers.LessThan",
        "signature": "org.mockito.internal.matchers.LessThan.getName()",
        "snippet": "    @Override\n    protected String getName() {\n        return \"lt\";\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/LessThan.java",
        "class_name": "org.mockito.internal.matchers.LessThan",
        "signature": "org.mockito.internal.matchers.LessThan.matchResult(int)",
        "snippet": "    @Override\n    protected boolean matchResult(int result) {\n        return result < 0;\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EqualsWithDelta.java",
        "class_name": "org.mockito.internal.matchers.EqualsWithDelta",
        "signature": "org.mockito.internal.matchers.EqualsWithDelta.EqualsWithDelta(java.lang.Number, java.lang.Number)",
        "snippet": "    public EqualsWithDelta(Number value, Number delta) {\n        this.wanted = value;\n        this.delta = delta;\n    }",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EqualsWithDelta.java",
        "class_name": "org.mockito.internal.matchers.EqualsWithDelta",
        "signature": "org.mockito.internal.matchers.EqualsWithDelta.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        Number actualNumber = (Number) actual;\n        if (wanted == null ^ actual == null) {\n            return false;\n        }\n\n        if (wanted == actual) {\n            return true;\n        }\n\n        return wanted.doubleValue() - delta.doubleValue() <= actualNumber.doubleValue()\n                && actualNumber.doubleValue() <= wanted.doubleValue()\n                        + delta.doubleValue();\n    }",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EqualsWithDelta.java",
        "class_name": "org.mockito.internal.matchers.EqualsWithDelta",
        "signature": "org.mockito.internal.matchers.EqualsWithDelta.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"eq(\" + wanted + \", \" + delta + \")\");\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/NotNull.java",
        "class_name": "org.mockito.internal.matchers.NotNull",
        "signature": "org.mockito.internal.matchers.NotNull.NotNull()",
        "snippet": "    private NotNull() {\n        \n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/NotNull.java",
        "class_name": "org.mockito.internal.matchers.NotNull",
        "signature": "org.mockito.internal.matchers.NotNull.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual != null;\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/NotNull.java",
        "class_name": "org.mockito.internal.matchers.NotNull",
        "signature": "org.mockito.internal.matchers.NotNull.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"notNull()\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.Equals(java.lang.Object)",
        "snippet": "    public Equals(Object wanted) {\n        this.wanted = wanted;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return Equality.areEqual(this.wanted, actual);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(describe(wanted));\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.describe(java.lang.Object)",
        "snippet": "    public String describe(Object object) {\n        return quoting() + object + quoting();\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.quoting()",
        "snippet": "    private String quoting() {\n        if (wanted instanceof String) {\n            return \"\\\"\";\n        } else if (wanted instanceof Character) {\n            return \"'\";\n        } else {\n            return \"\";\n        }\n    }",
        "begin_line": 35,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.getWanted()",
        "snippet": "    protected final Object getWanted() {\n        return wanted;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (o == null || !this.getClass().equals(o.getClass())) {\n            return false;\n        }\n        Equals other = (Equals) o;\n        return this.wanted == null && other.wanted == null || this.wanted != null && this.wanted.equals(other.wanted);\n    }",
        "begin_line": 49,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        return 1;\n    }",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.withExtraTypeInfo()",
        "snippet": "    public SelfDescribing withExtraTypeInfo() {\n        return new SelfDescribing() {\n            public void describeTo(Description description) {\n                description.appendText(describe(\"(\"+ wanted.getClass().getSimpleName() +\") \" + wanted));\n            }};\n    }",
        "begin_line": 63,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.Anonymous-c509757d-5346-4fa2-9965-ebb02de15a5d.describeTo(org.hamcrest.Description)",
        "snippet": "            public void describeTo(Description description) {\n                description.appendText(describe(\"(\"+ wanted.getClass().getSimpleName() +\") \" + wanted));\n            }};",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/Equals.java",
        "class_name": "org.mockito.internal.matchers.Equals",
        "signature": "org.mockito.internal.matchers.Equals.typeMatches(java.lang.Object)",
        "snippet": "    public boolean typeMatches(Object object) {\n        return wanted != null && object != null && object.getClass() == wanted.getClass();\n    }",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object argument) {\n        return true;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"<Capturing variable argument>\");\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.getLastVarargs()",
        "snippet": "    public List<T> getLastVarargs() {\n        if (arguments.isEmpty()) {\n            new Reporter().noArgumentValueWasCaptured();\n            return null;\n        } else {\n            return arguments.getLast();\n        }\n    }",
        "begin_line": 28,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.getAllVarargs()",
        "snippet": "    public List<List<T>> getAllVarargs() {\n        return arguments;\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.captureFrom(java.lang.Object)",
        "snippet": "    public void captureFrom(Object varArgArray) {\n        List<T> vararg = unpackAsList(varArgArray);\n        this.arguments.add(vararg);\n    }",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/VarargCapturingMatcher.java",
        "class_name": "org.mockito.internal.matchers.VarargCapturingMatcher",
        "signature": "org.mockito.internal.matchers.VarargCapturingMatcher.unpackAsList(java.lang.Object)",
        "snippet": "    private List<T> unpackAsList(Object varArgArray) {\n        if (varArgArray instanceof Object[]) {\n            return Arrays.asList((T[]) varArgArray);\n        } else if (varArgArray.getClass().isArray()) {\n            Object[] primitiveArray = new Object[Array.getLength(varArgArray)];\n            for (int i = 0; i < primitiveArray.length; i++) {\n                primitiveArray[i] = Array.get(varArgArray, i);\n            }\n            return Arrays.asList((T[]) primitiveArray);\n        } else {\n            return Collections.singletonList((T) varArgArray);\n        }\n    }",
        "begin_line": 46,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EndsWith.java",
        "class_name": "org.mockito.internal.matchers.EndsWith",
        "signature": "org.mockito.internal.matchers.EndsWith.EndsWith(java.lang.String)",
        "snippet": "    public EndsWith(String suffix) {\n        this.suffix = suffix;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EndsWith.java",
        "class_name": "org.mockito.internal.matchers.EndsWith",
        "signature": "org.mockito.internal.matchers.EndsWith.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return actual != null && ((String) actual).endsWith(suffix);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/EndsWith.java",
        "class_name": "org.mockito.internal.matchers.EndsWith",
        "signature": "org.mockito.internal.matchers.EndsWith.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"endsWith(\\\"\" + suffix + \"\\\")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.ReflectionEquals",
        "signature": "org.mockito.internal.matchers.apachecommons.ReflectionEquals.ReflectionEquals(java.lang.Object, java.lang.String...)",
        "snippet": "    public ReflectionEquals(Object wanted, String... excludeFields) {\n        this.wanted = wanted;\n        this.excludeFields = excludeFields;\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.ReflectionEquals",
        "signature": "org.mockito.internal.matchers.apachecommons.ReflectionEquals.matches(java.lang.Object)",
        "snippet": "    public boolean matches(Object actual) {\n        return EqualsBuilder.reflectionEquals(wanted, actual, excludeFields);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.ReflectionEquals",
        "signature": "org.mockito.internal.matchers.apachecommons.ReflectionEquals.describeTo(org.hamcrest.Description)",
        "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"refEq(\" + wanted + \")\");\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.EqualsBuilder()",
        "snippet": "    public EqualsBuilder() {\n        // do nothing for now.\n    }",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n     * <p>Constructor for EqualsBuilder.</p>\n     *\n     * <p>Starts off assuming that equals is <code>true</code>.</p>\n     * @see Object#equals(Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals(java.lang.Object, java.lang.Object)",
        "snippet": "    public static boolean reflectionEquals(Object lhs, Object rhs) {\n        return reflectionEquals(lhs, rhs, false, null, null);\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * <p>This method uses reflection to determine if the two <code>Object</code>s\n     * are equal.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly.</p>\n     *\n     * <p>Transient members will be not be tested, as they are likely derived\n     * fields, and not part of the value of the Object.</p>\n     *\n     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n     *\n     * @param lhs  <code>this</code> object\n     * @param rhs  the other object\n     * @return <code>true</code> if the two Objects have tested equals.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals(java.lang.Object, java.lang.Object, java.lang.String[])",
        "snippet": "    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n    }",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n     * <p>This method uses reflection to determine if the two <code>Object</code>s\n     * are equal.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly.</p>\n     *\n     * <p>Transient members will be not be tested, as they are likely derived\n     * fields, and not part of the value of the Object.</p>\n     *\n     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n     *\n     * @param lhs  <code>this</code> object\n     * @param rhs  the other object\n     * @param excludeFields  array of field names to exclude from testing\n     * @return <code>true</code> if the two Objects have tested equals.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals(java.lang.Object, java.lang.Object, boolean)",
        "snippet": "    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n        return reflectionEquals(lhs, rhs, testTransients, null, null);\n    }",
        "begin_line": 162,
        "end_line": 164,
        "comment": "\n     * <p>This method uses reflection to determine if the two <code>Object</code>s\n     * are equal.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly.</p>\n     *\n     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n     * members will be tested, otherwise they are ignored, as they are likely\n     * derived fields, and not part of the value of the <code>Object</code>.</p>\n     *\n     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n     *\n     * @param lhs  <code>this</code> object\n     * @param rhs  the other object\n     * @param testTransients  whether to include transient fields\n     * @return <code>true</code> if the two Objects have tested equals.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals(java.lang.Object, java.lang.Object, boolean, java.lang.Class)",
        "snippet": "    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n    }",
        "begin_line": 191,
        "end_line": 193,
        "comment": "\n     * <p>This method uses reflection to determine if the two <code>Object</code>s\n     * are equal.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly.</p>\n     *\n     * <p>If the testTransients parameter is set to <code>true</code>, transient\n     * members will be tested, otherwise they are ignored, as they are likely\n     * derived fields, and not part of the value of the <code>Object</code>.</p>\n     *\n     * <p>Static fields will not be included. Superclass fields will be appended\n     * up to and including the specified superclass. A null superclass is treated\n     * as java.lang.Object.</p>\n     *\n     * @param lhs  <code>this</code> object\n     * @param rhs  the other object\n     * @param testTransients  whether to include transient fields\n     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n     *  may be <code>null</code>\n     * @return <code>true</code> if the two Objects have tested equals.\n     * @since 2.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals(java.lang.Object, java.lang.Object, boolean, java.lang.Class, java.lang.String[])",
        "snippet": "    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n            String[] excludeFields) {\n        if (lhs == rhs) {\n            return true;\n        }\n        if (lhs == null || rhs == null) {\n            return false;\n        }\n        // Find the leaf class since there may be transients in the leaf \n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars, \n        // then a subclass can test equals to a superclass.\n        Class lhsClass = lhs.getClass();\n        Class rhsClass = rhs.getClass();\n        Class testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass = lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass = rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass = rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass = lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            return false;\n        }\n        EqualsBuilder equalsBuilder = new EqualsBuilder();\n        try {\n            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                testClass = testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n            }\n        } catch (IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and \n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            return false;\n        }\n        return equalsBuilder.isEquals();\n    }",
        "begin_line": 221,
        "end_line": 268,
        "comment": "\n     * <p>This method uses reflection to determine if the two <code>Object</code>s\n     * are equal.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly.</p>\n     *\n     * <p>If the testTransients parameter is set to <code>true</code>, transient\n     * members will be tested, otherwise they are ignored, as they are likely\n     * derived fields, and not part of the value of the <code>Object</code>.</p>\n     *\n     * <p>Static fields will not be included. Superclass fields will be appended\n     * up to and including the specified superclass. A null superclass is treated\n     * as java.lang.Object.</p>\n     *\n     * @param lhs  <code>this</code> object\n     * @param rhs  the other object\n     * @param testTransients  whether to include transient fields\n     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n     *  may be <code>null</code>\n     * @param excludeFields  array of field names to exclude from testing\n     * @return <code>true</code> if the two Objects have tested equals.\n     * @since 2.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionAppend(java.lang.Object, java.lang.Object, java.lang.Class, org.mockito.internal.matchers.apachecommons.EqualsBuilder, boolean, java.lang.String[])",
        "snippet": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields = clazz.getDeclaredFields();\n        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n            Field f = fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                && (f.getName().indexOf('$') == -1)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can't happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
        "begin_line": 281,
        "end_line": 306,
        "comment": "\n     * <p>Appends the fields and values defined by the given object of the\n     * given Class.</p>\n     * \n     * @param lhs  the left hand object\n     * @param rhs  the right hand object\n     * @param clazz  the class to append details of\n     * @param builder  the builder to append to\n     * @param useTransients  whether to test transient fields\n     * @param excludeFields  array of field names to exclude from testing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.appendSuper(boolean)",
        "snippet": "    public EqualsBuilder appendSuper(boolean superEquals) {\n        isEquals &= superEquals;\n        return this;\n    }",
        "begin_line": 317,
        "end_line": 320,
        "comment": "\n     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n     *\n     * @param superEquals  the result of calling <code>super.equals()</code>\n     * @return EqualsBuilder - used to chain calls.\n     * @since 2.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(java.lang.Object, java.lang.Object)",
        "snippet": "    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n            if (lhs instanceof java.math.BigDecimal && rhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal) lhs).compareTo((java.math.BigDecimal) rhs) == 0);\n            } else {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n            }\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        \n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        } else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }",
        "begin_line": 332,
        "end_line": 378,
        "comment": "\n     * <p>Test if two <code>Object</code>s are equal using their\n     * <code>equals</code> method.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the right hand object\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(long, long)",
        "snippet": "    public EqualsBuilder append(long lhs, long rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 391,
        "end_line": 394,
        "comment": "\n     * <p>\n     * Test if two <code>long</code> s are equal.\n     * </p>\n     * \n     * @param lhs\n     *                  the left hand <code>long</code>\n     * @param rhs\n     *                  the right hand <code>long</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(int, int)",
        "snippet": "    public EqualsBuilder append(int lhs, int rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 403,
        "end_line": 406,
        "comment": "\n     * <p>Test if two <code>int</code>s are equal.</p>\n     *\n     * @param lhs  the left hand <code>int</code>\n     * @param rhs  the right hand <code>int</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(short, short)",
        "snippet": "    public EqualsBuilder append(short lhs, short rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 415,
        "end_line": 418,
        "comment": "\n     * <p>Test if two <code>short</code>s are equal.</p>\n     *\n     * @param lhs  the left hand <code>short</code>\n     * @param rhs  the right hand <code>short</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(char, char)",
        "snippet": "    public EqualsBuilder append(char lhs, char rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 427,
        "end_line": 430,
        "comment": "\n     * <p>Test if two <code>char</code>s are equal.</p>\n     *\n     * @param lhs  the left hand <code>char</code>\n     * @param rhs  the right hand <code>char</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(byte, byte)",
        "snippet": "    public EqualsBuilder append(byte lhs, byte rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 439,
        "end_line": 442,
        "comment": "\n     * <p>Test if two <code>byte</code>s are equal.</p>\n     *\n     * @param lhs  the left hand <code>byte</code>\n     * @param rhs  the right hand <code>byte</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(double, double)",
        "snippet": "    public EqualsBuilder append(double lhs, double rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n    }",
        "begin_line": 457,
        "end_line": 462,
        "comment": "\n     * <p>Test if two <code>double</code>s are equal by testing that the\n     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n     *\n     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * <code>HashCodeBuilder</code>.</p>\n     *\n     * @param lhs  the left hand <code>double</code>\n     * @param rhs  the right hand <code>double</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(float, float)",
        "snippet": "    public EqualsBuilder append(float lhs, float rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n    }",
        "begin_line": 477,
        "end_line": 482,
        "comment": "\n     * <p>Test if two <code>float</code>s are equal byt testing that the\n     * pattern of bits returned by doubleToLong are equal.</p>\n     *\n     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * <code>HashCodeBuilder</code>.</p>\n     *\n     * @param lhs  the left hand <code>float</code>\n     * @param rhs  the right hand <code>float</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(boolean, boolean)",
        "snippet": "    public EqualsBuilder append(boolean lhs, boolean rhs) {\n        isEquals &= (lhs == rhs);\n        return this;\n    }",
        "begin_line": 491,
        "end_line": 494,
        "comment": "\n     * <p>Test if two <code>booleans</code>s are equal.</p>\n     *\n     * @param lhs  the left hand <code>boolean</code>\n     * @param rhs  the right hand <code>boolean</code>\n     * @return EqualsBuilder - used to chain calls.\n      ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(java.lang.Object[], java.lang.Object[])",
        "snippet": "    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 506,
        "end_line": 525,
        "comment": "\n     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n     *\n     * <p>This also will be called for the top level of\n     * multi-dimensional, ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  the left hand <code>Object[]</code>\n     * @param rhs  the right hand <code>Object[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(long[], long[])",
        "snippet": "    public EqualsBuilder append(long[] lhs, long[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 537,
        "end_line": 556,
        "comment": "\n     * <p>Deep comparison of array of <code>long</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(long, long)} is used.</p>\n     *\n     * @param lhs  the left hand <code>long[]</code>\n     * @param rhs  the right hand <code>long[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(int[], int[])",
        "snippet": "    public EqualsBuilder append(int[] lhs, int[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 568,
        "end_line": 587,
        "comment": "\n     * <p>Deep comparison of array of <code>int</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(int, int)} is used.</p>\n     *\n     * @param lhs  the left hand <code>int[]</code>\n     * @param rhs  the right hand <code>int[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(short[], short[])",
        "snippet": "    public EqualsBuilder append(short[] lhs, short[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 599,
        "end_line": 618,
        "comment": "\n     * <p>Deep comparison of array of <code>short</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(short, short)} is used.</p>\n     *\n     * @param lhs  the left hand <code>short[]</code>\n     * @param rhs  the right hand <code>short[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(char[], char[])",
        "snippet": "    public EqualsBuilder append(char[] lhs, char[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 630,
        "end_line": 649,
        "comment": "\n     * <p>Deep comparison of array of <code>char</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(char, char)} is used.</p>\n     *\n     * @param lhs  the left hand <code>char[]</code>\n     * @param rhs  the right hand <code>char[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(byte[], byte[])",
        "snippet": "    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 661,
        "end_line": 680,
        "comment": "\n     * <p>Deep comparison of array of <code>byte</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(byte, byte)} is used.</p>\n     *\n     * @param lhs  the left hand <code>byte[]</code>\n     * @param rhs  the right hand <code>byte[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(double[], double[])",
        "snippet": "    public EqualsBuilder append(double[] lhs, double[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 692,
        "end_line": 711,
        "comment": "\n     * <p>Deep comparison of array of <code>double</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(double, double)} is used.</p>\n     *\n     * @param lhs  the left hand <code>double[]</code>\n     * @param rhs  the right hand <code>double[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(float[], float[])",
        "snippet": "    public EqualsBuilder append(float[] lhs, float[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 723,
        "end_line": 742,
        "comment": "\n     * <p>Deep comparison of array of <code>float</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(float, float)} is used.</p>\n     *\n     * @param lhs  the left hand <code>float[]</code>\n     * @param rhs  the right hand <code>float[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.append(boolean[], boolean[])",
        "snippet": "    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }",
        "begin_line": 754,
        "end_line": 773,
        "comment": "\n     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n     * values are compared.</p>\n     *\n     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n     *\n     * @param lhs  the left hand <code>boolean[]</code>\n     * @param rhs  the right hand <code>boolean[]</code>\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.isEquals()",
        "snippet": "    public boolean isEquals() {\n        return this.isEquals;\n    }",
        "begin_line": 781,
        "end_line": 783,
        "comment": "\n     * <p>Returns <code>true</code> if the fields that have been checked\n     * are all equal.</p>\n     *\n     * @return boolean\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java",
        "class_name": "org.mockito.internal.matchers.apachecommons.EqualsBuilder",
        "signature": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.setEquals(boolean)",
        "snippet": "    protected void setEquals(boolean isEquals) {\n        this.isEquals = isEquals;\n    }",
        "begin_line": 791,
        "end_line": 793,
        "comment": "\n     * Sets the <code>isEquals</code> value.\n     * \n     * @param isEquals The value to set.\n     * @since 2.1\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/AbstractAwareMethod.java",
        "class_name": "org.mockito.internal.invocation.AbstractAwareMethod",
        "signature": "org.mockito.internal.invocation.AbstractAwareMethod.isAbstract()",
        "snippet": "    boolean isAbstract();",
        "begin_line": 9,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MatchersBinder.java",
        "class_name": "org.mockito.internal.invocation.MatchersBinder",
        "signature": "org.mockito.internal.invocation.MatchersBinder.bindMatchers(org.mockito.internal.progress.ArgumentMatcherStorage, org.mockito.invocation.Invocation)",
        "snippet": "    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n        List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();\n        validateMatchers(invocation, lastMatchers);\n\n        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<Matcher>)(List) lastMatchers);\n        return invocationWithMatchers;\n    }",
        "begin_line": 22,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MatchersBinder.java",
        "class_name": "org.mockito.internal.invocation.MatchersBinder",
        "signature": "org.mockito.internal.invocation.MatchersBinder.validateMatchers(org.mockito.invocation.Invocation, java.util.List<org.mockito.internal.matchers.LocalizedMatcher>)",
        "snippet": "    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n        if (!lastMatchers.isEmpty()) {\n            int recordedMatchersSize = lastMatchers.size();\n            int expectedMatchersSize = invocation.getArguments().length;\n            if (expectedMatchersSize != recordedMatchersSize) {\n                new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);\n            }\n        }\n    }",
        "begin_line": 30,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java",
        "class_name": "org.mockito.internal.invocation.CapturesArgumensFromInvocation",
        "signature": "org.mockito.internal.invocation.CapturesArgumensFromInvocation.captureArgumentsFrom(org.mockito.invocation.Invocation)",
        "snippet": "    void captureArgumentsFrom(Invocation i);",
        "begin_line": 12,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findInvocations(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findAllMatchingUnverifiedChunks(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n        List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);\n        return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, int, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n        List<Invocation> unverified = removeVerifiedInOrder(invocations, context);\n        List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n        \n        if (wantedCount != firstChunk.size()) {\n            return this.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n        } else {\n            return firstChunk;\n        }\n    }",
        "begin_line": 43,
        "end_line": 52,
        "comment": "\n     * some examples how it works:\n     * \n     * Given invocations sequence:\n     * 1,1,2,1\n     * \n     * if wanted is 1 and mode is times(2) then returns\n     * 1,1  \n     * \n     * if wanted is 1 and mode is atLeast() then returns\n     * 1,1,1\n     * \n     * if wanted is 1 and mode is times(x), where x != 2 then returns\n     * 1,1,1\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.getFirstMatchingChunk(org.mockito.internal.invocation.InvocationMatcher, java.util.List<org.mockito.invocation.Invocation>)",
        "snippet": "    private List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {\n        List<Invocation> firstChunk = new LinkedList<Invocation>();\n        for (Invocation invocation : unverified) {\n            if (wanted.matches(invocation)) {\n                firstChunk.add(invocation);\n            } else if (!firstChunk.isEmpty()) {\n                break;\n            }\n        }\n        return firstChunk;\n    }",
        "begin_line": 54,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n            if( wanted.matches( invocation )){\n                return invocation;\n            }\n        }\n        return null;\n    }",
        "begin_line": 66,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n        Invocation firstSimilar = null;\n        for (Invocation invocation : invocations) {\n            if (!wanted.hasSimilarMethod(invocation)) {\n                continue;\n            }\n            if (firstSimilar == null) {\n                firstSimilar = invocation;\n            }\n            if (wanted.hasSameMethod(invocation)) {\n                return invocation;\n            }\n        }\n        \n        return firstSimilar;\n    }",
        "begin_line": 75,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified(java.util.List<org.mockito.invocation.Invocation>)",
        "snippet": "    public Invocation findFirstUnverified(List<Invocation> invocations) {\n        return findFirstUnverified(invocations, null);\n    }",
        "begin_line": 92,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findFirstUnverified(java.util.List<org.mockito.invocation.Invocation>, java.lang.Object)",
        "snippet": "    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n        for (Invocation i : invocations) {\n            boolean mockIsValid = mock == null || mock == i.getMock();\n            if (!i.isVerified() && mockIsValid) {\n                return i;\n            }\n        }\n        return null;\n    }",
        "begin_line": 96,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.getLastLocation(java.util.List<org.mockito.invocation.Invocation>)",
        "snippet": "    public Location getLastLocation(List<Invocation> invocations) {\n        if (invocations.isEmpty()) {\n            return null;\n        } else {\n            Invocation last = invocations.get(invocations.size() - 1);\n            return last.getLocation();\n        }\n    }",
        "begin_line": 106,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findPreviousVerifiedInOrder(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n        \n        if (verifiedOnly.isEmpty()) {\n            return null;\n        } else {\n            return verifiedOnly.getLast();\n        }\n    }",
        "begin_line": 115,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.removeVerifiedInOrder(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {\n        List<Invocation> unverified = new LinkedList<Invocation>();\n        for (Invocation i : invocations) {\n            if (orderingContext.isVerified(i)) {\n                unverified.clear();\n            } else {\n                unverified.add(i);\n            }\n        }\n        return unverified;\n    }",
        "begin_line": 125,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.RemoveNotMatching.RemoveNotMatching(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "        private RemoveNotMatching(InvocationMatcher wanted) {\n            this.wanted = wanted;\n        }",
        "begin_line": 140,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.RemoveNotMatching.isOut(org.mockito.invocation.Invocation)",
        "snippet": "        public boolean isOut(Invocation invocation) {\n            return !wanted.matches(invocation);\n        }",
        "begin_line": 144,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.RemoveUnverifiedInOrder.RemoveUnverifiedInOrder(org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "        public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n            this.orderingContext = orderingContext;\n        }",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.RemoveUnverifiedInOrder.isOut(org.mockito.invocation.Invocation)",
        "snippet": "        public boolean isOut(Invocation invocation) {\n            return !orderingContext.isVerified(invocation);\n        }",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.InvocationsFinder",
        "signature": "org.mockito.internal.invocation.InvocationsFinder.findFirstUnverifiedInOrder(org.mockito.internal.verification.api.InOrderContext, java.util.List<org.mockito.invocation.Invocation>)",
        "snippet": "    public Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {\n        Invocation candidate = null;\n        for(Invocation i : orderedInvocations) {\n            if (!context.isVerified(i)) {\n                candidate = candidate != null ? candidate : i;\n            } else {\n                candidate = null;\n            }\n        }\n        return candidate;\n    }",
        "begin_line": 175,
        "end_line": 185,
        "comment": "\n     * i3 is unverified here:\n     * \n     * i1, i2, i3\n     *     v\n     *     \n     * all good here:\n     * \n     * i1, i2, i3\n     *     v   v\n     * \n     * @param context\n     * @param orderedInvocations\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.InvocationMatcher(org.mockito.invocation.Invocation, java.util.List<org.hamcrest.Matcher>)",
        "snippet": "    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }",
        "begin_line": 30,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.InvocationMatcher(org.mockito.invocation.Invocation)",
        "snippet": "    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.getMethod()",
        "snippet": "    public Method getMethod() {\n        return invocation.getMethod();\n    }",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.getInvocation()",
        "snippet": "    public Invocation getInvocation() {\n        return this.invocation;\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.getMatchers()",
        "snippet": "    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.toString()",
        "snippet": "    public String toString() {\n        return new PrintSettings().print(matchers, invocation);\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.matches(org.mockito.invocation.Invocation)",
        "snippet": "    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }",
        "begin_line": 59,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.safelyArgumentsMatch(java.lang.Object[])",
        "snippet": "    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
        "begin_line": 65,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSimilarMethod(org.mockito.invocation.Invocation)",
        "snippet": "    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }",
        "begin_line": 77,
        "end_line": 93,
        "comment": "\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSameMethod(org.mockito.invocation.Invocation)",
        "snippet": "    public boolean hasSameMethod(Invocation candidate) {\n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n            /* Avoid unnecessary cloning */\n            Class[] params1 = m1.getParameterTypes();\n            Class[] params2 = m2.getParameterTypes();\n            if (params1.length == params2.length) {\n                for (int i = 0; i < params1.length; i++) {\n                if (params1[i] != params2[i])\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 95,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.getLocation()",
        "snippet": "    public Location getLocation() {\n        return invocation.getLocation();\n    }",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(org.mockito.invocation.Invocation)",
        "snippet": "    public void captureArgumentsFrom(Invocation invocation) {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                //TODO SF - this whole lot can be moved captureFrom implementation\n                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    //since we've captured all varargs already, it does not make sense to process other matchers.\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    }",
        "begin_line": 120,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.isVarargMatcher(org.hamcrest.Matcher)",
        "snippet": "    private boolean isVarargMatcher(Matcher matcher) {\n        Matcher actualMatcher = matcher;\n        if (actualMatcher instanceof MatcherDecorator) {\n            actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();\n        }\n        return actualMatcher instanceof VarargMatcher;\n    }",
        "begin_line": 139,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.isVariableArgument(org.mockito.invocation.Invocation, int)",
        "snippet": "    private boolean isVariableArgument(Invocation invocation, int position) {\n        return invocation.getRawArguments().length - 1 == position\n                && invocation.getRawArguments()[position] != null\n                && invocation.getRawArguments()[position].getClass().isArray()\n                && invocation.getMethod().isVarArgs();\n    }",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMatcher.java",
        "class_name": "org.mockito.internal.invocation.InvocationMatcher",
        "signature": "org.mockito.internal.invocation.InvocationMatcher.createFrom(java.util.List<org.mockito.invocation.Invocation>)",
        "snippet": "    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }",
        "begin_line": 154,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/ArgumentsProcessor.java",
        "class_name": "org.mockito.internal.invocation.ArgumentsProcessor",
        "signature": "org.mockito.internal.invocation.ArgumentsProcessor.expandVarArgs(boolean, java.lang.Object[])",
        "snippet": "    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }",
        "begin_line": 21,
        "end_line": 39,
        "comment": " varArgs (1, a, b);",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/ArgumentsProcessor.java",
        "class_name": "org.mockito.internal.invocation.ArgumentsProcessor",
        "signature": "org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers(java.lang.Object[])",
        "snippet": "    public static List<Matcher> argumentsToMatchers(Object[] arguments) {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }",
        "begin_line": 41,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/UnusedStubsFinder.java",
        "class_name": "org.mockito.internal.invocation.UnusedStubsFinder",
        "signature": "org.mockito.internal.invocation.UnusedStubsFinder.find(java.util.List<?>)",
        "snippet": "    public List<Invocation> find(List<?> mocks) {\n        List<Invocation> unused = new LinkedList<Invocation>();\n        for (Object mock : mocks) {\n            InternalMockHandler<Object> handler = new MockUtil().getMockHandler(mock);\n            List<StubbedInvocationMatcher> fromSingleMock = handler.getInvocationContainer().getStubbedInvocations();\n            for(StubbedInvocationMatcher s : fromSingleMock) {\n                if (!s.wasUsed()) {\n                     unused.add(s.getInvocation());\n                }\n            }\n        }\n        return unused;\n    }",
        "begin_line": 22,
        "end_line": 34,
        "comment": "\n     * Finds all unused stubs for given mocks\n     * \n     * @param mocks\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.getName()",
        "snippet": "    public String getName();",
        "begin_line": 11,
        "end_line": 11,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.getReturnType()",
        "snippet": "    public Class<?> getReturnType();",
        "begin_line": 13,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.getParameterTypes()",
        "snippet": "    public Class<?>[] getParameterTypes();",
        "begin_line": 15,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.getExceptionTypes()",
        "snippet": "    public Class<?>[] getExceptionTypes();",
        "begin_line": 17,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.isVarArgs()",
        "snippet": "    public boolean isVarArgs();",
        "begin_line": 19,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/MockitoMethod.java",
        "class_name": "org.mockito.internal.invocation.MockitoMethod",
        "signature": "org.mockito.internal.invocation.MockitoMethod.getJavaMethod()",
        "snippet": "    public Method getJavaMethod();",
        "begin_line": 21,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.InvocationImpl(java.lang.Object, org.mockito.internal.invocation.MockitoMethod, java.lang.Object[], int, org.mockito.internal.invocation.realmethod.RealMethod)",
        "snippet": "    public InvocationImpl(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new LocationImpl();\n    }",
        "begin_line": 43,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getMock()",
        "snippet": "    public Object getMock() {\n        return mock;\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getMethod()",
        "snippet": "    public Method getMethod() {\n        return method.getJavaMethod();\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getArguments()",
        "snippet": "    public Object[] getArguments() {\n        return arguments;\n    }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getArgumentAt(int, java.lang.Class<T>)",
        "snippet": "    public <T> T getArgumentAt(int index, Class<T> clazz) {\n        return (T) arguments[index];\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.isVerified()",
        "snippet": "    public boolean isVerified() {\n        return verified || isIgnoredForVerification;\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getSequenceNumber()",
        "snippet": "    public int getSequenceNumber() {\n        return sequenceNumber;\n    }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object o) {\n        if (o == null || !o.getClass().equals(this.getClass())) {\n            return false;\n        }\n\n        InvocationImpl other = (InvocationImpl) o;\n\n        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n    }",
        "begin_line": 77,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.equalArguments(java.lang.Object[])",
        "snippet": "    private boolean equalArguments(Object[] arguments) {\n        return Arrays.equals(arguments, this.arguments);\n    }",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        return 1;\n    }",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.toString()",
        "snippet": "    public String toString() {\n        return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);\n    }",
        "begin_line": 96,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getLocation()",
        "snippet": "    public Location getLocation() {\n        return location;\n    }",
        "begin_line": 100,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getRawArguments()",
        "snippet": "    public Object[] getRawArguments() {\n        return this.rawArguments;\n    }",
        "begin_line": 104,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.getRawReturnType()",
        "snippet": "    public Class<?> getRawReturnType() {\n        return method.getReturnType();\n    }",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.callRealMethod()",
        "snippet": "    public Object callRealMethod() throws Throwable {\n        if (method.isAbstract()) {\n            new Reporter().cannotCallAbstractRealMethod();\n        }\n        return realMethod.invoke(mock, rawArguments);\n    }",
        "begin_line": 112,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.markVerified()",
        "snippet": "    public void markVerified() {\n        this.verified = true;\n    }",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.stubInfo()",
        "snippet": "    public StubInfo stubInfo() {\n        return stubInfo;\n    }",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.markStubbed(org.mockito.invocation.StubInfo)",
        "snippet": "    public void markStubbed(StubInfo stubInfo) {\n        this.stubInfo = stubInfo;\n    }",
        "begin_line": 127,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.isIgnoredForVerification()",
        "snippet": "    public boolean isIgnoredForVerification() {\n        return isIgnoredForVerification;\n    }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationImpl.java",
        "class_name": "org.mockito.internal.invocation.InvocationImpl",
        "signature": "org.mockito.internal.invocation.InvocationImpl.ignoreForVerification()",
        "snippet": "    public void ignoreForVerification() {\n        isIgnoredForVerification = true;\n    }",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/ArgumentsComparator.java",
        "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
        "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(org.mockito.internal.invocation.InvocationMatcher, org.mockito.invocation.Invocation)",
        "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        Object[] actualArgs = actual.getArguments();\n        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n    }",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/ArgumentsComparator.java",
        "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
        "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(org.mockito.internal.invocation.InvocationMatcher, java.lang.Object[])",
        "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {\n        if (actualArgs.length != invocationMatcher.getMatchers().size()) {\n            return false;\n        }\n        for (int i = 0; i < actualArgs.length; i++) {\n            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 21,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/ArgumentsComparator.java",
        "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
        "signature": "org.mockito.internal.invocation.ArgumentsComparator.varArgsMatch(org.mockito.internal.invocation.InvocationMatcher, org.mockito.invocation.Invocation)",
        "snippet": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
        "begin_line": 34,
        "end_line": 70,
        "comment": "ok, this method is a little bit messy but the vararg business unfortunately is messy...      ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMarker.java",
        "class_name": "org.mockito.internal.invocation.InvocationMarker",
        "signature": "org.mockito.internal.invocation.InvocationMarker.markVerified(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.CapturesArgumensFromInvocation)",
        "snippet": "    public void markVerified(List<Invocation> invocations, CapturesArgumensFromInvocation wanted) {\n        for (Invocation invocation : invocations) {\n            markVerified(invocation, wanted);\n        }\n    }",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMarker.java",
        "class_name": "org.mockito.internal.invocation.InvocationMarker",
        "signature": "org.mockito.internal.invocation.InvocationMarker.markVerified(org.mockito.invocation.Invocation, org.mockito.internal.invocation.CapturesArgumensFromInvocation)",
        "snippet": "    public void markVerified(Invocation invocation, CapturesArgumensFromInvocation wanted) {\n        invocation.markVerified();\n        wanted.captureArgumentsFrom(invocation);\n    }",
        "begin_line": 20,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/InvocationMarker.java",
        "class_name": "org.mockito.internal.invocation.InvocationMarker",
        "signature": "org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder(java.util.List<org.mockito.invocation.Invocation>, org.mockito.internal.invocation.CapturesArgumensFromInvocation, org.mockito.internal.verification.api.InOrderContext)",
        "snippet": "    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n        markVerified(chunk, wanted);\n        \n        for (Invocation i : chunk) {\n            context.markVerified(i);\n        }\n    }",
        "begin_line": 25,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/StubInfoImpl.java",
        "class_name": "org.mockito.internal.invocation.StubInfoImpl",
        "signature": "org.mockito.internal.invocation.StubInfoImpl.StubInfoImpl(org.mockito.invocation.DescribedInvocation)",
        "snippet": "    public StubInfoImpl(DescribedInvocation stubbedAt) {\n        this.stubbedAt = stubbedAt;\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/StubInfoImpl.java",
        "class_name": "org.mockito.internal.invocation.StubInfoImpl",
        "signature": "org.mockito.internal.invocation.StubInfoImpl.stubbedAt()",
        "snippet": "    public Location stubbedAt() {\n        return stubbedAt.getLocation();\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.SerializableMethod(java.lang.reflect.Method)",
        "snippet": "    public SerializableMethod(Method method) {\n        declaringClass = method.getDeclaringClass();\n        methodName = method.getName();\n        parameterTypes = method.getParameterTypes();\n        returnType = method.getReturnType();\n        exceptionTypes = method.getExceptionTypes();\n        isVarArgs = method.isVarArgs();\n        isAbstract = (method.getModifiers() & Modifier.ABSTRACT) != 0;\n    }",
        "begin_line": 26,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.getName()",
        "snippet": "    public String getName() {\n        return methodName;\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.getReturnType()",
        "snippet": "    public Class<?> getReturnType() {\n        return returnType;\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.getParameterTypes()",
        "snippet": "    public Class<?>[] getParameterTypes() {\n        return parameterTypes;\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.getExceptionTypes()",
        "snippet": "    public Class<?>[] getExceptionTypes() {\n        return exceptionTypes;\n    }",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.isVarArgs()",
        "snippet": "    public boolean isVarArgs() {\n        return isVarArgs;\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.isAbstract()",
        "snippet": "    public boolean isAbstract() {\n        return isAbstract;\n    }",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.getJavaMethod()",
        "snippet": "    public Method getJavaMethod() {\n        try {\n            return declaringClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (SecurityException e) {\n            String message = String.format(\n                    \"The method %1$s.%2$s is probably private or protected and cannot be mocked.\\n\" +\n                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n            throw new MockitoException(message, e);\n        } catch (NoSuchMethodException e) {\n            String message = String.format(\n                    \"The method %1$s.%2$s does not exists and you should not get to this point.\\n\" +\n                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n            throw new MockitoException(message, e);\n        }\n    }",
        "begin_line": 60,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        return 1;\n    }",
        "begin_line": 76,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/SerializableMethod.java",
        "class_name": "org.mockito.internal.invocation.SerializableMethod",
        "signature": "org.mockito.internal.invocation.SerializableMethod.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        SerializableMethod other = (SerializableMethod) obj;\n        if (declaringClass == null) {\n            if (other.declaringClass != null)\n                return false;\n        } else if (!declaringClass.equals(other.declaringClass))\n            return false;\n        if (methodName == null) {\n            if (other.methodName != null)\n                return false;\n        } else if (!methodName.equals(other.methodName))\n            return false;\n        if (!Arrays.equals(parameterTypes, other.parameterTypes))\n            return false;\n        if (returnType == null) {\n            if (other.returnType != null)\n                return false;\n        } else if (!returnType.equals(other.returnType))\n            return false;\n        return true;\n    }",
        "begin_line": 81,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/DefaultRealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.DefaultRealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.DefaultRealMethod.DefaultRealMethod(org.mockito.internal.creation.util.MockitoMethodProxy)",
        "snippet": "    public DefaultRealMethod(MockitoMethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/DefaultRealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.DefaultRealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.DefaultRealMethod.invoke(java.lang.Object, java.lang.Object[])",
        "snippet": "    public Object invoke(Object target, Object[] arguments) throws Throwable {\n        return methodProxy.invokeSuper(target, arguments);\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/CleanTraceRealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod.CleanTraceRealMethod(org.mockito.internal.creation.util.MockitoMethodProxy)",
        "snippet": "    public CleanTraceRealMethod(MockitoMethodProxy methodProxy) {\n        this(new DefaultRealMethod(methodProxy));\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/CleanTraceRealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod.CleanTraceRealMethod(org.mockito.internal.invocation.realmethod.RealMethod)",
        "snippet": "    public CleanTraceRealMethod(RealMethod realMethod) {\n        this.realMethod = realMethod;\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/CleanTraceRealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.CleanTraceRealMethod.invoke(java.lang.Object, java.lang.Object[])",
        "snippet": "    public Object invoke(Object target, Object[] arguments) throws Throwable {\n        try {\n            return realMethod.invoke(target, arguments);\n        } catch (Throwable t) {\n            new ConditionalStackTraceFilter().filter(t);\n            throw t;\n        }\n    }",
        "begin_line": 28,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/realmethod/RealMethod.java",
        "class_name": "org.mockito.internal.invocation.realmethod.RealMethod",
        "signature": "org.mockito.internal.invocation.realmethod.RealMethod.invoke(java.lang.Object, java.lang.Object[])",
        "snippet": "    Object invoke(Object target, Object[] arguments) throws Throwable;",
        "begin_line": 9,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.finder.AllInvocationsFinder",
        "signature": "org.mockito.internal.invocation.finder.AllInvocationsFinder.find(java.util.List<?>)",
        "snippet": "    public List<Invocation> find(List<?> mocks) {\n        Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n        for (Object mock : mocks) {\n            InternalMockHandler<Object> handler = new MockUtil().getMockHandler(mock);\n            List<Invocation> fromSingleMock = handler.getInvocationContainer().getInvocations();\n            invocationsInOrder.addAll(fromSingleMock);\n        }\n        \n        return new LinkedList<Invocation>(invocationsInOrder);\n    }",
        "begin_line": 22,
        "end_line": 31,
        "comment": "\n     * gets all invocations from mocks. Invocations are ordered earlier first. \n     * \n     * @param mocks mocks\n     * @return invocations\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.finder.AllInvocationsFinder",
        "signature": "org.mockito.internal.invocation.finder.AllInvocationsFinder.SequenceNumberComparator.compare(org.mockito.invocation.Invocation, org.mockito.invocation.Invocation)",
        "snippet": "        public int compare(Invocation o1, Invocation o2) {\n            return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n        }",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder",
        "signature": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find(java.util.List<?>)",
        "snippet": "    public List<Invocation> find(List<?> mocks) {\n        List<Invocation> invocations = new AllInvocationsFinder().find(mocks);\n        return ListUtil.filter(invocations, new RemoveIgnoredForVerification());\n    }",
        "begin_line": 19,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java",
        "class_name": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder",
        "signature": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.RemoveIgnoredForVerification.isOut(org.mockito.invocation.Invocation)",
        "snippet": "        public boolean isOut(Invocation invocation) {\n            return invocation.isIgnoredForVerification();\n        }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainer.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainer",
        "signature": "org.mockito.internal.stubbing.InvocationContainer.getInvocations()",
        "snippet": "    List<Invocation> getInvocations();",
        "begin_line": 13,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainer.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainer",
        "signature": "org.mockito.internal.stubbing.InvocationContainer.getStubbedInvocations()",
        "snippet": "    List<StubbedInvocationMatcher> getStubbedInvocations();",
        "begin_line": 15,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.when(T)",
        "snippet": "    public <T> T when(T mock) {\n        MockUtil mockUtil = new MockUtil();\n        \n        if (mock == null) {\n            reporter.nullPassedToWhenMethod();\n        } else {\n            if (!mockUtil.isMock(mock)) {\n                reporter.notAMockPassedToWhenMethod();\n            }\n        }\n        \n        mockUtil.getMockHandler(mock).setAnswersForStubbing(answers);\n        return mock;\n    }",
        "begin_line": 22,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doReturn(java.lang.Object)",
        "snippet": "    public Stubber doReturn(Object toBeReturned) {\n        answers.add(new Returns(toBeReturned));\n        return this;\n    }",
        "begin_line": 37,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doThrow(java.lang.Throwable)",
        "snippet": "    public Stubber doThrow(Throwable toBeThrown) {\n        answers.add(new ThrowsException(toBeThrown));\n        return this;\n    }",
        "begin_line": 42,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    public Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n        answers.add(new ThrowsExceptionClass(toBeThrown));\n        return this;\n    }",
        "begin_line": 47,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doNothing()",
        "snippet": "    public Stubber doNothing() {\n        answers.add(new DoesNothing());\n        return this;\n    }",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public Stubber doAnswer(Answer answer) {\n        answers.add(answer);\n        return this;\n    }",
        "begin_line": 57,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubberImpl.java",
        "class_name": "org.mockito.internal.stubbing.StubberImpl",
        "signature": "org.mockito.internal.stubbing.StubberImpl.doCallRealMethod()",
        "snippet": "    public Stubber doCallRealMethod() {\n        answers.add(new CallsRealMethods());\n        return this;\n    }",
        "begin_line": 62,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenReturn(T)",
        "snippet": "    public OngoingStubbing<T> thenReturn(T value) {\n        return thenAnswer(new Returns(value));\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "TODO why we need this method? The other thenReturn covers it.",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenReturn(T, T...)",
        "snippet": "    public OngoingStubbing<T> thenReturn(T value, T... values) {\n        OngoingStubbing<T> stubbing = thenReturn(value);            \n        if (values == null) {\n            //TODO below does not seem right\n            return stubbing.thenReturn(null);\n        }\n        for (T v: values) {\n            stubbing = stubbing.thenReturn(v);\n        }\n        return stubbing;\n    }",
        "begin_line": 21,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenThrow(java.lang.Throwable)",
        "snippet": "    private OngoingStubbing<T> thenThrow(Throwable throwable) {\n        return thenAnswer(new ThrowsException(throwable));\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenThrow(java.lang.Throwable...)",
        "snippet": "    public OngoingStubbing<T> thenThrow(Throwable... throwables) {\n        if (throwables == null) {\n            thenThrow((Throwable) null);\n        }\n        OngoingStubbing<T> stubbing = null;\n        for (Throwable t: throwables) {\n            if (stubbing == null) {\n                stubbing = thenThrow(t);                    \n            } else {\n                stubbing = stubbing.thenThrow(t);\n            }\n        }\n        return stubbing;\n    }        ",
        "begin_line": 37,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    private OngoingStubbing<T> thenThrow(Class<? extends Throwable> throwableClass) {\n        return thenAnswer(new ThrowsExceptionClass(throwableClass));\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenThrow(java.lang.Class<? extends java.lang.Throwable>...)",
        "snippet": "    public OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses) {\n        if (throwableClasses == null) {\n            thenThrow((Throwable) null);\n        }\n        OngoingStubbing<T> stubbing = null;\n        for (Class<? extends Throwable> t: throwableClasses) {\n            if (stubbing == null) {\n                stubbing = thenThrow(t);\n            } else {\n                stubbing = stubbing.thenThrow(t);\n            }\n        }\n        return stubbing;\n    }",
        "begin_line": 56,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.thenCallRealMethod()",
        "snippet": "    public OngoingStubbing<T> thenCallRealMethod() {\n        return thenAnswer(new CallsRealMethods());\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.toReturn(T)",
        "snippet": "    public DeprecatedOngoingStubbing<T> toReturn(T value) {\n        return toAnswer(new Returns(value));\n    }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/BaseStubbing.java",
        "class_name": "org.mockito.internal.stubbing.BaseStubbing",
        "signature": "org.mockito.internal.stubbing.BaseStubbing.toThrow(java.lang.Throwable)",
        "snippet": "    public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n        return toAnswer(new ThrowsException(throwable));\n    }",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.InvocationContainerImpl(org.mockito.internal.progress.MockingProgress, org.mockito.mock.MockCreationSettings)",
        "snippet": "    public InvocationContainerImpl(MockingProgress mockingProgress, MockCreationSettings mockSettings) {\n        this.mockingProgress = mockingProgress;\n        this.registeredInvocations = createRegisteredInvocations(mockSettings);\n    }",
        "begin_line": 34,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.setInvocationForPotentialStubbing(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n        registeredInvocations.add(invocation.getInvocation());\n        this.invocationForStubbing = invocation;\n    }",
        "begin_line": 39,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.resetInvocationForPotentialStubbing(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n        this.invocationForStubbing = invocationMatcher;\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.addAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public void addAnswer(Answer answer) {\n        registeredInvocations.removeLast();\n        addAnswer(answer, false);\n    }",
        "begin_line": 48,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.addConsecutiveAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public void addConsecutiveAnswer(Answer answer) {\n        addAnswer(answer, true);\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.addAnswer(org.mockito.stubbing.Answer, boolean)",
        "snippet": "    public void addAnswer(Answer answer, boolean isConsecutive) {\n        Invocation invocation = invocationForStubbing.getInvocation();\n        mockingProgress.stubbingCompleted(invocation);\n        AnswersValidator answersValidator = new AnswersValidator();\n        answersValidator.validate(answer, invocation);\n\n        synchronized (stubbed) {\n            if (isConsecutive) {\n                stubbed.getFirst().addAnswer(answer);\n            } else {\n                stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n            }\n        }\n    }",
        "begin_line": 57,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.answerTo(org.mockito.invocation.Invocation)",
        "snippet": "    Object answerTo(Invocation invocation) throws Throwable {\n        return findAnswerFor(invocation).answer(invocation);\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.findAnswerFor(org.mockito.invocation.Invocation)",
        "snippet": "    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n        synchronized (stubbed) {\n            for (StubbedInvocationMatcher s : stubbed) {\n                if (s.matches(invocation)) {\n                    s.markStubUsed(invocation);\n                    invocation.markStubbed(new StubInfoImpl(s));\n                    return s;\n                }\n            }\n        }\n\n        return null;\n    }",
        "begin_line": 76,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.addAnswerForVoidMethod(org.mockito.stubbing.Answer)",
        "snippet": "    public void addAnswerForVoidMethod(Answer answer) {\n        answersForStubbing.add(answer);\n    }",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.setAnswersForStubbing(java.util.List<org.mockito.stubbing.Answer>)",
        "snippet": "    public void setAnswersForStubbing(List<Answer> answers) {\n        answersForStubbing.addAll(answers);\n    }",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.hasAnswersForStubbing()",
        "snippet": "    public boolean hasAnswersForStubbing() {\n        return !answersForStubbing.isEmpty();\n    }",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.hasInvocationForPotentialStubbing()",
        "snippet": "    public boolean hasInvocationForPotentialStubbing() {\n        return !registeredInvocations.isEmpty();\n    }",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.setMethodForStubbing(org.mockito.internal.invocation.InvocationMatcher)",
        "snippet": "    public void setMethodForStubbing(InvocationMatcher invocation) {\n        invocationForStubbing = invocation;\n        assert hasAnswersForStubbing();\n        for (int i = 0; i < answersForStubbing.size(); i++) {\n            addAnswer(answersForStubbing.get(i), i != 0);\n        }\n        answersForStubbing.clear();\n    }",
        "begin_line": 106,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"invocationForStubbing: \" + invocationForStubbing;\n    }",
        "begin_line": 115,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.getInvocations()",
        "snippet": "    public List<Invocation> getInvocations() {\n        return registeredInvocations.getAll();\n    }",
        "begin_line": 120,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.getStubbedInvocations()",
        "snippet": "    public List<StubbedInvocationMatcher> getStubbedInvocations() {\n        return stubbed;\n    }",
        "begin_line": 124,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.invokedMock()",
        "snippet": "    public Object invokedMock() {\n        return invocationForStubbing.getInvocation().getMock();\n    }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.getInvocationForStubbing()",
        "snippet": "    public InvocationMatcher getInvocationForStubbing() {\n        return invocationForStubbing;\n    }",
        "begin_line": 132,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/InvocationContainerImpl.java",
        "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
        "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.createRegisteredInvocations(org.mockito.mock.MockCreationSettings)",
        "snippet": "    private RegisteredInvocations createRegisteredInvocations(MockCreationSettings mockSettings) {\n        return mockSettings.isStubOnly()\n          ? new SingleRegisteredInvocation()\n          : new DefaultRegisteredInvocations();\n    }",
        "begin_line": 136,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.StubbedInvocationMatcher(org.mockito.internal.invocation.InvocationMatcher, org.mockito.stubbing.Answer)",
        "snippet": "    public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n        super(invocation.getInvocation(), invocation.getMatchers());\n        this.answers.add(answer);\n    }",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        //see ThreadsShareGenerouslyStubbedMockTest\n        Answer a;\n        synchronized(answers) {\n            a = answers.size() == 1 ? answers.peek() : answers.poll();\n        }\n        return a.answer(invocation);\n    }",
        "begin_line": 28,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.addAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public void addAnswer(Answer answer) {\n        answers.add(answer);\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.markStubUsed(org.mockito.invocation.DescribedInvocation)",
        "snippet": "    public void markStubUsed(DescribedInvocation usedAt) {\n        this.usedAt = usedAt;\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.wasUsed()",
        "snippet": "    public boolean wasUsed() {\n        return usedAt != null;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java",
        "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
        "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return super.toString() + \" stubbed with: \" + answers;\n    }",
        "begin_line": 49,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.OngoingStubbingImpl(org.mockito.internal.stubbing.InvocationContainerImpl)",
        "snippet": "    public OngoingStubbingImpl(InvocationContainerImpl invocationContainerImpl) {\n        this.invocationContainerImpl = invocationContainerImpl;\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.thenAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public OngoingStubbing<T> thenAnswer(Answer<?> answer) {\n        if(!invocationContainerImpl.hasInvocationForPotentialStubbing()) {\n            new Reporter().incorrectUseOfApi();\n        }\n\n        invocationContainerImpl.addAnswer(answer);\n        return new ConsecutiveStubbing<T>(invocationContainerImpl);\n    }",
        "begin_line": 23,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.then(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public OngoingStubbing<T> then(Answer<?> answer) {\n        return thenAnswer(answer);\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.toAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n        invocationContainerImpl.addAnswer(answer);\n        return new ConsecutiveStubbing<T>(invocationContainerImpl);\n    }",
        "begin_line": 36,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.getRegisteredInvocations()",
        "snippet": "    public List<Invocation> getRegisteredInvocations() {\n        //TODO interface for tests\n        return invocationContainerImpl.getInvocations();\n    }",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/OngoingStubbingImpl.java",
        "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
        "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.getMock()",
        "snippet": "    public <M> M getMock() {\n        return (M) invocationContainerImpl.invokedMock();\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/ConsecutiveStubbing.java",
        "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
        "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.ConsecutiveStubbing(org.mockito.internal.stubbing.InvocationContainerImpl)",
        "snippet": "    public ConsecutiveStubbing(InvocationContainerImpl invocationContainerImpl) {\n        this.invocationContainerImpl = invocationContainerImpl;\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/ConsecutiveStubbing.java",
        "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
        "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.thenAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public OngoingStubbing<T> thenAnswer(Answer<?> answer) {\n        invocationContainerImpl.addConsecutiveAnswer(answer);\n        return this;\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/ConsecutiveStubbing.java",
        "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
        "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.then(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public OngoingStubbing<T> then(Answer<?> answer) {\n        return thenAnswer(answer);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/ConsecutiveStubbing.java",
        "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
        "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.toAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n        invocationContainerImpl.addConsecutiveAnswer(answer);\n        return this;\n    }",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/ConsecutiveStubbing.java",
        "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
        "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.getMock()",
        "snippet": "    public <M> M getMock() {\n        return (M) invocationContainerImpl.invokedMock();\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java",
        "class_name": "org.mockito.internal.stubbing.VoidMethodStubbableImpl",
        "signature": "org.mockito.internal.stubbing.VoidMethodStubbableImpl.VoidMethodStubbableImpl(T, org.mockito.internal.stubbing.InvocationContainerImpl)",
        "snippet": "    public VoidMethodStubbableImpl(T mock, InvocationContainerImpl invocationContainerImpl) {\n        this.mock = mock;\n        this.invocationContainerImpl = invocationContainerImpl;\n    }",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java",
        "class_name": "org.mockito.internal.stubbing.VoidMethodStubbableImpl",
        "signature": "org.mockito.internal.stubbing.VoidMethodStubbableImpl.toThrow(java.lang.Throwable)",
        "snippet": "    public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n        invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(throwable));\n        return this;\n    }",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java",
        "class_name": "org.mockito.internal.stubbing.VoidMethodStubbableImpl",
        "signature": "org.mockito.internal.stubbing.VoidMethodStubbableImpl.toReturn()",
        "snippet": "    public VoidMethodStubbable<T> toReturn() {\n        invocationContainerImpl.addAnswerForVoidMethod(new DoesNothing());\n        return this;\n    }",
        "begin_line": 26,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java",
        "class_name": "org.mockito.internal.stubbing.VoidMethodStubbableImpl",
        "signature": "org.mockito.internal.stubbing.VoidMethodStubbableImpl.toAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n        invocationContainerImpl.addAnswerForVoidMethod(answer);\n        return this;\n    }",
        "begin_line": 31,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java",
        "class_name": "org.mockito.internal.stubbing.VoidMethodStubbableImpl",
        "signature": "org.mockito.internal.stubbing.VoidMethodStubbableImpl.on()",
        "snippet": "    public T on() {\n        return mock;\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer",
        "signature": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return new GlobalConfiguration().getDefaultAnswer().answer(invocation);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Object ret = delegate.answer(invocation);\n        if (ret != null) {\n            return ret;\n        }\n            \n        return returnValueFor(invocation.getMethod().getReturnType());\n    }",
        "begin_line": 20,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks.returnValueFor(java.lang.Class<?>)",
        "snippet": "    Object returnValueFor(Class<?> clazz) {\n        if (!mockitoCore.isTypeMockable(clazz)) {\n            return null;\n        }\n        \n        return mockitoCore.mock(clazz, new MockSettingsImpl().defaultAnswer(this));\n    }",
        "begin_line": 29,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Object ret = delegate.answer(invocation);\n        if (ret != null) {\n            return ret;\n        }\n\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
        "begin_line": 56,
        "end_line": 64,
        "comment": " (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues.returnValueFor(java.lang.Class<?>)",
        "snippet": "    Object returnValueFor(Class<?> type) {\n        if (type == String.class) {\n            return \"\";\n        }  else if (type.isArray()) {\n            Class<?> componenetType = type.getComponentType();\n            return Array.newInstance(componenetType, 0);\n        }\n        return null;\n    }",
        "begin_line": 66,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
        "begin_line": 62,
        "end_line": 80,
        "comment": " (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.returnValueFor(java.lang.Class<?>)",
        "snippet": "    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        //Let's not care about the rest of collections.\n        return null;\n    }",
        "begin_line": 82,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(final InvocationOnMock invocation) throws Throwable {\n        Object defaultReturnValue = delegate.answer(invocation);\n        if (defaultReturnValue != null) {\n            return defaultReturnValue;\n        }\n        Class<?> type = invocation.getMethod().getReturnType();\n        if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {\n            final Location location = new LocationImpl();\n            return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));\n        }\n        return null;\n    }",
        "begin_line": 42,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls.ThrowsSmartNullPointer.ThrowsSmartNullPointer(org.mockito.invocation.InvocationOnMock, org.mockito.invocation.Location)",
        "snippet": "        public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {\n            this.unstubbedInvocation = unstubbedInvocation;\n            this.location = location;\n        }",
        "begin_line": 59,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls.ThrowsSmartNullPointer.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "        public Object answer(InvocationOnMock currentInvocation) throws Throwable {\n            if (new ObjectMethodsGuru().isToString(currentInvocation.getMethod())) {\n                return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n                        unstubbedInvocation.toString();\n            }\n\n            new Reporter().smartNullPointerException(unstubbedInvocation.toString(), location);\n            return null;\n        }",
        "begin_line": 64,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations.ForwardsInvocations(java.lang.Object)",
        "snippet": "    public ForwardsInvocations(Object delegatedObject) {\n        this.delegatedObject = delegatedObject ;\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Method mockMethod = invocation.getMethod();\n        \n        Object result = null;\n        \n        try {\n            Method delegateMethod = getDelegateMethod(mockMethod);\n            \n            if (!compatibleReturnTypes(mockMethod.getReturnType(), delegateMethod.getReturnType())) {\n                new Reporter().delegatedMethodHasWrongReturnType(mockMethod, delegateMethod, invocation.getMock(), delegatedObject);\n            }\n            \n            result = delegateMethod.invoke(delegatedObject, invocation.getArguments());\n        } catch (NoSuchMethodException e) {\n            new Reporter().delegatedMethodDoesNotExistOnDelegate(mockMethod, invocation.getMock(), delegatedObject);\n        } catch (InvocationTargetException e) {\n            // propagate the original exception from the delegate\n            throw e.getCause();\n        }\n        \n        return result;\n    }",
        "begin_line": 32,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations.getDelegateMethod(java.lang.reflect.Method)",
        "snippet": "    private Method getDelegateMethod(Method mockMethod) throws NoSuchMethodException {\n        if (mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {\n            // Compatible class. Return original method.\n            return mockMethod;\n        } else {\n            // Return method of delegate object with the same signature as mockMethod.\n            return delegatedObject.getClass().getMethod(mockMethod.getName(), mockMethod.getParameterTypes());\n        }\n    }",
        "begin_line": 55,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations.compatibleReturnTypes(java.lang.Class<?>, java.lang.Class<?>)",
        "snippet": "    private static boolean compatibleReturnTypes(Class<?> superType, Class<?> subType) {\n        return superType.equals(subType) || superType.isAssignableFrom(subType);\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        GenericMetadataSupport returnTypeGenericMetadata =\n                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n\n        Class<?> rawType = returnTypeGenericMetadata.rawType();\n        if (!mockitoCore().isTypeMockable(rawType)) {\n            return delegate().returnValueFor(rawType);\n        }\n\n        return deepStub(invocation, returnTypeGenericMetadata);\n    }",
        "begin_line": 47,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.deepStub(org.mockito.invocation.InvocationOnMock, org.mockito.internal.util.reflection.GenericMetadataSupport)",
        "snippet": "    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n\n        // matches invocation for verification\n        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n                return stubbedInvocationMatcher.answer(invocation);\n            }\n        }\n\n        // record deep stub answer\n        return recordDeepStubAnswer(\n                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\n                container\n        );\n    }",
        "begin_line": 59,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.newDeepStubMock(org.mockito.internal.util.reflection.GenericMetadataSupport, java.lang.Object)",
        "snippet": "    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n        return mockitoCore().mock(\n                returnTypeGenericMetadata.rawType(),\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n        );\n    }",
        "begin_line": 88,
        "end_line": 94,
        "comment": "\n     * Creates a mock using the Generics Metadata.\n     *\n     * <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n     * that was resolved for the current return type, for this to happen we associate to the mock an new instance of\n     * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n     *\n     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n     * @param parentMock The parent of the current deep stub mock.\n     * @return The mock\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.withSettingsUsing(org.mockito.internal.util.reflection.GenericMetadataSupport, org.mockito.mock.MockCreationSettings)",
        "snippet": "    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                : withSettings();\n\n        return propagateSerializationSettings(mockSettings, parentMockSettings)\n                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n    }",
        "begin_line": 96,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.propagateSerializationSettings(org.mockito.MockSettings, org.mockito.mock.MockCreationSettings)",
        "snippet": "    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\n        return mockSettings.serializable(parentMockSettings.getSerializableMode());\n    }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.returnsDeepStubsAnswerUsing(org.mockito.internal.util.reflection.GenericMetadataSupport)",
        "snippet": "    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n        return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.recordDeepStubAnswer(java.lang.Object, org.mockito.internal.stubbing.InvocationContainerImpl)",
        "snippet": "    private Object recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) throws Throwable {\n        container.addAnswer(new DeeplyStubbedAnswer(mock), false);\n        return mock;\n    }",
        "begin_line": 113,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.actualParameterizedType(java.lang.Object)",
        "snippet": "    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n    }",
        "begin_line": 118,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.ReturnsDeepStubsSerializationFallback.ReturnsDeepStubsSerializationFallback(org.mockito.internal.util.reflection.GenericMetadataSupport)",
        "snippet": "        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {\n            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n        }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.ReturnsDeepStubsSerializationFallback.actualParameterizedType(java.lang.Object)",
        "snippet": "        @Override\n        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n            return returnTypeGenericMetadata;\n        }",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.ReturnsDeepStubsSerializationFallback.writeReplace()",
        "snippet": "        private Object writeReplace() throws IOException {\n            return Mockito.RETURNS_DEEP_STUBS;\n        }",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.DeeplyStubbedAnswer.DeeplyStubbedAnswer(java.lang.Object)",
        "snippet": "        DeeplyStubbedAnswer(Object mock) {\n            this.mock = mock;\n        }",
        "begin_line": 146,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.DeeplyStubbedAnswer.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "        public Object answer(InvocationOnMock invocation) throws Throwable {\n            return mock;\n        }",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.mockitoCore()",
        "snippet": "    private static MockitoCore mockitoCore() {\n        return LazyHolder.MOCKITO_CORE;\n    }",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java",
        "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs",
        "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.delegate()",
        "snippet": "    private static ReturnsEmptyValues delegate() {\n        return LazyHolder.DELEGATE;\n    }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.MethodInfo(org.mockito.invocation.Invocation)",
        "snippet": "    public MethodInfo(Invocation theInvocation) {\n        this.method = theInvocation.getMethod();\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.isValidException(java.lang.Throwable)",
        "snippet": "    public boolean isValidException(Throwable throwable) {\n        Class<?>[] exceptions = method.getExceptionTypes();\n        Class<?> throwableClass = throwable.getClass();\n        for (Class<?> exception : exceptions) {\n            if (exception.isAssignableFrom(throwableClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
        "begin_line": 25,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.isValidReturnType(java.lang.Class)",
        "snippet": "    public boolean isValidReturnType(Class clazz) {\n        if (method.getReturnType().isPrimitive() || clazz.isPrimitive()) {\n            return Primitives.primitiveTypeOf(clazz) == Primitives.primitiveTypeOf(method.getReturnType());\n        } else {\n            return method.getReturnType().isAssignableFrom(clazz);\n        }\n    }",
        "begin_line": 37,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.isVoid()",
        "snippet": "    public boolean isVoid() {\n        return this.method.getReturnType() == Void.TYPE;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.printMethodReturnType()",
        "snippet": "    public String printMethodReturnType() {\n        return method.getReturnType().getSimpleName();\n    }",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.getMethodName()",
        "snippet": "    public String getMethodName() {\n        return method.getName();\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.returnsPrimitive()",
        "snippet": "    public boolean returnsPrimitive() {\n        return method.getReturnType().isPrimitive();\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.getMethod()",
        "snippet": "    public Method getMethod() {\n        return method;\n    }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.isDeclaredOnInterface()",
        "snippet": "    public boolean isDeclaredOnInterface() {\n        return method.getDeclaringClass().isInterface();\n    }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/MethodInfo.java",
        "class_name": "org.mockito.internal.stubbing.answers.MethodInfo",
        "signature": "org.mockito.internal.stubbing.answers.MethodInfo.isAbstract()",
        "snippet": "    public boolean isAbstract() {\n        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n    }",
        "begin_line": 69,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter",
        "signature": "org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter.AnswerReturnValuesAdapter(org.mockito.ReturnValues)",
        "snippet": "    public AnswerReturnValuesAdapter(ReturnValues returnValues) {\n        this.returnValues = returnValues;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter",
        "signature": "org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return returnValues.valueFor(invocation);\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.Returns(java.lang.Object)",
        "snippet": "    public Returns(Object value) {\n        this.value = value;\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return value;\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.printReturnType()",
        "snippet": "    public String printReturnType() {\n        return value.getClass().getSimpleName();\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.getReturnType()",
        "snippet": "    public Class<?> getReturnType() {\n        return value.getClass();\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.returnsNull()",
        "snippet": "    public boolean returnsNull() {\n        return value == null;\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/Returns.java",
        "class_name": "org.mockito.internal.stubbing.answers.Returns",
        "signature": "org.mockito.internal.stubbing.answers.Returns.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return \"Returns: \" + value;\n    }",
        "begin_line": 37,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validate(org.mockito.stubbing.Answer<?>, org.mockito.invocation.Invocation)",
        "snippet": "    public void validate(Answer<?> answer, Invocation invocation) {\n        MethodInfo methodInfo = new MethodInfo(invocation);\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, methodInfo);\n        }\n\n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, methodInfo);\n        }\n\n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, methodInfo);\n        }\n\n        if (answer instanceof CallsRealMethods) {\n            validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);\n        }\n\n        if (answer instanceof ReturnsArgumentAt) {\n            ReturnsArgumentAt returnsArgumentAt = (ReturnsArgumentAt) answer;\n            validateReturnArgIdentity(returnsArgumentAt, invocation);\n        }\n    }",
        "begin_line": 15,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateReturnArgIdentity(org.mockito.internal.stubbing.answers.ReturnsArgumentAt, org.mockito.invocation.Invocation)",
        "snippet": "    private void validateReturnArgIdentity(ReturnsArgumentAt returnsArgumentAt, Invocation invocation) {\n        returnsArgumentAt.validateIndexWithinInvocationRange(invocation);\n\n        MethodInfo methodInfo = new MethodInfo(invocation);\n        if (!methodInfo.isValidReturnType(returnsArgumentAt.returnedTypeOnSignature(invocation))) {\n            new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),\n                    returnsArgumentAt.returnedTypeOnSignature(invocation),\n                    returnsArgumentAt.wantedArgumentPosition());\n        }\n\n    }",
        "begin_line": 39,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateMockingConcreteClass(org.mockito.internal.stubbing.answers.CallsRealMethods, org.mockito.internal.stubbing.answers.MethodInfo)",
        "snippet": "    private void validateMockingConcreteClass(CallsRealMethods answer, MethodInfo methodInfo) {\n        if (methodInfo.isAbstract()) {\n            reporter.cannotCallAbstractRealMethod();\n        }\n    }",
        "begin_line": 51,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateDoNothing(org.mockito.internal.stubbing.answers.DoesNothing, org.mockito.internal.stubbing.answers.MethodInfo)",
        "snippet": "    private void validateDoNothing(DoesNothing answer, MethodInfo methodInfo) {\n        if (!methodInfo.isVoid()) {\n            reporter.onlyVoidMethodsCanBeSetToDoNothing();\n        }\n    }",
        "begin_line": 57,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateReturnValue(org.mockito.internal.stubbing.answers.Returns, org.mockito.internal.stubbing.answers.MethodInfo)",
        "snippet": "    private void validateReturnValue(Returns answer, MethodInfo methodInfo) {\n        if (methodInfo.isVoid()) {\n            reporter.cannotStubVoidMethodWithAReturnValue(methodInfo.getMethodName());\n        }\n\n        if (answer.returnsNull() && methodInfo.returnsPrimitive()) {\n            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), \"null\", methodInfo.getMethodName());\n        }\n\n        if (!answer.returnsNull() && !methodInfo.isValidReturnType(answer.getReturnType())) {\n            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), answer.printReturnType(), methodInfo.getMethodName());\n        }\n    }",
        "begin_line": 63,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateException(org.mockito.internal.stubbing.answers.ThrowsException, org.mockito.internal.stubbing.answers.MethodInfo)",
        "snippet": "    private void validateException(ThrowsException answer, MethodInfo methodInfo) {\n        Throwable throwable = answer.getThrowable();\n        if (throwable == null) {\n            reporter.cannotStubWithNullThrowable();\n        }\n\n        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n            return;\n        }\n\n        if (!methodInfo.isValidException(throwable)) {\n            reporter.checkedExceptionInvalid(throwable);\n        }\n    }",
        "begin_line": 77,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/AnswersValidator.java",
        "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
        "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateDefaultAnswerReturnedValue(org.mockito.invocation.Invocation, java.lang.Object)",
        "snippet": "    public void validateDefaultAnswerReturnedValue(Invocation invocation, Object returnedValue) {\n        MethodInfo methodInfo = new MethodInfo(invocation);\n        if (returnedValue != null && !methodInfo.isValidReturnType(returnedValue.getClass())) {\n            reporter.wrongTypeReturnedByDefaultAnswer(\n                    invocation.getMock(),\n                    methodInfo.printMethodReturnType(),\n                    returnedValue.getClass().getSimpleName(),\n                    methodInfo.getMethodName());\n        }\n    }",
        "begin_line": 92,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsException.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsException",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsException.ThrowsException(java.lang.Throwable)",
        "snippet": "    public ThrowsException(Throwable throwable) {\n        this.throwable = throwable;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsException.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsException",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsException.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        if (new MockUtil().isMock(throwable)) {\n            throw throwable;\n        }\n        Throwable t = throwable.fillInStackTrace();\n        filter.filter(t);\n        throw t;\n    }",
        "begin_line": 24,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsException.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsException",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsException.getThrowable()",
        "snippet": "    public Throwable getThrowable() {\n        return throwable;\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/DoesNothing.java",
        "class_name": "org.mockito.internal.stubbing.answers.DoesNothing",
        "signature": "org.mockito.internal.stubbing.answers.DoesNothing.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return null;\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/CallsRealMethods.java",
        "class_name": "org.mockito.internal.stubbing.answers.CallsRealMethods",
        "signature": "org.mockito.internal.stubbing.answers.CallsRealMethods.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n            return RETURNS_DEFAULTS.answer(invocation);\n        }\n        return invocation.callRealMethod();\n    }",
        "begin_line": 36,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.ReturnsArgumentAt(int)",
        "snippet": "    public ReturnsArgumentAt(int wantedArgumentPosition) {\n        this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Build the identity answer to return the argument at the given position in the argument array.\n     *\n     * @param wantedArgumentPosition The position of the argument identity to return in the invocation.\n     *                      Using <code>-1</code> indicates the last argument.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        validateIndexWithinInvocationRange(invocation);\n        return invocation.getArguments()[actualArgumentPosition(invocation)];\n    }",
        "begin_line": 40,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.actualArgumentPosition(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    private int actualArgumentPosition(InvocationOnMock invocation) {\n        return returningLastArg() ?\n                lastArgumentIndexOf(invocation) :\n                argumentIndexOf(invocation);\n    }",
        "begin_line": 46,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.returningLastArg()",
        "snippet": "    private boolean returningLastArg() {\n        return wantedArgumentPosition == LAST_ARGUMENT;\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.argumentIndexOf(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    private int argumentIndexOf(InvocationOnMock invocation) {\n        return wantedArgumentPosition;\n    }",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.lastArgumentIndexOf(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    private int lastArgumentIndexOf(InvocationOnMock invocation) {\n        return invocation.getArguments().length - 1;\n    }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.checkWithinAllowedRange(int)",
        "snippet": "    private int checkWithinAllowedRange(int argumentPosition) {\n        if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {\n            new Reporter().invalidArgumentRangeAtIdentityAnswerCreationTime();\n        }\n        return argumentPosition;\n    }",
        "begin_line": 64,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.wantedArgumentPosition()",
        "snippet": "    public int wantedArgumentPosition() {\n        return wantedArgumentPosition;\n    }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.validateIndexWithinInvocationRange(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public void validateIndexWithinInvocationRange(InvocationOnMock invocation) {\n        if (!argumentPositionInRange(invocation)) {\n            new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation,\n                                                                        returningLastArg(),\n                                                                        wantedArgumentPosition);\n        }\n    }",
        "begin_line": 75,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.argumentPositionInRange(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    private boolean argumentPositionInRange(InvocationOnMock invocation) {\n        int actualArgumentPosition = actualArgumentPosition(invocation);\n        if (actualArgumentPosition < 0) {\n            return false;\n        }\n        if (!invocation.getMethod().isVarArgs()) {\n            return invocation.getArguments().length > actualArgumentPosition;\n        }\n        // for all varargs accepts positive ranges\n        return true;\n    }",
        "begin_line": 83,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsArgumentAt.returnedTypeOnSignature(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Class returnedTypeOnSignature(InvocationOnMock invocation) {\n        int actualArgumentPosition = actualArgumentPosition(invocation);\n\n        if(!invocation.getMethod().isVarArgs()) {\n            return invocation.getMethod().getParameterTypes()[actualArgumentPosition];\n        }\n\n        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n        int varargPosition = parameterTypes.length - 1;\n\n        if(actualArgumentPosition < varargPosition) {\n            return parameterTypes[actualArgumentPosition];\n        } else {\n            return parameterTypes[varargPosition].getComponentType();\n        }\n    }",
        "begin_line": 95,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass.ThrowsExceptionClass(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {\n        this.throwableClass = throwableClass;\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        //TODO centralize the use of Objenesis. Why do we use ObjenesisHelper?\n        Throwable throwable = (Throwable) ObjenesisHelper.newInstance(throwableClass);\n        throwable.fillInStackTrace();\n        filter.filter(throwable);\n        throw throwable;\n    }",
        "begin_line": 24,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java",
        "class_name": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass",
        "signature": "org.mockito.internal.stubbing.answers.ThrowsExceptionClass.getThrowableClass()",
        "snippet": "    public Class<? extends Throwable> getThrowableClass() {\n        return throwableClass;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsElementsOf",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsElementsOf.ReturnsElementsOf(java.util.Collection<?>)",
        "snippet": "    public ReturnsElementsOf(Collection<?> elements) {\n        if (elements == null) {\n            throw new MockitoException(\"ReturnsElementsOf does not accept null as constructor argument.\\n\" +\n                    \"Please pass a collection instance\");\n        }\n        this.elements = new LinkedList<Object>(elements);\n    }",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java",
        "class_name": "org.mockito.internal.stubbing.answers.ReturnsElementsOf",
        "signature": "org.mockito.internal.stubbing.answers.ReturnsElementsOf.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        if (elements.size() == 1)\n            return elements.get(0);\n        else \n            return elements.poll();\n    }",
        "begin_line": 44,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/answers/ReturnsElementsOf.java",
        "class_name": "org.mockito.stubbing.answers.ReturnsElementsOf",
        "signature": "org.mockito.stubbing.answers.ReturnsElementsOf.ReturnsElementsOf(java.util.Collection<?>)",
        "snippet": "    @Deprecated\n    public ReturnsElementsOf(Collection<?> elements) {\n        super(elements);\n    }",
        "begin_line": 25,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/stubbing/answers/ClonesArguments.java",
        "class_name": "org.mockito.internal.stubbing.answers.ClonesArguments",
        "signature": "org.mockito.internal.stubbing.answers.ClonesArguments.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Object[] arguments = invocation.getArguments();\n        for (int i = 0; i < arguments.length; i++) {\n            Object from = arguments[i];\n            Object newInstance = ObjenesisHelper.newInstance(from.getClass());\n            new LenientCopyTool().copyToRealObject(from, newInstance);\n            arguments[i] = newInstance;\n        }\n        return new ReturnsEmptyValues().answer(invocation);\n    }",
        "begin_line": 16,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.DelegatingMethod(java.lang.reflect.Method)",
        "snippet": "    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.getExceptionTypes()",
        "snippet": "    public Class<?>[] getExceptionTypes() {\n        return method.getExceptionTypes();\n    }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.getJavaMethod()",
        "snippet": "    public Method getJavaMethod() {\n        return method;\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.getName()",
        "snippet": "    public String getName() {\n        return method.getName();\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.getParameterTypes()",
        "snippet": "    public Class<?>[] getParameterTypes() {\n        return method.getParameterTypes();\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.getReturnType()",
        "snippet": "    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.isVarArgs()",
        "snippet": "    public boolean isVarArgs() {\n        return method.isVarArgs();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.isAbstract()",
        "snippet": "    public boolean isAbstract() {\n        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o instanceof DelegatingMethod) {\n            DelegatingMethod that = (DelegatingMethod) o;\n            return method.equals(that.method);\n        } else {\n            return method.equals(o);\n        }\n    }",
        "begin_line": 53,
        "end_line": 64,
        "comment": "\n     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,\n     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/DelegatingMethod.java",
        "class_name": "org.mockito.internal.creation.DelegatingMethod",
        "signature": "org.mockito.internal.creation.DelegatingMethod.hashCode()",
        "snippet": "    @Override\n    public int hashCode() {\n        return method.hashCode();\n    }",
        "begin_line": 66,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.serializable()",
        "snippet": "    public MockSettings serializable() {\n        return serializable(SerializableMode.BASIC);\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.serializable(org.mockito.mock.SerializableMode)",
        "snippet": "    public MockSettings serializable(SerializableMode mode) {\n        this.serializableMode = mode;\n        return this;\n    }",
        "begin_line": 37,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.extraInterfaces(java.lang.Class...)",
        "snippet": "    public MockSettings extraInterfaces(Class... extraInterfaces) {\n        if (extraInterfaces == null || extraInterfaces.length == 0) {\n            new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n        }\n\n        for (Class i : extraInterfaces) {\n            if (i == null) {\n                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n            } else if (!i.isInterface()) {\n                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n            }\n        }\n        this.extraInterfaces = newSet(extraInterfaces);\n        return this;\n    }",
        "begin_line": 42,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getMockName()",
        "snippet": "    public MockName getMockName() {\n        return mockName;\n    }",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getExtraInterfaces()",
        "snippet": "    public Set<Class> getExtraInterfaces() {\n        return extraInterfaces;\n    }",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getSpiedInstance()",
        "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.name(java.lang.String)",
        "snippet": "    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.spiedInstance(java.lang.Object)",
        "snippet": "    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.defaultAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        if (defaultAnswer == null) {\n            new Reporter().defaultAnswerDoesNotAcceptNullParameter();\n        }\n        return this;\n    }",
        "begin_line": 80,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getDefaultAnswer()",
        "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.stubOnly()",
        "snippet": "    public MockSettingsImpl stubOnly() {\n        this.stubOnly = true;\n        return this;\n    }",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.useConstructor()",
        "snippet": "    public MockSettings useConstructor() {\n        this.useConstructor = true;\n        return this;\n    }",
        "begin_line": 97,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.outerInstance(java.lang.Object)",
        "snippet": "    public MockSettings outerInstance(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n        return this;\n    }",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.isUsingConstructor()",
        "snippet": "    public boolean isUsingConstructor() {\n        return useConstructor;\n    }",
        "begin_line": 107,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getOuterClassInstance()",
        "snippet": "    public Object getOuterClassInstance() {\n        return outerClassInstance;\n    }",
        "begin_line": 111,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.isStubOnly()",
        "snippet": "    public boolean isStubOnly() {\n        return this.stubOnly;\n    }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.verboseLogging()",
        "snippet": "    public MockSettings verboseLogging() {\n        if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n            invocationListeners(new VerboseMockInvocationLogger());\n        }\n        return this;\n    }",
        "begin_line": 119,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.invocationListeners(org.mockito.listeners.InvocationListener...)",
        "snippet": "    public MockSettings invocationListeners(InvocationListener... listeners) {\n        if (listeners == null || listeners.length == 0) {\n            new Reporter().invocationListenersRequiresAtLeastOneListener();\n        }\n        for (InvocationListener listener : listeners) {\n            if (listener == null) {\n                new Reporter().invocationListenerDoesNotAcceptNullParameters();\n            }\n            this.invocationListeners.add(listener);\n        }\n        return this;\n    }",
        "begin_line": 126,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.invocationListenersContainsType(java.lang.Class<?>)",
        "snippet": "    private boolean invocationListenersContainsType(Class<?> clazz) {\n        for (InvocationListener listener : invocationListeners) {\n            if (listener.getClass().equals(clazz)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "begin_line": 139,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getInvocationListeners()",
        "snippet": "    public List<InvocationListener> getInvocationListeners() {\n        return this.invocationListeners;\n    }",
        "begin_line": 148,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.hasInvocationListeners()",
        "snippet": "    public boolean hasInvocationListeners() {\n        return !invocationListeners.isEmpty();\n    }",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.getTypeToMock()",
        "snippet": "    public Class<T> getTypeToMock() {\n        return typeToMock;\n    }",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.confirm(java.lang.Class<T>)",
        "snippet": "    public MockCreationSettings<T> confirm(Class<T> typeToMock) {\n        return validatedSettings(typeToMock, this);\n    }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.validatedSettings(java.lang.Class<T>, org.mockito.internal.creation.settings.CreationSettings<T>)",
        "snippet": "    private static <T> CreationSettings<T> validatedSettings(Class<T> typeToMock, CreationSettings<T> source) {\n        MockCreationValidator validator = new MockCreationValidator();\n\n        validator.validateType(typeToMock);\n        validator.validateExtraInterfaces(typeToMock, source.getExtraInterfaces());\n        validator.validateMockedType(typeToMock, source.getSpiedInstance());\n\n        //TODO SF - add this validation and also add missing coverage\n//        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n\n        validator.validateSerializable(typeToMock, source.isSerializable());\n        validator.validateConstructorUse(source.isUsingConstructor(), source.getSerializableMode());\n\n        //TODO SF - I don't think we really need CreationSettings type\n        CreationSettings<T> settings = new CreationSettings<T>(source);\n        settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n        settings.setTypeToMock(typeToMock);\n        settings.setExtraInterfaces(prepareExtraInterfaces(source));\n        return settings;\n    }",
        "begin_line": 164,
        "end_line": 183,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/MockSettingsImpl.java",
        "class_name": "org.mockito.internal.creation.MockSettingsImpl",
        "signature": "org.mockito.internal.creation.MockSettingsImpl.prepareExtraInterfaces(org.mockito.internal.creation.settings.CreationSettings)",
        "snippet": "    private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n        Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n        if(settings.isSerializable()) {\n            interfaces.add(Serializable.class);\n        }\n        return interfaces;\n    }",
        "begin_line": 185,
        "end_line": 191,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/MockitoMethodProxy.java",
        "class_name": "org.mockito.internal.creation.util.MockitoMethodProxy",
        "signature": "org.mockito.internal.creation.util.MockitoMethodProxy.invokeSuper(java.lang.Object, java.lang.Object[])",
        "snippet": "    Object invokeSuper(Object target, Object[] arguments) throws Throwable;",
        "begin_line": 9,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.SearchingClassLoader(java.lang.ClassLoader, java.lang.ClassLoader)",
        "snippet": "    public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {\n        super(parent);\n        this.nextToSearch = nextToSearch;\n    }",
        "begin_line": 18,
        "end_line": 21,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.combineLoadersOf(java.lang.Class<?>...)",
        "snippet": "    public static ClassLoader combineLoadersOf(Class<?>... classes) {\n        return combineLoadersOf(classes[0], classes);\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.combineLoadersOf(java.lang.Class<?>, java.lang.Class<?>...)",
        "snippet": "    private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\n        List<ClassLoader> loaders = new ArrayList<ClassLoader>();\n        \n        addIfNewElement(loaders, first.getClassLoader());\n        for (Class<?> c : others) {\n            addIfNewElement(loaders, c.getClassLoader());\n        }\n        \n        // To support Eclipse Plug-in tests.\n        // In an Eclipse plug-in, we will not be on the system class loader\n        // but in the class loader of the plug-in.\n        //\n        // Note: I've been unable to reproduce the error in the test suite.\n        addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\n        \n        // To support the Maven Surefire plugin.\n        // Note: I've been unable to reproduce the error in the test suite.\n        addIfNewElement(loaders, currentThread().getContextClassLoader());\n\n        //Had to comment that out because it didn't work with in-container Spring tests\n        //addIfNewElement(loaders, ClassLoader.getSystemClassLoader());\n        \n        return combine(loaders);\n    }",
        "begin_line": 27,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.combine(java.util.List<java.lang.ClassLoader>)",
        "snippet": "    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n        \n        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n        }\n        \n        return loader;\n    }",
        "begin_line": 52,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.addIfNewElement(java.util.List<java.lang.ClassLoader>, java.lang.ClassLoader)",
        "snippet": "    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n        if (c != null && !loaders.contains(c)) {\n            loaders.add(c);\n        }\n    }",
        "begin_line": 62,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/util/SearchingClassLoader.java",
        "class_name": "org.mockito.internal.creation.util.SearchingClassLoader",
        "signature": "org.mockito.internal.creation.util.SearchingClassLoader.findClass(java.lang.String)",
        "snippet": "    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        if (nextToSearch != null) {\n            return nextToSearch.loadClass(name);\n        } else {\n            return super.findClass(name); // will throw ClassNotFoundException\n        }\n    }",
        "begin_line": 68,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.CreationSettings()",
        "snippet": "    public CreationSettings() {}",
        "begin_line": 37,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.CreationSettings(org.mockito.internal.creation.settings.CreationSettings)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    public CreationSettings(CreationSettings copy) {\n        this.typeToMock = copy.typeToMock;\n        this.extraInterfaces = copy.extraInterfaces;\n        this.name = copy.name;\n        this.spiedInstance = copy.spiedInstance;\n        this.defaultAnswer = copy.defaultAnswer;\n        this.mockName = copy.mockName;\n        this.serializableMode = copy.serializableMode;\n        this.invocationListeners = copy.invocationListeners;\n        this.stubOnly = copy.stubOnly;\n        this.useConstructor = copy.isUsingConstructor();\n        this.outerClassInstance = copy.getOuterClassInstance();\n    }",
        "begin_line": 39,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getTypeToMock()",
        "snippet": "    public Class<T> getTypeToMock() {\n        return typeToMock;\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.setTypeToMock(java.lang.Class<T>)",
        "snippet": "    public CreationSettings<T> setTypeToMock(Class<T> typeToMock) {\n        this.typeToMock = typeToMock;\n        return this;\n    }",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getExtraInterfaces()",
        "snippet": "    public Set<Class> getExtraInterfaces() {\n        return extraInterfaces;\n    }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.setExtraInterfaces(java.util.Set<java.lang.Class>)",
        "snippet": "    public CreationSettings<T> setExtraInterfaces(Set<Class> extraInterfaces) {\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }",
        "begin_line": 67,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getName()",
        "snippet": "    public String getName() {\n        return name;\n    }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getSpiedInstance()",
        "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getDefaultAnswer()",
        "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }",
        "begin_line": 80,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getMockName()",
        "snippet": "    public MockName getMockName() {\n        return mockName;\n    }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.setMockName(org.mockito.mock.MockName)",
        "snippet": "    public CreationSettings<T> setMockName(MockName mockName) {\n        this.mockName = mockName;\n        return this;\n    }",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.isSerializable()",
        "snippet": "    public boolean isSerializable() {\n        return serializableMode != SerializableMode.NONE;\n    }",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getSerializableMode()",
        "snippet": "    public SerializableMode getSerializableMode() {\n        return serializableMode;\n    }",
        "begin_line": 97,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getInvocationListeners()",
        "snippet": "    public List<InvocationListener> getInvocationListeners() {\n        return invocationListeners;\n    }",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.isUsingConstructor()",
        "snippet": "    public boolean isUsingConstructor() {\n        return useConstructor;\n    }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.getOuterClassInstance()",
        "snippet": "    public Object getOuterClassInstance() {\n        return outerClassInstance;\n    }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/settings/CreationSettings.java",
        "class_name": "org.mockito.internal.creation.settings.CreationSettings",
        "signature": "org.mockito.internal.creation.settings.CreationSettings.isStubOnly()",
        "snippet": "    public boolean isStubOnly() {\n        return stubOnly;\n    }",
        "begin_line": 113,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.ConstructorInstantiator(java.lang.Object)",
        "snippet": "    public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.newInstance(java.lang.Class<T>)",
        "snippet": "    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withParams(cls, outerClassInstance);\n    }",
        "begin_line": 15,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.withParams(java.lang.Class<T>, java.lang.Object...)",
        "snippet": "    private static <T> T withParams(Class<T> cls, Object... params) {\n        try {\n            //this is kind of over-engineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return invokeConstructor(constructor, params);\n                }\n            }\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n        throw paramsException(cls, null);\n    }",
        "begin_line": 22,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.invokeConstructor(java.lang.reflect.Constructor<?>, java.lang.Object...)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {\n        AccessibilityChanger accessibility = new AccessibilityChanger();\n        accessibility.enableAccess(constructor);\n        return (T) constructor.newInstance(params);\n    }",
        "begin_line": 38,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.paramsException(java.lang.Class<T>, java.lang.Exception)",
        "snippet": "    private static <T> InstantiationException paramsException(Class<T> cls, Exception e) {\n        return new InstantiationException(join(\n                \"Unable to create instance of '\" + cls.getSimpleName() + \"'.\",\n                \"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.\")\n                , e);\n    }",
        "begin_line": 45,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.paramsMatch(java.lang.Class<?>[], java.lang.Object[])",
        "snippet": "    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n        if (params.length != types.length) {\n            return false;\n        }\n        for (int i = 0; i < params.length; i++) {\n            if (!types[i].isInstance(params[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "begin_line": 52,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ConstructorInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ConstructorInstantiator",
        "signature": "org.mockito.internal.creation.instance.ConstructorInstantiator.noArgConstructor(java.lang.Class<T>)",
        "snippet": "    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return invokeConstructor(cls.getDeclaredConstructor());\n        } catch (Throwable t) {\n            throw new InstantiationException(join(\n                    \"Unable to create instance of '\" + cls.getSimpleName() + \"'.\",\n                    \"Please ensure it has 0-arg constructor which invokes cleanly.\"),\n                    t);\n        }\n    }",
        "begin_line": 64,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/Instantiator.java",
        "class_name": "org.mockito.internal.creation.instance.Instantiator",
        "signature": "org.mockito.internal.creation.instance.Instantiator.newInstance(java.lang.Class<T>)",
        "snippet": "    <T> T newInstance(Class<T> cls) throws InstantiationException;",
        "begin_line": 11,
        "end_line": 11,
        "comment": "\n     * Creates instance of given class\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/InstantiatorProvider.java",
        "class_name": "org.mockito.internal.creation.instance.InstantiatorProvider",
        "signature": "org.mockito.internal.creation.instance.InstantiatorProvider.getInstantiator(org.mockito.mock.MockCreationSettings)",
        "snippet": "    public Instantiator getInstantiator(MockCreationSettings settings) {\n        if (settings.isUsingConstructor()) {\n            return new ConstructorInstantiator(settings.getOuterClassInstance());\n        } else {\n            return INSTANCE;\n        }\n    }",
        "begin_line": 9,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/ObjenesisInstantiator.java",
        "class_name": "org.mockito.internal.creation.instance.ObjenesisInstantiator",
        "signature": "org.mockito.internal.creation.instance.ObjenesisInstantiator.newInstance(java.lang.Class<T>)",
        "snippet": "    public <T> T newInstance(Class<T> cls) {\n        return objenesis.newInstance(cls);\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/creation/instance/InstantiationException.java",
        "class_name": "org.mockito.internal.creation.instance.InstantiationException",
        "signature": "org.mockito.internal.creation.instance.InstantiationException.InstantiationException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public InstantiationException(String message, Throwable cause) {\n        super(message, cause);\n    }",
        "begin_line": 7,
        "end_line": 9,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/ClassPathLoader.java",
        "class_name": "org.mockito.internal.configuration.ClassPathLoader",
        "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
        "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass;\n        try {\n            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one.\n            return null;\n        }\n\n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
        "begin_line": 63,
        "end_line": 81,
        "comment": "\n     * @return configuration loaded from classpath or null\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/CaptorAnnotationProcessor.java",
        "class_name": "org.mockito.internal.configuration.CaptorAnnotationProcessor",
        "signature": "org.mockito.internal.configuration.CaptorAnnotationProcessor.process(org.mockito.Captor, java.lang.reflect.Field)",
        "snippet": "    public Object process(Captor annotation, Field field) {\n        Class<?> type = field.getType();\n        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n               + field.getName() + \"' has wrong type\\n\"\n               + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n        }\n        Class cls = new GenericMaster().getGenericType(field);\n        return ArgumentCaptor.forClass(cls);\n    }",
        "begin_line": 18,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
        "snippet": "    IMockitoConfiguration getIt() {\n        return GLOBAL_CONFIGURATION.get();\n    }",
        "begin_line": 25,
        "end_line": 27,
        "comment": "back door for testing",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
        "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (GLOBAL_CONFIGURATION.get() == null) {\n            GLOBAL_CONFIGURATION.set(createConfig());\n        }\n    }",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
        "snippet": "    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
        "begin_line": 36,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
        "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.getReturnValues()",
        "snippet": "    public ReturnValues getReturnValues() {\n        return GLOBAL_CONFIGURATION.get().getReturnValues();\n    }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
        "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return GLOBAL_CONFIGURATION.get().getAnnotationEngine();\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.cleansStackTrace()",
        "snippet": "    public boolean cleansStackTrace() {\n        return GLOBAL_CONFIGURATION.get().cleansStackTrace();\n    }",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.enableClassCache()",
        "snippet": "    public boolean enableClassCache() {\n        return GLOBAL_CONFIGURATION.get().enableClassCache();\n    }",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/GlobalConfiguration.java",
        "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
        "signature": "org.mockito.internal.configuration.GlobalConfiguration.getDefaultAnswer()",
        "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return GLOBAL_CONFIGURATION.get().getDefaultAnswer();\n    }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
        "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
        "snippet": "    public Object createMockFor(Annotation annotation, Field field) {\n        return null;\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
        "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n    public void process(Class<?> context, Object testInstance) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                field.setAccessible(true);\n                Object instance;\n                try {\n                    instance = field.get(testInstance);\n                    assertNotInterface(instance, field.getType());\n                    if (new MockUtil().isMock(instance)) {\n                        // instance has been spied earlier\n                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                        Mockito.reset(instance);\n                    } else if (instance != null) {\n                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    } else {\n                        field.set(testInstance, newSpyInstance(testInstance, field));\n                    }\n                } catch (Exception e) {\n                    throw new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName() + \"'.\\n\" + e.getMessage(), e);\n                }\n            }\n        }\n    }",
        "begin_line": 46,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
        "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNotInterface(java.lang.Object, java.lang.Class<?>)",
        "snippet": "    private static void assertNotInterface(Object testInstance, Class<?> type) {\n        type = testInstance != null? testInstance.getClass() : type;\n        if (type.isInterface()) {\n            throw new MockitoException(\"Type '\" + type.getSimpleName() + \"' is an interface and it cannot be spied on.\");\n        }\n    }",
        "begin_line": 76,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
        "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.newSpyInstance(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    private static Object newSpyInstance(Object testInstance, Field field)\n            throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        MockSettings settings = withSettings()\n                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                .name(field.getName());\n        Class<?> type = field.getType();\n        if (type.isInterface()) {\n            return Mockito.mock(type, settings.useConstructor());\n        }\n        if (!Modifier.isStatic(type.getModifiers())) {\n            Class<?> enclosing = type.getEnclosingClass();\n            if (enclosing != null) {\n                if (!enclosing.isInstance(testInstance)) {\n                    throw new MockitoException(\"@Spy annotation can only initialize inner classes declared in the test. \"\n                            + \"Inner class: '\" + type.getSimpleName() + \"', \"\n                            + \"outer class: '\" + enclosing.getSimpleName() + \"'.\");\n                }\n                return Mockito.mock(type, settings\n                        .useConstructor()\n                        .outerInstance(testInstance));\n            }\n        }\n        Constructor<?> constructor;\n        try {\n            constructor = type.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw new MockitoException(\"Please ensure that the type '\" + type.getSimpleName() + \"' has 0-arg constructor.\");\n        }\n\n        if (Modifier.isPrivate(constructor.getModifiers())) {\n            constructor.setAccessible(true);\n            return Mockito.mock(type, settings\n                    .spiedInstance(constructor.newInstance()));\n        } else {\n            return Mockito.mock(type, settings.useConstructor());\n        }\n    }",
        "begin_line": 83,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/SpyAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
        "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNoIncompatibleAnnotations(java.lang.Class, java.lang.reflect.Field, java.lang.Class...)",
        "snippet": "    void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }\n    }",
        "begin_line": 122,
        "end_line": 128,
        "comment": "TODO duplicated elsewhere",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.DefaultAnnotationEngine()",
        "snippet": "    public DefaultAnnotationEngine() {\n        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n    }",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
        "snippet": "    @SuppressWarnings(\"deprecation\")\n    public Object createMockFor(Annotation annotation, Field field) {\n        return forAnnotation(annotation).process(annotation, field);\n    }",
        "begin_line": 41,
        "end_line": 44,
        "comment": " (non-Javadoc)\n    * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n    ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.forAnnotation(A)",
        "snippet": "    private <A extends Annotation> FieldAnnotationProcessor<A> forAnnotation(A annotation) {\n        if (annotationProcessorMap.containsKey(annotation.annotationType())) {\n            return (FieldAnnotationProcessor<A>) annotationProcessorMap.get(annotation.annotationType());\n        }\n        return new FieldAnnotationProcessor<A>() {\n            public Object process(A annotation, Field field) {\n                return null;\n            }\n        };\n    }",
        "begin_line": 46,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.Anonymous-e6e27706-4b2d-4707-8c67-ba4ab76687f7.process(A, java.lang.reflect.Field)",
        "snippet": "            public Object process(A annotation, Field field) {\n                return null;\n            }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.registerAnnotationProcessor(java.lang.Class<A>, org.mockito.internal.configuration.FieldAnnotationProcessor<A>)",
        "snippet": "    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {\n        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n    }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned = false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock = createMockFor(annotation, field);\n                if (mock != null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned = true;                    \n                    try {\n                        new FieldSetter(testInstance, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
        "begin_line": 61,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
        "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.throwIfAlreadyAssigned(java.lang.reflect.Field, boolean)",
        "snippet": "    void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
        "begin_line": 81,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/MockAnnotationProcessor.java",
        "class_name": "org.mockito.internal.configuration.MockAnnotationProcessor",
        "signature": "org.mockito.internal.configuration.MockAnnotationProcessor.process(org.mockito.Mock, java.lang.reflect.Field)",
        "snippet": "    public Object process(Mock annotation, Field field) {\n        MockSettings mockSettings = Mockito.withSettings();\n        if (annotation.extraInterfaces().length > 0) { // never null\n            mockSettings.extraInterfaces(annotation.extraInterfaces());\n        }\n        if (\"\".equals(annotation.name())) {\n            mockSettings.name(field.getName());\n        } else {\n            mockSettings.name(annotation.name());\n        }\n        if(annotation.serializable()){\n            mockSettings.serializable();\n        }\n\n        // see @Mock answer default value\n        mockSettings.defaultAnswer(annotation.answer());\n        return Mockito.mock(field.getType(), mockSettings);\n    }",
        "begin_line": 17,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java",
        "class_name": "org.mockito.internal.configuration.MockitoAnnotationsMockAnnotationProcessor",
        "signature": "org.mockito.internal.configuration.MockitoAnnotationsMockAnnotationProcessor.process(org.mockito.MockitoAnnotations.Mock, java.lang.reflect.Field)",
        "snippet": "    public Object process(Mock annotation, Field field) {\n        return Mockito.mock(field.getType(), field.getName());\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/InjectingAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
        "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
        "snippet": "    @Deprecated\n    public Object createMockFor(Annotation annotation, Field field) {\n        return delegate.createMockFor(annotation, field);\n    }",
        "begin_line": 33,
        "end_line": 36,
        "comment": "*\n     * Create a mock using {@link DefaultAnnotationEngine}\n     *\n     * @see org.mockito.internal.configuration.DefaultAnnotationEngine\n     * @see org.mockito.configuration.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/InjectingAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
        "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        processIndependentAnnotations(testInstance.getClass(), testInstance);\n        processInjectMocks(testInstance.getClass(), testInstance);\n    }",
        "begin_line": 54,
        "end_line": 57,
        "comment": "\n     * Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields\n     * annotated &#64;InjectMocks.\n     *\n     * <p>\n     * This code process the test class and the super classes.\n     * <ol>\n     * <li>First create Mocks, Spies, Captors.</li>\n     * <li>Then try to inject them.</li>\n     * </ol>\n     *\n     * @param clazz Not used\n     * @param testInstance The instance of the test, should not be null.\n     *\n     * @see org.mockito.configuration.AnnotationEngine#process(Class, Object)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/InjectingAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
        "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            injectMocks(testInstance);\n            classContext = classContext.getSuperclass();\n        }\n    }",
        "begin_line": 59,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/InjectingAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
        "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            //this will create @Mocks, @Captors, etc:\n            delegate.process(classContext, testInstance);\n            //this will create @Spies:\n            spyAnnotationEngine.process(classContext, testInstance);\n\n            classContext = classContext.getSuperclass();\n        }\n    }",
        "begin_line": 67,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/InjectingAnnotationEngine.java",
        "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
        "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(java.lang.Object)",
        "snippet": "    public void injectMocks(final Object testClassInstance) {\n        Class<?> clazz = testClassInstance.getClass();\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Set<Object> mocks = newMockSafeHashSet();\n        \n        while (clazz != Object.class) {\n            new InjectMocksScanner(clazz).addTo(mockDependentFields);\n            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n            clazz = clazz.getSuperclass();\n        }\n        \n        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n    }",
        "begin_line": 89,
        "end_line": 101,
        "comment": "\n     * Initializes mock/spies dependencies for objects annotated with\n     * &#064;InjectMocks for given testClassInstance.\n     * <p>\n     * See examples in javadoc for {@link MockitoAnnotations} class.\n     * \n     * @param testClassInstance\n     *            Test class, usually <code>this</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/FieldAnnotationProcessor.java",
        "class_name": "org.mockito.internal.configuration.FieldAnnotationProcessor",
        "signature": "org.mockito.internal.configuration.FieldAnnotationProcessor.process(A, java.lang.reflect.Field)",
        "snippet": "    Object process(A annotation, Field field);",
        "begin_line": 14,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/DefaultInjectionEngine.java",
        "class_name": "org.mockito.internal.configuration.DefaultInjectionEngine",
        "signature": "org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(java.util.Set<java.lang.reflect.Field>, java.util.Set<java.lang.Object>, java.lang.Object)",
        "snippet": "    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n        MockInjection.onFields(needingInjection, testClassInstance)\n                .withMocks(mocks)\n                .tryConstructorInjection()\n                .tryPropertyOrFieldInjection()\n                .handleSpyAnnotation()\n                .apply();\n    }",
        "begin_line": 19,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java",
        "class_name": "org.mockito.internal.configuration.injection.SpyOnInjectedFieldsHandler",
        "signature": "org.mockito.internal.configuration.injection.SpyOnInjectedFieldsHandler.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    @Override\n    protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n        FieldReader fieldReader = new FieldReader(fieldOwner, field);\n\n        // TODO refoctor : code duplicated in SpyAnnotationEngine\n        if(!fieldReader.isNull() && field.isAnnotationPresent(Spy.class)) {\n            try {\n                Object instance = fieldReader.read();\n                if (new MockUtil().isMock(instance)) {\n                    // A. instance has been spied earlier\n                    // B. protect against multiple use of MockitoAnnotations.initMocks()\n                    Mockito.reset(instance);\n                } else {\n                    new FieldSetter(fieldOwner, field).set(\n                        Mockito.mock(instance.getClass(), withSettings()\n                            .spiedInstance(instance)\n                            .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                            .name(field.getName()))\n                    );\n                }\n            } catch (Exception e) {\n                throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n            }\n        }\n\n        return false;\n    }",
        "begin_line": 30,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.nop()",
        "snippet": "    public static final MockInjectionStrategy nop() {\n        return new MockInjectionStrategy() {\n            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n                return false;\n            }\n        };\n    }",
        "begin_line": 19,
        "end_line": 25,
        "comment": "\n     * NOP Strategy that will always try the next strategy.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.Anonymous-eb9eb8d3-347f-49b7-bbd0-c78080379813.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n                return false;\n            }",
        "begin_line": 21,
        "end_line": 23,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.thenTry(org.mockito.internal.configuration.injection.MockInjectionStrategy)",
        "snippet": "    public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n        if(nextStrategy != null) {\n            nextStrategy.thenTry(strategy);\n        } else {\n            nextStrategy = strategy;\n        }\n        return strategy;\n    }",
        "begin_line": 40,
        "end_line": 47,
        "comment": "\n     * Enqueue next injection strategy.\n     *\n     * <p>\n     * The implementation should take care of the actual calling if required.\n     * </p>\n     *\n     * @param strategy Queued strategy.\n     * @return The passed strategy instance to allow chaining.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.process(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    public boolean process(Field onField, Object fieldOwnedBy, Set<Object> mockCandidates) {\n        if(processInjection(onField, fieldOwnedBy, mockCandidates)) {\n            return true;\n        }\n        return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);\n    }",
        "begin_line": 67,
        "end_line": 72,
        "comment": "\n     * Actually inject mockCandidates on field.\n     *\n     * <p>\n     * Actual algorithm is defined in the implementations of {@link #processInjection(Field, Object, Set)}.\n     * However if injection occurred successfully, the process should return <code>true</code>,\n     * and <code>false</code> otherwise.\n     * </p>\n     *\n     * <p>\n     * The code takes care of calling the next strategy if available and if of course if required\n     * </p>\n     *\n     * @param onField Field needing injection.\n     * @param fieldOwnedBy The owning instance of the field.\n     * @param mockCandidates A set of mock candidate, that might be injected.\n     * @return <code>true</code> if successful, <code>false</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    protected abstract boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates);",
        "begin_line": 86,
        "end_line": 86,
        "comment": "\n     * Process actual injection.\n     *\n     * <p>\n     * Don't call this method directly, instead call {@link #process(Field, Object, Set)}\n     * </p>\n     *\n     * @param field Field needing injection\n     * @param fieldOwner Field owner instance.\n     * @param mockCandidates Pool of mocks to inject.\n     * @return <code>true</code> if injection occurred, <code>false</code> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
        "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n        return nextStrategy != null && nextStrategy.process(field, fieldOwner, mockCandidates);\n    }",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.onField(java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    public static OngoingMockInjection onField(Field field, Object ofInstance) {\n        return new OngoingMockInjection(field, ofInstance);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * Create a new configuration setup for a field\n     *\n     *\n     * @param field Field needing mock injection\n     * @param ofInstance Instance owning the <code>field</code>\n     * @return New configuration builder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.onFields(java.util.Set<java.lang.reflect.Field>, java.lang.Object)",
        "snippet": "    public static OngoingMockInjection onFields(Set<Field> fields, Object ofInstance) {\n        return new OngoingMockInjection(fields, ofInstance);\n    }",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * Create a new configuration setup for fields\n     *\n     *\n     * @param fields Fields needing mock injection\n     * @param ofInstance Instance owning the <code>field</code>\n     * @return New configuration builder\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.OngoingMockInjection(java.lang.reflect.Field, java.lang.Object)",
        "snippet": "        private OngoingMockInjection(Field field, Object fieldOwner) {\n            this(Collections.singleton(field), fieldOwner);\n        }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.OngoingMockInjection(java.util.Set<java.lang.reflect.Field>, java.lang.Object)",
        "snippet": "        private OngoingMockInjection(Set<Field> fields, Object fieldOwner) {\n            this.fieldOwner = checkNotNull(fieldOwner, \"fieldOwner\");\n            this.fields.addAll(checkItemsNotNull(fields, \"fields\"));\n        }",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.withMocks(java.util.Set<java.lang.Object>)",
        "snippet": "        public OngoingMockInjection withMocks(Set<Object> mocks) {\n            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n            return this;\n        }",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.tryConstructorInjection()",
        "snippet": "        public OngoingMockInjection tryConstructorInjection() {\n            injectionStrategies.thenTry(new ConstructorInjection());\n            return this;\n        }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.tryPropertyOrFieldInjection()",
        "snippet": "        public OngoingMockInjection tryPropertyOrFieldInjection() {\n            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n            return this;\n        }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.handleSpyAnnotation()",
        "snippet": "        public OngoingMockInjection handleSpyAnnotation() {\n            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n            return this;\n        }",
        "begin_line": 85,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/MockInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.MockInjection",
        "signature": "org.mockito.internal.configuration.injection.MockInjection.OngoingMockInjection.apply()",
        "snippet": "        public void apply() {\n            for (Field field : fields) {\n                injectionStrategies.process(field, fieldOwner, mocks);\n                postInjectionStrategies.process(field, fieldOwner, mocks);\n            }\n        }",
        "begin_line": 90,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection()",
        "snippet": "    public ConstructorInjection() { }",
        "begin_line": 42,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection(org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver)",
        "snippet": "    ConstructorInjection(ConstructorArgumentResolver argResolver) {\n        this.argResolver = argResolver;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": " visible for testing",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n        try {\n            SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);\n            FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n\n            return report.fieldWasInitializedUsingContructorArgs();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause = e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            // other causes should be fine\n            return false;\n        }\n\n    }",
        "begin_line": 49,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.SimpleArgumentResolver.SimpleArgumentResolver(java.util.Set<java.lang.Object>)",
        "snippet": "        public SimpleArgumentResolver(Set<Object> objects) {\n            this.objects = objects;\n        }",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.SimpleArgumentResolver.resolveTypeInstances(java.lang.Class<?>...)",
        "snippet": "        public Object[] resolveTypeInstances(Class<?>... argTypes) {\n            List<Object> argumentInstances = new ArrayList<Object>(argTypes.length);\n            for (Class<?> argType : argTypes) {\n                argumentInstances.add(objectThatIsAssignableFrom(argType));\n            }\n            return argumentInstances.toArray();\n        }",
        "begin_line": 76,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/ConstructorInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
        "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.SimpleArgumentResolver.objectThatIsAssignableFrom(java.lang.Class<?>)",
        "snippet": "        private Object objectThatIsAssignableFrom(Class<?> argType) {\n            for (Object object : objects) {\n                if(argType.isAssignableFrom(object.getClass())) return object;\n            }\n            return null;\n        }",
        "begin_line": 84,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.Anonymous-04cf204b-8aa0-4483-8335-034439c437f9.isOut(java.lang.reflect.Field)",
        "snippet": "        public boolean isOut(Field object) {\n            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n        }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(java.lang.reflect.Field, java.lang.Object, java.util.Set<java.lang.Object>)",
        "snippet": "    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {\n        // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n\n        // for each field in the class hierarchy\n        boolean injectionOccurred = false;\n        Class<?> fieldClass = report.fieldClass();\n        Object fieldInstanceNeedingInjection = report.fieldInstance();\n        while (fieldClass != Object.class) {\n            injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n            fieldClass = fieldClass.getSuperclass();\n        }\n        return injectionOccurred;\n    }",
        "begin_line": 71,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.initializeInjectMocksField(java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n        FieldInitializationReport report = null;\n        try {\n            report = new FieldInitializer(fieldOwner, field).initialize();\n        } catch (MockitoException e) {\n            if(e.getCause() instanceof InvocationTargetException) {\n                Throwable realCause = e.getCause().getCause();\n                new Reporter().fieldInitialisationThrewException(field, realCause);\n            }\n            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n        }\n        return report; // never null\n    }",
        "begin_line": 86,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(java.lang.Class<?>, java.util.Set<java.lang.Object>, java.lang.Object)",
        "snippet": "    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n        boolean injectionOccurred = false;\n        List<Field> orderedInstanceFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n        // pass 1\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        // pass 2\n        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n        return injectionOccurred;\n    }",
        "begin_line": 101,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidatesOnFields(java.util.Set<java.lang.Object>, java.lang.Object, boolean, java.util.List<java.lang.reflect.Field>)",
        "snippet": "    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n            Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n            if (injected != null) {\n                injectionOccurred |= true;\n                mocks.remove(injected);\n                it.remove();\n            }\n        }\n        return injectionOccurred;\n    }",
        "begin_line": 111,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java",
        "class_name": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection",
        "signature": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(java.lang.Class<?>)",
        "snippet": "    private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());\n        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);\n\n        return new SuperTypesLastSorter().sort(declaredFields);\n    }",
        "begin_line": 124,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.MockScanner(java.lang.Object, java.lang.Class<?>)",
        "snippet": "    public MockScanner(Object instance, Class<?> clazz) {\n        this.instance = instance;\n        this.clazz = clazz;\n    }",
        "begin_line": 32,
        "end_line": 35,
        "comment": "\n     * Creates a MockScanner.\n     *\n     * @param instance The test instance\n     * @param clazz    The class in the type hierarchy of this instance.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.addPreparedMocks(java.util.Set<java.lang.Object>)",
        "snippet": "    public void addPreparedMocks(Set<Object> mocks) {\n        mocks.addAll(scan());\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Add the scanned and prepared mock instance to the given collection.\n     *\n     * <p>\n     * The preparation of mocks consists only in defining a MockName if not already set.\n     * </p>\n     *\n     * @param mocks Set of mocks\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.scan()",
        "snippet": "    private Set<Object> scan() {\n        Set<Object> mocks = newMockSafeHashSet();\n        for (Field field : clazz.getDeclaredFields()) {\n            // mock or spies only\n            FieldReader fieldReader = new FieldReader(instance, field);\n\n            Object mockInstance = preparedMock(fieldReader.read(), field);\n            if (mockInstance != null) {\n                mocks.add(mockInstance);\n            }\n        }\n        return mocks;\n    }",
        "begin_line": 55,
        "end_line": 67,
        "comment": "\n     * Scan and prepare mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.\n     *\n     * @return A prepared set of mock\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.preparedMock(java.lang.Object, java.lang.reflect.Field)",
        "snippet": "    private Object preparedMock(Object instance, Field field) {\n        if (isAnnotatedByMockOrSpy(field)) {\n            return instance;\n        } else if (isMockOrSpy(instance)) {\n            mockUtil.maybeRedefineMockName(instance, field.getName());\n            return instance;\n        }\n        return null;\n    }",
        "begin_line": 69,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isAnnotatedByMockOrSpy(java.lang.reflect.Field)",
        "snippet": "    private boolean isAnnotatedByMockOrSpy(Field field) {\n        return null != field.getAnnotation(Spy.class)\n                || null != field.getAnnotation(Mock.class)\n                || null != field.getAnnotation(MockitoAnnotations.Mock.class);\n    }",
        "begin_line": 79,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/MockScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isMockOrSpy(java.lang.Object)",
        "snippet": "    private boolean isMockOrSpy(Object instance) {\n        return mockUtil.isMock(instance)\n                || mockUtil.isSpy(instance);\n    }",
        "begin_line": 85,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.InjectMocksScanner(java.lang.Class<?>)",
        "snippet": "    public InjectMocksScanner(Class<?> clazz) {\n        this.clazz = clazz;\n    }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "\n     * Create a new InjectMocksScanner for the given clazz on the given instance\n     *\n     * @param clazz    Current class in the hierarchy of the test\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.addTo(java.util.Set<java.lang.reflect.Field>)",
        "snippet": "    public void addTo(Set<Field> mockDependentFields) {\n        mockDependentFields.addAll(scan());\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "\n     * Add the fields annotated by @{@link InjectMocks}\n     *\n     * @param mockDependentFields Set of fields annotated by  @{@link InjectMocks}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.scan()",
        "snippet": "    private Set<Field> scan() {\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null != field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }",
        "begin_line": 48,
        "end_line": 59,
        "comment": "\n     * Scan fields annotated by &#064;InjectMocks\n     *\n     * @return Fields that depends on Mock\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java",
        "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
        "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.assertNoAnnotations(java.lang.reflect.Field, java.lang.Class...)",
        "snippet": "    void assertNoAnnotations(final Field field, final Class... annotations) {\n        for (Class annotation : annotations) {\n            if (field.isAnnotationPresent(annotation)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n            }\n        }\n    }",
        "begin_line": 61,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/OngoingInjecter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.OngoingInjecter",
        "signature": "org.mockito.internal.configuration.injection.filter.OngoingInjecter.thenInject()",
        "snippet": "    Object thenInject();",
        "begin_line": 21,
        "end_line": 21,
        "comment": "\n     * Inject the mock.\n     *\n     * <p>\n     * Please check the actual implementation.\n     * </p>\n     *\n     * @return the mock that was injected, <code>null</code> otherwise.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.TypeBasedCandidateFilter(org.mockito.internal.configuration.injection.filter.MockCandidateFilter)",
        "snippet": "    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.filterCandidate(java.util.Collection<java.lang.Object>, java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n    }",
        "begin_line": 20,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.NameBasedCandidateFilter(org.mockito.internal.configuration.injection.filter.MockCandidateFilter)",
        "snippet": "    public NameBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.filterCandidate(java.util.Collection<java.lang.Object>, java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n        List<Object> mockNameMatches = new ArrayList<Object>();\n        if(mocks.size() > 1) {\n            for (Object mock : mocks) {\n                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n                    mockNameMatches.add(mock);\n                }\n            }\n            return next.filterCandidate(mockNameMatches, field, fieldInstance);\n        }\n        return next.filterCandidate(mocks, field, fieldInstance);\n    }",
        "begin_line": 22,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.MockCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.MockCandidateFilter.filterCandidate(java.util.Collection<java.lang.Object>, java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            Object fieldInstance\n    );",
        "begin_line": 12,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.filterCandidate(java.util.Collection<java.lang.Object>, java.lang.reflect.Field, java.lang.Object)",
        "snippet": "    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }",
        "begin_line": 23,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.Anonymous-02efc463-f053-4feb-a208-52b4bac5772e.thenInject()",
        "snippet": "                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }",
        "begin_line": 28,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java",
        "class_name": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter",
        "signature": "org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter.Anonymous-069174de-4c57-4217-bb72-a8b9061fba4a.thenInject()",
        "snippet": "            public Object thenInject() {\n                return null;\n            }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginFinder.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
        "signature": "org.mockito.internal.configuration.plugins.PluginFinder.PluginFinder(org.mockito.plugins.PluginSwitch)",
        "snippet": "    public PluginFinder(PluginSwitch pluginSwitch) {\n        this.pluginSwitch = pluginSwitch;\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginFinder.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
        "signature": "org.mockito.internal.configuration.plugins.PluginFinder.findPluginClass(java.lang.Iterable<java.net.URL>)",
        "snippet": "    String findPluginClass(Iterable<URL> resources) {\n        for (URL resource : resources) {\n            InputStream s = null;\n            try {\n                s = resource.openStream();\n                String pluginClassName = new PluginFileReader().readPluginClass(s);\n                if (pluginClassName == null) {\n                    //For backwards compatibility\n                    //If the resource does not have plugin class name we're ignoring it\n                    continue;\n                }\n                if (!pluginSwitch.isEnabled(pluginClassName)) {\n                    continue;\n                }\n                return pluginClassName;\n            } catch(Exception e) {\n                throw new MockitoException(\"Problems reading plugin implementation from: \" + resource, e);\n            } finally {\n                IOUtil.closeQuietly(s);\n            }\n        }\n        return null;\n    }",
        "begin_line": 18,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginLoader.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
        "signature": "org.mockito.internal.configuration.plugins.PluginLoader.PluginLoader(org.mockito.plugins.PluginSwitch)",
        "snippet": "    public PluginLoader(PluginSwitch pluginSwitch) {\n        this.pluginSwitch = pluginSwitch;\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginLoader.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
        "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(java.lang.Class<T>, java.lang.String)",
        "snippet": "    <T> T loadPlugin(Class<T> pluginType, String defaultPluginClassName) {\n        T plugin = loadImpl(pluginType);\n        if (plugin != null) {\n            return plugin;\n        }\n\n        try {\n            // Default implementation. Use our own ClassLoader instead of the context\n            // ClassLoader, as the default implementation is assumed to be part of\n            // Mockito and may not be available via the context ClassLoader.\n            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n        } catch (Exception e) {\n            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n                    \"Failed to load \" + pluginType, e);\n        }\n    }",
        "begin_line": 23,
        "end_line": 39,
        "comment": "\n     * Scans the classpath for given pluginType. If not found, default class is used.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginLoader.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
        "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(java.lang.Class<T>)",
        "snippet": "    <T> T loadImpl(Class<T> service) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        if (loader == null) {\n            loader = ClassLoader.getSystemClassLoader();\n        }\n        Enumeration<URL> resources;\n        try {\n            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n        } catch (IOException e) {\n            throw new MockitoException(\"Failed to load \" + service, e);\n        }\n\n        try {\n            String foundPluginClass = new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));\n            if (foundPluginClass != null) {\n                Class<?> pluginClass = loader.loadClass(foundPluginClass);\n                Object plugin = pluginClass.newInstance();\n                return service.cast(plugin);\n            }\n            return null;\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\n                    \"Failed to load \" + service + \" implementation declared in \" + resources, e);\n        }\n    }",
        "begin_line": 45,
        "end_line": 69,
        "comment": "\n     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n     * Java 6 / Android 2.3 (Gingerbread).\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java",
        "class_name": "org.mockito.internal.configuration.plugins.DefaultPluginSwitch",
        "signature": "org.mockito.internal.configuration.plugins.DefaultPluginSwitch.isEnabled(java.lang.String)",
        "snippet": "    public boolean isEnabled(String pluginClassName) {\n        return true;\n    }",
        "begin_line": 6,
        "end_line": 8,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/Plugins.java",
        "class_name": "org.mockito.internal.configuration.plugins.Plugins",
        "signature": "org.mockito.internal.configuration.plugins.Plugins.getStackTraceCleanerProvider()",
        "snippet": "    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n        return registry.getStackTraceCleanerProvider();\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "\n     * The implementation of the stack trace cleaner\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/Plugins.java",
        "class_name": "org.mockito.internal.configuration.plugins.Plugins",
        "signature": "org.mockito.internal.configuration.plugins.Plugins.getMockMaker()",
        "snippet": "    public static MockMaker getMockMaker() {\n        return registry.getMockMaker();\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "\n     * Returns the implementation of the mock maker available for the current runtime.\n     *\n     * <p>Returns default mock maker if no\n     * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginRegistry.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginRegistry",
        "signature": "org.mockito.internal.configuration.plugins.PluginRegistry.getStackTraceCleanerProvider()",
        "snippet": "    StackTraceCleanerProvider getStackTraceCleanerProvider() {\n        //TODO we should throw some sensible exception if this is null.\n        return stackTraceCleanerProvider;\n    }",
        "begin_line": 21,
        "end_line": 24,
        "comment": "\n     * The implementation of the stack trace cleaner\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginRegistry.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginRegistry",
        "signature": "org.mockito.internal.configuration.plugins.PluginRegistry.getMockMaker()",
        "snippet": "    MockMaker getMockMaker() {\n        return mockMaker;\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "\n     * Returns the implementation of the mock maker available for the current runtime.\n     *\n     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n     * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginFileReader.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginFileReader",
        "signature": "org.mockito.internal.configuration.plugins.PluginFileReader.readPluginClass(java.io.InputStream)",
        "snippet": "    String readPluginClass(InputStream input) throws IOException {\n        for(String line: IOUtil.readLines(input)) {\n            String stripped = stripCommentAndWhitespace(line);\n            if (stripped.length() > 0) {\n                return stripped;\n            }\n        }\n        return null;\n    }",
        "begin_line": 11,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/internal/configuration/plugins/PluginFileReader.java",
        "class_name": "org.mockito.internal.configuration.plugins.PluginFileReader",
        "signature": "org.mockito.internal.configuration.plugins.PluginFileReader.stripCommentAndWhitespace(java.lang.String)",
        "snippet": "    private static String stripCommentAndWhitespace(String line) {\n        int hash = line.indexOf('#');\n        if (hash != -1) {\n            line = line.substring(0, hash);\n        }\n        return line.trim();\n    }",
        "begin_line": 21,
        "end_line": 27,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockName.java",
        "class_name": "org.mockito.mock.MockName",
        "signature": "org.mockito.mock.MockName.toString()",
        "snippet": "    String toString();",
        "begin_line": 15,
        "end_line": 15,
        "comment": "\n     * the name\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockName.java",
        "class_name": "org.mockito.mock.MockName",
        "signature": "org.mockito.mock.MockName.isDefault()",
        "snippet": "    boolean isDefault();",
        "begin_line": 20,
        "end_line": 20,
        "comment": "\n     * default name means generated by Mockito. non-default means the user has named the mock at creation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getTypeToMock()",
        "snippet": "    Class<T> getTypeToMock();",
        "begin_line": 23,
        "end_line": 23,
        "comment": "\n     * Mocked type. An interface or class the mock should implement / extend.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getExtraInterfaces()",
        "snippet": "    Set<Class> getExtraInterfaces();",
        "begin_line": 28,
        "end_line": 28,
        "comment": "\n     * the extra interfaces the mock object should implement.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getMockName()",
        "snippet": "    MockName getMockName();",
        "begin_line": 33,
        "end_line": 33,
        "comment": "\n     * the name of this mock, as printed on verification errors; see {@link org.mockito.MockSettings#name}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getDefaultAnswer()",
        "snippet": "    Answer getDefaultAnswer();",
        "begin_line": 38,
        "end_line": 38,
        "comment": "\n     * the default answer for this mock, see {@link org.mockito.MockSettings#defaultAnswer}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getSpiedInstance()",
        "snippet": "    Object getSpiedInstance();",
        "begin_line": 43,
        "end_line": 43,
        "comment": "\n     * the spied instance - needed for spies.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.isSerializable()",
        "snippet": "    boolean isSerializable();",
        "begin_line": 48,
        "end_line": 48,
        "comment": "\n     * if the mock is serializable, see {@link org.mockito.MockSettings#serializable}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getSerializableMode()",
        "snippet": "    SerializableMode getSerializableMode();",
        "begin_line": 53,
        "end_line": 53,
        "comment": "\n     * @return the serializable mode of this mock\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.isStubOnly()",
        "snippet": "    boolean isStubOnly();",
        "begin_line": 60,
        "end_line": 60,
        "comment": "\n     * Whether the mock is only for stubbing, i.e. does not remember\n     * parameters on its invocation and therefore cannot\n     * be used for verification\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getInvocationListeners()",
        "snippet": "    List<InvocationListener> getInvocationListeners();",
        "begin_line": 65,
        "end_line": 65,
        "comment": "\n     * The invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.isUsingConstructor()",
        "snippet": "    @Incubating\n    boolean isUsingConstructor();",
        "begin_line": 72,
        "end_line": 73,
        "comment": "\n     * Informs whether the mock instance should be created via constructor\n     *\n     * @since 1.10.12\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/mock/MockCreationSettings.java",
        "class_name": "org.mockito.mock.MockCreationSettings",
        "signature": "org.mockito.mock.MockCreationSettings.getOuterClassInstance()",
        "snippet": "    @Incubating\n    Object getOuterClassInstance();",
        "begin_line": 81,
        "end_line": 82,
        "comment": "\n     * Used when mocking non-static inner classes in conjunction with {@link #isUsingConstructor()}\n     *\n     * @return the outer class instance used for creation of the mock object via the constructor.\n     * @since 1.10.12\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.VerboseMockitoJUnitRunner(java.lang.Class<?>)",
        "snippet": "    public VerboseMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {\n        this(new RunnerFactory().create(klass));\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.VerboseMockitoJUnitRunner(org.mockito.internal.runners.RunnerImpl)",
        "snippet": "    VerboseMockitoJUnitRunner(RunnerImpl runnerImpl) {\n        this.runner = runnerImpl;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    @Override\n    public void run(RunNotifier notifier) {        \n\n        //a listener that changes the failure's exception in a very hacky way...\n        RunListener listener = new RunListener() {\n            \n            WarningsCollector warningsCollector;\n                       \n            @Override\n            public void testStarted(Description description) throws Exception {\n                warningsCollector = new WarningsCollector();\n            }\n            \n            @Override \n            public void testFailure(final Failure failure) throws Exception {       \n                String warnings = warningsCollector.getWarnings();\n                new JUnitFailureHacker().appendWarnings(failure, warnings);                              \n            }\n        };\n\n        notifier.addFirstListener(listener);\n\n        runner.run(notifier);\n    }",
        "begin_line": 50,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.Anonymous-0edc31cd-e8de-4bdd-9541-1ce60377f45a.testStarted(org.junit.runner.Description)",
        "snippet": "            @Override\n            public void testStarted(Description description) throws Exception {\n                warningsCollector = new WarningsCollector();\n            }",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.Anonymous-81205734-8840-4bd4-8e4b-abfde50e51cf.testFailure(org.junit.runner.notification.Failure)",
        "snippet": "            @Override \n            public void testFailure(final Failure failure) throws Exception {       \n                String warnings = warningsCollector.getWarnings();\n                new JUnitFailureHacker().appendWarnings(failure, warnings);                              \n            }",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.getDescription()",
        "snippet": "    @Override\n    public Description getDescription() {\n        return runner.getDescription();\n    }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/VerboseMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.VerboseMockitoJUnitRunner",
        "signature": "org.mockito.runners.VerboseMockitoJUnitRunner.filter(org.junit.runner.manipulation.Filter)",
        "snippet": "    public void filter(Filter filter) throws NoTestsRemainException {\n        //filter is required because without it UnrootedTests show up in Eclipse\n        runner.filter(filter);\n    }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/MockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.MockitoJUnitRunner",
        "signature": "org.mockito.runners.MockitoJUnitRunner.MockitoJUnitRunner(java.lang.Class<?>)",
        "snippet": "    public MockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {\n        runner = new RunnerFactory().create(klass);\n    }",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/MockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.MockitoJUnitRunner",
        "signature": "org.mockito.runners.MockitoJUnitRunner.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    @Override\n    public void run(final RunNotifier notifier) {           \n        runner.run(notifier);\n    }",
        "begin_line": 60,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/MockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.MockitoJUnitRunner",
        "signature": "org.mockito.runners.MockitoJUnitRunner.getDescription()",
        "snippet": "    @Override\n    public Description getDescription() {\n        return runner.getDescription();\n    }",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/MockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.MockitoJUnitRunner",
        "signature": "org.mockito.runners.MockitoJUnitRunner.filter(org.junit.runner.manipulation.Filter)",
        "snippet": "    public void filter(Filter filter) throws NoTestsRemainException {\n        //filter is required because without it UnrootedTests show up in Eclipse\n        runner.filter(filter);\n    }",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/MockitoJUnit44Runner.java",
        "class_name": "org.mockito.runners.MockitoJUnit44Runner",
        "signature": "org.mockito.runners.MockitoJUnit44Runner.MockitoJUnit44Runner(java.lang.Class<?>)",
        "snippet": "    public MockitoJUnit44Runner(Class<?> klass) throws InvocationTargetException {\n        super(klass);\n    }",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.ConsoleSpammingMockitoJUnitRunner(java.lang.Class<?>)",
        "snippet": "    public ConsoleSpammingMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {\n        this(new ConsoleMockitoLogger(), new RunnerFactory().create(klass));\n    }",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.ConsoleSpammingMockitoJUnitRunner(org.mockito.internal.util.MockitoLogger, org.mockito.internal.runners.RunnerImpl)",
        "snippet": "    ConsoleSpammingMockitoJUnitRunner(MockitoLogger logger, RunnerImpl runnerImpl) {\n        this.runner = runnerImpl;\n        this.logger = logger;\n    }",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.run(org.junit.runner.notification.RunNotifier)",
        "snippet": "    @Override\n    public void run(RunNotifier notifier) {\n        RunListener listener = new RunListener() {\n            WarningsCollector warningsCollector;\n            \n            @Override\n            public void testStarted(Description description) throws Exception {\n                warningsCollector = new WarningsCollector();\n            }\n            \n            @Override public void testFailure(Failure failure) throws Exception {                \n                logger.log(warningsCollector.getWarnings());\n            }\n        };\n\n        notifier.addListener(listener);\n\n        runner.run(notifier);\n    }",
        "begin_line": 103,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.Anonymous-54c274c7-cd0f-43e6-a3f5-229a95b10e01.testStarted(org.junit.runner.Description)",
        "snippet": "            @Override\n            public void testStarted(Description description) throws Exception {\n                warningsCollector = new WarningsCollector();\n            }",
        "begin_line": 108,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.Anonymous-cfb75813-770e-4294-ab37-233659397ad3.testFailure(org.junit.runner.notification.Failure)",
        "snippet": "            @Override public void testFailure(Failure failure) throws Exception {                \n                logger.log(warningsCollector.getWarnings());\n            }",
        "begin_line": 113,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.getDescription()",
        "snippet": "    @Override\n    public Description getDescription() {\n        return runner.getDescription();\n    }",
        "begin_line": 123,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java",
        "class_name": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner",
        "signature": "org.mockito.runners.ConsoleSpammingMockitoJUnitRunner.filter(org.junit.runner.manipulation.Filter)",
        "snippet": "    public void filter(Filter filter) throws NoTestsRemainException {\n        //filter is required because without it UnrootedTests show up in Eclipse\n        runner.filter(filter);\n    }",
        "begin_line": 128,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationMode.java",
        "class_name": "org.mockito.verification.VerificationMode",
        "signature": "org.mockito.verification.VerificationMode.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    void verify(VerificationData data);",
        "begin_line": 34,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/After.java",
        "class_name": "org.mockito.verification.After",
        "signature": "org.mockito.verification.After.After(long, org.mockito.verification.VerificationMode)",
        "snippet": "    public After(long delayMillis, VerificationMode verificationMode) {\n        this(10, delayMillis, verificationMode);\n    }",
        "begin_line": 19,
        "end_line": 21,
        "comment": "\n     * See the javadoc for {@link VerificationAfterDelay}\n     * <p>\n     * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n     * See javadoc for {@link VerificationWithTimeout}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/After.java",
        "class_name": "org.mockito.verification.After",
        "signature": "org.mockito.verification.After.After(long, long, org.mockito.verification.VerificationMode)",
        "snippet": "    After(long pollingPeriod, long delayMillis, VerificationMode verificationMode) {\n        this(new VerificationOverTimeImpl(pollingPeriod, delayMillis, verificationMode, false));\n    }",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/After.java",
        "class_name": "org.mockito.verification.After",
        "signature": "org.mockito.verification.After.After(org.mockito.internal.verification.VerificationOverTimeImpl)",
        "snippet": "    After(VerificationOverTimeImpl verificationOverTime) {\n        super(verificationOverTime);\n    }",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/After.java",
        "class_name": "org.mockito.verification.After",
        "signature": "org.mockito.verification.After.copySelfWithNewVerificationMode(org.mockito.verification.VerificationMode)",
        "snippet": "    @Override\n    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode) {\n        return new After(wrappedVerification.copyWithVerificationMode(verificationMode));\n    }",
        "begin_line": 31,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.Timeout(long, org.mockito.verification.VerificationMode)",
        "snippet": "    public Timeout(long millis, VerificationMode delegate) {\n        this(10, millis, delegate);\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "\n     * See the javadoc for {@link VerificationWithTimeout}\n     * <p>\n     * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n     * See javadoc for {@link VerificationWithTimeout}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.Timeout(long, long, org.mockito.verification.VerificationMode)",
        "snippet": "    Timeout(long pollingPeriodMillis, long millis, VerificationMode delegate) {\n        this(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true));\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "\n     * See the javadoc for {@link VerificationWithTimeout}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.Timeout(long, org.mockito.verification.VerificationMode, org.mockito.internal.util.Timer)",
        "snippet": "    Timeout(long pollingPeriodMillis, VerificationMode delegate, Timer timer) {\n        this(new VerificationOverTimeImpl(pollingPeriodMillis, delegate, true, timer));\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "\n     * See the javadoc for {@link VerificationWithTimeout}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.Timeout(org.mockito.internal.verification.VerificationOverTimeImpl)",
        "snippet": "    Timeout(VerificationOverTimeImpl verificationOverTime) {\n        super(verificationOverTime);\n    }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.copySelfWithNewVerificationMode(org.mockito.verification.VerificationMode)",
        "snippet": "    @Override\n    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode newVerificationMode) {\n        return new Timeout(wrappedVerification.copyWithVerificationMode(newVerificationMode));\n    }",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.atMost(int)",
        "snippet": "    public VerificationMode atMost(int maxNumberOfInvocations) {\n        new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();\n        return null;\n    }",
        "begin_line": 51,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/Timeout.java",
        "class_name": "org.mockito.verification.Timeout",
        "signature": "org.mockito.verification.Timeout.never()",
        "snippet": "    public VerificationMode never() {\n        new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();\n        return null;\n    }",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.times(int)",
        "snippet": "    public VerificationMode times(int wantedNumberOfInvocations);",
        "begin_line": 42,
        "end_line": 42,
        "comment": "\n     * Allows verifying exact number of invocations within given timeout\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, timeout(100).times(2)).someMethod(\"some arg\");\n     * </code></pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param wantedNumberOfInvocations wanted number of invocations \n     * \n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.never()",
        "snippet": "    @Deprecated    \n    public VerificationMode never();",
        "begin_line": 57,
        "end_line": 58,
        "comment": "\n     * @deprecated\n     * Validation with timeout combined with never simply does not make sense, as never() will typically immediately pass,\n     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().never(). \n     * <p>\n     * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n     * <p>\n     * In a future release we will remove timeout(x).atMost(y) and timeout(x).never() from the API.\n     * <p>\n     * Do you want to find out more? See <a href=\"http://code.google.com/p/mockito/issues/detail?id=235\">issue 235</a>\n     * \n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.atLeastOnce()",
        "snippet": "    public VerificationMode atLeastOnce();",
        "begin_line": 71,
        "end_line": 71,
        "comment": "\n     * Allows at-least-once verification within given timeout. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, timeout(100).atLeastOnce()).someMethod(\"some arg\");\n     * </code></pre>\n     * Alias to atLeast(1)\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.atLeast(int)",
        "snippet": "    public VerificationMode atLeast(int minNumberOfInvocations);",
        "begin_line": 85,
        "end_line": 85,
        "comment": "\n     * Allows at-least-x verification within given timeout. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, timeout(100).atLeast(3)).someMethod(\"some arg\");\n     * </code></pre>\n     * \n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @param minNumberOfInvocations minimum number of invocations \n     * \n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.atMost(int)",
        "snippet": "    @Deprecated\n    public VerificationMode atMost(int maxNumberOfInvocations);",
        "begin_line": 102,
        "end_line": 103,
        "comment": "\n     * @deprecated\n     *\n     * <b>Deprecated</b>\n     * Validation with timeout combined with never simply does not make sense, as atMost() will typically immediately pass,\n     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().atMost(). \n     * <p>\n     * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n     * <p>\n     * In a future release we will remove timeout(x).atMost(y) and timeout(x).never() from the API.\n     * <p>\n     * Do you want to find out more? See <a href=\"http://code.google.com/p/mockito/issues/detail?id=235\">issue 235</a>\n     *\n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWithTimeout.java",
        "class_name": "org.mockito.verification.VerificationWithTimeout",
        "signature": "org.mockito.verification.VerificationWithTimeout.only()",
        "snippet": "    public VerificationMode only();       ",
        "begin_line": 121,
        "end_line": 121,
        "comment": "\n     * Allows checking if given method was the only one invoked. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     *   verify(mock, only()).someMethod();\n     *   //above is a shorthand for following 2 lines of code:\n     *   verify(mock).someMethod();\n     *   verifyNoMoreInvocations(mock);\n     * </code></pre>\n     * \n     * <p>\n     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     * \n     * @return verification mode\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.VerificationWrapper(WrapperType)",
        "snippet": "    public VerificationWrapper(WrapperType wrappedVerification) {\n        this.wrappedVerification = wrappedVerification;\n    }",
        "begin_line": 10,
        "end_line": 12,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.verify(org.mockito.internal.verification.api.VerificationData)",
        "snippet": "    public void verify(VerificationData data) {\n        wrappedVerification.verify(data);\n    } ",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.copySelfWithNewVerificationMode(org.mockito.verification.VerificationMode)",
        "snippet": "    protected abstract VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode);",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.times(int)",
        "snippet": "    public VerificationMode times(int wantedNumberOfInvocations) {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.times(wantedNumberOfInvocations));\n    }",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.never()",
        "snippet": "    public VerificationMode never() {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.atMost(0));\n    }",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.atLeastOnce()",
        "snippet": "    public VerificationMode atLeastOnce() {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.atLeastOnce());\n    }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.atLeast(int)",
        "snippet": "    public VerificationMode atLeast(int minNumberOfInvocations) {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.atLeast(minNumberOfInvocations));\n    }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.atMost(int)",
        "snippet": "    public VerificationMode atMost(int maxNumberOfInvocations) {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.atMost(maxNumberOfInvocations));\n    }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationWrapper.java",
        "class_name": "org.mockito.verification.VerificationWrapper",
        "signature": "org.mockito.verification.VerificationWrapper.only()",
        "snippet": "    public VerificationMode only() {\n        return copySelfWithNewVerificationMode(VerificationModeFactory.only());\n    }",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.times(int)",
        "snippet": "    public VerificationMode times(int wantedNumberOfInvocations);",
        "begin_line": 34,
        "end_line": 34,
        "comment": "\n     * Verifies that there are exactly N invocations during the given period. This will wait the full period given.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.never()",
        "snippet": "    public VerificationMode never();",
        "begin_line": 40,
        "end_line": 40,
        "comment": "\n     * Allows verification that there are no invocations at any point during the given period. This will wait the \n     * full period given, unless an invocation occurs (in which case there will be immediate failure)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.atLeastOnce()",
        "snippet": "    public VerificationMode atLeastOnce();",
        "begin_line": 45,
        "end_line": 45,
        "comment": "\n     * Verifies that there is at least 1 invocation during the given period. This will wait the full period given.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.atLeast(int)",
        "snippet": "    public VerificationMode atLeast(int minNumberOfInvocations);",
        "begin_line": 50,
        "end_line": 50,
        "comment": "\n     * Verifies that there is are least N invocations during the given period. This will wait the full period given.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.atMost(int)",
        "snippet": "    public VerificationMode atMost(int maxNumberOfInvocations);",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Verifies that there is are most N invocations during the given period. This will wait the full period given,\n     * unless too many invocations occur (in which case there will be an immediate failure)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/verification/VerificationAfterDelay.java",
        "class_name": "org.mockito.verification.VerificationAfterDelay",
        "signature": "org.mockito.verification.VerificationAfterDelay.only()",
        "snippet": "    public VerificationMode only();",
        "begin_line": 62,
        "end_line": 62,
        "comment": "\n     * Verifies that there the given method is invoked and is the only method invoked. This will wait the full \n     * period given, unless another method is invoked (in which case there will be an immediate failure)\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/PrintableInvocation.java",
        "class_name": "org.mockito.exceptions.PrintableInvocation",
        "signature": "org.mockito.exceptions.PrintableInvocation.toString()",
        "snippet": "    String toString();",
        "begin_line": 18,
        "end_line": 18,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/PrintableInvocation.java",
        "class_name": "org.mockito.exceptions.PrintableInvocation",
        "signature": "org.mockito.exceptions.PrintableInvocation.getLocation()",
        "snippet": "    Location getLocation();",
        "begin_line": 20,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.checkedExceptionInvalid(java.lang.Throwable)",
        "snippet": "    public void checkedExceptionInvalid(Throwable t) {\n        throw new MockitoException(join(\n                \"Checked exception is invalid for this method!\",\n                \"Invalid: \" + t\n        ));\n    }",
        "begin_line": 56,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotStubWithNullThrowable()",
        "snippet": "    public void cannotStubWithNullThrowable() {\n        throw new MockitoException(join(\n                \"Cannot stub with null throwable!\"\n        ));\n\n    }",
        "begin_line": 63,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.unfinishedStubbing(org.mockito.invocation.Location)",
        "snippet": "    public void unfinishedStubbing(Location location) {\n        throw new UnfinishedStubbingException(join(\n                \"Unfinished stubbing detected here:\",\n                location,\n                \"\",\n                \"E.g. thenReturn() may be missing.\",\n                \"Examples of correct stubbing:\",\n                \"    when(mock.isOk()).thenReturn(true);\",\n                \"    when(mock.isOk()).thenThrow(exception);\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"Hints:\",\n                \" 1. missing thenReturn()\",\n                \" 2. you are trying to stub a final method, you naughty developer!\",\n                \" 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed\",\n                \"\"\n        ));\n    }",
        "begin_line": 70,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.incorrectUseOfApi()",
        "snippet": "    public void incorrectUseOfApi() {\n        throw new MockitoException(join(\n                \"Incorrect use of API detected here:\",\n                new LocationImpl(),\n                \"\",\n                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                \"Examples of correct usage:\",\n                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n                \"\"\n        ));\n    }",
        "begin_line": 88,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.missingMethodInvocation()",
        "snippet": "    public void missingMethodInvocation() {\n        throw new MissingMethodInvocationException(join(\n                \"when() requires an argument which has to be 'a method call on a mock'.\",\n                \"For example:\",\n                \"    when(mock.getArticles()).thenReturn(articles);\",\n                \"\",\n                \"Also, this error might show up because:\",\n                \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                \"   Those methods *cannot* be stubbed/verified.\",\n                \"   \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"2. inside when() you don't call method on mock but on some other object.\",\n                \"\"\n        ));\n    }",
        "begin_line": 101,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.unfinishedVerificationException(org.mockito.invocation.Location)",
        "snippet": "    public void unfinishedVerificationException(Location location) {\n        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                \"Missing method call for verify(mock) here:\",\n                location,\n                \"\",\n                \"Example of correct verification:\",\n                \"    verify(mock).doSomething()\",\n                \"\",\n                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                \"Those methods *cannot* be stubbed/verified.\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n\n        throw exception;\n    }",
        "begin_line": 116,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.notAMockPassedToVerify(java.lang.Class)",
        "snippet": "    public void notAMockPassedToVerify(Class type) {\n        throw new NotAMockException(join(\n                \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                \"Make sure you place the parenthesis correctly!\",\n                \"See the examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\"\n        ));\n    }",
        "begin_line": 133,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.nullPassedToVerify()",
        "snippet": "    public void nullPassedToVerify() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to verify() should be a mock but is null!\",\n                \"Examples of correct verifications:\",\n                \"    verify(mock).someMethod();\",\n                \"    verify(mock, times(10)).someMethod();\",\n                \"    verify(mock, atLeastOnce()).someMethod();\",\n                \"    not: verify(mock.someMethod());\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }",
        "begin_line": 144,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.notAMockPassedToWhenMethod()",
        "snippet": "    public void notAMockPassedToWhenMethod() {\n        throw new NotAMockException(join(\n                \"Argument passed to when() is not a mock!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n        ));\n    }",
        "begin_line": 156,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.nullPassedToWhenMethod()",
        "snippet": "    public void nullPassedToWhenMethod() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument passed to when() is null!\",\n                \"Example of correct stubbing:\",\n                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                \"Also, if you use @Mock annotation don't miss initMocks()\"\n        ));\n    }",
        "begin_line": 164,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.mocksHaveToBePassedToVerifyNoMoreInteractions()",
        "snippet": "    public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that should be verified, e.g:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }",
        "begin_line": 173,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.notAMockPassedToVerifyNoMoreInteractions()",
        "snippet": "    public void notAMockPassedToVerifyNoMoreInteractions() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                \"\"\n        ));\n    }",
        "begin_line": 183,
        "end_line": 191,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.nullPassedToVerifyNoMoreInteractions()",
        "snippet": "    public void nullPassedToVerifyNoMoreInteractions() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Examples of correct verifications:\",\n                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                \"    verifyZeroInteractions(mockOne, mockTwo);\"\n        ));\n    }",
        "begin_line": 193,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.notAMockPassedWhenCreatingInOrder()",
        "snippet": "    public void notAMockPassedWhenCreatingInOrder() {\n        throw new NotAMockException(join(\n                \"Argument(s) passed is not a mock!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }",
        "begin_line": 202,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.nullPassedWhenCreatingInOrder()",
        "snippet": "    public void nullPassedWhenCreatingInOrder() {\n        throw new NullInsteadOfMockException(join(\n                \"Argument(s) passed is null!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }",
        "begin_line": 211,
        "end_line": 218,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.mocksHaveToBePassedWhenCreatingInOrder()",
        "snippet": "    public void mocksHaveToBePassedWhenCreatingInOrder() {\n        throw new MockitoException(join(\n                \"Method requires argument(s)!\",\n                \"Pass mocks that require verification in order.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n        ));\n    }",
        "begin_line": 220,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.inOrderRequiresFamiliarMock()",
        "snippet": "    public void inOrderRequiresFamiliarMock() {\n        throw new MockitoException(join(\n                \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                \"For example:\",\n                \"    InOrder inOrder = inOrder(mockOne);\",\n                \"    inOrder.verify(mockOne).doStuff();\"\n        ));\n    }",
        "begin_line": 229,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invalidUseOfMatchers(int, java.util.List<org.mockito.internal.matchers.LocalizedMatcher>)",
        "snippet": "    public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers!\",\n                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size() + \" recorded:\" +\n                        locationsOf(recordedMatchers),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers class.\",\n                \"\"\n        ));\n    }",
        "begin_line": 238,
        "end_line": 255,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.incorrectUseOfAdditionalMatchers(java.lang.String, int, java.util.Collection<org.mockito.internal.matchers.LocalizedMatcher>)",
        "snippet": "    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n                new LocationImpl(),\n                \"\",\n                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                locationsOf(matcherStack),\n                \"\",\n                \"This exception may occur if matchers are combined with raw values:\",\n                \"    //incorrect:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n                \"When using matchers, all arguments have to be provided by matchers.\",\n                \"For example:\",\n                \"    //correct:\",\n                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n                \"\",\n                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n                \"\"\n        ));\n    }",
        "begin_line": 257,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.stubPassedToVerify()",
        "snippet": "    public void stubPassedToVerify() {\n        throw new CannotVerifyStubOnlyMock(join(\n                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n        ));\n    }",
        "begin_line": 278,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.reportNoSubMatchersFound(java.lang.String)",
        "snippet": "    public void reportNoSubMatchersFound(String additionalMatcherName) {\n        throw new InvalidUseOfMatchersException(join(\n                \"No matchers found for additional matcher \" + additionalMatcherName,\n                new LocationImpl(),\n                \"\"\n        ));\n    }",
        "begin_line": 285,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.locationsOf(java.util.Collection<org.mockito.internal.matchers.LocalizedMatcher>)",
        "snippet": "    private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n        List<String> description = new ArrayList<String>();\n        for (LocalizedMatcher matcher : matchers)\n            description.add(matcher.getLocation().toString());\n        return join(description.toArray());\n    }",
        "begin_line": 294,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.argumentsAreDifferent(java.lang.String, java.lang.String, org.mockito.invocation.Location)",
        "snippet": "    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\",\n                wanted,\n                new LocationImpl(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n        );\n\n        throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n    }",
        "begin_line": 301,
        "end_line": 312,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wantedButNotInvoked(org.mockito.invocation.DescribedInvocation)",
        "snippet": "    public void wantedButNotInvoked(DescribedInvocation wanted) {\n        throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n    }",
        "begin_line": 314,
        "end_line": 316,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wantedButNotInvoked(org.mockito.invocation.DescribedInvocation, java.util.List<? extends org.mockito.invocation.DescribedInvocation>)",
        "snippet": "    public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {\n        String allInvocations;\n        if (invocations.isEmpty()) {\n            allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n        } else {\n            StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n            for (DescribedInvocation i : invocations) {\n                sb.append(i.toString())\n                        .append(\"\\n\")\n                        .append(i.getLocation())\n                        .append(\"\\n\\n\");\n            }\n            allInvocations = sb.toString();\n        }\n\n        String message = createWantedButNotInvokedMessage(wanted);\n        throw new WantedButNotInvoked(message + allInvocations);\n    }",
        "begin_line": 318,
        "end_line": 335,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.createWantedButNotInvokedMessage(org.mockito.invocation.DescribedInvocation)",
        "snippet": "    private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {\n        return join(\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"\"\n        );\n    }",
        "begin_line": 337,
        "end_line": 344,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wantedButNotInvokedInOrder(org.mockito.invocation.DescribedInvocation, org.mockito.invocation.DescribedInvocation)",
        "snippet": "    public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure\",\n                \"Wanted but not invoked:\",\n                wanted.toString(),\n                new LocationImpl(),\n                \"Wanted anywhere AFTER following interaction:\",\n                previous.toString(),\n                previous.getLocation(),\n                \"\"\n        ));\n    }",
        "begin_line": 346,
        "end_line": 357,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.tooManyActualInvocations(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new TooManyActualInvocations(message);\n    }",
        "begin_line": 359,
        "end_line": 362,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.createTooManyInvocationsMessage(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n                                                   Location firstUndesired) {\n        return join(\n                wanted.toString(),\n                \"Wanted \" + pluralize(wantedCount) + \":\",\n                new LocationImpl(),\n                \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                firstUndesired,\n                \"\"\n        );\n    }",
        "begin_line": 364,
        "end_line": 374,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.neverWantedButInvoked(org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n        throw new NeverWantedButInvoked(join(\n                wanted.toString(),\n                \"Never wanted here:\",\n                new LocationImpl(),\n                \"But invoked here:\",\n                firstUndesired,\n                \"\"\n        ));\n    }",
        "begin_line": 376,
        "end_line": 385,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.tooManyActualInvocationsInOrder(int, int, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n        String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }",
        "begin_line": 387,
        "end_line": 392,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n                                                     Location lastActualInvocation) {\n        String ending =\n                (lastActualInvocation != null) ? lastActualInvocation + \"\\n\" : \"\\n\";\n\n        String message = join(\n                wanted.toString(),\n                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                new LocationImpl(),\n                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                ending\n        );\n        return message;\n    }",
        "begin_line": 394,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new TooLittleActualInvocations(message);\n    }",
        "begin_line": 409,
        "end_line": 413,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy, org.mockito.invocation.DescribedInvocation, org.mockito.invocation.Location)",
        "snippet": "    public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n\n        throw new VerificationInOrderFailure(join(\n                \"Verification in order failure:\" + message\n        ));\n    }",
        "begin_line": 415,
        "end_line": 421,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.noMoreInteractionsWanted(org.mockito.invocation.Invocation, java.util.List<org.mockito.internal.exceptions.VerificationAwareInvocation>)",
        "snippet": "    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n        String scenario = scenarioPrinter.print(invocations);\n\n        throw new NoInteractionsWanted(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation(),\n                scenario\n        ));\n    }",
        "begin_line": 423,
        "end_line": 434,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.noMoreInteractionsWantedInOrder(org.mockito.invocation.Invocation)",
        "snippet": "    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n        throw new VerificationInOrderFailure(join(\n                \"No interactions wanted here:\",\n                new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                undesired.getLocation()\n        ));\n    }",
        "begin_line": 436,
        "end_line": 443,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotMockFinalClass(java.lang.Class<?>)",
        "snippet": "    public void cannotMockFinalClass(Class<?> clazz) {\n        throw new MockitoException(join(\n                \"Cannot mock/spy \" + clazz.toString(),\n                \"Mockito cannot mock/spy following:\",\n                \"  - final classes\",\n                \"  - anonymous classes\",\n                \"  - primitive types\"\n        ));\n    }",
        "begin_line": 445,
        "end_line": 453,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotStubVoidMethodWithAReturnValue(java.lang.String)",
        "snippet": "    public void cannotStubVoidMethodWithAReturnValue(String methodName) {\n        throw new CannotStubVoidMethodWithReturnValue(join(\n                \"'\" + methodName + \"' is a *void method* and it *cannot* be stubbed with a *return value*!\",\n                \"Voids are usually stubbed with Throwables:\",\n                \"    doThrow(exception).when(mock).someVoidMethod();\",\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. The method you are trying to stub is *overloaded*. Make sure you are calling the right overloaded version.\",\n                \"2. Somewhere in your test you are stubbing *final methods*. Sorry, Mockito does not verify/stub final methods.\",\n                \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"4. \" + MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }",
        "begin_line": 455,
        "end_line": 470,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.onlyVoidMethodsCanBeSetToDoNothing()",
        "snippet": "    public void onlyVoidMethodsCanBeSetToDoNothing() {\n        throw new MockitoException(join(\n                \"Only void methods can doNothing()!\",\n                \"Example of correct use of doNothing():\",\n                \"    doNothing().\",\n                \"    doThrow(new RuntimeException())\",\n                \"    .when(mock).someVoidMethod();\",\n                \"Above means:\",\n                \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n        ));\n    }",
        "begin_line": 472,
        "end_line": 482,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wrongTypeOfReturnValue(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"***\",\n                \"If you're unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }",
        "begin_line": 484,
        "end_line": 497,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wrongTypeReturnedByDefaultAnswer(java.lang.Object, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public void wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {\n        throw new WrongTypeOfReturnValue(join(\n                \"Default answer returned a result with the wrong type:\",\n                actualType + \" cannot be returned by \" + methodName + \"()\",\n                methodName + \"() should return \" + expectedType,\n                \"\",\n                \"The default answer of \" + safelyGetMockName(mock) + \" that was configured on the mock is probably incorrectly implemented.\",\n                \"\"\n        ));\n    }",
        "begin_line": 499,
        "end_line": 508,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wantedAtMostX(int, int)",
        "snippet": "    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n    }",
        "begin_line": 511,
        "end_line": 513,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.misplacedArgumentMatcher(java.util.List<org.mockito.internal.matchers.LocalizedMatcher>)",
        "snippet": "    public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {\n        throw new InvalidUseOfMatchersException(join(\n                \"Misplaced argument matcher detected here:\",\n                locationsOf(lastMatchers),\n                \"\",\n                \"You cannot use argument matchers outside of verification or stubbing.\",\n                \"Examples of correct usage of argument matchers:\",\n                \"    when(mock.get(anyInt())).thenReturn(null);\",\n                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod(anyObject());\",\n                \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                \"\",\n                \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                MockitoLimitations.NON_PUBLIC_PARENT,\n                \"\"\n        ));\n    }",
        "begin_line": 515,
        "end_line": 531,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.smartNullPointerException(java.lang.String, org.mockito.invocation.Location)",
        "snippet": "    public void smartNullPointerException(String invocation, Location location) {\n        throw new SmartNullPointerException(join(\n                \"You have a NullPointerException here:\",\n                new LocationImpl(),\n                \"because this method call was *not* stubbed correctly:\",\n                location,\n                invocation,\n                \"\"\n        ));\n    }",
        "begin_line": 533,
        "end_line": 542,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.noArgumentValueWasCaptured()",
        "snippet": "    public void noArgumentValueWasCaptured() {\n        throw new MockitoException(join(\n                \"No argument value was captured!\",\n                \"You might have forgotten to use argument.capture() in verify()...\",\n                \"...or you used capture() in stubbing but stubbed method was not called.\",\n                \"Be aware that it is recommended to use capture() only with verify()\",\n                \"\",\n                \"Examples of correct argument capturing:\",\n                \"    ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\",\n                \"    verify(mock).doSomething(argument.capture());\",\n                \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                \"\"\n        ));\n    }",
        "begin_line": 544,
        "end_line": 557,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.extraInterfacesDoesNotAcceptNullParameters()",
        "snippet": "    public void extraInterfacesDoesNotAcceptNullParameters() {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept null parameters.\"\n        ));\n    }",
        "begin_line": 559,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.extraInterfacesAcceptsOnlyInterfaces(java.lang.Class<?>)",
        "snippet": "    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() accepts only interfaces.\",\n                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n        ));\n    }",
        "begin_line": 565,
        "end_line": 570,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.extraInterfacesCannotContainMockedType(java.lang.Class<?>)",
        "snippet": "    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n        throw new MockitoException(join(\n                \"extraInterfaces() does not accept the same type as the mocked type.\",\n                \"You mocked following type: \" + wrongType.getSimpleName(),\n                \"and you passed the same very interface to the extraInterfaces()\"\n        ));\n    }",
        "begin_line": 572,
        "end_line": 578,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.extraInterfacesRequiresAtLeastOneInterface()",
        "snippet": "    public void extraInterfacesRequiresAtLeastOneInterface() {\n        throw new MockitoException(join(\n                \"extraInterfaces() requires at least one interface.\"\n        ));\n    }",
        "begin_line": 580,
        "end_line": 584,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.mockedTypeIsInconsistentWithSpiedInstanceType(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your spied instance.\",\n                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct spying:\",\n                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n        ));\n    }",
        "begin_line": 586,
        "end_line": 595,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotCallAbstractRealMethod()",
        "snippet": "    public void cannotCallAbstractRealMethod() {\n        throw new MockitoException(join(\n                \"Cannot call abstract real method on java object!\",\n                \"Calling real methods is only possible when mocking non abstract method.\",\n                \"  //correct example:\",\n                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n        ));\n    }",
        "begin_line": 597,
        "end_line": 604,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotVerifyToString()",
        "snippet": "    public void cannotVerifyToString() {\n        throw new MockitoException(join(\n                \"Mockito cannot verify toString()\",\n                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n                        \"Verifying it may give inconsistent or hard to understand results. \" +\n                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n        ));\n    }",
        "begin_line": 606,
        "end_line": 614,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.moreThanOneAnnotationNotAllowed(java.lang.String)",
        "snippet": "    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n    }",
        "begin_line": 616,
        "end_line": 620,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.unsupportedCombinationOfAnnotations(java.lang.String, java.lang.String)",
        "snippet": "    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n    }",
        "begin_line": 622,
        "end_line": 625,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotInitializeForSpyAnnotation(java.lang.String, java.lang.Exception)",
        "snippet": "    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @Spy:\",\n                \"   @Spy List mock = new LinkedList();\",\n                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"\"), details);\n    }",
        "begin_line": 627,
        "end_line": 636,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotInitializeForInjectMocksAnnotation(java.lang.String, java.lang.Exception)",
        "snippet": "    public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However, I failed because: \" + details.getMessage(),\n                \"Examples of correct usage of @InjectMocks:\",\n                \"   @InjectMocks Service service = new Service();\",\n                \"   @InjectMocks Service service;\",\n                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                \"   //and... don't forget about some @Mocks for injection :)\",\n                \"\"), details);\n    }",
        "begin_line": 638,
        "end_line": 648,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.atMostAndNeverShouldNotBeUsedWithTimeout()",
        "snippet": "    public void atMostAndNeverShouldNotBeUsedWithTimeout() {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"timeout() should not be used with atMost() or never() because...\",\n                \"...it does not make much sense - the test would have passed immediately in concurency\",\n                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n                \"If you want to find out more please refer to issue 235\",\n                \"\"));\n    }",
        "begin_line": 650,
        "end_line": 659,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.fieldInitialisationThrewException(java.lang.reflect.Field, java.lang.Throwable)",
        "snippet": "    public void fieldInitialisationThrewException(Field field, Throwable details) {\n        throw new MockitoException(join(\n                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() + \"'.\",\n                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n                \"\"), details);\n\n    }",
        "begin_line": 661,
        "end_line": 668,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invocationListenerDoesNotAcceptNullParameters()",
        "snippet": "    public void invocationListenerDoesNotAcceptNullParameters() {\n        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n    }",
        "begin_line": 670,
        "end_line": 672,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invocationListenersRequiresAtLeastOneListener()",
        "snippet": "    public void invocationListenersRequiresAtLeastOneListener() {\n        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n    }",
        "begin_line": 674,
        "end_line": 676,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invocationListenerThrewException(org.mockito.listeners.InvocationListener, java.lang.Throwable)",
        "snippet": "    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n        throw new MockitoException(StringJoiner.join(\n                \"The invocation listener with type \" + listener.getClass().getName(),\n                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n    }",
        "begin_line": 678,
        "end_line": 682,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotInjectDependency(java.lang.reflect.Field, java.lang.Object, java.lang.Exception)",
        "snippet": "    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {\n        throw new MockitoException(join(\n                \"Mockito couldn't inject mock dependency '\" + safelyGetMockName(matchingMock) + \"' on field \",\n                \"'\" + field + \"'\",\n                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n                \"Also I failed because: \" + exceptionCauseMessageIfAvailable(details),\n                \"\"\n        ), details);\n    }",
        "begin_line": 684,
        "end_line": 692,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.exceptionCauseMessageIfAvailable(java.lang.Exception)",
        "snippet": "    private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() == null) {\n            return details.getMessage();\n        }\n        return details.getCause().getMessage();\n    }",
        "begin_line": 694,
        "end_line": 699,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.mockedTypeIsInconsistentWithDelegatedInstanceType(java.lang.Class, java.lang.Object)",
        "snippet": "    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n        throw new MockitoException(join(\n                \"Mocked type must be the same as the type of your delegated instance.\",\n                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                \"  //correct delegate:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n                \"  //incorrect - types don't match:\",\n                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n        ));\n    }",
        "begin_line": 701,
        "end_line": 710,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.spyAndDelegateAreMutuallyExclusive()",
        "snippet": "    public void spyAndDelegateAreMutuallyExclusive() {\n        throw new MockitoException(join(\n                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n        ));\n    }",
        "begin_line": 712,
        "end_line": 716,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invalidArgumentRangeAtIdentityAnswerCreationTime()",
        "snippet": "    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n        throw new MockitoException(join(\"Invalid argument index.\",\n                \"The index need to be a positive number that indicates the position of the argument to return.\",\n                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n                \"returned.\"));\n    }",
        "begin_line": 718,
        "end_line": 723,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.invalidArgumentPositionRangeAtInvocationTime(org.mockito.invocation.InvocationOnMock, boolean, int)",
        "snippet": "    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n        throw new MockitoException(\n                join(\"Invalid argument index for the current invocation of method : \",\n                        \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                        \"\",\n                        (willReturnLastParameter ?\n                                \"Last parameter wanted\" :\n                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                        \"\"));\n    }",
        "begin_line": 725,
        "end_line": 736,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.possibleArgumentTypesOf(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n        if (parameterTypes.length == 0) {\n            return new StringBuilder(\"the method has no arguments.\\n\");\n        }\n\n        StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n            stringBuilder.append(\"    [\").append(i);\n\n            if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {\n                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");\n            } else {\n                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n            }\n        }\n        return stringBuilder;\n    }",
        "begin_line": 738,
        "end_line": 755,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.wrongTypeOfArgumentToReturn(org.mockito.invocation.InvocationOnMock, java.lang.String, java.lang.Class, int)",
        "snippet": "    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n        throw new WrongTypeOfReturnValue(join(\n                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n                \"method should return the type '\" + expectedType + \"'\",\n                \" -> \" + safelyGetMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                \"\",\n                \"The reason for this error can be :\",\n                \"1. The wanted argument position is incorrect.\",\n                \"2. The answer is used on the wrong interaction.\",\n                \"\",\n                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n                \"***\",\n                \"However if you're still unsure why you're getting above error read on.\",\n                \"Due to the nature of the syntax above problem might occur because:\",\n                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                \"\"\n        ));\n    }",
        "begin_line": 757,
        "end_line": 777,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.defaultAnswerDoesNotAcceptNullParameter()",
        "snippet": "    public void defaultAnswerDoesNotAcceptNullParameter() {\n        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n    }",
        "begin_line": 779,
        "end_line": 781,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.serializableWontWorkForObjectsThatDontImplementSerializable(java.lang.Class)",
        "snippet": "    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n        throw new MockitoException(join(\n                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                \"\",\n                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n                \"i.e. the top-most superclass has to implements Serializable.\",\n                \"\"\n        ));\n    }",
        "begin_line": 783,
        "end_line": 793,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.delegatedMethodHasWrongReturnType(java.lang.reflect.Method, java.lang.reflect.Method, java.lang.Object, java.lang.Object)",
        "snippet": "    public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {\n        throw new MockitoException(join(\n                \"Methods called on delegated instance must have compatible return types with the mock.\",\n                \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n                \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n                \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n                \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n        ));\n    }",
        "begin_line": 795,
        "end_line": 803,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.delegatedMethodDoesNotExistOnDelegate(java.lang.reflect.Method, java.lang.Object, java.lang.Object)",
        "snippet": "    public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {\n        throw new MockitoException(join(\n                \"Methods called on mock must exist in delegated instance.\",\n                \"When calling: \" + mockMethod + \" on mock: \" + safelyGetMockName(mock),\n                \"no such method was found.\",\n                \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n                \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n        ));\n    }",
        "begin_line": 805,
        "end_line": 813,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.usingConstructorWithFancySerializable(org.mockito.mock.SerializableMode)",
        "snippet": "    public void usingConstructorWithFancySerializable(SerializableMode mode) {\n        throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");\n    }",
        "begin_line": 815,
        "end_line": 817,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.cannotCreateTimerWithNegativeDurationTime(long)",
        "snippet": "    public void cannotCreateTimerWithNegativeDurationTime(long durationMillis) {\n        throw new FriendlyReminderException(join(\"\",\n                \"Don't panic! I'm just a friendly reminder!\",\n                \"It is impossible for time to go backward, therefore...\",\n                \"You cannot put negative value of duration: (\" +  durationMillis +  \")\",\n                \"as argument of timer methods (after(), timeout())\",\n                \"\"));\n    }",
        "begin_line": 819,
        "end_line": 826,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/Reporter.java",
        "class_name": "org.mockito.exceptions.Reporter",
        "signature": "org.mockito.exceptions.Reporter.safelyGetMockName(java.lang.Object)",
        "snippet": "    private MockName safelyGetMockName(Object mock) {\n        return new MockUtil().getMockName(mock);\n    }",
        "begin_line": 828,
        "end_line": 830,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/TooLittleActualInvocations.java",
        "class_name": "org.mockito.exceptions.verification.TooLittleActualInvocations",
        "signature": "org.mockito.exceptions.verification.TooLittleActualInvocations.TooLittleActualInvocations(java.lang.String)",
        "snippet": "    public TooLittleActualInvocations(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/NeverWantedButInvoked.java",
        "class_name": "org.mockito.exceptions.verification.NeverWantedButInvoked",
        "signature": "org.mockito.exceptions.verification.NeverWantedButInvoked.NeverWantedButInvoked(java.lang.String)",
        "snippet": "    public NeverWantedButInvoked(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/WantedButNotInvoked.java",
        "class_name": "org.mockito.exceptions.verification.WantedButNotInvoked",
        "signature": "org.mockito.exceptions.verification.WantedButNotInvoked.WantedButNotInvoked(java.lang.String)",
        "snippet": "    public WantedButNotInvoked(String message) {\n        super(message);\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/WantedButNotInvoked.java",
        "class_name": "org.mockito.exceptions.verification.WantedButNotInvoked",
        "signature": "org.mockito.exceptions.verification.WantedButNotInvoked.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return new RemoveFirstLine().of(super.toString());\n    }",
        "begin_line": 19,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/VerificationInOrderFailure.java",
        "class_name": "org.mockito.exceptions.verification.VerificationInOrderFailure",
        "signature": "org.mockito.exceptions.verification.VerificationInOrderFailure.VerificationInOrderFailure(java.lang.String)",
        "snippet": "    public VerificationInOrderFailure(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.ArgumentsAreDifferent.ArgumentsAreDifferent(java.lang.String)",
        "snippet": "    public ArgumentsAreDifferent(String message) {\n        super(message);\n    }",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.ArgumentsAreDifferent.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return new RemoveFirstLine().of(super.toString());\n    }",
        "begin_line": 19,
        "end_line": 22,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.ArgumentsAreDifferent(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public ArgumentsAreDifferent(String message, String wanted, String actual) {\n        super(message, wanted, actual);\n        this.message = message;\n        \n        unfilteredStackTrace = getStackTrace();\n        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n        filter.filter(this);\n    }",
        "begin_line": 19,
        "end_line": 26,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.getMessage()",
        "snippet": "    @Override\n    public String getMessage() {\n        return message;\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.getUnfilteredStackTrace()",
        "snippet": "    public StackTraceElement[] getUnfilteredStackTrace() {\n        return unfilteredStackTrace;\n    }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java",
        "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
        "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.toString()",
        "snippet": "    @Override\n    public String toString() {\n        return new RemoveFirstLine().of(super.toString());\n    }",
        "begin_line": 37,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/NoInteractionsWanted.java",
        "class_name": "org.mockito.exceptions.verification.NoInteractionsWanted",
        "signature": "org.mockito.exceptions.verification.NoInteractionsWanted.NoInteractionsWanted(java.lang.String)",
        "snippet": "    public NoInteractionsWanted(String message) {\n        super(message);\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/SmartNullPointerException.java",
        "class_name": "org.mockito.exceptions.verification.SmartNullPointerException",
        "signature": "org.mockito.exceptions.verification.SmartNullPointerException.SmartNullPointerException(java.lang.String)",
        "snippet": "    public SmartNullPointerException(String message) {\n        super(message);\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/verification/TooManyActualInvocations.java",
        "class_name": "org.mockito.exceptions.verification.TooManyActualInvocations",
        "signature": "org.mockito.exceptions.verification.TooManyActualInvocations.TooManyActualInvocations(java.lang.String)",
        "snippet": "    public TooManyActualInvocations(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoSerializationIssue.java",
        "class_name": "org.mockito.exceptions.base.MockitoSerializationIssue",
        "signature": "org.mockito.exceptions.base.MockitoSerializationIssue.MockitoSerializationIssue(java.lang.String, java.lang.Exception)",
        "snippet": "    public MockitoSerializationIssue(String message, Exception cause) {\n        super(message);\n        initCause(cause);\n        filterStackTrace();\n    }",
        "begin_line": 27,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoSerializationIssue.java",
        "class_name": "org.mockito.exceptions.base.MockitoSerializationIssue",
        "signature": "org.mockito.exceptions.base.MockitoSerializationIssue.getStackTrace()",
        "snippet": "    @Override\n    public StackTraceElement[] getStackTrace() {\n        filterStackTrace();\n        return super.getStackTrace();\n    }",
        "begin_line": 33,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoSerializationIssue.java",
        "class_name": "org.mockito.exceptions.base.MockitoSerializationIssue",
        "signature": "org.mockito.exceptions.base.MockitoSerializationIssue.filterStackTrace()",
        "snippet": "    private void filterStackTrace() {\n        unfilteredStackTrace = super.getStackTrace();\n\n        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n        filter.filter(this);\n    }",
        "begin_line": 39,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoSerializationIssue.java",
        "class_name": "org.mockito.exceptions.base.MockitoSerializationIssue",
        "signature": "org.mockito.exceptions.base.MockitoSerializationIssue.getUnfilteredStackTrace()",
        "snippet": "    public StackTraceElement[] getUnfilteredStackTrace() {\n        return unfilteredStackTrace;\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoAssertionError.java",
        "class_name": "org.mockito.exceptions.base.MockitoAssertionError",
        "signature": "org.mockito.exceptions.base.MockitoAssertionError.MockitoAssertionError(java.lang.String)",
        "snippet": "    public MockitoAssertionError(String message) {\n        super(message);\n\n        unfilteredStackTrace = getStackTrace();\n        \n        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n        filter.filter(this);\n    }",
        "begin_line": 17,
        "end_line": 24,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoAssertionError.java",
        "class_name": "org.mockito.exceptions.base.MockitoAssertionError",
        "signature": "org.mockito.exceptions.base.MockitoAssertionError.getUnfilteredStackTrace()",
        "snippet": "    public StackTraceElement[] getUnfilteredStackTrace() {\n        return unfilteredStackTrace;\n    }",
        "begin_line": 26,
        "end_line": 28,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoException.java",
        "class_name": "org.mockito.exceptions.base.MockitoException",
        "signature": "org.mockito.exceptions.base.MockitoException.MockitoException(java.lang.String, java.lang.Throwable)",
        "snippet": "    public MockitoException(String message, Throwable t) {\n        super(message, t);\n        filterStackTrace();\n    }",
        "begin_line": 28,
        "end_line": 31,
        "comment": " TODO lazy filtered stacktrace initialization",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoException.java",
        "class_name": "org.mockito.exceptions.base.MockitoException",
        "signature": "org.mockito.exceptions.base.MockitoException.MockitoException(java.lang.String)",
        "snippet": "    public MockitoException(String message) {\n        super(message);\n        filterStackTrace();\n    }",
        "begin_line": 33,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoException.java",
        "class_name": "org.mockito.exceptions.base.MockitoException",
        "signature": "org.mockito.exceptions.base.MockitoException.filterStackTrace()",
        "snippet": "    private void filterStackTrace() {\n        unfilteredStackTrace = getStackTrace();\n        \n        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n        filter.filter(this);\n    }",
        "begin_line": 38,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/base/MockitoException.java",
        "class_name": "org.mockito.exceptions.base.MockitoException",
        "signature": "org.mockito.exceptions.base.MockitoException.getUnfilteredStackTrace()",
        "snippet": "    public StackTraceElement[] getUnfilteredStackTrace() {\n        return unfilteredStackTrace;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/stacktrace/StackTraceCleaner.java",
        "class_name": "org.mockito.exceptions.stacktrace.StackTraceCleaner",
        "signature": "org.mockito.exceptions.stacktrace.StackTraceCleaner.isOut(java.lang.StackTraceElement)",
        "snippet": "    boolean isOut(StackTraceElement candidate);",
        "begin_line": 25,
        "end_line": 25,
        "comment": "\n     * Decides if element is excluded.\n     *\n     * @param candidate element of the actual stack trace\n     * @return whether the element should be excluded from cleaned stack trace.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/UnfinishedStubbingException.java",
        "class_name": "org.mockito.exceptions.misusing.UnfinishedStubbingException",
        "signature": "org.mockito.exceptions.misusing.UnfinishedStubbingException.UnfinishedStubbingException(java.lang.String)",
        "snippet": "    public UnfinishedStubbingException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java",
        "class_name": "org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock",
        "signature": "org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock.CannotVerifyStubOnlyMock(java.lang.String)",
        "snippet": "    public CannotVerifyStubOnlyMock(String message) {\n        super(message);\n    }",
        "begin_line": 12,
        "end_line": 14,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/NotAMockException.java",
        "class_name": "org.mockito.exceptions.misusing.NotAMockException",
        "signature": "org.mockito.exceptions.misusing.NotAMockException.NotAMockException(java.lang.String)",
        "snippet": "    public NotAMockException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/NullInsteadOfMockException.java",
        "class_name": "org.mockito.exceptions.misusing.NullInsteadOfMockException",
        "signature": "org.mockito.exceptions.misusing.NullInsteadOfMockException.NullInsteadOfMockException(java.lang.String)",
        "snippet": "    public NullInsteadOfMockException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/FriendlyReminderException.java",
        "class_name": "org.mockito.exceptions.misusing.FriendlyReminderException",
        "signature": "org.mockito.exceptions.misusing.FriendlyReminderException.FriendlyReminderException(java.lang.String)",
        "snippet": "    public FriendlyReminderException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/MockitoConfigurationException.java",
        "class_name": "org.mockito.exceptions.misusing.MockitoConfigurationException",
        "signature": "org.mockito.exceptions.misusing.MockitoConfigurationException.MockitoConfigurationException(java.lang.String)",
        "snippet": "    public MockitoConfigurationException(String message) {\n        super(message);\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/MockitoConfigurationException.java",
        "class_name": "org.mockito.exceptions.misusing.MockitoConfigurationException",
        "signature": "org.mockito.exceptions.misusing.MockitoConfigurationException.MockitoConfigurationException(java.lang.String, java.lang.Exception)",
        "snippet": "    public MockitoConfigurationException(String message, Exception cause) {\n        super(message, cause);\n    }",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/CannotStubVoidMethodWithReturnValue.java",
        "class_name": "org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue",
        "signature": "org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue.CannotStubVoidMethodWithReturnValue(java.lang.String)",
        "snippet": "    public CannotStubVoidMethodWithReturnValue(String message) {\n        super(message);\n    }",
        "begin_line": 6,
        "end_line": 8,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/UnfinishedVerificationException.java",
        "class_name": "org.mockito.exceptions.misusing.UnfinishedVerificationException",
        "signature": "org.mockito.exceptions.misusing.UnfinishedVerificationException.UnfinishedVerificationException(java.lang.String)",
        "snippet": "    public UnfinishedVerificationException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/MissingMethodInvocationException.java",
        "class_name": "org.mockito.exceptions.misusing.MissingMethodInvocationException",
        "signature": "org.mockito.exceptions.misusing.MissingMethodInvocationException.MissingMethodInvocationException(java.lang.String)",
        "snippet": "    public MissingMethodInvocationException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/WrongTypeOfReturnValue.java",
        "class_name": "org.mockito.exceptions.misusing.WrongTypeOfReturnValue",
        "signature": "org.mockito.exceptions.misusing.WrongTypeOfReturnValue.WrongTypeOfReturnValue(java.lang.String)",
        "snippet": "    public WrongTypeOfReturnValue(String message) {\n        super(message);\n    }",
        "begin_line": 13,
        "end_line": 15,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java",
        "class_name": "org.mockito.exceptions.misusing.InvalidUseOfMatchersException",
        "signature": "org.mockito.exceptions.misusing.InvalidUseOfMatchersException.InvalidUseOfMatchersException(java.lang.String)",
        "snippet": "    public InvalidUseOfMatchersException(String message) {\n        super(message);\n    }",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java",
        "class_name": "org.mockito.exceptions.misusing.InvalidUseOfMatchersException",
        "signature": "org.mockito.exceptions.misusing.InvalidUseOfMatchersException.InvalidUseOfMatchersException()",
        "snippet": "    public InvalidUseOfMatchersException() {\n        super(\"\");\n    }",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/junit/MockitoJUnitRule.java",
        "class_name": "org.mockito.junit.MockitoJUnitRule",
        "signature": "org.mockito.junit.MockitoJUnitRule.MockitoJUnitRule()",
        "snippet": "    @Deprecated\n    public MockitoJUnitRule() {\n        this.jUnitRule = new JUnitRule();\n    }",
        "begin_line": 25,
        "end_line": 28,
        "comment": "\n     * Please use {@link MockitoJUnit#rule()}.\n     * The reason of the deprecation is that we want to avoid concrete classes in the public api.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/junit/MockitoJUnitRule.java",
        "class_name": "org.mockito.junit.MockitoJUnitRule",
        "signature": "org.mockito.junit.MockitoJUnitRule.MockitoJUnitRule(java.lang.Object)",
        "snippet": "    @Deprecated\n    public MockitoJUnitRule(Object targetTest) {\n        this();\n    }",
        "begin_line": 34,
        "end_line": 37,
        "comment": "\n     * Please use {@link MockitoJUnit#rule()}.\n     * The reason of the deprecation is that we want to avoid concrete classes in the public api.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/junit/MockitoJUnitRule.java",
        "class_name": "org.mockito.junit.MockitoJUnitRule",
        "signature": "org.mockito.junit.MockitoJUnitRule.apply(org.junit.runners.model.Statement, org.junit.runners.model.FrameworkMethod, java.lang.Object)",
        "snippet": "    public Statement apply(Statement base, FrameworkMethod method, Object target) {\n        return jUnitRule.apply(base, target);\n    }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/junit/MockitoJUnit.java",
        "class_name": "org.mockito.junit.MockitoJUnit",
        "signature": "org.mockito.junit.MockitoJUnit.rule()",
        "snippet": "    public static MockitoRule rule() {\n        return new MockitoJUnitRule();\n    }",
        "begin_line": 16,
        "end_line": 18,
        "comment": "\n     * Creates rule instance that initiates &#064;Mocks\n     * See {@link MockitoRule}.\n     *\n     * @return the rule instance\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/InvocationListener.java",
        "class_name": "org.mockito.listeners.InvocationListener",
        "signature": "org.mockito.listeners.InvocationListener.reportInvocation(org.mockito.listeners.MethodInvocationReport)",
        "snippet": "    void reportInvocation(MethodInvocationReport methodInvocationReport);",
        "begin_line": 27,
        "end_line": 27,
        "comment": "\n     * Called after the invocation of the listener's mock if it returned normally.\n     *\n     * <p>\n     * Exceptions caused by this invocationListener will raise a {@link org.mockito.exceptions.base.MockitoException}.\n     * </p>\n     *\n     * @param methodInvocationReport Information about the method call that just happened.\n     *\n     * @see MethodInvocationReport\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/MethodInvocationReport.java",
        "class_name": "org.mockito.listeners.MethodInvocationReport",
        "signature": "org.mockito.listeners.MethodInvocationReport.getInvocation()",
        "snippet": "    DescribedInvocation getInvocation();",
        "begin_line": 27,
        "end_line": 27,
        "comment": "\n     * The return type is deprecated, please assign the return value from this method\n     * to the {@link DescribedInvocation} type. Sorry for inconvenience but we had to move\n     * {@link PrintableInvocation} to better place to keep the API consistency.\n     *\n     * @return Information on the method call, never {@code null}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/MethodInvocationReport.java",
        "class_name": "org.mockito.listeners.MethodInvocationReport",
        "signature": "org.mockito.listeners.MethodInvocationReport.getReturnedValue()",
        "snippet": "    Object getReturnedValue();",
        "begin_line": 32,
        "end_line": 32,
        "comment": "\n     * @return The resulting value of the method invocation, may be <code>null</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/MethodInvocationReport.java",
        "class_name": "org.mockito.listeners.MethodInvocationReport",
        "signature": "org.mockito.listeners.MethodInvocationReport.getThrowable()",
        "snippet": "    Throwable getThrowable();",
        "begin_line": 37,
        "end_line": 37,
        "comment": "\n     * @return The throwable raised by the method invocation, maybe <code>null</code>\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/MethodInvocationReport.java",
        "class_name": "org.mockito.listeners.MethodInvocationReport",
        "signature": "org.mockito.listeners.MethodInvocationReport.threwException()",
        "snippet": "    boolean threwException();",
        "begin_line": 42,
        "end_line": 42,
        "comment": "\n     * @return <code>true</code> if an exception was raised, <code>false</code> otherwise\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/listeners/MethodInvocationReport.java",
        "class_name": "org.mockito.listeners.MethodInvocationReport",
        "signature": "org.mockito.listeners.MethodInvocationReport.getLocationOfStubbing()",
        "snippet": "    String getLocationOfStubbing();",
        "begin_line": 47,
        "end_line": 47,
        "comment": "\n     * @return Location of the stub invocation\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.isVerified()",
        "snippet": "    boolean isVerified();",
        "begin_line": 23,
        "end_line": 23,
        "comment": "\n     * @return whether the invocation has been already verified.\n     * Needed for {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.getSequenceNumber()",
        "snippet": "    int getSequenceNumber();",
        "begin_line": 29,
        "end_line": 29,
        "comment": "\n     * @return the sequence number of the Invocation. Useful to determine the order of invocations.\n     * Used by verification in order.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.getLocation()",
        "snippet": "    Location getLocation();",
        "begin_line": 34,
        "end_line": 34,
        "comment": "\n     * @return the location in code of this invocation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.getRawArguments()",
        "snippet": "    Object[] getRawArguments();",
        "begin_line": 42,
        "end_line": 42,
        "comment": "\n     * Returns unprocessed arguments whereas {@link #getArguments()} returns\n     * arguments already processed (e.g. varargs expended, etc.).\n     *\n     * @return unprocessed arguments, exactly as provided to this invocation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.getRawReturnType()",
        "snippet": "    Class getRawReturnType();",
        "begin_line": 50,
        "end_line": 50,
        "comment": "\n     * Returns unprocessed arguments whereas {@link #getArguments()} returns\n     * arguments already processed (e.g. varargs expended, etc.).\n     *\n     * @return unprocessed arguments, exactly as provided to this invocation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.markVerified()",
        "snippet": "    void markVerified();",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Marks this invocation as verified so that it will not cause verification error at\n     * {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.stubInfo()",
        "snippet": "    StubInfo stubInfo();",
        "begin_line": 62,
        "end_line": 62,
        "comment": "\n     * @return the stubbing information for this invocation. May return null - this means\n     * the invocation was not stubbed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.markStubbed(org.mockito.invocation.StubInfo)",
        "snippet": "    void markStubbed(StubInfo stubInfo);",
        "begin_line": 69,
        "end_line": 69,
        "comment": "\n     * Marks this invocation as stubbed.\n     *\n     * @param stubInfo the information about stubbing.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.isIgnoredForVerification()",
        "snippet": "    boolean isIgnoredForVerification();",
        "begin_line": 77,
        "end_line": 77,
        "comment": "\n     * Informs if the invocation participates in verify-no-more-invocations or verification in order.\n     *\n     * @return whether this invocation should be ignored for the purposes of\n     * verify-no-more-invocations or verification in order.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Invocation.java",
        "class_name": "org.mockito.invocation.Invocation",
        "signature": "org.mockito.invocation.Invocation.ignoreForVerification()",
        "snippet": "    void ignoreForVerification();",
        "begin_line": 83,
        "end_line": 83,
        "comment": "\n     * Configures this invocation to be ignored for verify-no-more-invocations or verification in order.\n     * See also {@link #isIgnoredForVerification()}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/DescribedInvocation.java",
        "class_name": "org.mockito.invocation.DescribedInvocation",
        "signature": "org.mockito.invocation.DescribedInvocation.toString()",
        "snippet": "    String toString();",
        "begin_line": 19,
        "end_line": 19,
        "comment": "\n     * Describes the invocation in the human friendly way.\n     *\n     * @return the description of this invocation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/DescribedInvocation.java",
        "class_name": "org.mockito.invocation.DescribedInvocation",
        "signature": "org.mockito.invocation.DescribedInvocation.getLocation()",
        "snippet": "    Location getLocation();",
        "begin_line": 26,
        "end_line": 26,
        "comment": "\n     * The place in the code where the invocation happened.\n     *\n     * @return the location of the invocation.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/InvocationOnMock.java",
        "class_name": "org.mockito.invocation.InvocationOnMock",
        "signature": "org.mockito.invocation.InvocationOnMock.getMock()",
        "snippet": "    Object getMock();",
        "begin_line": 23,
        "end_line": 23,
        "comment": "\n     * returns the mock object \n     * \n     * @return mock object\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/InvocationOnMock.java",
        "class_name": "org.mockito.invocation.InvocationOnMock",
        "signature": "org.mockito.invocation.InvocationOnMock.getMethod()",
        "snippet": "    Method getMethod();",
        "begin_line": 30,
        "end_line": 30,
        "comment": "\n     * returns the method\n     * \n     * @return method\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/InvocationOnMock.java",
        "class_name": "org.mockito.invocation.InvocationOnMock",
        "signature": "org.mockito.invocation.InvocationOnMock.getArguments()",
        "snippet": "    Object[] getArguments();",
        "begin_line": 37,
        "end_line": 37,
        "comment": "\n     * returns arguments passed to the method\n     * \n     * @return arguments\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/InvocationOnMock.java",
        "class_name": "org.mockito.invocation.InvocationOnMock",
        "signature": "org.mockito.invocation.InvocationOnMock.getArgumentAt(int, java.lang.Class<T>)",
        "snippet": "    <T> T getArgumentAt(int index, Class<T> clazz);",
        "begin_line": 45,
        "end_line": 45,
        "comment": "\n    * Returns casted argument using position\n    * @param index argument position\n    * @param clazz argument type\n    * @return casted argument on position\n    ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/InvocationOnMock.java",
        "class_name": "org.mockito.invocation.InvocationOnMock",
        "signature": "org.mockito.invocation.InvocationOnMock.callRealMethod()",
        "snippet": "    Object callRealMethod() throws Throwable;",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * calls real method\n     * <p>\n     * <b>Warning:</b> depending on the real implementation it might throw exceptions  \n     *\n     * @return whatever the real method returns / throws\n     * @throws Throwable in case real method throws \n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/Location.java",
        "class_name": "org.mockito.invocation.Location",
        "signature": "org.mockito.invocation.Location.toString()",
        "snippet": "    String toString();",
        "begin_line": 15,
        "end_line": 15,
        "comment": "\n     * @return the location\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/StubInfo.java",
        "class_name": "org.mockito.invocation.StubInfo",
        "signature": "org.mockito.invocation.StubInfo.stubbedAt()",
        "snippet": "    Location stubbedAt();",
        "begin_line": 15,
        "end_line": 15,
        "comment": "\n     * @return the location where the invocation was stubbed.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/invocation/MockHandler.java",
        "class_name": "org.mockito.invocation.MockHandler",
        "signature": "org.mockito.invocation.MockHandler.handle(org.mockito.invocation.Invocation)",
        "snippet": "    Object handle(Invocation invocation) throws Throwable;",
        "begin_line": 28,
        "end_line": 28,
        "comment": "\n     * Takes an invocation object and handles it.\n     * <p>\n     * The default implementation provided by Mockito handles invocations by recording\n     * method calls on mocks for further verification, captures the stubbing information when mock is stubbed,\n     * returns the stubbed values for invocations that have been stubbed, and much more.\n     *\n     * @param invocation The invocation to handle\n     * @return Result\n     * @throws Throwable Throwable\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/VoidMethodStubbable.java",
        "class_name": "org.mockito.stubbing.VoidMethodStubbable",
        "signature": "org.mockito.stubbing.VoidMethodStubbable.toThrow(java.lang.Throwable)",
        "snippet": "    VoidMethodStubbable<T> toThrow(Throwable throwable);",
        "begin_line": 43,
        "end_line": 43,
        "comment": "\n     * Stubs void method with an exception. E.g:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n     * </code></pre>\n     *\n     * If throwable is a checked exception then it has to\n     * match one of the checked exceptions of method signature.\n     *\n     * See examples in javadoc for {@link Mockito#stubVoid}\n     *\n     * @param throwable to be thrown on method invocation\n     *\n     * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/VoidMethodStubbable.java",
        "class_name": "org.mockito.stubbing.VoidMethodStubbable",
        "signature": "org.mockito.stubbing.VoidMethodStubbable.toReturn()",
        "snippet": "    VoidMethodStubbable<T> toReturn();",
        "begin_line": 67,
        "end_line": 67,
        "comment": "\n     * Stubs void method to 'just return' (e.g. to <b>not</b> to throw any exception)\n     * <p>\n     * <b>Only use this method if you're stubbing consecutive calls.</b>\n     * <p>\n     * For example:\n     * <pre class=\"code\"><code class=\"java\">\n     * stubVoid(mock)\n     *   .toReturn()\n     *   .toThrow(new RuntimeException())\n     *   .on().foo(10);\n     * </code></pre>\n     * <ul>\n     * <li>first time foo(10) is called the mock will 'just return' (e.g. don't throw any exception)</li>\n     * <li>second time foo(10) is called the mock will throw RuntimeException</li>\n     * <li>every consecutive time foo(10) is called the mock will throw RuntimeException</li>\n     * </ul>\n     * <p>\n     * See examples in javadoc for {@link Mockito#stubVoid}\n     *\n     * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/VoidMethodStubbable.java",
        "class_name": "org.mockito.stubbing.VoidMethodStubbable",
        "signature": "org.mockito.stubbing.VoidMethodStubbable.toAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    VoidMethodStubbable<T> toAnswer(Answer<?> answer);",
        "begin_line": 90,
        "end_line": 90,
        "comment": "\n     * Stubs a void method with generic {@link Answer}\n     * <p>\n     * For Example:\n     * <pre class=\"code\"><code class=\"java\">\n     * stubVoid(mock)\n     *   .toAnswer(new Answer() {\n     *                 public Object answer(InvocationOnMOck invocation) {\n     *                     Visitor v = (Visitor) invocation.getArguments()[0];\n     *                     v.visitMock(invocation.getMock());\n     *\n     *                     return null;\n     *                 }\n     *             })\n     *    .on().accept(any());\n     * </code></pre>\n     *\n     * @param answer the custom answer to execute.\n     *\n     * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/VoidMethodStubbable.java",
        "class_name": "org.mockito.stubbing.VoidMethodStubbable",
        "signature": "org.mockito.stubbing.VoidMethodStubbable.on()",
        "snippet": "    T on();",
        "begin_line": 103,
        "end_line": 103,
        "comment": "\n     * Choose void method for stubbing. E.g:\n     *\n     * <pre class=\"code\"><code class=\"java\">\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod(\"some arg\");\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito#stubVoid}\n     *\n     * @return mock object itself\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.when(T)",
        "snippet": "    <T> T when(T mock);",
        "begin_line": 72,
        "end_line": 72,
        "comment": "\n     * Allows to choose a method when stubbing in doThrow()|doAnswer()|doNothing()|doReturn() style\n     * <p> \n     * Example:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doThrow(new RuntimeException())\n     *   .when(mockedList).clear();\n     *   \n     *   //following throws RuntimeException:\n     *   mockedList.clear();\n     * </code></pre>\n     * \n     * Read more about those methods:\n     * <p>\n     * {@link Mockito#doThrow(Throwable)}\n     * <p>\n     * {@link Mockito#doAnswer(Answer)}\n     * <p>\n     * {@link Mockito#doNothing()}\n     * <p>\n     * {@link Mockito#doReturn(Object)}\n     * <p>\n     * \n     *  See examples in javadoc for {@link Mockito}\n     * \n     * @param mock The mock\n     * @return select method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doThrow(java.lang.Throwable)",
        "snippet": "    Stubber doThrow(Throwable toBeThrown);",
        "begin_line": 86,
        "end_line": 86,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Throwable)} style:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doThrow(new RuntimeException(\"one\")).\n     *   doThrow(new RuntimeException(\"two\"))\n     *   .when(mock).someVoidMethod();\n     * </code></pre>\n     * See javadoc for {@link Mockito#doThrow(Throwable)}\n     * \n     * @param toBeThrown to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doThrow(java.lang.Class<? extends java.lang.Throwable>)",
        "snippet": "    Stubber doThrow(Class<? extends Throwable> toBeThrown);",
        "begin_line": 100,
        "end_line": 100,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class)} style:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doThrow(RuntimeException.class).\n     *   doThrow(IllegalArgumentException.class)\n     *   .when(mock).someVoidMethod();\n     * </code></pre>\n     * See javadoc for {@link Mockito#doThrow(Class)}\n     *\n     * @param toBeThrown exception class to be thrown when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doAnswer(org.mockito.stubbing.Answer)",
        "snippet": "    Stubber doAnswer(Answer answer);    ",
        "begin_line": 114,
        "end_line": 114,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doAnswer(Answer)} style:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doAnswer(answerOne).\n     *   doAnswer(answerTwo)\n     *   .when(mock).someVoidMethod();\n     * </code></pre>\n     * See javadoc for {@link Mockito#doAnswer(Answer)}\n     * \n     * @param answer to answer when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doNothing()",
        "snippet": "    Stubber doNothing();",
        "begin_line": 127,
        "end_line": 127,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doNothing()} style:\n     * <pre class=\"code\"><code class=\"java\">\n     *   doNothing().\n     *   doThrow(new RuntimeException(\"two\"))\n     *   .when(mock).someVoidMethod();\n     * </code></pre>\n     * See javadoc for {@link Mockito#doNothing()}\n     * \n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doReturn(java.lang.Object)",
        "snippet": "    Stubber doReturn(Object toBeReturned);",
        "begin_line": 137,
        "end_line": 137,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doReturn(Object)} style.\n     * <p>\n     * See javadoc for {@link Mockito#doReturn(Object)}\n     * \n     * @param toBeReturned to be returned when the stubbed method is called\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Stubber.java",
        "class_name": "org.mockito.stubbing.Stubber",
        "signature": "org.mockito.stubbing.Stubber.doCallRealMethod()",
        "snippet": "    Stubber doCallRealMethod();",
        "begin_line": 146,
        "end_line": 146,
        "comment": "\n     * Use it for stubbing consecutive calls in {@link Mockito#doCallRealMethod()} style.\n     * <p>\n     * See javadoc for {@link Mockito#doCallRealMethod()}\n     *\n     * @return stubber - to select a method for stubbing\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/Answer.java",
        "class_name": "org.mockito.stubbing.Answer",
        "signature": "org.mockito.stubbing.Answer.answer(org.mockito.invocation.InvocationOnMock)",
        "snippet": "    T answer(InvocationOnMock invocation) throws Throwable;",
        "begin_line": 38,
        "end_line": 38,
        "comment": "\n     * @param invocation the invocation on the mock.\n     *\n     * @return the value to be returned\n     *\n     * @throws Throwable the throwable to be thrown\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/DeprecatedOngoingStubbing.java",
        "class_name": "org.mockito.stubbing.DeprecatedOngoingStubbing",
        "signature": "org.mockito.stubbing.DeprecatedOngoingStubbing.toReturn(T)",
        "snippet": "    DeprecatedOngoingStubbing<T> toReturn(T value);",
        "begin_line": 46,
        "end_line": 46,
        "comment": "\n     * Set a return value for the stubbed method. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * stub(mock.someMethod()).toReturn(10);\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito#stub}\n     *\n     * @param value return value\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/DeprecatedOngoingStubbing.java",
        "class_name": "org.mockito.stubbing.DeprecatedOngoingStubbing",
        "signature": "org.mockito.stubbing.DeprecatedOngoingStubbing.toThrow(java.lang.Throwable)",
        "snippet": "    DeprecatedOngoingStubbing<T> toThrow(Throwable throwable);",
        "begin_line": 63,
        "end_line": 63,
        "comment": "\n     * Set a Throwable to be thrown when the stubbed method is called. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * stub(mock.someMethod()).toThrow(new RuntimeException());\n     * </code></pre>\n     *\n     * If throwable is a checked exception then it has to\n     * match one of the checked exceptions of method signature.\n     *\n     * See examples in javadoc for {@link Mockito#stub}\n     *\n     * @param throwable to be thrown on method invocation\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/DeprecatedOngoingStubbing.java",
        "class_name": "org.mockito.stubbing.DeprecatedOngoingStubbing",
        "signature": "org.mockito.stubbing.DeprecatedOngoingStubbing.toAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer);",
        "begin_line": 79,
        "end_line": 79,
        "comment": "\n     * Set a generic Answer for the stubbed method. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * stub(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n     *         return (Integer) invocation.getArguments()[0];\n     *     }\n     * }\n     * </code></pre>\n     *\n     * @param answer the custom answer to execute.\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenReturn(T)",
        "snippet": "    OngoingStubbing<T> thenReturn(T value);",
        "begin_line": 49,
        "end_line": 49,
        "comment": "\n     * Sets a return value to be returned when the method is called. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * when(mock.someMethod()).thenReturn(10);\n     * </code></pre>\n     *\n     * See examples in javadoc for {@link Mockito#when}\n     *\n     * @param value return value\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenReturn(T, T...)",
        "snippet": "    OngoingStubbing<T> thenReturn(T value, T... values);",
        "begin_line": 66,
        "end_line": 66,
        "comment": "\n     * Sets consecutive return values to be returned when the method is called. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * when(mock.someMethod()).thenReturn(1, 2, 3);\n     * </code></pre>\n     *\n     * Last return value in the sequence (in example: 3) determines the behavior of further consecutive calls.\n     * <p>\n     * See examples in javadoc for {@link Mockito#when}\n     *\n     * @param value first return value\n     * @param values next return values\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenThrow(java.lang.Throwable...)",
        "snippet": "    OngoingStubbing<T> thenThrow(Throwable... throwables);",
        "begin_line": 88,
        "end_line": 88,
        "comment": "\n     * Sets Throwable objects to be thrown when the method is called. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * when(mock.someMethod()).thenThrow(new RuntimeException());\n     * </code></pre>\n     *\n     * If throwables contain a checked exception then it has to\n     * match one of the checked exceptions of method signature.\n     * <p>\n     * You can specify throwables to be thrown for consecutive calls. \n     * In that case the last throwable determines the behavior of further consecutive calls.\n     * <p>\n     * if throwable is null then exception will be thrown.\n     * <p>\n     * See examples in javadoc for {@link Mockito#when}\n     *\n     * @param throwables to be thrown on method invocation\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenThrow(java.lang.Class<? extends java.lang.Throwable>...)",
        "snippet": "    OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses);",
        "begin_line": 114,
        "end_line": 114,
        "comment": "\n     * Sets Throwable classes to be thrown when the method is called. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * when(mock.someMethod()).thenThrow(RuntimeException.class);\n     * </code></pre>\n     *\n     * <p>\n     * Each throwable class will be instantiated for each method invocation.\n     * <p>\n     * If throwableClasses contain a checked exception then it has to\n     * match one of the checked exceptions of method signature.\n     * <p>\n     * You can specify throwableClasses to be thrown for consecutive calls.\n     * In that case the last throwable determines the behavior of further consecutive calls.\n     * <p>\n     * if throwable is null then exception will be thrown.\n     * <p>\n     * See examples in javadoc for {@link Mockito#when}\n     *\n     * @param throwableClasses to be thrown on method invocation\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     * @since 1.9.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenCallRealMethod()",
        "snippet": "    OngoingStubbing<T> thenCallRealMethod();",
        "begin_line": 145,
        "end_line": 145,
        "comment": "     \n     * Sets the real implementation to be called when the method is called on a mock object.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't... \n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy: \n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <pre class=\"code\"><code class=\"java\">\n     *   // someMethod() must be safe (e.g. doesn't throw, doesn't have dependencies to the object state, etc.)\n     *   // if it isn't safe then you will have trouble stubbing it using this api. Use Mockito.doCallRealMethod() instead. \n     *   when(mock.someMethod()).thenCallRealMethod();\n     *   \n     *   // calls real method:\n     *   mock.someMethod();\n     *   \n     * </code></pre>\n     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n     * <p>\n     * See examples in javadoc for {@link Mockito#when}\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.thenAnswer(org.mockito.stubbing.Answer<?>)",
        "snippet": "    OngoingStubbing<T> thenAnswer(Answer<?> answer);",
        "begin_line": 161,
        "end_line": 161,
        "comment": "\n     * Sets a generic Answer for the method. E.g:\n     * <pre class=\"code\"><code class=\"java\">\n     * when(mock.someMethod(10)).thenAnswer(new Answer&lt;Integer&gt;() {\n     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n     *         return (Integer) invocation.getArguments()[0];\n     *     }\n     * }\n     * </code></pre>\n     *\n     * @param answer the custom answer to execute.\n     *\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.then(org.mockito.stubbing.Answer<?>)",
        "snippet": "    OngoingStubbing<T> then(Answer<?> answer);",
        "begin_line": 182,
        "end_line": 182,
        "comment": "\n     * Sets a generic Answer for the method.\n     *\n     * This method is an alias of {@link #thenAnswer(Answer)}. This alias allows\n     * more readable tests on occasion, for example:\n     * <pre class=\"code\"><code class=\"java\">\n     * //using 'then' alias:\n     * when(mock.foo()).then(returnCoolValue());\n     *\n     * //versus good old 'thenAnswer:\n     * when(mock.foo()).thenAnswer(byReturningCoolValue());\n     * </code></pre>\n     *\n     * @param answer the custom answer to execute.\n     * @return iOngoingStubbing object that allows stubbing consecutive calls\n     *\n     * @see #thenAnswer(Answer)\n     * @since 1.9.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/stubbing/OngoingStubbing.java",
        "class_name": "org.mockito.stubbing.OngoingStubbing",
        "signature": "org.mockito.stubbing.OngoingStubbing.getMock()",
        "snippet": "    <M> M getMock();",
        "begin_line": 201,
        "end_line": 201,
        "comment": "\n     * Returns the mock that was used for this stub.\n     * <p>\n     * It allows to create a stub in one line of code.\n     * This can be helpful to keep test code clean.\n     * For example, some boring stub can be created & stubbed at field initialization in a test:\n     * <pre class=\"code\"><code class=\"java\">\n     * public class CarTest {\n     *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();\n     *\n     *   &#064;Test public void should... {}\n     * </code></pre>\n     *\n     * @param <M> The mock type given by the variable type.\n     * @return Mock used in this ongoing stubbing.\n     * @since 1.9.0\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/plugins/PluginSwitch.java",
        "class_name": "org.mockito.plugins.PluginSwitch",
        "signature": "org.mockito.plugins.PluginSwitch.isEnabled(java.lang.String)",
        "snippet": "    boolean isEnabled(String pluginClassName);",
        "begin_line": 51,
        "end_line": 51,
        "comment": "\n     * Mockito invokes this method for every plugin found in the classpath\n     * (except from the {@code PluginSwitch} implementation itself).\n     * If no custom plugins are discovered this method is not invoked.\n     *\n     * @since 1.10.15\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/plugins/MockMaker.java",
        "class_name": "org.mockito.plugins.MockMaker",
        "signature": "org.mockito.plugins.MockMaker.createMock(org.mockito.mock.MockCreationSettings<T>, org.mockito.invocation.MockHandler)",
        "snippet": "    <T> T createMock(\n            MockCreationSettings<T> settings,\n            MockHandler handler\n    );",
        "begin_line": 66,
        "end_line": 69,
        "comment": "\n     * If you want to provide your own implementation of {@code MockMaker} this method should:\n     * <ul>\n     *     <li>Create a proxy object that implements {@code settings.typeToMock} and potentially also {@code settings.extraInterfaces}.</li>\n     *     <li>You may use the information from {@code settings} to create/configure your proxy object.</li>\n     *     <li>Your proxy object should carry the {@code handler} with it. For example, if you generate byte code\n     *     to create the proxy you could generate an extra field to keep the {@code handler} with the generated object.\n     *     Your implementation of {@code MockMaker} is required to provide this instance of {@code handler} when\n     *     {@link #getHandler(Object)} is called.\n     *     </li>\n     * </ul>\n     *\n     * @param settings - mock creation settings like type to mock, extra interfaces and so on.\n     * @param handler See {@link org.mockito.invocation.MockHandler}.\n     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of\n     *                {@link #getHandler(Object)} will return this instance.\n     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.\n     * @return The mock instance.\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/plugins/MockMaker.java",
        "class_name": "org.mockito.plugins.MockMaker",
        "signature": "org.mockito.plugins.MockMaker.getHandler(java.lang.Object)",
        "snippet": "    MockHandler getHandler(Object mock);",
        "begin_line": 81,
        "end_line": 81,
        "comment": "\n     * Returns the handler for the {@code mock}. <b>Do not</b> provide your own implementations at this time\n     * because the work on the {@link MockHandler} api is not completed.\n     * Use the instance provided to you by Mockito at {@link #createMock} or {@link #resetMock}.\n     *\n     * @param mock The mock instance.\n     * @return may return null - it means that there is no handler attached to provided object.\n     *   This means the passed object is not really a Mockito mock.\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/plugins/MockMaker.java",
        "class_name": "org.mockito.plugins.MockMaker",
        "signature": "org.mockito.plugins.MockMaker.resetMock(java.lang.Object, org.mockito.invocation.MockHandler, org.mockito.mock.MockCreationSettings)",
        "snippet": "    void resetMock(\n            Object mock,\n            MockHandler newHandler,\n            MockCreationSettings settings\n    );",
        "begin_line": 97,
        "end_line": 101,
        "comment": "\n     * Replaces the existing handler on {@code mock} with {@code newHandler}.\n     *\n     * <p>The invocation handler actually store invocations to achieve\n     * stubbing and verification. In order to reset the mock, we pass\n     * a new instance of the invocation handler.</p>\n     *\n     * <p>Your implementation should make sure the {@code newHandler} is correctly associated to passed {@code mock}</p>\n     *\n     * @param mock The mock instance whose invocation handler is to be replaced.\n     * @param newHandler The new invocation handler instance.\n     * @param settings The mock settings - should you need to access some of the mock creation details.\n     * @since 1.9.5\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/plugins/StackTraceCleanerProvider.java",
        "class_name": "org.mockito.plugins.StackTraceCleanerProvider",
        "signature": "org.mockito.plugins.StackTraceCleanerProvider.getStackTraceCleaner(org.mockito.exceptions.stacktrace.StackTraceCleaner)",
        "snippet": "    StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner);",
        "begin_line": 23,
        "end_line": 23,
        "comment": "\n     * Allows configuring custom StackTraceCleaner.\n     *\n     * @param defaultCleaner - Mockito's default StackTraceCleaner\n     * @return StackTraceCleaner to use\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/IMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.IMockitoConfiguration",
        "signature": "org.mockito.configuration.IMockitoConfiguration.getReturnValues()",
        "snippet": "    @Deprecated\n    ReturnValues getReturnValues();",
        "begin_line": 51,
        "end_line": 52,
        "comment": "\n     * @deprecated\n     * <b>Please use {@link IMockitoConfiguration#getDefaultAnswer()}</b>\n     * <p>\n     * Steps: \n     * <p>\n     * 1. Leave the implementation of getReturnValues() method empty - it's not going to be used anyway.\n     * <p>\n     * 2. Implement getDefaultAnswer() instead.\n     * <p>\n     * In rare cases your code might not compile with recent deprecation & changes.\n     * Very sorry for inconvenience but it had to be done in order to keep framework consistent.\n     * <p>\n     * See javadoc {@link ReturnValues} for info why this method was deprecated\n     * <p>\n     * Allows configuring the default return values of unstubbed invocations\n     * <p>\n     * See javadoc for {@link IMockitoConfiguration}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/IMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.IMockitoConfiguration",
        "signature": "org.mockito.configuration.IMockitoConfiguration.getDefaultAnswer()",
        "snippet": "    Answer<Object> getDefaultAnswer();",
        "begin_line": 59,
        "end_line": 59,
        "comment": "\n     * Allows configuring the default answers of unstubbed invocations\n     * <p>\n     * See javadoc for {@link IMockitoConfiguration}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/IMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.IMockitoConfiguration",
        "signature": "org.mockito.configuration.IMockitoConfiguration.getAnnotationEngine()",
        "snippet": "    AnnotationEngine getAnnotationEngine();",
        "begin_line": 66,
        "end_line": 66,
        "comment": "\n     * Configures annotations for mocks\n     * <p>\n     * See javadoc for {@link IMockitoConfiguration}\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/IMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.IMockitoConfiguration",
        "signature": "org.mockito.configuration.IMockitoConfiguration.cleansStackTrace()",
        "snippet": "    boolean cleansStackTrace();",
        "begin_line": 77,
        "end_line": 77,
        "comment": "\n     * This should be turned on unless you're a Mockito developer and you wish\n     * to have verbose (read: messy) stack traces that only few understand (eg:\n     * Mockito developers)\n     * <p>\n     * See javadoc for {@link IMockitoConfiguration}\n     * \n     * @return if Mockito should clean stack traces\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/IMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.IMockitoConfiguration",
        "signature": "org.mockito.configuration.IMockitoConfiguration.enableClassCache()",
        "snippet": "    boolean enableClassCache();",
        "begin_line": 83,
        "end_line": 83,
        "comment": "\n     * Allow objenesis to cache classes. If you're in an environment where classes \n     * are dynamically reloaded, you can disable this to avoid classcast exceptions.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/DefaultMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
        "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getReturnValues()",
        "snippet": "    @Deprecated\n    public ReturnValues getReturnValues() {\n        throw new RuntimeException(\"\\n\" + \"This method should not be used by the framework because it was deprecated\"\n                + \"\\n\" + \"Please report the failure to the Mockito mailing list\");\n    }",
        "begin_line": 25,
        "end_line": 29,
        "comment": " (non-Javadoc)\n     * @see org.mockito.IMockitoConfiguration#getReturnValues()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/DefaultMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
        "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getDefaultAnswer()",
        "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return new ReturnsEmptyValues();\n    }",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/DefaultMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
        "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
        "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": " (non-Javadoc)\n     * @see org.mockito.IMockitoConfiguration#getAnnotationEngine()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/DefaultMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
        "signature": "org.mockito.configuration.DefaultMockitoConfiguration.cleansStackTrace()",
        "snippet": "    public boolean cleansStackTrace() {\n        return true;\n    }",
        "begin_line": 45,
        "end_line": 47,
        "comment": " (non-Javadoc)\n     * @see org.mockito.configuration.IMockitoConfiguration#cleansStackTrace()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/DefaultMockitoConfiguration.java",
        "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
        "signature": "org.mockito.configuration.DefaultMockitoConfiguration.enableClassCache()",
        "snippet": "    public boolean enableClassCache() {\n        return true;\n    }",
        "begin_line": 52,
        "end_line": 54,
        "comment": " (non-Javadoc)\n     * @see org.mockito.configuration.IMockitoConfiguration#enableClassCache()\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/AnnotationEngine.java",
        "class_name": "org.mockito.configuration.AnnotationEngine",
        "signature": "org.mockito.configuration.AnnotationEngine.createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)",
        "snippet": "    @Deprecated\n    Object createMockFor(Annotation annotation, Field field);",
        "begin_line": 29,
        "end_line": 30,
        "comment": "\n     * @deprecated\n     * Please use {@link AnnotationEngine#process(Class, Object)} method instead that is more robust\n     * <p>\n     * Creates mock, ArgumentCaptor or wraps field instance in spy object.\n     * Only if of correct annotation type.\n     *\n     * @param annotation Annotation\n     * @param field Field details\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "src/org/mockito/configuration/AnnotationEngine.java",
        "class_name": "org.mockito.configuration.AnnotationEngine",
        "signature": "org.mockito.configuration.AnnotationEngine.process(java.lang.Class<?>, java.lang.Object)",
        "snippet": "    void process(Class<?> clazz, Object testInstance);",
        "begin_line": 40,
        "end_line": 40,
        "comment": "\n     * Allows extending the interface to perform action on specific fields on the test class.\n     * <p>\n     * See the implementation of this method to figure out what is it for.\n     * \n     * @param clazz Class where to extract field information, check implementation for details\n     * @param testInstance Test instance\n     ",
        "resolved_comments": {}
    }
]