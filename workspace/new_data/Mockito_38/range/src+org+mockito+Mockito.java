{
  "filepath": "/tmp/Mockito-38b/src/org/mockito/Mockito.java",
  "nodes": [
    {
      "type": "class_interface",
      "name": "Mockito",
      "is_interface": false,
      "parent_types": [
        "org.mockito.Matchers"
      ],
      "begin_line": 567,
      "end_line": 1482,
      "comment": "\r\n * \u003cp align\u003d\"left\"\u003e\u003cimg src\u003d\"logo.jpg\"/\u003e\u003c/p\u003e\r\n * Mockito library enables mocks creation, verification and stubbing.\r\n * \u003cp\u003e\r\n * This javadoc content is also available on the \u003ca href\u003d\"http://mockito.org\"\u003ehttp://mockito.org\u003c/a\u003e web page. \r\n * All documentation is kept in javadocs because it guarantees consistency between what\u0027s on the web and what\u0027s in the source code.\r\n * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \r\n * \r\n * \u003ch1\u003eContents\u003c/h1\u003e\r\n * \r\n * \u003cb\u003e \r\n *      \u003ca href\u003d\"#1\"\u003e1. Let\u0027s verify some behaviour! \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#2\"\u003e2. How about some stubbing? \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#3\"\u003e3. Argument matchers \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#4\"\u003e4. Verifying exact number of invocations / at least once / never \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#5\"\u003e5. Stubbing void methods with exceptions \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#6\"\u003e6. Verification in order \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#7\"\u003e7. Making sure interaction(s) never happened on mock \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#8\"\u003e8. Finding redundant invocations \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#9\"\u003e9. Shorthand for mocks creation - \u0026#064;Mock annotation \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#10\"\u003e10. Stubbing consecutive calls (iterator-style stubbing) \u003c/a\u003e\u003cbr/\u003e \r\n *      \u003ca href\u003d\"#11\"\u003e11. Stubbing with callbacks \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#12\"\u003e12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#13\"\u003e13. Spying on real objects \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#14\"\u003e14. Changing default return values of unstubbed invocations \u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#15\"\u003e15. (**New**) Capturing arguments for further assertions\u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#16\"\u003e16. (**New**) Real partial mocks\u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#17\"\u003e17. (**New**) Resetting mocks\u003c/a\u003e\u003cbr/\u003e\r\n *      \u003ca href\u003d\"#18\"\u003e18. (**New**) Troubleshooting \u0026 validating framework usage\u003c/a\u003e\u003cbr/\u003e\r\n * \u003c/b\u003e\r\n * \r\n * \u003cp\u003e\r\n * Following examples mock a List, because everyone knows its interface (methods\r\n * like add(), get(), clear() will be used). \u003cbr\u003e\r\n * You probably wouldn\u0027t mock List class \u0027in real\u0027.\r\n * \r\n * \u003ch3 id\u003d\"1\"\u003e1. Let\u0027s verify some behaviour!\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * //Let\u0027s import Mockito statically so that the code looks clearer\r\n * import static org.mockito.Mockito.*;\r\n * \r\n * //mock creation\r\n * List mockedList \u003d mock(List.class);\r\n * \r\n * //using mock object\r\n * mockedList.add(\"one\");\r\n * mockedList.clear();\r\n * \r\n * //verification\r\n * verify(mockedList).add(\"one\");\r\n * verify(mockedList).clear();\r\n * \u003c/pre\u003e\r\n * \r\n * \u003cp\u003e\r\n * Once created, mock will remember all interactions. Then you can selectively\r\n * verify whatever interaction you are interested in.\r\n * \r\n * \u003ch3 id\u003d\"2\"\u003e2. How about some stubbing?\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * //You can mock concrete classes, not only interfaces\r\n * LinkedList mockedList \u003d mock(LinkedList.class);\r\n * \r\n * //stubbing\r\n * when(mockedList.get(0)).thenReturn(\"first\");\r\n * when(mockedList.get(1)).thenThrow(new RuntimeException());\r\n * \r\n * //following prints \"first\"\r\n * System.out.println(mockedList.get(0));\r\n * \r\n * //following throws runtime exception\r\n * System.out.println(mockedList.get(1));\r\n * \r\n * //following prints \"null\" because get(999) was not stubbed\r\n * System.out.println(mockedList.get(999));\r\n *  \r\n * //Although it is possible to verify a stubbed invocation, usually \u003cb\u003eit\u0027s just redundant\u003c/b\u003e\r\n * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\r\n * //If your code doesn\u0027t care what get(0) returns then it should not be stubbed. Not convinced? See \u003ca href\u003d\"http://monkeyisland.pl/2008/04/26/asking-and-telling\"\u003ehere\u003c/a\u003e.\r\n * verify(mockedList).get(0);\r\n * \u003c/pre\u003e\r\n * \r\n * \u003cul\u003e\r\n * \u003cli\u003e By default, for all methods that return value, mock returns null, an\r\n * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\r\n * false, ... for int/Integer, boolean/Boolean, ...). \u003c/li\u003e\r\n * \r\n * \u003cli\u003e Stubbing can be overridden: for example common stubbing can go to\r\n * fixture setup but the test methods can override it. \u003c/li\u003e\r\n * \r\n * \u003cli\u003e Once stubbed, the method will always return stubbed value regardless\r\n * of how many times it is called. \u003c/li\u003e\r\n * \r\n * \u003cli\u003e Last stubbing is more important - when you stubbed the same method with\r\n * the same arguments many times. \u003c/li\u003e\r\n * \r\n * \u003c/ul\u003e\r\n * \r\n * \u003ch3 id\u003d\"3\"\u003e3. Argument matchers\u003c/h3\u003e\r\n * \r\n * Mockito verifies argument values in natural java style: by using an equals() method.\r\n * Sometimes, when extra flexibility is required then you might use argument matchers:  \r\n * \r\n * \u003cpre\u003e\r\n * //stubbing using built-in anyInt() argument matcher\r\n * when(mockedList.get(anyInt())).thenReturn(\"element\");\r\n * \r\n * //stubbing using hamcrest (let\u0027s say isValid() returns your own hamcrest matcher):\r\n * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\r\n * \r\n * //following prints \"element\"\r\n * System.out.println(mockedList.get(999));\r\n * \r\n * //\u003cb\u003eyou can also verify using an argument matcher\u003c/b\u003e\r\n * verify(mockedList).get(anyInt());\r\n * \u003c/pre\u003e\r\n * \r\n * \u003cp\u003e\r\n * Argument matchers allow flexible verification or stubbing. \r\n * {@link Matchers Click here to see} more built-in matchers \r\n * and examples of \u003cb\u003ecustom argument matchers / hamcrest matchers\u003c/b\u003e.\r\n * \u003cp\u003e\r\n * For information solely on \u003cb\u003ecustom argument matchers\u003c/b\u003e check out javadoc for {@link ArgumentMatcher} class.\r\n * \u003cp\u003e\r\n * Be reasonable with using complicated argument matching.\r\n * The natural matching style using equals() with occasional anyX() matchers tend to give clean \u0026 simple tests.\r\n * Sometimes it\u0027s just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\r\n * \u003cp\u003e\r\n * Also, read \u003ca href\u003d\"#15\"\u003esection 15\u003c/a\u003e or javadoc for {@link ArgumentCaptor} class.\r\n * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \r\n * \u003cp\u003e\r\n * \u003cb\u003eWarning on argument matchers:\u003c/b\u003e\r\n * \u003cp\u003e\r\n * If you are using argument matchers, \u003cb\u003eall arguments\u003c/b\u003e have to be provided\r\n * by matchers.\r\n * \u003cp\u003e\r\n * E.g: (example shows verification but the same applies to stubbing):\r\n * \r\n * \u003cpre\u003e\r\n *   verify(mock).someMethod(anyInt(), anyString(), \u003cb\u003eeq(\"third argument\")\u003c/b\u003e);\r\n *   //above is correct - eq() is also an argument matcher\r\n *   \r\n *   verify(mock).someMethod(anyInt(), anyString(), \u003cb\u003e\"third argument\"\u003c/b\u003e);\r\n *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\r\n * \u003c/pre\u003e\r\n * \r\n * \u003ch3 id\u003d\"4\"\u003e4. Verifying exact number of invocations / at least x / never\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * //using mock \r\n * mockedList.add(\"once\");\r\n * \r\n * mockedList.add(\"twice\");\r\n * mockedList.add(\"twice\");\r\n * \r\n * mockedList.add(\"three times\");\r\n * mockedList.add(\"three times\");\r\n * mockedList.add(\"three times\");\r\n * \r\n * //following two verifications work exactly the same - times(1) is used by default\r\n * verify(mockedList).add(\"once\");\r\n * verify(mockedList, times(1)).add(\"once\");\r\n * \r\n * //exact number of invocations verification\r\n * verify(mockedList, times(2)).add(\"twice\");\r\n * verify(mockedList, times(3)).add(\"three times\");\r\n * \r\n * //verification using never(). never() is an alias to times(0)\r\n * verify(mockedList, never()).add(\"never happened\");\r\n * \r\n * //verification using atLeast()/atMost()\r\n * verify(mockedList, atLeastOnce()).add(\"three times\");\r\n * verify(mockedList, atLeast(2)).add(\"five times\");\r\n * verify(mockedList, atMost(5)).add(\"three times\");\r\n * \r\n * \u003c/pre\u003e\r\n * \r\n * \u003cp\u003e\r\n * \u003cb\u003etimes(1) is the default.\u003c/b\u003e Therefore using times(1) explicitly can be\r\n * omitted.\r\n * \r\n * \u003ch3 id\u003d\"5\"\u003e5. Stubbing void methods with exceptions\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n *   doThrow(new RuntimeException()).when(mockedList).clear();\r\n *   \r\n *   //following throws RuntimeException:\r\n *   mockedList.clear();\r\n * \u003c/pre\u003e\r\n * \r\n * Read more about doThrow|doAnswer family of methods in paragraph 12.\r\n * \u003cp\u003e\r\n * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\r\n * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\r\n * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \r\n * \r\n * \u003ch3 id\u003d\"6\"\u003e6. Verification in order\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * List firstMock \u003d mock(List.class);\r\n * List secondMock \u003d mock(List.class);\r\n * \r\n * //using mocks\r\n * firstMock.add(\"was called first\");\r\n * secondMock.add(\"was called second\");\r\n * \r\n * //create inOrder object passing any mocks that need to be verified in order\r\n * InOrder inOrder \u003d inOrder(firstMock, secondMock);\r\n * \r\n * //following will make sure that firstMock was called before secondMock\r\n * inOrder.verify(firstMock).add(\"was called first\");\r\n * inOrder.verify(secondMock).add(\"was called second\");\r\n * \u003c/pre\u003e\r\n * \r\n * Verification in order is flexible - \u003cb\u003eyou don\u0027t have to verify all\r\n * interactions\u003c/b\u003e one-by-one but only those that you are interested in\r\n * testing in order.\r\n * \u003cp\u003e\r\n * Also, you can create InOrder object passing only mocks that are relevant for\r\n * in-order verification.\r\n * \r\n * \u003ch3 id\u003d\"7\"\u003e7. Making sure interaction(s) never happened on mock\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * //using mocks - only mockOne is interacted\r\n * mockOne.add(\"one\");\r\n * \r\n * //ordinary verification\r\n * verify(mockOne).add(\"one\");\r\n * \r\n * //verify that method was never called on a mock\r\n * verify(mockOne, never()).add(\"two\");\r\n * \r\n * //verify that other mocks were not interacted\r\n * verifyZeroInteractions(mockTwo, mockThree);\r\n * \r\n * \u003c/pre\u003e\r\n * \r\n * \u003ch3 id\u003d\"8\"\u003e8. Finding redundant invocations\u003c/h3\u003e\r\n * \r\n * \u003cpre\u003e\r\n * //using mocks\r\n * mockedList.add(\"one\");\r\n * mockedList.add(\"two\");\r\n * \r\n * verify(mockedList).add(\"one\");\r\n * \r\n * //following verification will fail \r\n * verifyNoMoreInteractions(mockedList);\r\n * \u003c/pre\u003e\r\n * \r\n * A word of \u003cb\u003ewarning\u003c/b\u003e: \r\n * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \r\n * verifyNoMoreInteractions() is not recommended to use in every test method. \r\n * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it\u0027s relevant.\r\n * Abusing it leads to overspecified, less maintainable tests. You can find further reading \r\n * \u003ca href\u003d\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\"\u003ehere\u003c/a\u003e.\r\n * \r\n * \u003cp\u003e   \r\n * See also {@link Mockito#never()} - it is more explicit and\r\n * communicates the intent well.\r\n * \u003cp\u003e\r\n * \r\n * \u003ch3 id\u003d\"9\"\u003e9. Shorthand for mocks creation - \u0026#064;Mock annotation\u003c/h3\u003e\r\n * \r\n * \u003cul\u003e\r\n * \u003cli\u003eMinimizes repetitive mock creation code.\u003c/li\u003e\r\n * \u003cli\u003eMakes the test class more readable.\u003c/li\u003e\r\n * \u003cli\u003eMakes the verification error easier to read because the \u003cb\u003efield name\u003c/b\u003e\r\n * is used to identify the mock.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n * \r\n * \u003cpre\u003e\r\n *   public class ArticleManagerTest { \r\n *     \r\n *       \u0026#064;Mock private ArticleCalculator calculator;\r\n *       \u0026#064;Mock private ArticleDatabase database;\r\n *       \u0026#064;Mock private UserProvider userProvider;\r\n *     \r\n *       private ArticleManager manager;\r\n * \u003c/pre\u003e\r\n * \r\n * \u003cb\u003eImportant!\u003c/b\u003e This needs to be somewhere in the base class or a test\r\n * runner:\r\n * \r\n * \u003cpre\u003e\r\n * MockitoAnnotations.initMocks(testClass);\r\n * \u003c/pre\u003e\r\n * \r\n * You can use built-in runner: {@link MockitoJUnitRunner}.\r\n * \u003cp\u003e\r\n * Read more here: {@link MockitoAnnotations}\r\n * \r\n * \u003ch3 id\u003d\"10\"\u003e 10. Stubbing consecutive calls (iterator-style stubbing)\u003c/h3\u003e\r\n * \r\n * Sometimes we need to stub with different return value/exception for the same\r\n * method call. Typical use case could be mocking iterators. \r\n * Original version of Mockito did not have this feature to promote simple mocking. \r\n * For example, instead of iterators one could use {@link Iterable} or simply\r\n * collections. Those offer natural ways of stubbing (e.g. using real\r\n * collections). In rare scenarios stubbing consecutive calls could be useful,\r\n * though:\r\n * \u003cp\u003e\r\n * \r\n * \u003cpre\u003e\r\n * when(mock.someMethod(\"some arg\"))\r\n *   .thenThrow(new RuntimeException())\r\n *   .thenReturn(\"foo\");\r\n * \r\n * //First call: throws runtime exception:\r\n * mock.someMethod(\"some arg\");\r\n * \r\n * //Second call: prints \"foo\"\r\n * System.out.println(mock.someMethod(\"some arg\"));\r\n * \r\n * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \r\n * System.out.println(mock.someMethod(\"some arg\"));\r\n * \u003c/pre\u003e\r\n * \r\n * Alternative, shorter version of consecutive stubbing:\r\n * \r\n * \u003cpre\u003e\r\n * when(mock.someMethod(\"some arg\"))\r\n *   .thenReturn(\"one\", \"two\", \"three\");\r\n * \u003c/pre\u003e\r\n * \r\n * \u003ch3 id\u003d\"11\"\u003e 11. Stubbing with callbacks\u003c/h3\u003e\r\n * \r\n * Allows stubbing with generic {@link Answer} interface.\r\n*  \u003cp\u003e\r\n * Yet another controversial feature which was not included in Mockito\r\n * originally. We recommend using simple stubbing with toReturn() or\r\n * toThrow() only. Those two should be \u003cb\u003ejust enough\u003c/b\u003e to test/test-drive\r\n * any clean \u0026 simple code.\r\n * \r\n * \u003cpre\u003e\r\n * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\r\n *     Object answer(InvocationOnMock invocation) {\r\n *         Object[] args \u003d invocation.getArguments();\r\n *         Object mock \u003d invocation.getMock();\r\n *         return \"called with arguments: \" + args;\r\n *     }\r\n * });\r\n * \r\n * //Following prints \"called with arguments: foo\"\r\n * System.out.println(mock.someMethod(\"foo\"));\r\n * \u003c/pre\u003e\r\n * \r\n * \u003ch3 id\u003d\"12\"\u003e 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)\u003c/h3\u003e\r\n * \r\n * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\r\n * \u003cp\u003e\r\n * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \r\n * The main reason is improved readability and consistency with the family of doAnswer() methods.\r\n * \u003cp\u003e\r\n * Use doThrow() when you want to stub a void method with an exception:\r\n * \u003cpre\u003e\r\n *   doThrow(new RuntimeException()).when(mockedList).clear();\r\n *   \r\n *   //following throws RuntimeException:\r\n *   mockedList.clear();\r\n * \u003c/pre\u003e\r\n * \r\n * Read more about other methods:\r\n * \u003cp\u003e\r\n * {@link Mockito#doThrow(Throwable)}\r\n * \u003cp\u003e\r\n * {@link Mockito#doAnswer(Answer)}\r\n * \u003cp\u003e\r\n * {@link Mockito#doNothing()}\r\n * \u003cp\u003e\r\n * {@link Mockito#doReturn(Object)}\r\n * \r\n * \u003ch3 id\u003d\"13\"\u003e 13. Spying on real objects\u003c/h3\u003e\r\n * \r\n * You can create spies of real objects. When you use the spy then the \u003cb\u003ereal\u003c/b\u003e methods are called (unless a method was stubbed).\r\n * \u003cp\u003e\r\n * Real spies should be used \u003cb\u003ecarefully and occasionally\u003c/b\u003e, for example when dealing with legacy code.\r\n * \r\n * \u003cp\u003e\r\n * Spying on real objects can be associated with \"partial mocking\" concept. \r\n * \u003cb\u003eBefore the release 1.8\u003c/b\u003e, Mockito spies were not real partial mocks. \r\n * The reason was we thought partial mock is a code smell. \r\n * At some point we found legitimate use cases for partial mocks \r\n * (3rd party interfaces, interim refactoring of legacy code, the full article is \u003ca href\u003d\r\n * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\r\n * \u003ehere\u003c/a\u003e)\r\n * \u003cp\u003e\r\n *\r\n * \u003cpre\u003e\r\n *   List list \u003d new LinkedList();\r\n *   List spy \u003d spy(list);\r\n * \r\n *   //optionally, you can stub out some methods:\r\n *   when(spy.size()).thenReturn(100);\r\n * \r\n *   //using the spy calls \u003cb\u003ereal\u003c/b\u003e methods\r\n *   spy.add(\"one\");\r\n *   spy.add(\"two\");\r\n * \r\n *   //prints \"one\" - the first element of a list\r\n *   System.out.println(spy.get(0));\r\n * \r\n *   //size() method was stubbed - 100 is printed\r\n *   System.out.println(spy.size());\r\n * \r\n *   //optionally, you can verify\r\n *   verify(spy).add(\"one\");\r\n *   verify(spy).add(\"two\");\r\n * \u003c/pre\u003e\r\n * \r\n * \u003ch4\u003eImportant gotcha on spying real objects!\u003c/h4\u003e\r\n * \r\n * 1. Sometimes it\u0027s impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\r\n * \r\n * \u003cpre\u003e\r\n *   List list \u003d new LinkedList();\r\n *   List spy \u003d spy(list);\r\n *   \r\n *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\r\n *   when(spy.get(0)).thenReturn(\"foo\");\r\n *   \r\n *   //You have to use doReturn() for stubbing\r\n *   doReturn(\"foo\").when(spy).get(0);\r\n * \u003c/pre\u003e\r\n * \r\n * 2. Watch out for final methods. \r\n * Mockito doesn\u0027t mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method \u003d trouble.\r\n * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\r\n * Typically you may get a NullPointerException because mock instances don\u0027t have fields initiated.\r\n * \r\n * \u003ch3 id\u003d\"14\"\u003e14. Changing default return values of unstubbed invocations\u003c/h3\u003e\r\n * \r\n * You can create a mock with specified strategy for its return values.\r\n * It\u0027s quite advanced feature and typically you don\u0027t need it to write decent tests.\r\n * However, it can be helpful for working with \u003cb\u003elegacy systems\u003c/b\u003e.\r\n * \u003cp\u003e\r\n * It is the default answer so it will be used \u003cb\u003eonly when you don\u0027t\u003c/b\u003e stub the method call.\r\n * \r\n * \u003cpre\u003e\r\n *   Foo mock \u003d mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\r\n *   Foo mockTwo \u003d mock(Foo.class, new YourOwnAnswer()); \r\n * \u003c/pre\u003e\r\n * \r\n * \u003cp\u003e\r\n * Read more about this interesting implementation of \u003ci\u003eAnswer\u003c/i\u003e: {@link Mockito#RETURNS_SMART_NULLS}\r\n * \r\n * \u003ch3 id\u003d\"15\"\u003e15. (**New**) Capturing arguments for further assertions\u003c/h3\u003e\r\n * \r\n * Mockito verifies argument values in natural java style: by using an equals() method.\r\n * This is also the recommended way of matching arguments because it makes tests clean \u0026 simple.\r\n * In some situations though, it is helpful to assert on certain arguments after the actual verification.\r\n * For example:\r\n * \u003cpre\u003e\r\n *   ArgumentCaptor\u0026lt;Person\u0026gt; argument \u003d new ArgumentCaptor\u0026lt;Person\u0026gt;();\r\n *   verify(mock).doSomething(argument.capture());\r\n *   assertEquals(\"John\", argument.getValue().getName());\r\n * \u003c/pre\u003e\r\n * \r\n * \u003cb\u003eWarning:\u003c/b\u003e it is recommended to use ArgumentCaptor with verification \u003cb\u003ebut not\u003c/b\u003e with stubbing.\r\n * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or \u0027then\u0027) block.\r\n * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\r\n * \u003cp\u003e\r\n * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\r\n * Both techniques can be used for making sure certain arguments where passed to mocks. \r\n * However, ArgumentCaptor may be a better fit if:\r\n * \u003cul\u003e  \r\n * \u003cli\u003ecustom argument matcher is not likely to be reused\u003c/li\u003e\r\n * \u003cli\u003eyou just need it to assert on argument values to complete verification\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\r\n * \r\n * \u003ch3 id\u003d\"16\"\u003e16. (**New**) Real partial mocks\u003c/h3\u003e\r\n *  \r\n *  Finally, after many internal debates \u0026 discussions on the mailing list, partial mock support was added to Mockito.\r\n *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\r\n *  \u003ca href\u003d\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\u003ehere\u003c/a\u003e\r\n *  \u003cp\u003e\r\n *  \u003cb\u003eBefore release 1.8\u003c/b\u003e spy() was not producing real partial mocks and it was confusing for some users.\r\n *  Read more about spying: \u003ca href\u003d\"#13\"\u003ehere\u003c/a\u003e or in javadoc for {@link Mockito#spy(Object)} method. \r\n *  \u003cp\u003e\r\n *  \u003cpre\u003e\r\n *    //you can create partial mock with spy() method:    \r\n *    List list \u003d spy(new LinkedList());\r\n *    \r\n *    //you can enable partial mock capabilities selectively on mocks:\r\n *    Foo mock \u003d mock(Foo.class);\r\n *    //Be sure the real implementation is \u0027safe\u0027.\r\n *    //If real implementation throws exceptions or depends on specific state of the object then you\u0027re in trouble.\r\n *    when(mock.someMethod()).thenCallRealMethod();\r\n *  \u003c/pre\u003e\r\n *  \r\n * As usual you are going to read \u003cb\u003ethe partial mock warning\u003c/b\u003e:\r\n * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n * How does partial mock fit into this paradigm? Well, it just doesn\u0027t... \r\n * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n * In most cases, this is not the way you want to design your application.\r\n * \u003cp\u003e\r\n * However, there are rare cases when partial mocks come handy: \r\n * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n * However, I wouldn\u0027t use partial mocks for new, test-driven \u0026 well-designed code.\r\n *  \r\n * \u003ch3 id\u003d\"17\"\u003e17. (**New**) Resetting mocks\u003c/h3\u003e\r\n *  \r\n * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\r\n * Normally, you don\u0027t need to reset your mocks, just create new mocks for each test method. \r\n * \u003cp\u003e\r\n * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\r\n * \u003cb\u003eFirst potential code smell is reset() in the middle of the test method.\u003c/b\u003e This probably means you\u0027re testing too much.\r\n * Follow the whisper of your test methods: \"Please keep us small \u0026 focused on single behavior\". \r\n * There are several threads about it on mockito mailing list.\r\n * \u003cp\u003e\r\n * The only reason we added reset() method is to\r\n * make it possible to work with container-injected mocks.\r\n * See issue 55 (\u003ca href\u003d\"http://code.google.com/p/mockito/issues/detail?id\u003d55\"\u003ehere\u003c/a\u003e)\r\n * or FAQ (\u003ca href\u003d\"http://code.google.com/p/mockito/wiki/FAQ\"\u003ehere\u003c/a\u003e).\r\n * \u003cp\u003e\r\n * \u003cb\u003eDon\u0027t harm yourself.\u003c/b\u003e reset() in the middle of the test method is a code smell (you\u0027re probably testing too much). \r\n * \u003cpre\u003e\r\n *   List mock \u003d mock(List.class);\r\n *   when(mock.size()).thenReturn(10);\r\n *   mock.add(1);\r\n *   \r\n *   reset(mock);\r\n *   //at this point the mock forgot any interactions \u0026 stubbing\r\n * \u003c/pre\u003e\r\n *  \r\n * \u003ch3 id\u003d\"18\"\u003e18. (**New**) Troubleshooting \u0026 validating framework usage\u003c/h3\u003e\r\n * \r\n * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \r\n * \u003ca href\u003d\"http://code.google.com/p/mockito/wiki/FAQ\"\u003ehttp://code.google.com/p/mockito/wiki/FAQ\u003c/a\u003e\r\n * \u003cp\u003e\r\n * In case of questions you may also post to mockito mailing list: \r\n * \u003ca href\u003d\"http://groups.google.com/group/mockito\"\u003ehttp://groups.google.com/group/mockito\u003c/a\u003e\r\n * \u003cp\u003e\r\n * Next, you should know that Mockito validates if you use it correctly \u003cb\u003eall the time\u003c/b\u003e. \r\n * However, there\u0027s a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\r\n "
    },
    {
      "type": "field",
      "varNames": [
        "MOCKITO_CORE"
      ],
      "begin_line": 570,
      "end_line": 570,
      "comment": ""
    },
    {
      "type": "field",
      "varNames": [
        "RETURNS_DEFAULTS"
      ],
      "begin_line": 581,
      "end_line": 581,
      "comment": "\r\n     * The default Answer of every mock \u003cb\u003eif\u003c/b\u003e the mock was not stubbed. \r\n     * Typically it just returns some empty value. \r\n     * \u003cp\u003e\r\n     * {@link Answer} can be used to define the return values of unstubbed invocations. \r\n     * \u003cp\u003e\r\n     * This implementation first tries the global configuration. \r\n     * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\r\n     "
    },
    {
      "type": "field",
      "varNames": [
        "RETURNS_SMART_NULLS"
      ],
      "begin_line": 613,
      "end_line": 613,
      "comment": "\r\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n     * \u003cp\u003e\r\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n     * \u003cp\u003e\r\n     * This implementation can be helpful when working with legacy code.\r\n     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\r\n     * This implementation of Answer \u003cb\u003ereturns SmartNull instead of null\u003c/b\u003e.\r\n     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\r\n     * \u003cp\u003e\r\n     * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\r\n     * then it tries to return SmartNull. If the return type is final then plain null is returned.\r\n     * \u003cp\u003e\r\n     * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \u003cpre\u003e\r\n     *   Foo mock \u003d (Foo.class, RETURNS_SMART_NULLS);\r\n     *   \r\n     *   //calling unstubbed method here:\r\n     *   Stuff stuff \u003d mock.getStuff();\r\n     *   \r\n     *   //using object returned by unstubbed call:\r\n     *   stuff.doSomething();\r\n     *   \r\n     *   //Above doesn\u0027t yield NullPointerException this time!\r\n     *   //Instead, SmartNullPointerException is thrown. \r\n     *   //Exception\u0027s cause links to unstubbed \u003ci\u003emock.getStuff()\u003c/i\u003e - just click on the stack trace.  \r\n     * \u003c/pre\u003e\r\n     "
    },
    {
      "type": "field",
      "varNames": [
        "RETURNS_MOCKS"
      ],
      "begin_line": 626,
      "end_line": 626,
      "comment": "\r\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n     * \u003cp\u003e\r\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n     * \u003cp\u003e\r\n     * This implementation can be helpful when working with legacy code. \r\n     * \u003cp\u003e\r\n     * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\r\n     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\r\n     * \u003cp\u003e\r\n     "
    },
    {
      "type": "field",
      "varNames": [
        "CALLS_REAL_METHODS"
      ],
      "begin_line": 660,
      "end_line": 660,
      "comment": "\r\n     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n     * \u003cp\u003e\r\n     * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n     * \u003cp\u003e\r\n     * This implementation can be helpful when working with legacy code.\r\n     * When this implementation is used, unstubbed methods will delegate to the real implementation.\r\n     * This is a way to create a partial mock object that calls real methods by default.\r\n     * \u003cp\u003e\r\n     * As usual you are going to read \u003cb\u003ethe partial mock warning\u003c/b\u003e:\r\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n     * How does partial mock fit into this paradigm? Well, it just doesn\u0027t... \r\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n     * In most cases, this is not the way you want to design your application.\r\n     * \u003cp\u003e\r\n     * However, there are rare cases when partial mocks come handy: \r\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n     * However, I wouldn\u0027t use partial mocks for new, test-driven \u0026 well-designed code.\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \u003cpre\u003e\r\n     * Foo mock \u003d mock(Foo.class, CALLS_REAL_METHODS);\r\n     *\r\n     * // this calls the real implementation of Foo.getSomething()\r\n     * value \u003d mock.getSomething();\r\n     *\r\n     * when(mock.getSomething()).thenReturn(fakeValue);\r\n     *\r\n     * // now fakeValue is returned\r\n     * value \u003d mock.getSomething();\r\n     * \u003c/pre\u003e\r\n     "
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.mock(java.lang.Class\u003cT\u003e)",
      "begin_line": 670,
      "end_line": 672,
      "comment": "\r\n     * Creates mock object of given class or interface.\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param classToMock class or interface to mock\r\n     * @return mock object\r\n     ",
      "child_ranges": [
        "(line 671,col 9)-(line 671,col 81)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.mock(java.lang.Class\u003cT\u003e, java.lang.String)",
      "begin_line": 688,
      "end_line": 692,
      "comment": "\r\n     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \r\n     * \u003cp\u003e\r\n     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \r\n     * \u003cb\u003eIf you have too many mocks then refactor the code\u003c/b\u003e so that it\u0027s easy to test/debug without necessity of naming mocks.\r\n     * \u003cp\u003e\r\n     * \u003cb\u003eIf you use \u0026#064;Mock annotation then you\u0027ve got naming mocks for free!\u003c/b\u003e \u0026#064;Mock uses field name as mock name. {@link Mock Read more.}\r\n     * \u003cp\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param classToMock class or interface to mock\r\n     * @return mock object\r\n     ",
      "child_ranges": [
        "(line 689,col 9)-(line 691,col 50)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.mock(java.lang.Class\u003cT\u003e, org.mockito.ReturnValues)",
      "begin_line": 723,
      "end_line": 726,
      "comment": "\r\n     * @deprecated\r\n     * \u003cb\u003ePlease use mock(Foo.class, defaultAnswer);\u003c/b\u003e\r\n     * \u003cp\u003e\r\n     * See {@link Mockito#mock(Class, Answer)}\r\n     * \u003cp\u003e\r\n     * Why it is deprecated? ReturnValues is being replaced by Answer\r\n     * for better consistency \u0026 interoperability of the framework. \r\n     * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\r\n     * There\u0027s no point in mainting exactly the same interfaces.\r\n     * \u003cp\u003e\r\n     * Creates mock with a specified strategy for its return values. \r\n     * It\u0027s quite advanced feature and typically you don\u0027t need it to write decent tests.\r\n     * However it can be helpful when working with legacy systems.\r\n     * \u003cp\u003e\r\n     * Obviously return values are used only when you don\u0027t stub the method call.\r\n     *\r\n     * \u003cpre\u003e\r\n     *   Foo mock \u003d mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\r\n     *   Foo mockTwo \u003d mock(Foo.class, new YourOwnReturnValues()); \r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003cp\u003eSee examples in javadoc for {@link Mockito} class\u003c/p\u003e\r\n     * \r\n     * @param classToMock class or interface to mock\r\n     * @param returnValues default return values for unstubbed methods\r\n     *\r\n     * @return mock object\r\n     ",
      "child_ranges": [
        "(line 725,col 9)-(line 725,col 108)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.mock(java.lang.Class\u003cT\u003e, org.mockito.stubbing.Answer)",
      "begin_line": 747,
      "end_line": 749,
      "comment": "\r\n     * Creates mock with a specified strategy for its answers to interactions. \r\n     * It\u0027s quite advanced feature and typically you don\u0027t need it to write decent tests.\r\n     * However it can be helpful when working with legacy systems.\r\n     * \u003cp\u003e\r\n     * It is the default answer so it will be used \u003cb\u003eonly when you don\u0027t\u003c/b\u003e stub the method call.\r\n     *\r\n     * \u003cpre\u003e\r\n     *   Foo mock \u003d mock(Foo.class, RETURNS_SMART_NULLS);\r\n     *   Foo mockTwo \u003d mock(Foo.class, new YourOwnAnswer()); \r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003cp\u003eSee examples in javadoc for {@link Mockito} class\u003c/p\u003e\r\n     * \r\n     * @param classToMock class or interface to mock\r\n     * @param defaultAnswer default answer for unstubbed methods\r\n     *\r\n     * @return mock object\r\n     ",
      "child_ranges": [
        "(line 748,col 9)-(line 748,col 78)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.mock(java.lang.Class\u003cT\u003e, org.mockito.MockSettings)",
      "begin_line": 774,
      "end_line": 776,
      "comment": "\r\n     * Creates a mock with some non-standard settings.\r\n     * \u003cp\u003e\r\n     * The number of configuration points for a mock grows \r\n     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \r\n     * Hence {@link MockSettings}.\r\n     * \u003cpre\u003e\r\n     *   Listener mock \u003d mock(Listener.class, withSettings()\r\n     *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\r\n     *   );  \r\n     * \u003c/pre\u003e\r\n     * \u003cb\u003eUse it carefully and occasionally\u003c/b\u003e. What might be reason your test needs non-standard mocks? \r\n     * Is the code under test so complicated that it requires non-standard mocks? \r\n     * Wouldn\u0027t you prefer to refactor the code under test so it is testable in a simple way?\r\n     * \u003cp\u003e\r\n     * See also {@link Mockito#withSettings()}\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param classToMock class or interface to mock\r\n     * @param mockSettings additional mock settings\r\n     * @return mock object\r\n     ",
      "child_ranges": [
        "(line 775,col 9)-(line 775,col 60)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.spy(T)",
      "begin_line": 844,
      "end_line": 848,
      "comment": "\r\n     * Creates a spy of the real object. The spy calls \u003cb\u003ereal\u003c/b\u003e methods unless they are stubbed.\r\n     * \u003cp\u003e\r\n     * Real spies should be used \u003cb\u003ecarefully and occasionally\u003c/b\u003e, for example when dealing with legacy code.\r\n     * \u003cp\u003e\r\n     * As usual you are going to read \u003cb\u003ethe partial mock warning\u003c/b\u003e:\r\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n     * How does partial mock fit into this paradigm? Well, it just doesn\u0027t... \r\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n     * In most cases, this is not the way you want to design your application.\r\n     * \u003cp\u003e\r\n     * However, there are rare cases when partial mocks come handy: \r\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n     * However, I wouldn\u0027t use partial mocks for new, test-driven \u0026 well-designed code.\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \r\n     * \u003cpre\u003e\r\n     *   List list \u003d new LinkedList();\r\n     *   List spy \u003d spy(list);\r\n     * \r\n     *   //optionally, you can stub out some methods:\r\n     *   when(spy.size()).thenReturn(100);\r\n     * \r\n     *   //using the spy calls \u003cb\u003ereal\u003c/b\u003e methods\r\n     *   spy.add(\"one\");\r\n     *   spy.add(\"two\");\r\n     * \r\n     *   //prints \"one\" - the first element of a list\r\n     *   System.out.println(spy.get(0));\r\n     * \r\n     *   //size() method was stubbed - 100 is printed\r\n     *   System.out.println(spy.size());\r\n     * \r\n     *   //optionally, you can verify\r\n     *   verify(spy).add(\"one\");\r\n     *   verify(spy).add(\"two\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003ch4\u003eImportant gotcha on spying real objects!\u003c/h4\u003e\r\n     * \r\n     * 1. Sometimes it\u0027s impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\r\n     * \r\n     * \u003cpre\u003e\r\n     *   List list \u003d new LinkedList();\r\n     *   List spy \u003d spy(list);\r\n     *   \r\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\r\n     *   when(spy.get(0)).thenReturn(\"foo\");\r\n     *   \r\n     *   //You have to use doReturn() for stubbing\r\n     *   doReturn(\"foo\").when(spy).get(0);\r\n     * \u003c/pre\u003e\r\n     * \r\n     * 2. Watch out for final methods. \r\n     * Mockito doesn\u0027t mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method \u003d trouble.\r\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\r\n     * Typically you may get a NullPointerException because mock instances don\u0027t have fields initiated.\r\n     * \r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param object\r\n     *            to spy on\r\n     * @return a spy of the real object\r\n     ",
      "child_ranges": [
        "(line 845,col 9)-(line 847,col 52)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.stub(T)",
      "begin_line": 876,
      "end_line": 879,
      "comment": "\r\n     * \u003cpre\u003e\r\n     *   //Instead of:\r\n     *   stub(mock.count()).toReturn(10);\r\n     * \r\n     *   //Please do:\r\n     *   when(mock.count()).thenReturn(10);\r\n     * \u003c/pre\u003e \r\n     * \r\n     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \r\n     * \u003cp\u003e\r\n     * How to fix deprecation warnings? Typically it\u0027s just few minutes of search \u0026 replace job:\r\n     * \u003cpre\u003e\r\n     *   Mockito.stub;  \u003ci\u003ereplace with:\u003c/i\u003e  Mockito.when;\r\n     *   stub(          \u003ci\u003ereplace with:\u003c/i\u003e  when(\r\n     *   .toReturn(     \u003ci\u003ereplace with:\u003c/i\u003e  .thenReturn(\r\n     *   .toThrow(      \u003ci\u003ereplace with:\u003c/i\u003e  .thenThrow(\r\n     *   .toAnswer(     \u003ci\u003ereplace with:\u003c/i\u003e  .thenAnswer(\r\n     * \u003c/pre\u003e\r\n     * If you\u0027re an existing user then sorry for making your code littered with deprecation warnings. \r\n     * This change was required to make Mockito better.\r\n     * \r\n     * @param methodCall\r\n     *            method call\r\n     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\r\n     ",
      "child_ranges": [
        "(line 878,col 9)-(line 878,col 45)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.when(T)",
      "begin_line": 940,
      "end_line": 942,
      "comment": "\r\n     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \r\n     * \u003cp\u003e\r\n     * Simply put: \"\u003cb\u003eWhen\u003c/b\u003e the x method is called \u003cb\u003ethen\u003c/b\u003e return y\".\r\n     * \u003cp\u003e\r\n     * \u003cb\u003ewhen() is a successor of deprecated {@link Mockito#stub(Object)}\u003c/b\u003e\r\n     * \u003cp\u003e\r\n     * Examples:\r\n     * \r\n     * \u003cpre\u003e\r\n     * \u003cb\u003ewhen\u003c/b\u003e(mock.someMethod()).\u003cb\u003ethenReturn\u003c/b\u003e(10);\r\n     *\r\n     * //you can use flexible argument matchers, e.g:\r\n     * when(mock.someMethod(\u003cb\u003eanyString()\u003c/b\u003e)).thenReturn(10);\r\n     *\r\n     * //setting exception to be thrown:\r\n     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\r\n     *\r\n     * //you can set different behavior for consecutive method calls.\r\n     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\r\n     * when(mock.someMethod(\"some arg\"))\r\n     *  .thenThrow(new RuntimeException())\r\n     *  .thenReturn(\"foo\");\r\n     *  \r\n     * //Alternative, shorter version for consecutive stubbing:\r\n     * when(mock.someMethod(\"some arg\"))\r\n     *  .thenReturn(\"one\", \"two\");\r\n     * //is the same as:\r\n     * when(mock.someMethod(\"some arg\"))\r\n     *  .thenReturn(\"one\")\r\n     *  .thenReturn(\"two\");\r\n     *\r\n     * //shorter version for consecutive method calls throwing exceptions:\r\n     * when(mock.someMethod(\"some arg\"))\r\n     *  .thenThrow(new RuntimeException(), new NullPointerException();\r\n     *   \r\n     * \u003c/pre\u003e\r\n     * \r\n     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\r\n     * \u003cp\u003e\r\n     * Stubbing can be overridden: for example common stubbing can go to fixture\r\n     * setup but the test methods can override it.\r\n     * \u003cp\u003e\r\n     * Once stubbed, the method will always return stubbed value regardless\r\n     * of how many times it is called.\r\n     * \u003cp\u003e\r\n     * Last stubbing is more important - when you stubbed the same method with\r\n     * the same arguments many times.\r\n     * \u003cp\u003e\r\n     * Although it is possible to verify a stubbed invocation, usually \u003cb\u003eit\u0027s just redundant\u003c/b\u003e.\r\n     * Let\u0027s say you\u0027ve stubbed foo.bar(). \r\n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\r\n     * If your code doesn\u0027t care what get(0) returns then it should not be stubbed. \r\n     * Not convinced? See \u003ca href\u003d\"http://monkeyisland.pl/2008/04/26/asking-and-telling\"\u003ehere\u003c/a\u003e.\r\n     * \r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * @param methodCall method to be stubbed\r\n     ",
      "child_ranges": [
        "(line 941,col 9)-(line 941,col 45)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.verify(T)",
      "begin_line": 969,
      "end_line": 971,
      "comment": "\r\n     * Verifies certain behavior \u003cb\u003ehappened once\u003c/b\u003e \r\n     * \u003cp\u003e\r\n     * Alias to \u003ccode\u003everify(mock, times(1))\u003c/code\u003e E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * Above is equivalent to:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, times(1)).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003cp\u003e\r\n     * Although it is possible to verify a stubbed invocation, usually \u003cb\u003eit\u0027s just redundant\u003c/b\u003e.\r\n     * Let\u0027s say you\u0027ve stubbed foo.bar(). \r\n     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\r\n     * If your code doesn\u0027t care what get(0) returns then it should not be stubbed. \r\n     * Not convinced? See \u003ca href\u003d\"http://monkeyisland.pl/2008/04/26/asking-and-telling\"\u003ehere\u003c/a\u003e.\r\n     * \r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param mock to be verified\r\n     * @return mock object itself\r\n     ",
      "child_ranges": [
        "(line 970,col 9)-(line 970,col 51)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.reset(T...)",
      "begin_line": 1000,
      "end_line": 1002,
      "comment": "\r\n     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\r\n     * Normally, you don\u0027t need to reset your mocks, just create new mocks for each test method. \r\n     * \u003cp\u003e\r\n     * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\r\n     * \u003cb\u003eFirst potential code smell is reset() in the middle of the test method.\u003c/b\u003e This probably means you\u0027re testing too much.\r\n     * Follow the whisper of your test methods: \"Please keep us small \u0026 focused on single behavior\". \r\n     * There are several threads about it on mockito mailing list.\r\n     * \u003cp\u003e\r\n     * The only reason we added reset() method is to\r\n     * make it possible to work with container-injected mocks.\r\n     * See issue 55 (\u003ca href\u003d\"http://code.google.com/p/mockito/issues/detail?id\u003d55\"\u003ehere\u003c/a\u003e)\r\n     * or FAQ (\u003ca href\u003d\"http://code.google.com/p/mockito/wiki/FAQ\"\u003ehere\u003c/a\u003e).\r\n     * \u003cp\u003e\r\n     * \u003cb\u003eDon\u0027t harm yourself.\u003c/b\u003e reset() in the middle of the test method is a code smell (you\u0027re probably testing too much). \r\n     * \u003cpre\u003e\r\n     *   List mock \u003d mock(List.class);\r\n     *   when(mock.size()).thenReturn(10);\r\n     *   mock.add(1);\r\n     *   \r\n     *   reset(mock);\r\n     *   //at this point the mock forgot any interactions \u0026 stubbing\r\n     * \u003c/pre\u003e\r\n     * \r\n     * @param \u003cT\u003e\r\n     * @param mocks\r\n     ",
      "child_ranges": [
        "(line 1001,col 9)-(line 1001,col 34)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.verify(T, org.mockito.internal.verification.api.VerificationMode)",
      "begin_line": 1024,
      "end_line": 1026,
      "comment": "\r\n     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, times(5)).someMethod(\"was called five times\");\r\n     *   \r\n     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\r\n     *   \r\n     *   //you can use flexible argument matchers, e.g:\r\n     *   verify(mock, atLeastOnce()).someMethod(\u003cb\u003eanyString()\u003c/b\u003e);\r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003cb\u003etimes(1) is the default\u003c/b\u003e and can be omitted\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param mock to be verified\r\n     * @param mode times(x), atLeastOnce() or never()\r\n     * \r\n     * @return mock object itself\r\n     ",
      "child_ranges": [
        "(line 1025,col 9)-(line 1025,col 47)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.verifyNoMoreInteractions(java.lang.Object...)",
      "begin_line": 1069,
      "end_line": 1071,
      "comment": "\r\n     * Checks if any of given mocks has any unverified interaction.\r\n     * \u003cp\u003e\r\n     * You can use this method after you verified your mocks - to make sure that nothing\r\n     * else was invoked on your mocks.\r\n     * \u003cp\u003e\r\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\r\n     * \u003cp\u003e\r\n     * Stubbed invocations (if called) are also treated as interactions.\r\n     * \u003cp\u003e\r\n     * A word of \u003cb\u003ewarning\u003c/b\u003e: \r\n     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \r\n     * verifyNoMoreInteractions() is not recommended to use in every test method. \r\n     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it\u0027s relevant.\r\n     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \r\n     * \u003ca href\u003d\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\"\u003ehere\u003c/a\u003e.\r\n     * \u003cp\u003e\r\n     * This method will also detect unverified invocations that occurred before the test method,\r\n     * for example: in setUp(), \u0026#064;Before method or in constructor.\r\n     * Consider writing nice code that makes interactions only in test methods.\r\n     * \r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \r\n     * \u003cpre\u003e\r\n     * //interactions\r\n     * mock.doSomething();\r\n     * mock.doSomethingUnexpected();\r\n     * \r\n     * //verification\r\n     * verify(mock).doSomething();\r\n     * \r\n     * //following will fail because \u0027doSomethingUnexpected()\u0027 is unexpected\r\n     * verifyNoMoreInteractions(mock);\r\n     * \r\n     * \u003c/pre\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param mocks to be verified\r\n     ",
      "child_ranges": [
        "(line 1070,col 9)-(line 1070,col 53)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.verifyZeroInteractions(java.lang.Object...)",
      "begin_line": 1088,
      "end_line": 1090,
      "comment": "\r\n     * Verifies that no interactions happened on given mocks.\r\n     * \u003cpre\u003e\r\n     *   verifyZeroInteractions(mockOne, mockTwo);\r\n     * \u003c/pre\u003e\r\n     * This method will also detect invocations \r\n     * that occurred before the test method, for example: in setUp(), \u0026#064;Before method or in constructor.\r\n     * Consider writing nice code that makes interactions only in test methods.  \r\n     * \u003cp\u003e\r\n     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param mocks to be verified\r\n     ",
      "child_ranges": [
        "(line 1089,col 9)-(line 1089,col 53)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.stubVoid(T)",
      "begin_line": 1124,
      "end_line": 1126,
      "comment": "\r\n     * \u003cpre\u003e\r\n     *   //Instead of:\r\n     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\r\n     * \r\n     *   //Please do:\r\n     *   doThrow(e).when(mock).someVoidMethod();\r\n     * \u003c/pre\u003e \r\n     * \r\n     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \r\n     * \u003cp\u003e\r\n     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\r\n     * \r\n     * \u003cpre\u003e\r\n     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\r\n     * \r\n     * //you can stub with different behavior for consecutive calls.\r\n     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \r\n     * stubVoid(mock)\r\n     *   .toThrow(new RuntimeException())\r\n     *   .toReturn()\r\n     *   .on().someMethod();\r\n     * \u003c/pre\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\r\n     * \r\n     * @param mock\r\n     *            to stub\r\n     * @return stubbable object that allows stubbing with throwable\r\n     ",
      "child_ranges": [
        "(line 1125,col 9)-(line 1125,col 43)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.doThrow(java.lang.Throwable)",
      "begin_line": 1142,
      "end_line": 1144,
      "comment": "\r\n     * Use doThrow() when you want to stub the void method with an exception.\r\n     * \u003cp\u003e\r\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \r\n     * \u003cpre\u003e\r\n     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\r\n     * \u003c/pre\u003e\r\n     * \r\n     * @param toBeThrown to be thrown when the stubbed method is called\r\n     * @return stubber - to select a method for stubbing\r\n     ",
      "child_ranges": [
        "(line 1143,col 9)-(line 1143,col 70)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.doCallRealMethod()",
      "begin_line": 1176,
      "end_line": 1178,
      "comment": "\r\n     * Use doCallRealMethod() when you want to call the real implementation of a method.\r\n     * \u003cp\u003e\r\n     * As usual you are going to read \u003cb\u003ethe partial mock warning\u003c/b\u003e:\r\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n     * How does partial mock fit into this paradigm? Well, it just doesn\u0027t... \r\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n     * In most cases, this is not the way you want to design your application.\r\n     * \u003cp\u003e\r\n     * However, there are rare cases when partial mocks come handy: \r\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n     * However, I wouldn\u0027t use partial mocks for new, test-driven \u0026 well-designed code.\r\n     * \u003cp\u003e\r\n     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \r\n     * \u003cb\u003eMockito.spy() is a recommended way of creating partial mocks.\u003c/b\u003e \r\n     * The reason is it guarantees real methods are called against correctly constructed object because you\u0027re responsible for constructing the object passed to spy() method.\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \u003cpre\u003e\r\n     *   Foo mock \u003d mock(Foo.class);\r\n     *   doCallRealMethod().when(mock).someVoidMethod();\r\n     *\r\n     *   // this will call the real implementation of Foo.someVoidMethod()\r\n     *   mock.someVoidMethod();\r\n     * \u003c/pre\u003e\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     *\r\n     * @return stubber - to select a method for stubbing\r\n     ",
      "child_ranges": [
        "(line 1177,col 9)-(line 1177,col 61)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.doAnswer(org.mockito.stubbing.Answer)",
      "begin_line": 1202,
      "end_line": 1204,
      "comment": "\r\n     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\r\n     * \u003cp\u003e\r\n     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\r\n     * \u003cp\u003e\r\n     * Example:\r\n     * \r\n     * \u003cpre\u003e\r\n     *  doAnswer(new Answer() {\r\n     *      public Object answer(InvocationOnMock invocation) {\r\n     *          Object[] args \u003d invocation.getArguments();\r\n     *          Mock mock \u003d invocation.getMock();\r\n     *          return null;\r\n     *      }})\r\n     *  .when(mock).someMethod();\r\n     * \u003c/pre\u003e\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param answer to answer when the stubbed method is called\r\n     * @return stubber - to select a method for stubbing\r\n     ",
      "child_ranges": [
        "(line 1203,col 9)-(line 1203,col 45)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.doNothing()",
      "begin_line": 1241,
      "end_line": 1243,
      "comment": "\r\n     * Use doNothing() for setting void methods to do nothing. \u003cb\u003eBeware that void methods on mocks do nothing by default!\u003c/b\u003e \r\n     * However, there are rare situations when doNothing() comes handy:  \r\n     * \u003cp\u003e\r\n     * 1. Stubbing consecutive calls on a void method:\r\n     * \u003cpre\u003e\r\n     *   doNothing().\r\n     *   doThrow(new RuntimeException())\r\n     *   .when(mock).someVoidMethod();\r\n     *   \r\n     *   //does nothing the first time:\r\n     *   mock.someVoidMethod();\r\n     *   \r\n     *   //throws RuntimeException the next time:\r\n     *   mock.someVoidMethod();\r\n     * \u003c/pre\u003e\r\n     * \r\n     * 2. When you spy real objects and you want the void method to do nothing:\r\n     * \u003cpre\u003e\r\n     *   List list \u003d new LinkedList();\r\n     *   List spy \u003d spy(list);\r\n     *   \r\n     *   //let\u0027s make clear() do nothing\r\n     *   doNothing().when(spy).clear();\r\n     *   \r\n     *   spy.add(\"one\");\r\n     *   \r\n     *   //clear() does nothing, so the list still contains \"one\"\r\n     *   spy.clear();\r\n     * \u003c/pre\u003e\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     *   \r\n     * @return stubber - to select a method for stubbing\r\n     ",
      "child_ranges": [
        "(line 1242,col 9)-(line 1242,col 56)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.doReturn(java.lang.Object)",
      "begin_line": 1287,
      "end_line": 1289,
      "comment": "\r\n     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\r\n     * \u003cp\u003e\r\n     * \u003cb\u003eBeware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \r\n     * and more readable\u003c/b\u003e (especially when stubbing consecutive calls). \r\n     * \u003cp\u003e\r\n     * Here are those rare occasions when doReturn() comes handy:\r\n     * \u003cp\u003e\r\n     * \r\n     * 1. When spying real objects and calling real methods on a spy brings side effects  \r\n     * \r\n     * \u003cpre\u003e\r\n     *   List list \u003d new LinkedList();\r\n     *   List spy \u003d spy(list);\r\n     *   \r\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\r\n     *   when(spy.get(0)).thenReturn(\"foo\");\r\n     *   \r\n     *   //You have to use doReturn() for stubbing:\r\n     *   doReturn(\"foo\").when(spy).get(0);\r\n     * \u003c/pre\u003e\r\n     * \r\n     * 2. Overriding a previous exception-stubbing:\r\n     * \r\n     * \u003cpre\u003e\r\n     *   when(mock.foo()).thenThrow(new RuntimeException());\r\n     *   \r\n     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown. \r\n     *   when(mock.foo()).thenReturn(\"bar\");\r\n     *   \r\n     *   //You have to use doReturn() for stubbing:\r\n     *   doReturn(\"bar\").when(mock).foo();\r\n     * \u003c/pre\u003e\r\n     * \r\n     * Above scenarios shows a tradeoff of Mockito\u0027s ellegant syntax. Note that the scenarios are very rare, though. \r\n     * Spying should be sporadic and overriding exception-stubbing is very rare.  \r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param toBeReturned to be returned when the stubbed method is called\r\n     * @return stubber - to select a method for stubbing\r\n     ",
      "child_ranges": [
        "(line 1288,col 9)-(line 1288,col 64)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.inOrder(java.lang.Object...)",
      "begin_line": 1312,
      "end_line": 1314,
      "comment": "\r\n     * Creates InOrder object that allows verifying mocks in order.\r\n     * \r\n     * \u003cpre\u003e\r\n     *   InOrder inOrder \u003d inOrder(firstMock, secondMock);\r\n     *   \r\n     *   inOrder.verify(firstMock).add(\"was called first\");\r\n     *   inOrder.verify(secondMock).add(\"was called second\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * Verification in order is flexible - \u003cb\u003eyou don\u0027t have to verify all interactions\u003c/b\u003e one-by-one\r\n     * but only those that you are interested in testing in order.\r\n     * \u003cp\u003e\r\n     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param mocks to be verified in order\r\n     * \r\n     * @return InOrder object to be used to verify in order\r\n     ",
      "child_ranges": [
        "(line 1313,col 9)-(line 1313,col 43)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.times(int)",
      "begin_line": 1328,
      "end_line": 1330,
      "comment": "\r\n     * Allows verifying exact number of invocations. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, times(2)).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param wantedNumberOfInvocations wanted number of invocations \r\n     * \r\n     * @return verification mode\r\n     ",
      "child_ranges": [
        "(line 1329,col 9)-(line 1329,col 72)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.never()",
      "begin_line": 1349,
      "end_line": 1351,
      "comment": "\r\n     * Alias to times(0), see {@link Mockito#times(int)}\r\n     * \u003cp\u003e\r\n     * Verifies that interaction did not happen. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, never()).someMethod();\r\n     * \u003c/pre\u003e\r\n     * \r\n     * \u003cp\u003e\r\n     * If you want to verify there were NO interactions with the mock \r\n     * check out {@link Mockito#verifyZeroInteractions(Object...)}\r\n     * or {@link Mockito#verifyNoMoreInteractions(Object...)}\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @return verification mode\r\n     ",
      "child_ranges": [
        "(line 1350,col 9)-(line 1350,col 24)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.atLeastOnce()",
      "begin_line": 1364,
      "end_line": 1366,
      "comment": "\r\n     * Allows at-least-once verification. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * Alias to atLeast(1)\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @return verification mode\r\n     ",
      "child_ranges": [
        "(line 1365,col 9)-(line 1365,col 53)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.atLeast(int)",
      "begin_line": 1380,
      "end_line": 1382,
      "comment": "\r\n     * Allows at-least-x verification. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param minNumberOfInvocations minimum number of invocations \r\n     * \r\n     * @return verification mode\r\n     ",
      "child_ranges": [
        "(line 1381,col 9)-(line 1381,col 71)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.atMost(int)",
      "begin_line": 1396,
      "end_line": 1398,
      "comment": "\r\n     * Allows at-most-x verification. E.g:\r\n     * \u003cpre\u003e\r\n     *   verify(mock, atMost(3)).someMethod(\"some arg\");\r\n     * \u003c/pre\u003e\r\n     * \r\n     * See examples in javadoc for {@link Mockito} class\r\n     * \r\n     * @param maxNumberOfInvocations max number of invocations \r\n     * \r\n     * @return verification mode\r\n     ",
      "child_ranges": [
        "(line 1397,col 9)-(line 1397,col 70)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.validateMockitoUsage()",
      "begin_line": 1445,
      "end_line": 1447,
      "comment": "\r\n     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \u003ca href\u003d\"http://code.google.com/p/mockito/wiki/FAQ\"\u003ehttp://code.google.com/p/mockito/wiki/FAQ\u003c/a\u003e\r\n     * \u003cp\u003e\r\n     * In case of questions you may also post to mockito mailing list: \u003ca href\u003d\"http://groups.google.com/group/mockito\"\u003ehttp://groups.google.com/group/mockito\u003c/a\u003e \r\n     * \u003cp\u003e\r\n     * {@link Mockito#validateMockitoUsage()} \u003cb\u003eexplicitly validates\u003c/b\u003e the framework state to detect invalid use of Mockito.\r\n     * However, this feature is optional \u003cb\u003ebecause Mockito validates the usage all the time...\u003c/b\u003e but there is a gotcha so read on.\r\n     * \u003cp\u003e\r\n     * Examples of incorrect use:\r\n     * \u003cpre\u003e\r\n     * //Oups, someone forgot thenReturn() part:\r\n     * when(mock.get());\r\n     * \r\n     * //Oups, someone put the verified method call inside verify() where it should be outside:\r\n     * verify(mock.execute());\r\n     * \r\n     * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\r\n     * verify(mock);\r\n     * \u003c/pre\u003e\r\n     * \r\n     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. \r\n     * The gotcha is that Mockito does the validation \u003cb\u003enext time\u003c/b\u003e you use the framework (e.g. next time you verify, stub, call mock etc.). \r\n     * But even though the exception might be thrown in the next test, \r\n     * the exception \u003cb\u003emessage contains a navigable stack trace element\u003c/b\u003e with location of the defect. \r\n     * Hence you can click and find the place where Mockito was misused.\r\n     * \u003cp\u003e\r\n     * Sometimes though, you might want to validate the framework usage explicitly. \r\n     * For example, one of the users wanted to put {@link Mockito#validateMockitoUsage()} in his \u0026#064;After method\r\n     * so that he knows immediately when he misused Mockito. \r\n     * Without it, he would have known about it not sooner than \u003cb\u003enext time\u003c/b\u003e he used the framework.\r\n     * One more benefit of having validateMockitoUsage() in \u0026#064;After is that jUnit runner will always fail in the test method with defect\r\n     * whereas ordinary \u0027next-time\u0027 validation might fail the \u003cb\u003enext\u003c/b\u003e test method. \r\n     * But even though JUnit might report next test as red, don\u0027t worry about it \r\n     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.   \r\n     * \u003cp\u003e\r\n     * \u003cb\u003eBuilt-in runner: {@link MockitoJUnitRunner}\u003c/b\u003e does validateMockitoUsage() after each test method.\r\n     * \u003cp\u003e\r\n     * Bear in mind that \u003cb\u003eusually you don\u0027t have to validateMockitoUsage()\u003c/b\u003e \r\n     * and framework validation triggered on next-time basis should be just enough,\r\n     * mainly because of enhanced exception message with clickable location of defect.\r\n     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure\r\n     * (like your own runner or base class for all tests) because adding a special action to \u0026#064;After has zero cost.\r\n     * \u003cp\u003e\r\n     * See examples in javadoc for {@link Mockito} class\r\n     ",
      "child_ranges": [
        "(line 1446,col 9)-(line 1446,col 44)"
      ]
    },
    {
      "type": "method",
      "signature": "org.mockito.Mockito.withSettings()",
      "begin_line": 1479,
      "end_line": 1481,
      "comment": "\r\n     * Allows mock creation with additional mock settings. \r\n     * \u003cp\u003e\r\n     * Don\u0027t use it too often. \r\n     * Consider writing simple tests that use simple mocks. \r\n     * Repeat after me: simple tests push simple, KISSy, readable \u0026 maintainable code.\r\n     * If you cannot write a test in a simple way - refactor the code under test.\r\n     * \u003cp\u003e\r\n     * Examples of mock settings:\r\n     * \u003cpre\u003e\r\n     *   //Creates mock with different default answer \u0026 name\r\n     *   Foo mock \u003d mock(Foo.class, withSettings()\r\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\r\n     *       .name(\"cool mockie\"));\r\n     *       \r\n     *   //Creates mock with different default answer, descriptive name and extra interfaces\r\n     *   Foo mock \u003d mock(Foo.class, withSettings()\r\n     *       .defaultAnswer(RETURNS_SMART_NULLS)\r\n     *       .name(\"cool mockie\")\r\n     *       .extraInterfaces(Bar.class));    \r\n     * \u003c/pre\u003e\r\n     * {@link MockSettings} has been introduced for two reasons. \r\n     * Firstly, to make it easy to add another mock settings when the demand comes.\r\n     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\r\n     * \u003cp\u003e\r\n     * See javadoc for {@link MockSettings} to learn about possible mock settings.\r\n     * \u003cp\u003e\r\n     * \r\n     * @return mock settings instance with defaults.\r\n     ",
      "child_ranges": [
        "(line 1480,col 9)-(line 1480,col 70)"
      ]
    }
  ]
}