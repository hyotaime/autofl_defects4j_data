[
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Gson()",
        "snippet": "  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }",
        "begin_line": 170,
        "end_line": 176,
        "comment": "\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Gson(com.google.gson.internal.Excluder, com.google.gson.FieldNamingStrategy, java.util.Map<java.lang.reflect.Type, com.google.gson.InstanceCreator<?>>, boolean, boolean, boolean, boolean, boolean, boolean, boolean, com.google.gson.LongSerializationPolicy, java.util.List<com.google.gson.TypeAdapterFactory>)",
        "snippet": "  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n      LongSerializationPolicy longSerializationPolicy,\n      List<TypeAdapterFactory> typeAdapterFactories) {\n    this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n    this.serializeNulls = serializeNulls;\n    this.generateNonExecutableJson = generateNonExecutableGson;\n    this.htmlSafe = htmlSafe;\n    this.prettyPrinting = prettyPrinting;\n    this.lenient = lenient;\n\n    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n    // built-in type adapters that cannot be overridden\n    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n    factories.add(ObjectTypeAdapter.FACTORY);\n\n    // the excluder must precede all adapters that handle user-defined types\n    factories.add(excluder);\n\n    // user's type adapters\n    factories.addAll(typeAdapterFactories);\n\n    // type adapters for basic platform types\n    factories.add(TypeAdapters.STRING_FACTORY);\n    factories.add(TypeAdapters.INTEGER_FACTORY);\n    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.BYTE_FACTORY);\n    factories.add(TypeAdapters.SHORT_FACTORY);\n    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\n    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n    factories.add(TypeAdapters.newFactory(double.class, Double.class,\n            doubleAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.newFactory(float.class, Float.class,\n            floatAdapter(serializeSpecialFloatingPointValues)));\n    factories.add(TypeAdapters.NUMBER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n    factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\n    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n    factories.add(TypeAdapters.CHARACTER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n    factories.add(TypeAdapters.URL_FACTORY);\n    factories.add(TypeAdapters.URI_FACTORY);\n    factories.add(TypeAdapters.UUID_FACTORY);\n    factories.add(TypeAdapters.CURRENCY_FACTORY);\n    factories.add(TypeAdapters.LOCALE_FACTORY);\n    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n    factories.add(TypeAdapters.BIT_SET_FACTORY);\n    factories.add(DateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CALENDAR_FACTORY);\n    factories.add(TimeTypeAdapter.FACTORY);\n    factories.add(SqlDateTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n    factories.add(ArrayTypeAdapter.FACTORY);\n    factories.add(TypeAdapters.CLASS_FACTORY);\n\n    // type adapters for composite and user-defined types\n    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n    factories.add(TypeAdapters.ENUM_FACTORY);\n    factories.add(new ReflectiveTypeAdapterFactory(\n        constructorConstructor, fieldNamingPolicy, excluder));\n\n    this.factories = Collections.unmodifiableList(factories);\n  }",
        "begin_line": 178,
        "end_line": 250,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.doubleAdapter(boolean)",
        "snippet": "  private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n    if (serializeSpecialFloatingPointValues) {\n      return TypeAdapters.DOUBLE;\n    }\n    return new TypeAdapter<Number>() {\n      @Override public Double read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextDouble();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        double doubleValue = value.doubleValue();\n        checkValidFloatingPoint(doubleValue);\n        out.value(value);\n      }\n    };\n  }",
        "begin_line": 252,
        "end_line": 274,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-a3e07dc8-c168-44b4-8b06-c421b9cc7a60.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public Double read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextDouble();\n      }",
        "begin_line": 257,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-04dc5623-974a-4d2c-9497-54ae75c5eef4.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        double doubleValue = value.doubleValue();\n        checkValidFloatingPoint(doubleValue);\n        out.value(value);\n      }",
        "begin_line": 264,
        "end_line": 272,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.floatAdapter(boolean)",
        "snippet": "  private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\n    if (serializeSpecialFloatingPointValues) {\n      return TypeAdapters.FLOAT;\n    }\n    return new TypeAdapter<Number>() {\n      @Override public Float read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return (float) in.nextDouble();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        float floatValue = value.floatValue();\n        checkValidFloatingPoint(floatValue);\n        out.value(value);\n      }\n    };\n  }",
        "begin_line": 276,
        "end_line": 298,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-19f42ae3-91d4-4ded-8a82-5d27395bd4a0.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public Float read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return (float) in.nextDouble();\n      }",
        "begin_line": 281,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-b5d83fcf-de24-4415-a846-cfda669ad361.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        float floatValue = value.floatValue();\n        checkValidFloatingPoint(floatValue);\n        out.value(value);\n      }",
        "begin_line": 288,
        "end_line": 296,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.checkValidFloatingPoint(double)",
        "snippet": "  static void checkValidFloatingPoint(double value) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(value\n          + \" is not a valid double value as per JSON specification. To override this\"\n          + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n    }\n  }",
        "begin_line": 300,
        "end_line": 306,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.longAdapter(com.google.gson.LongSerializationPolicy)",
        "snippet": "  private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\n    if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\n      return TypeAdapters.LONG;\n    }\n    return new TypeAdapter<Number>() {\n      @Override public Number read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextLong();\n      }\n      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        out.value(value.toString());\n      }\n    };\n  }",
        "begin_line": 308,
        "end_line": 328,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-4dc3b3c3-a8b6-401b-9ed2-10ed236de98a.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public Number read(JsonReader in) throws IOException {\n        if (in.peek() == JsonToken.NULL) {\n          in.nextNull();\n          return null;\n        }\n        return in.nextLong();\n      }",
        "begin_line": 313,
        "end_line": 319,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-9019bfbb-a687-4c2a-929d-79f28f77c885.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "      @Override public void write(JsonWriter out, Number value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n          return;\n        }\n        out.value(value.toString());\n      }",
        "begin_line": 320,
        "end_line": 326,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.atomicLongAdapter(com.google.gson.TypeAdapter<java.lang.Number>)",
        "snippet": "  private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\n    return new TypeAdapter<AtomicLong>() {\n      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {\n        longAdapter.write(out, value.get());\n      }\n      @Override public AtomicLong read(JsonReader in) throws IOException {\n        Number value = longAdapter.read(in);\n        return new AtomicLong(value.longValue());\n      }\n    }.nullSafe();\n  }",
        "begin_line": 330,
        "end_line": 340,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-1746bf47-d263-4eb9-94da-29f02475aaf9.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLong)",
        "snippet": "      @Override public void write(JsonWriter out, AtomicLong value) throws IOException {\n        longAdapter.write(out, value.get());\n      }",
        "begin_line": 332,
        "end_line": 334,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-b03750b7-ff42-499b-a2b3-1c2f25e54c62.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public AtomicLong read(JsonReader in) throws IOException {\n        Number value = longAdapter.read(in);\n        return new AtomicLong(value.longValue());\n      }",
        "begin_line": 335,
        "end_line": 338,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.atomicLongArrayAdapter(com.google.gson.TypeAdapter<java.lang.Number>)",
        "snippet": "  private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\n    return new TypeAdapter<AtomicLongArray>() {\n      @Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n        out.beginArray();\n        for (int i = 0, length = value.length(); i < length; i++) {\n          longAdapter.write(out, value.get(i));\n        }\n        out.endArray();\n      }\n      @Override public AtomicLongArray read(JsonReader in) throws IOException {\n        List<Long> list = new ArrayList<Long>();\n        in.beginArray();\n        while (in.hasNext()) {\n            long value = longAdapter.read(in).longValue();\n            list.add(value);\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicLongArray array = new AtomicLongArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n      }\n    }.nullSafe();\n  }",
        "begin_line": 342,
        "end_line": 367,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-bb18abc5-cd40-4422-b286-fbfa406211b5.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLongArray)",
        "snippet": "      @Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n        out.beginArray();\n        for (int i = 0, length = value.length(); i < length; i++) {\n          longAdapter.write(out, value.get(i));\n        }\n        out.endArray();\n      }",
        "begin_line": 344,
        "end_line": 350,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.Anonymous-895d2831-258a-4873-b51d-dce067bcfa99.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public AtomicLongArray read(JsonReader in) throws IOException {\n        List<Long> list = new ArrayList<Long>();\n        in.beginArray();\n        while (in.hasNext()) {\n            long value = longAdapter.read(in).longValue();\n            list.add(value);\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicLongArray array = new AtomicLongArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n      }",
        "begin_line": 351,
        "end_line": 365,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.getAdapter(com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\n    if (cached != null) {\n      return (TypeAdapter<T>) cached;\n    }\n\n    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n    boolean requiresThreadLocalCleanup = false;\n    if (threadCalls == null) {\n      threadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n      calls.set(threadCalls);\n      requiresThreadLocalCleanup = true;\n    }\n\n    // the key and value type parameters always agree\n    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n    if (ongoingCall != null) {\n      return ongoingCall;\n    }\n\n    try {\n      FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n      threadCalls.put(type, call);\n\n      for (TypeAdapterFactory factory : factories) {\n        TypeAdapter<T> candidate = factory.create(this, type);\n        if (candidate != null) {\n          call.setDelegate(candidate);\n          typeTokenCache.put(type, candidate);\n          return candidate;\n        }\n      }\n      throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n    } finally {\n      threadCalls.remove(type);\n\n      if (requiresThreadLocalCleanup) {\n        calls.remove();\n      }\n    }\n  }",
        "begin_line": 375,
        "end_line": 416,
        "comment": "\n   * Returns the type adapter for {@code} type.\n   *\n   * @throws IllegalArgumentException if this GSON cannot serialize and\n   *     deserialize {@code type}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.getDelegateAdapter(com.google.gson.TypeAdapterFactory, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n    boolean skipPastFound = false;\n    // Skip past if and only if the specified factory is present in the factories.\n    // This is useful because the factories created through JsonAdapter annotations are not\n    // registered in this list.\n    if (!factories.contains(skipPast)) skipPastFound = true;\n\n    for (TypeAdapterFactory factory : factories) {\n      if (!skipPastFound) {\n        if (factory == skipPast) {\n          skipPastFound = true;\n        }\n        continue;\n      }\n\n      TypeAdapter<T> candidate = factory.create(this, type);\n      if (candidate != null) {\n        return candidate;\n      }\n    }\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n  }",
        "begin_line": 468,
        "end_line": 489,
        "comment": "\n   * This method is used to get an alternate type adapter for the specified type. This is used\n   * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\n   * may have registered. This features is typically used when you want to register a type\n   * adapter that does a little bit of work but then delegates further processing to the Gson\n   * default type adapter. Here is an example:\n   * <p>Let's say we want to write a type adapter that counts the number of objects being read\n   *  from or written to JSON. We can achieve this by writing a type adapter factory that uses\n   *  the <code>getDelegateAdapter</code> method:\n   *  <pre> {@code\n   *  class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   *    public int numReads = 0;\n   *    public int numWrites = 0;\n   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n   *      return new TypeAdapter<T>() {\n   *        public void write(JsonWriter out, T value) throws IOException {\n   *          ++numWrites;\n   *          delegate.write(out, value);\n   *        }\n   *        public T read(JsonReader in) throws IOException {\n   *          ++numReads;\n   *          return delegate.read(in);\n   *        }\n   *      };\n   *    }\n   *  }\n   *  } </pre>\n   *  This factory can now be used like this:\n   *  <pre> {@code\n   *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();\n   *  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();\n   *  // Call gson.toJson() and fromJson methods on objects\n   *  System.out.println(\"Num JSON reads\" + stats.numReads);\n   *  System.out.println(\"Num JSON writes\" + stats.numWrites);\n   *  }</pre>\n   *  Note that this call will skip all factories registered before {@code skipPast}. In case of\n   *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n   *  that the order of registration does not prevent this method from reaching a factory they\n   *  would expect to reply from this call.\n   *  Note that since you can not override type adapter factories for String and Java primitive\n   *  types, our stats factory will not count the number of String or primitives that will be\n   *  read or written.\n   * @param skipPast The type adapter factory that needs to be skipped while searching for\n   *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter\n   *   factory from where {@link #getDelegateAdapter} method is being invoked).\n   * @param type Type for which the delegate adapter is being searched for.\n   *\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.getAdapter(java.lang.Class<T>)",
        "snippet": "  public <T> TypeAdapter<T> getAdapter(Class<T> type) {\n    return getAdapter(TypeToken.get(type));\n  }",
        "begin_line": 497,
        "end_line": 499,
        "comment": "\n   * Returns the type adapter for {@code} type.\n   *\n   * @throws IllegalArgumentException if this GSON cannot serialize and\n   *     deserialize {@code type}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object)",
        "snippet": "  public JsonElement toJsonTree(Object src) {\n    if (src == null) {\n      return JsonNull.INSTANCE;\n    }\n    return toJsonTree(src, src.getClass());\n  }",
        "begin_line": 514,
        "end_line": 519,
        "comment": "\n   * This method serializes the specified object into its equivalent representation as a tree of\n   * {@link JsonElement}s. This method should be used when the specified object is not a generic\n   * type. This method uses {@link Class#getClass()} to get the type for the specified object, but\n   * the {@code getClass()} loses the generic type information because of the Type Erasure feature\n   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n   * just the object itself should not be of a generic type. If the object is of generic type, use\n   * {@link #toJsonTree(Object, Type)} instead.\n   *\n   * @param src the object for which Json representation is to be created setting for Gson\n   * @return Json representation of {@code src}.\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object, java.lang.reflect.Type)",
        "snippet": "  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    JsonTreeWriter writer = new JsonTreeWriter();\n    toJson(src, typeOfSrc, writer);\n    return writer.get();\n  }",
        "begin_line": 537,
        "end_line": 541,
        "comment": "\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\n   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\n   * instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(java.lang.Object)",
        "snippet": "  public String toJson(Object src) {\n    if (src == null) {\n      return toJson(JsonNull.INSTANCE);\n    }\n    return toJson(src, src.getClass());\n  }",
        "begin_line": 556,
        "end_line": 561,
        "comment": "\n   * This method serializes the specified object into its equivalent Json representation.\n   * This method should be used when the specified object is not a generic type. This method uses\n   * {@link Class#getClass()} to get the type for the specified object, but the\n   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n   * just the object itself should not be of a generic type. If the object is of generic type, use\n   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a\n   * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which Json representation is to be created setting for Gson\n   * @return Json representation of {@code src}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type)",
        "snippet": "  public String toJson(Object src, Type typeOfSrc) {\n    StringWriter writer = new StringWriter();\n    toJson(src, typeOfSrc, writer);\n    return writer.toString();\n  }",
        "begin_line": 578,
        "end_line": 582,
        "comment": "\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out\n   * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.Appendable)",
        "snippet": "  public void toJson(Object src, Appendable writer) throws JsonIOException {\n    if (src != null) {\n      toJson(src, src.getClass(), writer);\n    } else {\n      toJson(JsonNull.INSTANCE, writer);\n    }\n  }",
        "begin_line": 598,
        "end_line": 604,
        "comment": "\n   * This method serializes the specified object into its equivalent Json representation.\n   * This method should be used when the specified object is not a generic type. This method uses\n   * {@link Class#getClass()} to get the type for the specified object, but the\n   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n   * just the object itself should not be of a generic type. If the object is of generic type, use\n   * {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which Json representation is to be created setting for Gson\n   * @param writer Writer to which the Json representation needs to be written\n   * @throws JsonIOException if there was a problem writing to the writer\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, java.lang.Appendable)",
        "snippet": "  public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\n    try {\n      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n      toJson(src, typeOfSrc, jsonWriter);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
        "begin_line": 622,
        "end_line": 629,
        "comment": "\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @throws JsonIOException if there was a problem writing to the writer\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, com.google.gson.stream.JsonWriter)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\n    TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));\n    boolean oldLenient = writer.isLenient();\n    writer.setLenient(true);\n    boolean oldHtmlSafe = writer.isHtmlSafe();\n    writer.setHtmlSafe(htmlSafe);\n    boolean oldSerializeNulls = writer.getSerializeNulls();\n    writer.setSerializeNulls(serializeNulls);\n    try {\n      ((TypeAdapter<Object>) adapter).write(writer, src);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } finally {\n      writer.setLenient(oldLenient);\n      writer.setHtmlSafe(oldHtmlSafe);\n      writer.setSerializeNulls(oldSerializeNulls);\n    }\n  }",
        "begin_line": 636,
        "end_line": 654,
        "comment": "\n   * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to\n   * {@code writer}.\n   * @throws JsonIOException if there was a problem writing to the writer\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement)",
        "snippet": "  public String toJson(JsonElement jsonElement) {\n    StringWriter writer = new StringWriter();\n    toJson(jsonElement, writer);\n    return writer.toString();\n  }",
        "begin_line": 663,
        "end_line": 667,
        "comment": "\n   * Converts a tree of {@link JsonElement}s into its equivalent JSON representation.\n   *\n   * @param jsonElement root of a tree of {@link JsonElement}s\n   * @return JSON String representation of the tree\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, java.lang.Appendable)",
        "snippet": "  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n    try {\n      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n      toJson(jsonElement, jsonWriter);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
        "begin_line": 677,
        "end_line": 684,
        "comment": "\n   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\n   *\n   * @param jsonElement root of a tree of {@link JsonElement}s\n   * @param writer Writer to which the Json representation needs to be written\n   * @throws JsonIOException if there was a problem writing to the writer\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.newJsonWriter(java.io.Writer)",
        "snippet": "  public JsonWriter newJsonWriter(Writer writer) throws IOException {\n    if (generateNonExecutableJson) {\n      writer.write(JSON_NON_EXECUTABLE_PREFIX);\n    }\n    JsonWriter jsonWriter = new JsonWriter(writer);\n    if (prettyPrinting) {\n      jsonWriter.setIndent(\"  \");\n    }\n    jsonWriter.setSerializeNulls(serializeNulls);\n    return jsonWriter;\n  }",
        "begin_line": 689,
        "end_line": 699,
        "comment": "\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.newJsonReader(java.io.Reader)",
        "snippet": "  public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader = new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }",
        "begin_line": 704,
        "end_line": 708,
        "comment": "\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
        "snippet": "  public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {\n    boolean oldLenient = writer.isLenient();\n    writer.setLenient(true);\n    boolean oldHtmlSafe = writer.isHtmlSafe();\n    writer.setHtmlSafe(htmlSafe);\n    boolean oldSerializeNulls = writer.getSerializeNulls();\n    writer.setSerializeNulls(serializeNulls);\n    try {\n      Streams.write(jsonElement, writer);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } finally {\n      writer.setLenient(oldLenient);\n      writer.setHtmlSafe(oldHtmlSafe);\n      writer.setSerializeNulls(oldSerializeNulls);\n    }\n  }",
        "begin_line": 714,
        "end_line": 730,
        "comment": "\n   * Writes the JSON for {@code jsonElement} to {@code writer}.\n   * @throws JsonIOException if there was a problem writing to the writer\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.Class<T>)",
        "snippet": "  public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
        "begin_line": 749,
        "end_line": 752,
        "comment": "\n   * This method deserializes the specified Json into an object of the specified class. It is not\n   * suitable to use if the specified class is a generic type since it will not have the generic\n   * type information because of the Type Erasure feature of Java. Therefore, this method should not\n   * be used if the desired type is a generic type. Note that this method works fine if the any of\n   * the fields of the specified object are generics, just the object itself should not be a\n   * generic type. For the cases when the object is of generic type, invoke\n   * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * classOfT\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.reflect.Type)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    T target = (T) fromJson(reader, typeOfT);\n    return target;\n  }",
        "begin_line": 772,
        "end_line": 780,
        "comment": "\n   * This method deserializes the specified Json into an object of the specified type. This method\n   * is useful if the specified object is a generic type. For non-generic objects, use\n   * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.Class<T>)",
        "snippet": "  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = newJsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
        "begin_line": 800,
        "end_line": 805,
        "comment": "\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified class. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a\n   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing the Json from which the object is to be deserialized.\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.reflect.Type)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }",
        "begin_line": 826,
        "end_line": 832,
        "comment": "\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.assertFullConsumption(java.lang.Object, com.google.gson.stream.JsonReader)",
        "snippet": "  private static void assertFullConsumption(Object obj, JsonReader reader) {\n    try {\n      if (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n        throw new JsonIOException(\"JSON document was not fully consumed.\");\n      }\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
        "begin_line": 834,
        "end_line": 844,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(com.google.gson.stream.JsonReader, java.lang.reflect.Type)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }",
        "begin_line": 854,
        "end_line": 883,
        "comment": "\n   * Reads the next JSON value from {@code reader} and convert it to an object\n   * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\n   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n   *\n   * @throws JsonIOException if there was a problem writing to the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.Class<T>)",
        "snippet": "  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }",
        "begin_line": 901,
        "end_line": 904,
        "comment": "\n   * This method deserializes the Json read from the specified parse tree into an object of the\n   * specified type. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(JsonElement, Type)}.\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param classOfT The class of T\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.reflect.Type)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return (T) fromJson(new JsonTreeReader(json), typeOfT);\n  }",
        "begin_line": 924,
        "end_line": 930,
        "comment": "\n   * This method deserializes the Json read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.FutureTypeAdapter.setDelegate(com.google.gson.TypeAdapter<T>)",
        "snippet": "    public void setDelegate(TypeAdapter<T> typeAdapter) {\n      if (delegate != null) {\n        throw new AssertionError();\n      }\n      delegate = typeAdapter;\n    }",
        "begin_line": 935,
        "end_line": 940,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.FutureTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public T read(JsonReader in) throws IOException {\n      if (delegate == null) {\n        throw new IllegalStateException();\n      }\n      return delegate.read(in);\n    }",
        "begin_line": 942,
        "end_line": 947,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.FutureTypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (delegate == null) {\n        throw new IllegalStateException();\n      }\n      delegate.write(out, value);\n    }",
        "begin_line": 949,
        "end_line": 954,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/Gson.java",
        "class_name": "com.google.gson.Gson",
        "signature": "com.google.gson.Gson.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return new StringBuilder(\"{serializeNulls:\")\n        .append(serializeNulls)\n        .append(\"factories:\").append(factories)\n        .append(\",instanceCreators:\").append(constructorConstructor)\n        .append(\"}\")\n        .toString();\n  }",
        "begin_line": 957,
        "end_line": 965,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSerializationContext.java",
        "class_name": "com.google.gson.JsonSerializationContext",
        "signature": "com.google.gson.JsonSerializationContext.serialize(java.lang.Object)",
        "snippet": "  public JsonElement serialize(Object src);",
        "begin_line": 36,
        "end_line": 36,
        "comment": "\n   * Invokes default serialization on the specified object.\n   *\n   * @param src the object that needs to be serialized.\n   * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSerializationContext.java",
        "class_name": "com.google.gson.JsonSerializationContext",
        "signature": "com.google.gson.JsonSerializationContext.serialize(java.lang.Object, java.lang.reflect.Type)",
        "snippet": "  public JsonElement serialize(Object src, Type typeOfSrc);",
        "begin_line": 48,
        "end_line": 48,
        "comment": "\n   * Invokes default serialization on the specified object passing the specific type information.\n   * It should never be invoked on the element received as a parameter of the\n   * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method. Doing\n   * so will result in an infinite loop since Gson will in-turn call the custom serializer again.\n   *\n   * @param src the object that needs to be serialized.\n   * @param typeOfSrc the actual genericized type of src object.\n   * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
        "snippet": "    @Override public String translateName(Field f) {\n      return f.getName();\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
        "snippet": "    @Override public String translateName(Field f) {\n      return upperCaseFirstLetter(f.getName());\n    }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
        "snippet": "    @Override public String translateName(Field f) {\n      return upperCaseFirstLetter(separateCamelCase(f.getName(), \" \"));\n    }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
        "snippet": "    @Override public String translateName(Field f) {\n      return separateCamelCase(f.getName(), \"_\").toLowerCase(Locale.ENGLISH);\n    }",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
        "snippet": "    @Override public String translateName(Field f) {\n      return separateCamelCase(f.getName(), \"-\").toLowerCase(Locale.ENGLISH);\n    }",
        "begin_line": 114,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.separateCamelCase(java.lang.String, java.lang.String)",
        "snippet": "  static String separateCamelCase(String name, String separator) {\n    StringBuilder translation = new StringBuilder();\n    for (int i = 0; i < name.length(); i++) {\n      char character = name.charAt(i);\n      if (Character.isUpperCase(character) && translation.length() != 0) {\n        translation.append(separator);\n      }\n      translation.append(character);\n    }\n    return translation.toString();\n  }",
        "begin_line": 123,
        "end_line": 133,
        "comment": "\n   * Converts the field name that uses camel-case define word separation into\n   * separate words that are separated by the provided {@code separatorString}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.upperCaseFirstLetter(java.lang.String)",
        "snippet": "  static String upperCaseFirstLetter(String name) {\n    StringBuilder fieldNameBuilder = new StringBuilder();\n    int index = 0;\n    char firstCharacter = name.charAt(index);\n\n    while (index < name.length() - 1) {\n      if (Character.isLetter(firstCharacter)) {\n        break;\n      }\n\n      fieldNameBuilder.append(firstCharacter);\n      firstCharacter = name.charAt(++index);\n    }\n\n    if (index == name.length()) {\n      return fieldNameBuilder.toString();\n    }\n\n    if (!Character.isUpperCase(firstCharacter)) {\n      String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);\n      return fieldNameBuilder.append(modifiedTarget).toString();\n    } else {\n      return name;\n    }\n  }",
        "begin_line": 138,
        "end_line": 162,
        "comment": "\n   * Ensures the JSON field names begins with an upper case letter.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingPolicy.java",
        "class_name": "com.google.gson.FieldNamingPolicy",
        "signature": "com.google.gson.FieldNamingPolicy.modifyString(char, java.lang.String, int)",
        "snippet": "  private static String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {\n    return (indexOfSubstring < srcString.length())\n        ? firstCharacter + srcString.substring(indexOfSubstring)\n        : String.valueOf(firstCharacter);\n  }",
        "begin_line": 164,
        "end_line": 168,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonDeserializationContext.java",
        "class_name": "com.google.gson.JsonDeserializationContext",
        "signature": "com.google.gson.JsonDeserializationContext.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type)",
        "snippet": "  public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException;",
        "begin_line": 43,
        "end_line": 43,
        "comment": "\n   * Invokes default deserialization on the specified object. It should never be invoked on\n   * the element received as a parameter of the\n   * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)} method. Doing\n   * so will result in an infinite loop since Gson will in-turn call the custom deserializer again.\n   *\n   * @param json the parse tree.\n   * @param typeOfT type of the expected return value.\n   * @param <T> The type of the deserialized object.\n   * @return An object of type typeOfT.\n   * @throws JsonParseException if the parse tree does not contain expected data.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/InstanceCreator.java",
        "class_name": "com.google.gson.InstanceCreator",
        "signature": "com.google.gson.InstanceCreator.createInstance(java.lang.reflect.Type)",
        "snippet": "  public T createInstance(Type type);",
        "begin_line": 91,
        "end_line": 91,
        "comment": "\n   * Gson invokes this call-back method during deserialization to create an instance of the\n   * specified type. The fields of the returned instance are overwritten with the data present\n   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not\n   * return an instance that is useful elsewhere. In particular, do not return a common instance,\n   * always use {@code new} to create a new instance.\n   *\n   * @param type the parameterized T represented as a {@link Type}.\n   * @return a default object instance of type T.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "  public abstract void write(JsonWriter out, T value) throws IOException;",
        "begin_line": 127,
        "end_line": 127,
        "comment": "\n   * Writes one JSON value (an array, object, string, number, boolean or null)\n   * for {@code value}.\n   *\n   * @param value the Java object to write. May be null.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.toJson(java.io.Writer, T)",
        "snippet": "  public final void toJson(Writer out, T value) throws IOException {\n    JsonWriter writer = new JsonWriter(out);\n    write(writer, value);\n  }",
        "begin_line": 140,
        "end_line": 143,
        "comment": "\n   * Converts {@code value} to a JSON document and writes it to {@code out}.\n   * Unlike Gson's similar {@link Gson#toJson(JsonElement, Appendable) toJson}\n   * method, this write is strict. Create a {@link\n   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call\n   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient\n   * writing.\n   *\n   * @param value the Java object to convert. May be null.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.nullSafe()",
        "snippet": "  public final TypeAdapter<T> nullSafe() {\n    return new TypeAdapter<T>() {\n      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n        } else {\n          TypeAdapter.this.write(out, value);\n        }\n      }\n      @Override public T read(JsonReader reader) throws IOException {\n        if (reader.peek() == JsonToken.NULL) {\n          reader.nextNull();\n          return null;\n        }\n        return TypeAdapter.this.read(reader);\n      }\n    };\n  }",
        "begin_line": 185,
        "end_line": 202,
        "comment": "\n   * This wrapper method is used to make a type adapter null tolerant. In general, a\n   * type adapter is required to handle nulls in write and read methods. Here is how this\n   * is typically done:<br>\n   * <pre>   {@code\n   *\n   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,\n   *   new TypeAdapter<Foo>() {\n   *     public Foo read(JsonReader in) throws IOException {\n   *       if (in.peek() == JsonToken.NULL) {\n   *         in.nextNull();\n   *         return null;\n   *       }\n   *       // read a Foo from in and return it\n   *     }\n   *     public void write(JsonWriter out, Foo src) throws IOException {\n   *       if (src == null) {\n   *         out.nullValue();\n   *         return;\n   *       }\n   *       // write src as JSON to out\n   *     }\n   *   }).create();\n   * }</pre>\n   * You can avoid this boilerplate handling of nulls by wrapping your type adapter with\n   * this method. Here is how we will rewrite the above example:\n   * <pre>   {@code\n   *\n   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,\n   *   new TypeAdapter<Foo>() {\n   *     public Foo read(JsonReader in) throws IOException {\n   *       // read a Foo from in and return it\n   *     }\n   *     public void write(JsonWriter out, Foo src) throws IOException {\n   *       // write src as JSON to out\n   *     }\n   *   }.nullSafe()).create();\n   * }</pre>\n   * Note that we didn't need to check for nulls in our type adapter after we used nullSafe.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.Anonymous-6d0fe8be-45e4-4da0-9a97-80d856ad8929.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (value == null) {\n          out.nullValue();\n        } else {\n          TypeAdapter.this.write(out, value);\n        }\n      }",
        "begin_line": 187,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.Anonymous-a5e8470e-e9ff-4dfc-8c55-42f66ee41ae8.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public T read(JsonReader reader) throws IOException {\n        if (reader.peek() == JsonToken.NULL) {\n          reader.nextNull();\n          return null;\n        }\n        return TypeAdapter.this.read(reader);\n      }",
        "begin_line": 194,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.toJson(T)",
        "snippet": "  public final String toJson(T value) {\n    StringWriter stringWriter = new StringWriter();\n    try {\n      toJson(stringWriter, value);\n    } catch (IOException e) {\n      throw new AssertionError(e); // No I/O writing to a StringWriter.\n    }\n    return stringWriter.toString();\n  }",
        "begin_line": 214,
        "end_line": 222,
        "comment": "\n   * Converts {@code value} to a JSON document. Unlike Gson's similar {@link\n   * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link\n   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call\n   * {@link #write(com.google.gson.stream.JsonWriter, Object)} for lenient\n   * writing.\n   *\n   * @param value the Java object to convert. May be null.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.toJsonTree(T)",
        "snippet": "  public final JsonElement toJsonTree(T value) {\n    try {\n      JsonTreeWriter jsonWriter = new JsonTreeWriter();\n      write(jsonWriter, value);\n      return jsonWriter.get();\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
        "begin_line": 231,
        "end_line": 239,
        "comment": "\n   * Converts {@code value} to a JSON tree.\n   *\n   * @param value the Java object to convert. May be null.\n   * @return the converted JSON tree. May be {@link JsonNull}.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  public abstract T read(JsonReader in) throws IOException;",
        "begin_line": 247,
        "end_line": 247,
        "comment": "\n   * Reads one JSON value (an array, object, string, number, boolean or null)\n   * and converts it to a Java object. Returns the converted object.\n   *\n   * @return the converted Java object. May be null.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.fromJson(java.io.Reader)",
        "snippet": "  public final T fromJson(Reader in) throws IOException {\n    JsonReader reader = new JsonReader(in);\n    return read(reader);\n  }",
        "begin_line": 258,
        "end_line": 261,
        "comment": "\n   * Converts the JSON document in {@code in} to a Java object. Unlike Gson's\n   * similar {@link Gson#fromJson(java.io.Reader, Class) fromJson} method, this\n   * read is strict. Create a {@link JsonReader#setLenient(boolean) lenient}\n   * {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n   *\n   * @return the converted Java object. May be null.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.fromJson(java.lang.String)",
        "snippet": "  public final T fromJson(String json) throws IOException {\n    return fromJson(new StringReader(json));\n  }",
        "begin_line": 272,
        "end_line": 274,
        "comment": "\n   * Converts the JSON document in {@code json} to a Java object. Unlike Gson's\n   * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is\n   * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code\n   * JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n   *\n   * @return the converted Java object. May be null.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapter.java",
        "class_name": "com.google.gson.TypeAdapter",
        "signature": "com.google.gson.TypeAdapter.fromJsonTree(com.google.gson.JsonElement)",
        "snippet": "  public final T fromJsonTree(JsonElement jsonTree) {\n    try {\n      JsonReader jsonReader = new JsonTreeReader(jsonTree);\n      return read(jsonReader);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    }\n  }",
        "begin_line": 282,
        "end_line": 289,
        "comment": "\n   * Converts {@code jsonTree} to a Java object.\n   *\n   * @param jsonTree the Java object to convert. May be {@link JsonNull}.\n   * @since 2.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParseException.java",
        "class_name": "com.google.gson.JsonParseException",
        "signature": "com.google.gson.JsonParseException.JsonParseException(java.lang.String)",
        "snippet": "  public JsonParseException(String msg) {\n    super(msg);\n  }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n   * Creates exception with the specified message. If you are wrapping another exception, consider\n   * using {@link #JsonParseException(String, Throwable)} instead.\n   *\n   * @param msg error message describing a possible cause of this exception.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParseException.java",
        "class_name": "com.google.gson.JsonParseException",
        "signature": "com.google.gson.JsonParseException.JsonParseException(java.lang.String, java.lang.Throwable)",
        "snippet": "  public JsonParseException(String msg, Throwable cause) {\n    super(msg, cause);\n  }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n   * Creates exception with the specified message and cause.\n   *\n   * @param msg error message describing what happened.\n   * @param cause root exception that caused this exception to be thrown.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParseException.java",
        "class_name": "com.google.gson.JsonParseException",
        "signature": "com.google.gson.JsonParseException.JsonParseException(java.lang.Throwable)",
        "snippet": "  public JsonParseException(Throwable cause) {\n    super(cause);\n  }",
        "begin_line": 61,
        "end_line": 63,
        "comment": "\n   * Creates exception with the specified cause. Consider using\n   * {@link #JsonParseException(String, Throwable)} instead if you can describe what happened.\n   *\n   * @param cause root exception that caused this exception to be thrown.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonIOException.java",
        "class_name": "com.google.gson.JsonIOException",
        "signature": "com.google.gson.JsonIOException.JsonIOException(java.lang.String)",
        "snippet": "  public JsonIOException(String msg) {\n    super(msg);\n  }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonIOException.java",
        "class_name": "com.google.gson.JsonIOException",
        "signature": "com.google.gson.JsonIOException.JsonIOException(java.lang.String, java.lang.Throwable)",
        "snippet": "  public JsonIOException(String msg, Throwable cause) {\n    super(msg, cause);\n  }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonIOException.java",
        "class_name": "com.google.gson.JsonIOException",
        "signature": "com.google.gson.JsonIOException.JsonIOException(java.lang.Throwable)",
        "snippet": "  public JsonIOException(Throwable cause) {\n    super(cause);\n  }",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n   * Creates exception with the specified cause. Consider using\n   * {@link #JsonIOException(String, Throwable)} instead if you can describe what happened.\n   *\n   * @param cause root exception that caused this exception to be thrown.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParser.java",
        "class_name": "com.google.gson.JsonParser",
        "signature": "com.google.gson.JsonParser.parse(java.lang.String)",
        "snippet": "  public JsonElement parse(String json) throws JsonSyntaxException {\n    return parse(new StringReader(json));\n  }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParser.java",
        "class_name": "com.google.gson.JsonParser",
        "signature": "com.google.gson.JsonParser.parse(java.io.Reader)",
        "snippet": "  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\n    try {\n      JsonReader jsonReader = new JsonReader(json);\n      JsonElement element = parse(jsonReader);\n      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\n        throw new JsonSyntaxException(\"Did not consume the entire document.\");\n      }\n      return element;\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
        "begin_line": 56,
        "end_line": 71,
        "comment": "\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonParser.java",
        "class_name": "com.google.gson.JsonParser",
        "signature": "com.google.gson.JsonParser.parse(com.google.gson.stream.JsonReader)",
        "snippet": "  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {\n    boolean lenient = json.isLenient();\n    json.setLenient(true);\n    try {\n      return Streams.parse(json);\n    } catch (StackOverflowError e) {\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } catch (OutOfMemoryError e) {\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n    } finally {\n      json.setLenient(lenient);\n    }\n  }",
        "begin_line": 80,
        "end_line": 92,
        "comment": "\r\n   * Returns the next value from the JSON stream as a parse tree.\r\n   *\r\n   * @throws JsonParseException if there is an IOException or if the specified\r\n   *     text is not valid JSON\r\n   * @since 1.6\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.JsonPrimitive(java.lang.Boolean)",
        "snippet": "  public JsonPrimitive(Boolean bool) {\n    setValue(bool);\n  }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n   * Create a primitive containing a boolean value.\n   *\n   * @param bool the value to create the primitive with.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.JsonPrimitive(java.lang.Number)",
        "snippet": "  public JsonPrimitive(Number number) {\n    setValue(number);\n  }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n   * Create a primitive containing a {@link Number}.\n   *\n   * @param number the value to create the primitive with.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.JsonPrimitive(java.lang.String)",
        "snippet": "  public JsonPrimitive(String string) {\n    setValue(string);\n  }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n   * Create a primitive containing a String value.\n   *\n   * @param string the value to create the primitive with.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.JsonPrimitive(java.lang.Character)",
        "snippet": "  public JsonPrimitive(Character c) {\n    setValue(c);\n  }",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n   * Create a primitive containing a character. The character is turned into a one character String\n   * since Json only supports String.\n   *\n   * @param c the value to create the primitive with.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.JsonPrimitive(java.lang.Object)",
        "snippet": "  JsonPrimitive(Object primitive) {\n    setValue(primitive);\n  }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n   * Create a primitive using the specified Object. It must be an instance of {@link Number}, a\n   * Java primitive type, or a String.\n   *\n   * @param primitive the value to create the primitive with.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.deepCopy()",
        "snippet": "  @Override\n  JsonPrimitive deepCopy() {\n    return this;\n  }",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.setValue(java.lang.Object)",
        "snippet": "  void setValue(Object primitive) {\n    if (primitive instanceof Character) {\n      // convert characters to strings since in JSON, characters are represented as a single\n      // character string\n      char c = ((Character) primitive).charValue();\n      this.value = String.valueOf(c);\n    } else {\n      $Gson$Preconditions.checkArgument(primitive instanceof Number\n              || isPrimitiveOrString(primitive));\n      this.value = primitive;\n    }\n  }",
        "begin_line": 93,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.isBoolean()",
        "snippet": "  public boolean isBoolean() {\n    return value instanceof Boolean;\n  }",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n   * Check whether this primitive contains a boolean value.\n   *\n   * @return true if this primitive contains a boolean value, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsBooleanWrapper()",
        "snippet": "  @Override\n  Boolean getAsBooleanWrapper() {\n    return (Boolean) value;\n  }",
        "begin_line": 120,
        "end_line": 123,
        "comment": "\n   * convenience method to get this element as a {@link Boolean}.\n   *\n   * @return get this element as a {@link Boolean}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsBoolean()",
        "snippet": "  @Override\n  public boolean getAsBoolean() {\n    if (isBoolean()) {\n      return getAsBooleanWrapper().booleanValue();\n    } else {\n      // Check to see if the value as a String is \"true\" in any case.\n      return Boolean.parseBoolean(getAsString());\n    }\n  }",
        "begin_line": 130,
        "end_line": 138,
        "comment": "\n   * convenience method to get this element as a boolean value.\n   *\n   * @return get this element as a primitive boolean value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.isNumber()",
        "snippet": "  public boolean isNumber() {\n    return value instanceof Number;\n  }",
        "begin_line": 145,
        "end_line": 147,
        "comment": "\n   * Check whether this primitive contains a Number.\n   *\n   * @return true if this primitive contains a Number, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsNumber()",
        "snippet": "  @Override\n  public Number getAsNumber() {\n    return value instanceof String ? new LazilyParsedNumber((String) value) : (Number) value;\n  }",
        "begin_line": 155,
        "end_line": 158,
        "comment": "\n   * convenience method to get this element as a Number.\n   *\n   * @return get this element as a Number.\n   * @throws NumberFormatException if the value contained is not a valid Number.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.isString()",
        "snippet": "  public boolean isString() {\n    return value instanceof String;\n  }",
        "begin_line": 165,
        "end_line": 167,
        "comment": "\n   * Check whether this primitive contains a String value.\n   *\n   * @return true if this primitive contains a String value, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsString()",
        "snippet": "  @Override\n  public String getAsString() {\n    if (isNumber()) {\n      return getAsNumber().toString();\n    } else if (isBoolean()) {\n      return getAsBooleanWrapper().toString();\n    } else {\n      return (String) value;\n    }\n  }",
        "begin_line": 174,
        "end_line": 183,
        "comment": "\n   * convenience method to get this element as a String.\n   *\n   * @return get this element as a String.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsDouble()",
        "snippet": "  @Override\n  public double getAsDouble() {\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\n  }",
        "begin_line": 191,
        "end_line": 194,
        "comment": "\n   * convenience method to get this element as a primitive double.\n   *\n   * @return get this element as a primitive double.\n   * @throws NumberFormatException if the value contained is not a valid double.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsBigDecimal()",
        "snippet": "  @Override\n  public BigDecimal getAsBigDecimal() {\n    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString());\n  }",
        "begin_line": 202,
        "end_line": 205,
        "comment": "\n   * convenience method to get this element as a {@link BigDecimal}.\n   *\n   * @return get this element as a {@link BigDecimal}.\n   * @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsBigInteger()",
        "snippet": "  @Override\n  public BigInteger getAsBigInteger() {\n    return value instanceof BigInteger ?\n        (BigInteger) value : new BigInteger(value.toString());\n  }",
        "begin_line": 213,
        "end_line": 217,
        "comment": "\n   * convenience method to get this element as a {@link BigInteger}.\n   *\n   * @return get this element as a {@link BigInteger}.\n   * @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsFloat()",
        "snippet": "  @Override\n  public float getAsFloat() {\n    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());\n  }",
        "begin_line": 225,
        "end_line": 228,
        "comment": "\n   * convenience method to get this element as a float.\n   *\n   * @return get this element as a float.\n   * @throws NumberFormatException if the value contained is not a valid float.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsLong()",
        "snippet": "  @Override\n  public long getAsLong() {\n    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());\n  }",
        "begin_line": 236,
        "end_line": 239,
        "comment": "\n   * convenience method to get this element as a primitive long.\n   *\n   * @return get this element as a primitive long.\n   * @throws NumberFormatException if the value contained is not a valid long.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsShort()",
        "snippet": "  @Override\n  public short getAsShort() {\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\n  }",
        "begin_line": 247,
        "end_line": 250,
        "comment": "\n   * convenience method to get this element as a primitive short.\n   *\n   * @return get this element as a primitive short.\n   * @throws NumberFormatException if the value contained is not a valid short value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsInt()",
        "snippet": "  @Override\n  public int getAsInt() {\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\n  }",
        "begin_line": 258,
        "end_line": 261,
        "comment": "\n  * convenience method to get this element as a primitive integer.\n  *\n  * @return get this element as a primitive integer.\n  * @throws NumberFormatException if the value contained is not a valid integer.\n  ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsByte()",
        "snippet": "  @Override\n  public byte getAsByte() {\n    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());\n  }",
        "begin_line": 263,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.getAsCharacter()",
        "snippet": "  @Override\n  public char getAsCharacter() {\n    return getAsString().charAt(0);\n  }",
        "begin_line": 268,
        "end_line": 271,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.isPrimitiveOrString(java.lang.Object)",
        "snippet": "  private static boolean isPrimitiveOrString(Object target) {\n    if (target instanceof String) {\n      return true;\n    }\n\n    Class<?> classOfPrimitive = target.getClass();\n    for (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\n      if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "begin_line": 273,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    if (value == null) {\n      return 31;\n    }\n    // Using recommended hashing algorithm from Effective Java for longs and doubles\n    if (isIntegral(this)) {\n      long value = getAsNumber().longValue();\n      return (int) (value ^ (value >>> 32));\n    }\n    if (value instanceof Number) {\n      long value = Double.doubleToLongBits(getAsNumber().doubleValue());\n      return (int) (value ^ (value >>> 32));\n    }\n    return value.hashCode();\n  }",
        "begin_line": 287,
        "end_line": 302,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n      return false;\n    }\n    JsonPrimitive other = (JsonPrimitive)obj;\n    if (value == null) {\n      return other.value == null;\n    }\n    if (isIntegral(this) && isIntegral(other)) {\n      return getAsNumber().longValue() == other.getAsNumber().longValue();\n    }\n    if (value instanceof Number && other.value instanceof Number) {\n      double a = getAsNumber().doubleValue();\n      // Java standard types other than double return true for two NaN. So, need\n      // special handling for double.\n      double b = other.getAsNumber().doubleValue();\n      return a == b || (Double.isNaN(a) && Double.isNaN(b));\n    }\n    return value.equals(other.value);\n  }",
        "begin_line": 304,
        "end_line": 327,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonPrimitive.java",
        "class_name": "com.google.gson.JsonPrimitive",
        "signature": "com.google.gson.JsonPrimitive.isIntegral(com.google.gson.JsonPrimitive)",
        "snippet": "  private static boolean isIntegral(JsonPrimitive primitive) {\n    if (primitive.value instanceof Number) {\n      Number number = (Number) primitive.value;\n      return number instanceof BigInteger || number instanceof Long || number instanceof Integer\n          || number instanceof Short || number instanceof Byte;\n    }\n    return false;\n  }",
        "begin_line": 333,
        "end_line": 340,
        "comment": "\n   * Returns true if the specified number is an integral type\n   * (Long, Integer, Short, Byte, BigInteger)\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.deepCopy()",
        "snippet": "  abstract JsonElement deepCopy();",
        "begin_line": 38,
        "end_line": 38,
        "comment": "\n   * Returns a deep copy of this element. Immutable elements like primitives\n   * and nulls are not copied.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.isJsonArray()",
        "snippet": "  public boolean isJsonArray() {\n    return this instanceof JsonArray;\n  }",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n   * provides check for verifying if this element is an array or not.\n   *\n   * @return true if this element is of type {@link JsonArray}, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.isJsonObject()",
        "snippet": "  public boolean isJsonObject() {\n    return this instanceof JsonObject;\n  }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "\n   * provides check for verifying if this element is a Json object or not.\n   *\n   * @return true if this element is of type {@link JsonObject}, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.isJsonPrimitive()",
        "snippet": "  public boolean isJsonPrimitive() {\n    return this instanceof JsonPrimitive;\n  }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "\n   * provides check for verifying if this element is a primitive or not.\n   *\n   * @return true if this element is of type {@link JsonPrimitive}, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.isJsonNull()",
        "snippet": "  public boolean isJsonNull() {\n    return this instanceof JsonNull;\n  }",
        "begin_line": 73,
        "end_line": 75,
        "comment": "\n   * provides check for verifying if this element represents a null value or not.\n   *\n   * @return true if this element is of type {@link JsonNull}, false otherwise.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsJsonObject()",
        "snippet": "  public JsonObject getAsJsonObject() {\n    if (isJsonObject()) {\n      return (JsonObject) this;\n    }\n    throw new IllegalStateException(\"Not a JSON Object: \" + this);\n  }",
        "begin_line": 86,
        "end_line": 91,
        "comment": "\n   * convenience method to get this element as a {@link JsonObject}. If the element is of some\n   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}\n   * first.\n   *\n   * @return get this element as a {@link JsonObject}.\n   * @throws IllegalStateException if the element is of another type.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsJsonArray()",
        "snippet": "  public JsonArray getAsJsonArray() {\n    if (isJsonArray()) {\n      return (JsonArray) this;\n    }\n    throw new IllegalStateException(\"This is not a JSON Array.\");\n  }",
        "begin_line": 102,
        "end_line": 107,
        "comment": "\n   * convenience method to get this element as a {@link JsonArray}. If the element is of some\n   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonArray()}\n   * first.\n   *\n   * @return get this element as a {@link JsonArray}.\n   * @throws IllegalStateException if the element is of another type.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsJsonPrimitive()",
        "snippet": "  public JsonPrimitive getAsJsonPrimitive() {\n    if (isJsonPrimitive()) {\n      return (JsonPrimitive) this;\n    }\n    throw new IllegalStateException(\"This is not a JSON Primitive.\");\n  }",
        "begin_line": 118,
        "end_line": 123,
        "comment": "\n   * convenience method to get this element as a {@link JsonPrimitive}. If the element is of some\n   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}\n   * first.\n   *\n   * @return get this element as a {@link JsonPrimitive}.\n   * @throws IllegalStateException if the element is of another type.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsJsonNull()",
        "snippet": "  public JsonNull getAsJsonNull() {\n    if (isJsonNull()) {\n      return (JsonNull) this;\n    }\n    throw new IllegalStateException(\"This is not a JSON Null.\");\n  }",
        "begin_line": 135,
        "end_line": 140,
        "comment": "\n   * convenience method to get this element as a {@link JsonNull}. If the element is of some\n   * other type, a {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonNull()}\n   * first.\n   *\n   * @return get this element as a {@link JsonNull}.\n   * @throws IllegalStateException if the element is of another type.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsBoolean()",
        "snippet": "  public boolean getAsBoolean() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 151,
        "end_line": 153,
        "comment": "\n   * convenience method to get this element as a boolean value.\n   *\n   * @return get this element as a primitive boolean value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * boolean value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsBooleanWrapper()",
        "snippet": "  Boolean getAsBooleanWrapper() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 164,
        "end_line": 166,
        "comment": "\n   * convenience method to get this element as a {@link Boolean} value.\n   *\n   * @return get this element as a {@link Boolean} value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * boolean value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsNumber()",
        "snippet": "  public Number getAsNumber() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n   * convenience method to get this element as a {@link Number}.\n   *\n   * @return get this element as a {@link Number}.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * number.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsString()",
        "snippet": "  public String getAsString() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 190,
        "end_line": 192,
        "comment": "\n   * convenience method to get this element as a string value.\n   *\n   * @return get this element as a string value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * string value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsDouble()",
        "snippet": "  public double getAsDouble() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 203,
        "end_line": 205,
        "comment": "\n   * convenience method to get this element as a primitive double value.\n   *\n   * @return get this element as a primitive double value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * double value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsFloat()",
        "snippet": "  public float getAsFloat() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 216,
        "end_line": 218,
        "comment": "\n   * convenience method to get this element as a primitive float value.\n   *\n   * @return get this element as a primitive float value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * float value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsLong()",
        "snippet": "  public long getAsLong() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 229,
        "end_line": 231,
        "comment": "\n   * convenience method to get this element as a primitive long value.\n   *\n   * @return get this element as a primitive long value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * long value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsInt()",
        "snippet": "  public int getAsInt() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 242,
        "end_line": 244,
        "comment": "\n   * convenience method to get this element as a primitive integer value.\n   *\n   * @return get this element as a primitive integer value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * integer value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsByte()",
        "snippet": "  public byte getAsByte() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 256,
        "end_line": 258,
        "comment": "\n   * convenience method to get this element as a primitive byte value.\n   *\n   * @return get this element as a primitive byte value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * byte value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsCharacter()",
        "snippet": "  public char getAsCharacter() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 270,
        "end_line": 272,
        "comment": "\n   * convenience method to get this element as a primitive character value.\n   *\n   * @return get this element as a primitive char value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * char value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsBigDecimal()",
        "snippet": "  public BigDecimal getAsBigDecimal() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 284,
        "end_line": 286,
        "comment": "\n   * convenience method to get this element as a {@link BigDecimal}.\n   *\n   * @return get this element as a {@link BigDecimal}.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.\n   * * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsBigInteger()",
        "snippet": "  public BigInteger getAsBigInteger() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 298,
        "end_line": 300,
        "comment": "\n   * convenience method to get this element as a {@link BigInteger}.\n   *\n   * @return get this element as a {@link BigInteger}.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.\n   * @throws NumberFormatException if the element is not a valid {@link BigInteger}.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.getAsShort()",
        "snippet": "  public short getAsShort() {\n    throw new UnsupportedOperationException(getClass().getSimpleName());\n  }",
        "begin_line": 311,
        "end_line": 313,
        "comment": "\n   * convenience method to get this element as a primitive short value.\n   *\n   * @return get this element as a primitive short value.\n   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n   * short value.\n   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonElement.java",
        "class_name": "com.google.gson.JsonElement",
        "signature": "com.google.gson.JsonElement.toString()",
        "snippet": "  @Override\n  public String toString() {\n    try {\n      StringWriter stringWriter = new StringWriter();\n      JsonWriter jsonWriter = new JsonWriter(stringWriter);\n      jsonWriter.setLenient(true);\n      Streams.write(this, jsonWriter);\n      return stringWriter.toString();\n    } catch (IOException e) {\n      throw new AssertionError(e);\n    }\n  }",
        "begin_line": 318,
        "end_line": 329,
        "comment": "\n   * Returns a String representation of this element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonDeserializer.java",
        "class_name": "com.google.gson.JsonDeserializer",
        "signature": "com.google.gson.JsonDeserializer.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type, com.google.gson.JsonDeserializationContext)",
        "snippet": "  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n      throws JsonParseException;",
        "begin_line": 89,
        "end_line": 90,
        "comment": "\n   * Gson invokes this call-back method during deserialization when it encounters a field of the\n   * specified type.\n   * <p>In the implementation of this call-back method, you should consider invoking\n   * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects\n   * for any non-trivial field of the returned object. However, you should never invoke it on the\n   * the same type passing {@code json} since that will cause an infinite loop (Gson will call your\n   * call-back method again).\n   *\n   * @param json The Json data being deserialized\n   * @param typeOfT The type of the Object to deserialize to\n   * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}\n   * @throws JsonParseException if json is not in the expected format of {@code typeofT}\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSerializer.java",
        "class_name": "com.google.gson.JsonSerializer",
        "signature": "com.google.gson.JsonSerializer.serialize(T, java.lang.reflect.Type, com.google.gson.JsonSerializationContext)",
        "snippet": "  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);",
        "begin_line": 88,
        "end_line": 88,
        "comment": "\n   * Gson invokes this call-back method during serialization when it encounters a field of the\n   * specified type.\n   *\n   * <p>In the implementation of this call-back method, you should consider invoking\n   * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any\n   * non-trivial field of the {@code src} object. However, you should never invoke it on the\n   * {@code src} object itself since that will cause an infinite loop (Gson will call your\n   * call-back method again).</p>\n   *\n   * @param src the object that needs to be converted to Json.\n   * @param typeOfSrc the actual type (fully genericized version) of the source object.\n   * @return a JsonElement corresponding to the specified object.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.deepCopy()",
        "snippet": "  @Override\n  JsonObject deepCopy() {\n    JsonObject result = new JsonObject();\n    for (Map.Entry<String, JsonElement> entry : members.entrySet()) {\n      result.add(entry.getKey(), entry.getValue().deepCopy());\n    }\n    return result;\n  }",
        "begin_line": 36,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.add(java.lang.String, com.google.gson.JsonElement)",
        "snippet": "  public void add(String property, JsonElement value) {\n    if (value == null) {\n      value = JsonNull.INSTANCE;\n    }\n    members.put(property, value);\n  }",
        "begin_line": 53,
        "end_line": 58,
        "comment": "\n   * Adds a member, which is a name-value pair, to self. The name must be a String, but the value\n   * can be an arbitrary JsonElement, thereby allowing you to build a full tree of JsonElements\n   * rooted at this node.\n   *\n   * @param property name of the member.\n   * @param value the member object.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.remove(java.lang.String)",
        "snippet": "  public JsonElement remove(String property) {\n    return members.remove(property);\n  }",
        "begin_line": 67,
        "end_line": 69,
        "comment": "\n   * Removes the {@code property} from this {@link JsonObject}.\n   *\n   * @param property name of the member that should be removed.\n   * @return the {@link JsonElement} object that is being removed.\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.addProperty(java.lang.String, java.lang.String)",
        "snippet": "  public void addProperty(String property, String value) {\n    add(property, createJsonElement(value));\n  }",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n   * Convenience method to add a primitive member. The specified value is converted to a\n   * JsonPrimitive of String.\n   *\n   * @param property name of the member.\n   * @param value the string value associated with the member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.addProperty(java.lang.String, java.lang.Number)",
        "snippet": "  public void addProperty(String property, Number value) {\n    add(property, createJsonElement(value));\n  }",
        "begin_line": 89,
        "end_line": 91,
        "comment": "\n   * Convenience method to add a primitive member. The specified value is converted to a\n   * JsonPrimitive of Number.\n   *\n   * @param property name of the member.\n   * @param value the number value associated with the member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.addProperty(java.lang.String, java.lang.Boolean)",
        "snippet": "  public void addProperty(String property, Boolean value) {\n    add(property, createJsonElement(value));\n  }",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n   * Convenience method to add a boolean member. The specified value is converted to a\n   * JsonPrimitive of Boolean.\n   *\n   * @param property name of the member.\n   * @param value the number value associated with the member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.addProperty(java.lang.String, java.lang.Character)",
        "snippet": "  public void addProperty(String property, Character value) {\n    add(property, createJsonElement(value));\n  }",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n   * Convenience method to add a char member. The specified value is converted to a\n   * JsonPrimitive of Character.\n   *\n   * @param property name of the member.\n   * @param value the number value associated with the member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.createJsonElement(java.lang.Object)",
        "snippet": "  private JsonElement createJsonElement(Object value) {\n    return value == null ? JsonNull.INSTANCE : new JsonPrimitive(value);\n  }",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n   * Creates the proper {@link JsonElement} object from the given {@code value} object.\n   *\n   * @param value the object to generate the {@link JsonElement} for\n   * @return a {@link JsonPrimitive} if the {@code value} is not null, otherwise a {@link JsonNull}\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.entrySet()",
        "snippet": "  public Set<Map.Entry<String, JsonElement>> entrySet() {\n    return members.entrySet();\n  }",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n   * Returns a set of members of this object. The set is ordered, and the order is in which the\n   * elements were added.\n   *\n   * @return a set of members of this object.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.has(java.lang.String)",
        "snippet": "  public boolean has(String memberName) {\n    return members.containsKey(memberName);\n  }",
        "begin_line": 141,
        "end_line": 143,
        "comment": "\n   * Convenience method to check if a member with the specified name is present in this object.\n   *\n   * @param memberName name of the member that is being checked for presence.\n   * @return true if there is a member with the specified name, false otherwise.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.get(java.lang.String)",
        "snippet": "  public JsonElement get(String memberName) {\n    return members.get(memberName);\n  }",
        "begin_line": 151,
        "end_line": 153,
        "comment": "\n   * Returns the member with the specified name.\n   *\n   * @param memberName name of the member that is being requested.\n   * @return the member matching the name. Null if no such member exists.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.getAsJsonPrimitive(java.lang.String)",
        "snippet": "  public JsonPrimitive getAsJsonPrimitive(String memberName) {\n    return (JsonPrimitive) members.get(memberName);\n  }",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n   * Convenience method to get the specified member as a JsonPrimitive element.\n   *\n   * @param memberName name of the member being requested.\n   * @return the JsonPrimitive corresponding to the specified member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.getAsJsonArray(java.lang.String)",
        "snippet": "  public JsonArray getAsJsonArray(String memberName) {\n    return (JsonArray) members.get(memberName);\n  }",
        "begin_line": 171,
        "end_line": 173,
        "comment": "\n   * Convenience method to get the specified member as a JsonArray.\n   *\n   * @param memberName name of the member being requested.\n   * @return the JsonArray corresponding to the specified member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.getAsJsonObject(java.lang.String)",
        "snippet": "  public JsonObject getAsJsonObject(String memberName) {\n    return (JsonObject) members.get(memberName);\n  }",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n   * Convenience method to get the specified member as a JsonObject.\n   *\n   * @param memberName name of the member being requested.\n   * @return the JsonObject corresponding to the specified member.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object o) {\n    return (o == this) || (o instanceof JsonObject\n        && ((JsonObject) o).members.equals(members));\n  }",
        "begin_line": 185,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonObject.java",
        "class_name": "com.google.gson.JsonObject",
        "signature": "com.google.gson.JsonObject.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return members.hashCode();\n  }",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.DefaultDateTypeAdapter()",
        "snippet": "  DefaultDateTypeAdapter() {\n    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }",
        "begin_line": 45,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.DefaultDateTypeAdapter(java.lang.String)",
        "snippet": "  DefaultDateTypeAdapter(String datePattern) {\n    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n  }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.DefaultDateTypeAdapter(int)",
        "snippet": "  DefaultDateTypeAdapter(int style) {\n    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n  }",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.DefaultDateTypeAdapter(int, int)",
        "snippet": "  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.DefaultDateTypeAdapter(java.text.DateFormat, java.text.DateFormat)",
        "snippet": "  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }",
        "begin_line": 63,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.serialize(java.util.Date, java.lang.reflect.Type, com.google.gson.JsonSerializationContext)",
        "snippet": "  @Override\n  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n    synchronized (localFormat) {\n      String dateFormatAsString = enUsFormat.format(src);\n      return new JsonPrimitive(dateFormatAsString);\n    }\n  }",
        "begin_line": 70,
        "end_line": 76,
        "comment": " See issue 162",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type, com.google.gson.JsonDeserializationContext)",
        "snippet": "  @Override\n  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n      throws JsonParseException {\n    if (!(json instanceof JsonPrimitive)) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(json);\n    if (typeOfT == Date.class) {\n      return date;\n    } else if (typeOfT == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (typeOfT == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      throw new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n    }\n  }",
        "begin_line": 78,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.deserializeToDate(com.google.gson.JsonElement)",
        "snippet": "  private Date deserializeToDate(JsonElement json) {\n    synchronized (localFormat) {\n      try {\n      \treturn localFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(json.getAsString());\n      } catch (ParseException ignored) {}\n      try {\n        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(json.getAsString(), e);\n      }\n    }\n  }",
        "begin_line": 96,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
        "class_name": "com.google.gson.DefaultDateTypeAdapter",
        "signature": "com.google.gson.DefaultDateTypeAdapter.toString()",
        "snippet": "  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(DefaultDateTypeAdapter.class.getSimpleName());\n    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');\n    return sb.toString();\n  }",
        "begin_line": 112,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/ExclusionStrategy.java",
        "class_name": "com.google.gson.ExclusionStrategy",
        "signature": "com.google.gson.ExclusionStrategy.shouldSkipField(com.google.gson.FieldAttributes)",
        "snippet": "  public boolean shouldSkipField(FieldAttributes f);",
        "begin_line": 102,
        "end_line": 102,
        "comment": "\n   * @param f the field object that is under test\n   * @return true if the field should be ignored; otherwise false\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/ExclusionStrategy.java",
        "class_name": "com.google.gson.ExclusionStrategy",
        "signature": "com.google.gson.ExclusionStrategy.shouldSkipClass(java.lang.Class<?>)",
        "snippet": "  public boolean shouldSkipClass(Class<?> clazz);",
        "begin_line": 108,
        "end_line": 108,
        "comment": "\n   * @param clazz the class object that is under test\n   * @return true if the class should be ignored; otherwise false\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonStreamParser.java",
        "class_name": "com.google.gson.JsonStreamParser",
        "signature": "com.google.gson.JsonStreamParser.JsonStreamParser(java.lang.String)",
        "snippet": "  public JsonStreamParser(String json) {\n    this(new StringReader(json));      \n  }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n   * @param json The string containing JSON elements concatenated to each other.\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonStreamParser.java",
        "class_name": "com.google.gson.JsonStreamParser",
        "signature": "com.google.gson.JsonStreamParser.JsonStreamParser(java.io.Reader)",
        "snippet": "  public JsonStreamParser(Reader reader) {\n    parser = new JsonReader(reader);\n    parser.setLenient(true);\n    lock = new Object();\n  }",
        "begin_line": 68,
        "end_line": 72,
        "comment": "\n   * @param reader The data stream containing JSON elements concatenated to each other.\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonStreamParser.java",
        "class_name": "com.google.gson.JsonStreamParser",
        "signature": "com.google.gson.JsonStreamParser.next()",
        "snippet": "  public JsonElement next() throws JsonParseException {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    try {\n      return Streams.parse(parser);\n    } catch (StackOverflowError e) {\n      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n    } catch (OutOfMemoryError e) {\n      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n    } catch (JsonParseException e) {\n      throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e;\n    }\n  }",
        "begin_line": 81,
        "end_line": 95,
        "comment": "\n   * Returns the next available {@link JsonElement} on the reader. Null if none available.\n   * \n   * @return the next available {@link JsonElement} on the reader. Null if none available.\n   * @throws JsonParseException if the incoming stream is malformed JSON.\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonStreamParser.java",
        "class_name": "com.google.gson.JsonStreamParser",
        "signature": "com.google.gson.JsonStreamParser.hasNext()",
        "snippet": "  public boolean hasNext() {\n    synchronized (lock) {\n      try {\n        return parser.peek() != JsonToken.END_DOCUMENT;\n      } catch (MalformedJsonException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IOException e) {\n        throw new JsonIOException(e);\n      }\n    }\n  }",
        "begin_line": 102,
        "end_line": 112,
        "comment": "\n   * Returns true if a {@link JsonElement} is available on the input for consumption\n   * @return true if a {@link JsonElement} is available on the input, false otherwise\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonStreamParser.java",
        "class_name": "com.google.gson.JsonStreamParser",
        "signature": "com.google.gson.JsonStreamParser.remove()",
        "snippet": "  public void remove() {\n    throw new UnsupportedOperationException();\n  }",
        "begin_line": 119,
        "end_line": 121,
        "comment": "\n   * This optional {@link Iterator} method is not relevant for stream parsing and hence is not\n   * implemented.\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.JsonArray()",
        "snippet": "  public JsonArray() {\n    elements = new ArrayList<JsonElement>();\n  }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "\n   * Creates an empty JsonArray.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.deepCopy()",
        "snippet": "  @Override\n  JsonArray deepCopy() {\n    JsonArray result = new JsonArray();\n    for (JsonElement element : elements) {\n      result.add(element.deepCopy());\n    }\n    return result;\n  }",
        "begin_line": 43,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.add(java.lang.Boolean)",
        "snippet": "  public void add(Boolean bool) {\n    elements.add(bool == null ? JsonNull.INSTANCE : new JsonPrimitive(bool));\n  }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n   * Adds the specified boolean to self.\n   *\n   * @param bool the boolean that needs to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.add(java.lang.Character)",
        "snippet": "  public void add(Character character) {\n    elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n  }",
        "begin_line": 66,
        "end_line": 68,
        "comment": "\n   * Adds the specified character to self.\n   *\n   * @param character the character that needs to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.add(java.lang.Number)",
        "snippet": "  public void add(Number number) {\n    elements.add(number == null ? JsonNull.INSTANCE : new JsonPrimitive(number));\n  }",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n   * Adds the specified number to self.\n   *\n   * @param number the number that needs to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.add(java.lang.String)",
        "snippet": "  public void add(String string) {\n    elements.add(string == null ? JsonNull.INSTANCE : new JsonPrimitive(string));\n  }",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n   * Adds the specified string to self.\n   *\n   * @param string the string that needs to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.add(com.google.gson.JsonElement)",
        "snippet": "  public void add(JsonElement element) {\n    if (element == null) {\n      element = JsonNull.INSTANCE;\n    }\n    elements.add(element);\n  }",
        "begin_line": 93,
        "end_line": 98,
        "comment": "\n   * Adds the specified element to self.\n   *\n   * @param element the element that needs to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.addAll(com.google.gson.JsonArray)",
        "snippet": "  public void addAll(JsonArray array) {\n    elements.addAll(array.elements);\n  }",
        "begin_line": 105,
        "end_line": 107,
        "comment": "\n   * Adds all the elements of the specified array to self.\n   *\n   * @param array the array whose elements need to be added to the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.set(int, com.google.gson.JsonElement)",
        "snippet": "  public JsonElement set(int index, JsonElement element) {\n    return elements.set(index, element);\n  }",
        "begin_line": 117,
        "end_line": 119,
        "comment": "\n   * Replaces the element at the specified position in this array with the specified element.\n   *   Element can be null.\n   * @param index index of the element to replace\n   * @param element element to be stored at the specified position\n   * @return the element previously at the specified position\n   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.remove(com.google.gson.JsonElement)",
        "snippet": "  public boolean remove(JsonElement element) {\n    return elements.remove(element);\n  }",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n   * Removes the first occurrence of the specified element from this array, if it is present.\n   * If the array does not contain the element, it is unchanged.\n   * @param element element to be removed from this array, if present\n   * @return true if this array contained the specified element, false otherwise\n   * @since 2.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.remove(int)",
        "snippet": "  public JsonElement remove(int index) {\n    return elements.remove(index);\n  }",
        "begin_line": 141,
        "end_line": 143,
        "comment": "\n   * Removes the element at the specified position in this array. Shifts any subsequent elements\n   * to the left (subtracts one from their indices). Returns the element that was removed from\n   * the array.\n   * @param index index the index of the element to be removed\n   * @return the element previously at the specified position\n   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds\n   * @since 2.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.contains(com.google.gson.JsonElement)",
        "snippet": "  public boolean contains(JsonElement element) {\n    return elements.contains(element);\n  }",
        "begin_line": 151,
        "end_line": 153,
        "comment": "\n   * Returns true if this array contains the specified element.\n   * @return true if this array contains the specified element.\n   * @param element whose presence in this array is to be tested\n   * @since 2.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.size()",
        "snippet": "  public int size() {\n    return elements.size();\n  }",
        "begin_line": 160,
        "end_line": 162,
        "comment": "\n   * Returns the number of elements in the array.\n   *\n   * @return the number of elements in the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.iterator()",
        "snippet": "  public Iterator<JsonElement> iterator() {\n    return elements.iterator();\n  }",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,\n   * the iterator navigates the elements in the order they were inserted.\n   *\n   * @return an iterator to navigate the elements of the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.get(int)",
        "snippet": "  public JsonElement get(int i) {\n    return elements.get(i);\n  }",
        "begin_line": 182,
        "end_line": 184,
        "comment": "\n   * Returns the ith element of the array.\n   *\n   * @param i the index of the element that is being sought.\n   * @return the element present at the ith index.\n   * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the\n   * {@link #size()} of the array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsNumber()",
        "snippet": "  @Override\n  public Number getAsNumber() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsNumber();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 194,
        "end_line": 200,
        "comment": "\n   * convenience method to get this array as a {@link Number} if it contains a single element.\n   *\n   * @return get this element as a number if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid Number.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsString()",
        "snippet": "  @Override\n  public String getAsString() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsString();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 210,
        "end_line": 216,
        "comment": "\n   * convenience method to get this array as a {@link String} if it contains a single element.\n   *\n   * @return get this element as a String if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid String.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsDouble()",
        "snippet": "  @Override\n  public double getAsDouble() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsDouble();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 226,
        "end_line": 232,
        "comment": "\n   * convenience method to get this array as a double if it contains a single element.\n   *\n   * @return get this element as a double if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid double.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsBigDecimal()",
        "snippet": "  @Override\n  public BigDecimal getAsBigDecimal() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigDecimal();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 243,
        "end_line": 249,
        "comment": "\n   * convenience method to get this array as a {@link BigDecimal} if it contains a single element.\n   *\n   * @return get this element as a {@link BigDecimal} if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.\n   * @throws IllegalStateException if the array has more than one element.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsBigInteger()",
        "snippet": "  @Override\n  public BigInteger getAsBigInteger() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigInteger();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 260,
        "end_line": 266,
        "comment": "\n   * convenience method to get this array as a {@link BigInteger} if it contains a single element.\n   *\n   * @return get this element as a {@link BigInteger} if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.\n   * @throws IllegalStateException if the array has more than one element.\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsFloat()",
        "snippet": "  @Override\n  public float getAsFloat() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsFloat();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 276,
        "end_line": 282,
        "comment": "\n   * convenience method to get this array as a float if it contains a single element.\n   *\n   * @return get this element as a float if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid float.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsLong()",
        "snippet": "  @Override\n  public long getAsLong() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsLong();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 292,
        "end_line": 298,
        "comment": "\n   * convenience method to get this array as a long if it contains a single element.\n   *\n   * @return get this element as a long if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid long.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsInt()",
        "snippet": "  @Override\n  public int getAsInt() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsInt();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 308,
        "end_line": 314,
        "comment": "\n   * convenience method to get this array as an integer if it contains a single element.\n   *\n   * @return get this element as an integer if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid integer.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsByte()",
        "snippet": "  @Override\n  public byte getAsByte() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsByte();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 316,
        "end_line": 322,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsCharacter()",
        "snippet": "  @Override\n  public char getAsCharacter() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsCharacter();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 324,
        "end_line": 330,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsShort()",
        "snippet": "  @Override\n  public short getAsShort() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsShort();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 340,
        "end_line": 346,
        "comment": "\n   * convenience method to get this array as a primitive short if it contains a single element.\n   *\n   * @return get this element as a primitive short if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid short.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.getAsBoolean()",
        "snippet": "  @Override\n  public boolean getAsBoolean() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBoolean();\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 356,
        "end_line": 362,
        "comment": "\n   * convenience method to get this array as a boolean if it contains a single element.\n   *\n   * @return get this element as a boolean if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid boolean.\n   * @throws IllegalStateException if the array has more than one element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object o) {\n    return (o == this) || (o instanceof JsonArray && ((JsonArray) o).elements.equals(elements));\n  }",
        "begin_line": 364,
        "end_line": 367,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonArray.java",
        "class_name": "com.google.gson.JsonArray",
        "signature": "com.google.gson.JsonArray.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return elements.hashCode();\n  }",
        "begin_line": 369,
        "end_line": 372,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/LongSerializationPolicy.java",
        "class_name": "com.google.gson.LongSerializationPolicy",
        "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
        "snippet": "    @Override public JsonElement serialize(Long value) {\n      return new JsonPrimitive(value);\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/LongSerializationPolicy.java",
        "class_name": "com.google.gson.LongSerializationPolicy",
        "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
        "snippet": "    @Override public JsonElement serialize(Long value) {\n      return new JsonPrimitive(String.valueOf(value));\n    }",
        "begin_line": 46,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/LongSerializationPolicy.java",
        "class_name": "com.google.gson.LongSerializationPolicy",
        "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
        "snippet": "  public abstract JsonElement serialize(Long value);",
        "begin_line": 57,
        "end_line": 57,
        "comment": "\n   * Serialize this {@code value} using this serialization policy.\n   *\n   * @param value the long value to be serialized into a {@link JsonElement}\n   * @return the serialized version of {@code value}\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.GsonBuilder()",
        "snippet": "  public GsonBuilder() {\n  }",
        "begin_line": 104,
        "end_line": 105,
        "comment": "\n   * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n   * settings. GsonBuilder follows the builder pattern, and it is typically used by first\n   * invoking various configuration methods to set desired options, and finally calling\n   * {@link #create()}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setVersion(double)",
        "snippet": "  public GsonBuilder setVersion(double ignoreVersionsAfter) {\n    excluder = excluder.withVersion(ignoreVersionsAfter);\n    return this;\n  }",
        "begin_line": 114,
        "end_line": 117,
        "comment": "\n   * Configures Gson to enable versioning support.\n   *\n   * @param ignoreVersionsAfter any field or type marked with a version higher than this value\n   * are ignored during serialization or deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.excludeFieldsWithModifiers(int...)",
        "snippet": "  public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n    excluder = excluder.withModifiers(modifiers);\n    return this;\n  }",
        "begin_line": 130,
        "end_line": 133,
        "comment": "\n   * Configures Gson to excludes all class fields that have the specified modifiers. By default,\n   * Gson will exclude all fields marked transient or static. This method will override that\n   * behavior.\n   *\n   * @param modifiers the field modifiers. You must use the modifiers specified in the\n   * {@link java.lang.reflect.Modifier} class. For example,\n   * {@link java.lang.reflect.Modifier#TRANSIENT},\n   * {@link java.lang.reflect.Modifier#STATIC}.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.generateNonExecutableJson()",
        "snippet": "  public GsonBuilder generateNonExecutableJson() {\n    this.generateNonExecutableJson = true;\n    return this;\n  }",
        "begin_line": 144,
        "end_line": 147,
        "comment": "\n   * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\n   * special text. This prevents attacks from third-party sites through script sourcing. See\n   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a>\n   * for details.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.excludeFieldsWithoutExposeAnnotation()",
        "snippet": "  public GsonBuilder excludeFieldsWithoutExposeAnnotation() {\n    excluder = excluder.excludeFieldsWithoutExposeAnnotation();\n    return this;\n  }",
        "begin_line": 155,
        "end_line": 158,
        "comment": "\n   * Configures Gson to exclude all fields from consideration for serialization or deserialization\n   * that do not have the {@link com.google.gson.annotations.Expose} annotation.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.serializeNulls()",
        "snippet": "  public GsonBuilder serializeNulls() {\n    this.serializeNulls = true;\n    return this;\n  }",
        "begin_line": 167,
        "end_line": 170,
        "comment": "\n   * Configure Gson to serialize null fields. By default, Gson omits all fields that are null\n   * during serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.enableComplexMapKeySerialization()",
        "snippet": "  public GsonBuilder enableComplexMapKeySerialization() {\n    complexMapKeySerialization = true;\n    return this;\n  }",
        "begin_line": 248,
        "end_line": 251,
        "comment": "\n   * Enabling this feature will only change the serialized form if the map key is\n   * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON\n   * form. The default implementation of map serialization uses {@code toString()}\n   * on the key; however, when this is called then one of the following cases\n   * apply:\n   *\n   * <h3>Maps as JSON objects</h3>\n   * For this case, assume that a type adapter is registered to serialize and\n   * deserialize some {@code Point} class, which contains an x and y coordinate,\n   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would\n   * then be serialized as a {@link JsonObject}.\n   *\n   * <p>Below is an example:\n   * <pre>  {@code\n   *   Gson gson = new GsonBuilder()\n   *       .register(Point.class, new MyPointTypeAdapter())\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }</pre>\n   * The above code prints this JSON object:<pre>  {@code\n   *   {\n   *     \"(5,6)\": \"a\",\n   *     \"(8,8)\": \"b\"\n   *   }\n   * }</pre>\n   *\n   * <h3>Maps as JSON arrays</h3>\n   * For this case, assume that a type adapter was NOT registered for some\n   * {@code Point} class, but rather the default Gson serialization is applied.\n   * In this case, some {@code new Point(2,3)} would serialize as {@code\n   * {\"x\":2,\"y\":5}}.\n   *\n   * <p>Given the assumption above, a {@code Map<Point, String>} will be\n   * serialize as an array of arrays (can be viewed as an entry set of pairs).\n   *\n   * <p>Below is an example of serializing complex types as JSON arrays:\n   * <pre> {@code\n   *   Gson gson = new GsonBuilder()\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<Point, String>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }\n   *\n   * The JSON output would look as follows:\n   * <pre>   {@code\n   *   [\n   *     [\n   *       {\n   *         \"x\": 5,\n   *         \"y\": 6\n   *       },\n   *       \"a\"\n   *     ],\n   *     [\n   *       {\n   *         \"x\": 8,\n   *         \"y\": 8\n   *       },\n   *       \"b\"\n   *     ]\n   *   ]\n   * }</pre>\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.disableInnerClassSerialization()",
        "snippet": "  public GsonBuilder disableInnerClassSerialization() {\n    excluder = excluder.disableInnerClassSerialization();\n    return this;\n  }",
        "begin_line": 259,
        "end_line": 262,
        "comment": "\n   * Configures Gson to exclude inner classes during serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setLongSerializationPolicy(com.google.gson.LongSerializationPolicy)",
        "snippet": "  public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\n    this.longSerializationPolicy = serializationPolicy;\n    return this;\n  }",
        "begin_line": 272,
        "end_line": 275,
        "comment": "\n   * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\n   * objects.\n   *\n   * @param serializationPolicy the particular policy to use for serializing longs.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)",
        "snippet": "  public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\n    this.fieldNamingPolicy = namingConvention;\n    return this;\n  }",
        "begin_line": 285,
        "end_line": 288,
        "comment": "\n   * Configures Gson to apply a specific naming policy to an object's field during serialization\n   * and deserialization.\n   *\n   * @param namingConvention the JSON field naming convention to use for serialization and\n   * deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setFieldNamingStrategy(com.google.gson.FieldNamingStrategy)",
        "snippet": "  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n    this.fieldNamingPolicy = fieldNamingStrategy;\n    return this;\n  }",
        "begin_line": 298,
        "end_line": 301,
        "comment": "\n   * Configures Gson to apply a specific naming policy strategy to an object's field during\n   * serialization and deserialization.\n   *\n   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setExclusionStrategies(com.google.gson.ExclusionStrategy...)",
        "snippet": "  public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\n    for (ExclusionStrategy strategy : strategies) {\n      excluder = excluder.withExclusionStrategy(strategy, true, true);\n    }\n    return this;\n  }",
        "begin_line": 313,
        "end_line": 318,
        "comment": "\n   * Configures Gson to apply a set of exclusion strategies during both serialization and\n   * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.\n   * This means that if one of the {@code strategies} suggests that a field (or class) should be\n   * skipped then that field (or object) is skipped during serialization/deserialization.\n   *\n   * @param strategies the set of strategy object to apply during object (de)serialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.addSerializationExclusionStrategy(com.google.gson.ExclusionStrategy)",
        "snippet": "  public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\n    excluder = excluder.withExclusionStrategy(strategy, true, false);\n    return this;\n  }",
        "begin_line": 332,
        "end_line": 335,
        "comment": "\n   * Configures Gson to apply the passed in exclusion strategy during serialization.\n   * If this method is invoked numerous times with different exclusion strategy objects\n   * then the exclusion strategies that were added will be applied as a disjunction rule.\n   * This means that if one of the added exclusion strategies suggests that a field (or\n   * class) should be skipped then that field (or object) is skipped during its\n   * serialization.\n   *\n   * @param strategy an exclusion strategy to apply during serialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.addDeserializationExclusionStrategy(com.google.gson.ExclusionStrategy)",
        "snippet": "  public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\n    excluder = excluder.withExclusionStrategy(strategy, false, true);\n    return this;\n  }",
        "begin_line": 349,
        "end_line": 352,
        "comment": "\n   * Configures Gson to apply the passed in exclusion strategy during deserialization.\n   * If this method is invoked numerous times with different exclusion strategy objects\n   * then the exclusion strategies that were added will be applied as a disjunction rule.\n   * This means that if one of the added exclusion strategies suggests that a field (or\n   * class) should be skipped then that field (or object) is skipped during its\n   * deserialization.\n   *\n   * @param strategy an exclusion strategy to apply during deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setPrettyPrinting()",
        "snippet": "  public GsonBuilder setPrettyPrinting() {\n    prettyPrinting = true;\n    return this;\n  }",
        "begin_line": 360,
        "end_line": 363,
        "comment": "\n   * Configures Gson to output Json that fits in a page for pretty printing. This option only\n   * affects Json serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setLenient()",
        "snippet": "  public GsonBuilder setLenient() {\n    lenient = true;\n    return this;\n  }",
        "begin_line": 373,
        "end_line": 376,
        "comment": "\n   * By default, Gson is strict and only accepts JSON as specified by\n   * <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. This option makes the parser\n   * liberal in what it accepts.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @see JsonReader#setLenient(boolean)\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.disableHtmlEscaping()",
        "snippet": "  public GsonBuilder disableHtmlEscaping() {\n    this.escapeHtmlChars = false;\n    return this;\n  }",
        "begin_line": 385,
        "end_line": 388,
        "comment": "\n   * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\n   * Gson to pass-through HTML characters as is.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setDateFormat(java.lang.String)",
        "snippet": "  public GsonBuilder setDateFormat(String pattern) {\n    // TODO(Joel): Make this fail fast if it is an invalid date format\n    this.datePattern = pattern;\n    return this;\n  }",
        "begin_line": 406,
        "end_line": 410,
        "comment": "\n   * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can\n   * call this method or {@link #setDateFormat(int)} multiple times, but only the last invocation\n   * will be used to decide the serialization format.\n   *\n   * <p>The date format will be used to serialize and deserialize {@link java.util.Date}, {@link\n   * java.sql.Timestamp} and {@link java.sql.Date}.\n   *\n   * <p>Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}\n   * class. See the documentation in {@link java.text.SimpleDateFormat} for more information on\n   * valid date and time patterns.</p>\n   *\n   * @param pattern the pattern that dates will be serialized/deserialized to/from\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setDateFormat(int)",
        "snippet": "  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n  }",
        "begin_line": 426,
        "end_line": 430,
        "comment": "\n   * Configures Gson to to serialize {@code Date} objects according to the style value provided.\n   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n   * invocation will be used to decide the serialization format.\n   *\n   * <p>Note that this style value should be one of the predefined constants in the\n   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\n   * information on the valid style constants.</p>\n   *\n   * @param style the predefined date style that date objects will be serialized/deserialized\n   * to/from\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.setDateFormat(int, int)",
        "snippet": "  public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {\n    this.dateStyle = dateStyle;\n    this.timeStyle = timeStyle;\n    this.datePattern = null;\n    return this;\n  }",
        "begin_line": 447,
        "end_line": 452,
        "comment": "\n   * Configures Gson to to serialize {@code Date} objects according to the style value provided.\n   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n   * invocation will be used to decide the serialization format.\n   *\n   * <p>Note that this style value should be one of the predefined constants in the\n   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\n   * information on the valid style constants.</p>\n   *\n   * @param dateStyle the predefined date style that date objects will be serialized/deserialized\n   * to/from\n   * @param timeStyle the predefined style for the time portion of the date objects\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.registerTypeAdapter(java.lang.reflect.Type, java.lang.Object)",
        "snippet": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n        || typeAdapter instanceof JsonDeserializer<?>\n        || typeAdapter instanceof InstanceCreator<?>\n        || typeAdapter instanceof TypeAdapter<?>);\n    if (typeAdapter instanceof InstanceCreator<?>) {\n      instanceCreators.put(type, (InstanceCreator) typeAdapter);\n    }\n    if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\n      TypeToken<?> typeToken = TypeToken.get(type);\n      factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\n    }\n    if (typeAdapter instanceof TypeAdapter<?>) {\n      factories.add(TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter)typeAdapter));\n    }\n    return this;\n  }",
        "begin_line": 470,
        "end_line": 487,
        "comment": "\n   * Configures Gson for custom serialization or deserialization. This method combines the\n   * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a\n   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\n   * all the required interfaces for custom serialization with Gson. If a type adapter was\n   * previously registered for the specified {@code type}, it is overwritten.\n   *\n   * <p>This registers the type specified and no other types: you must manually register related\n   * types! For example, applications registering {@code boolean.class} should also register {@code\n   * Boolean.class}.\n   *\n   * @param type the type definition for the type adapter being registered\n   * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},\n   * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.registerTypeAdapterFactory(com.google.gson.TypeAdapterFactory)",
        "snippet": "  public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\n    factories.add(factory);\n    return this;\n  }",
        "begin_line": 497,
        "end_line": 500,
        "comment": "\n   * Register a factory for type adapters. Registering a factory is useful when the type\n   * adapter needs to be configured based on the type of the field being processed. Gson\n   * is designed to handle a large number of factories, so you should consider registering\n   * them to be at par with registering an individual type adapter.\n   *\n   * @since 2.1\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.registerTypeHierarchyAdapter(java.lang.Class<?>, java.lang.Object)",
        "snippet": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n        || typeAdapter instanceof JsonDeserializer<?>\n        || typeAdapter instanceof TypeAdapter<?>);\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\n      hierarchyFactories.add(0,\n          TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\n    }\n    if (typeAdapter instanceof TypeAdapter<?>) {\n      factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));\n    }\n    return this;\n  }",
        "begin_line": 516,
        "end_line": 529,
        "comment": "\n   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n   * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and\n   * a {@link JsonDeserializer}. If a type adapter was previously registered for the specified\n   * type hierarchy, it is overridden. If a type adapter is registered for a specific type in\n   * the type hierarchy, it will be invoked instead of the one registered for the type hierarchy.\n   *\n   * @param baseType the class definition for the type adapter being registered for the base class\n   *        or interface\n   * @param typeAdapter This object must implement at least one of {@link TypeAdapter},\n   *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.serializeSpecialFloatingPointValues()",
        "snippet": "  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }",
        "begin_line": 551,
        "end_line": 554,
        "comment": "\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.create()",
        "snippet": "  public Gson create() {\n    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n    factories.addAll(this.factories);\n    Collections.reverse(factories);\n    factories.addAll(this.hierarchyFactories);\n    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\n\n    return new Gson(excluder, fieldNamingPolicy, instanceCreators,\n        serializeNulls, complexMapKeySerialization,\n        generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,\n        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);\n  }",
        "begin_line": 562,
        "end_line": 573,
        "comment": "\n   * Creates a {@link Gson} instance based on the current configuration. This method is free of\n   * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n   *\n   * @return an instance of Gson configured with the options currently set in this builder\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/GsonBuilder.java",
        "class_name": "com.google.gson.GsonBuilder",
        "signature": "com.google.gson.GsonBuilder.addTypeAdaptersForDate(java.lang.String, int, int, java.util.List<com.google.gson.TypeAdapterFactory>)",
        "snippet": "  private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n      List<TypeAdapterFactory> factories) {\n    DefaultDateTypeAdapter dateTypeAdapter;\n    if (datePattern != null && !\"\".equals(datePattern.trim())) {\n      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n    } else {\n      return;\n    }\n\n    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));\n    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));\n    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));\n  }",
        "begin_line": 575,
        "end_line": 589,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonNull.java",
        "class_name": "com.google.gson.JsonNull",
        "signature": "com.google.gson.JsonNull.JsonNull()",
        "snippet": "  @Deprecated\n  public JsonNull() {\n    // Do nothing\n  }",
        "begin_line": 38,
        "end_line": 41,
        "comment": "\r\n   * Creates a new JsonNull object.\r\n   * Deprecated since Gson version 1.8. Use {@link #INSTANCE} instead\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonNull.java",
        "class_name": "com.google.gson.JsonNull",
        "signature": "com.google.gson.JsonNull.deepCopy()",
        "snippet": "  @Override\n  JsonNull deepCopy() {\n    return INSTANCE;\n  }",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonNull.java",
        "class_name": "com.google.gson.JsonNull",
        "signature": "com.google.gson.JsonNull.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return JsonNull.class.hashCode();\n  }",
        "begin_line": 51,
        "end_line": 54,
        "comment": "\r\n   * All instances of JsonNull have the same hash code since they are indistinguishable\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonNull.java",
        "class_name": "com.google.gson.JsonNull",
        "signature": "com.google.gson.JsonNull.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object other) {\n    return this == other || other instanceof JsonNull;\n  }",
        "begin_line": 59,
        "end_line": 62,
        "comment": "\r\n   * All instances of JsonNull are the same\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/TypeAdapterFactory.java",
        "class_name": "com.google.gson.TypeAdapterFactory",
        "signature": "com.google.gson.TypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);",
        "begin_line": 169,
        "end_line": 169,
        "comment": "\n   * Returns a type adapter for {@code type}, or null if this factory doesn't\n   * support {@code type}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.FieldAttributes(java.lang.reflect.Field)",
        "snippet": "  public FieldAttributes(Field f) {\n    $Gson$Preconditions.checkNotNull(f);\n    this.field = f;\n  }",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n   * Constructs a Field Attributes object from the {@code f}.\n   *\n   * @param f the field to pull attributes from\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getDeclaringClass()",
        "snippet": "  public Class<?> getDeclaringClass() {\n    return field.getDeclaringClass();\n  }",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n   * @return the declaring class that contains this field\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getName()",
        "snippet": "  public String getName() {\n    return field.getName();\n  }",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n   * @return the name of the field\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getDeclaredType()",
        "snippet": "  public Type getDeclaredType() {\n    return field.getGenericType();\n  }",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getDeclaredClass()",
        "snippet": "  public Class<?> getDeclaredClass() {\n    return field.getType();\n  }",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n   * Returns the {@code Class} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getAnnotation(java.lang.Class<T>)",
        "snippet": "  public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n    return field.getAnnotation(annotation);\n  }",
        "begin_line": 110,
        "end_line": 112,
        "comment": "\n   * Return the {@code T} annotation object from this field if it exist; otherwise returns\n   * {@code null}.\n   *\n   * @param annotation the class of the annotation that will be retrieved\n   * @return the annotation instance if it is bound to the field; otherwise {@code null}\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.getAnnotations()",
        "snippet": "  public Collection<Annotation> getAnnotations() {\n    return Arrays.asList(field.getAnnotations());\n  }",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n   * Return the annotations that are present on this field.\n   *\n   * @return an array of all the annotations set on the field\n   * @since 1.4\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.hasModifier(int)",
        "snippet": "  public boolean hasModifier(int modifier) {\n    return (field.getModifiers() & modifier) != 0;\n  }",
        "begin_line": 134,
        "end_line": 136,
        "comment": "\n   * Returns {@code true} if the field is defined with the {@code modifier}.\n   *\n   * <p>This method is meant to be called as:\n   * <pre class=\"code\">\n   * boolean hasPublicModifier = fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);\n   * </pre>\n   *\n   * @see java.lang.reflect.Modifier\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.get(java.lang.Object)",
        "snippet": "  Object get(Object instance) throws IllegalAccessException {\n    return field.get(instance);\n  }",
        "begin_line": 145,
        "end_line": 147,
        "comment": "\n   * This is exposed internally only for the removing synthetic fields from the JSON output.\n   *\n   * @return true if the field is synthetic; otherwise false\n   * @throws IllegalAccessException\n   * @throws IllegalArgumentException\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldAttributes.java",
        "class_name": "com.google.gson.FieldAttributes",
        "signature": "com.google.gson.FieldAttributes.isSynthetic()",
        "snippet": "  boolean isSynthetic() {\n    return field.isSynthetic();\n  }",
        "begin_line": 154,
        "end_line": 156,
        "comment": "\n   * This is exposed internally only for the removing synthetic fields from the JSON output.\n   *\n   * @return true if the field is synthetic; otherwise false\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSyntaxException.java",
        "class_name": "com.google.gson.JsonSyntaxException",
        "signature": "com.google.gson.JsonSyntaxException.JsonSyntaxException(java.lang.String)",
        "snippet": "  public JsonSyntaxException(String msg) {\n    super(msg);\n  }",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSyntaxException.java",
        "class_name": "com.google.gson.JsonSyntaxException",
        "signature": "com.google.gson.JsonSyntaxException.JsonSyntaxException(java.lang.String, java.lang.Throwable)",
        "snippet": "  public JsonSyntaxException(String msg, Throwable cause) {\n    super(msg, cause);\n  }",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/JsonSyntaxException.java",
        "class_name": "com.google.gson.JsonSyntaxException",
        "signature": "com.google.gson.JsonSyntaxException.JsonSyntaxException(java.lang.Throwable)",
        "snippet": "  public JsonSyntaxException(Throwable cause) {\n    super(cause);\n  }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n   * Creates exception with the specified cause. Consider using\n   * {@link #JsonSyntaxException(String, Throwable)} instead if you can\n   * describe what actually happened.\n   *\n   * @param cause root exception that caused this exception to be thrown.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/FieldNamingStrategy.java",
        "class_name": "com.google.gson.FieldNamingStrategy",
        "signature": "com.google.gson.FieldNamingStrategy.translateName(java.lang.reflect.Field)",
        "snippet": "  public String translateName(Field f);",
        "begin_line": 39,
        "end_line": 39,
        "comment": "\n   * Translates the field name into its JSON field name representation.\n   *\n   * @param f the field object that we are translating\n   * @return the translated field name.\n   * @since 1.3\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.LazilyParsedNumber(java.lang.String)",
        "snippet": "  public LazilyParsedNumber(String value) {\n    this.value = value;\n  }",
        "begin_line": 30,
        "end_line": 32,
        "comment": " @param value must not be null ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.intValue()",
        "snippet": "  @Override\n  public int intValue() {\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException e) {\n      try {\n        return (int) Long.parseLong(value);\n      } catch (NumberFormatException nfe) {\n        return new BigDecimal(value).intValue();\n      }\n    }\n  }",
        "begin_line": 34,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.longValue()",
        "snippet": "  @Override\n  public long longValue() {\n    try {\n      return Long.parseLong(value);\n    } catch (NumberFormatException e) {\n      return new BigDecimal(value).longValue();\n    }\n  }",
        "begin_line": 47,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.floatValue()",
        "snippet": "  @Override\n  public float floatValue() {\n    return Float.parseFloat(value);\n  }",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.doubleValue()",
        "snippet": "  @Override\n  public double doubleValue() {\n    return Double.parseDouble(value);\n  }",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return value;\n  }",
        "begin_line": 66,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.writeReplace()",
        "snippet": "  private Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n  }",
        "begin_line": 76,
        "end_line": 78,
        "comment": "\n   * If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a BigDecimal so that they won't need Gson on the other side to\n   * deserialize it.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return value.hashCode();\n  }",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
        "class_name": "com.google.gson.internal.LazilyParsedNumber",
        "signature": "com.google.gson.internal.LazilyParsedNumber.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj instanceof LazilyParsedNumber) {\n      LazilyParsedNumber other = (LazilyParsedNumber) obj;\n      return value == other.value || value.equals(other.value);\n    }\n    return false;\n  }",
        "begin_line": 85,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.Primitives()",
        "snippet": "  private Primitives() {\n    throw new UnsupportedOperationException();\n  }",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.add(java.util.Map<java.lang.Class<?>, java.lang.Class<?>>, java.util.Map<java.lang.Class<?>, java.lang.Class<?>>, java.lang.Class<?>, java.lang.Class<?>)",
        "snippet": "  private static void add(Map<Class<?>, Class<?>> forward,\n      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n    forward.put(key, value);\n    backward.put(value, key);\n  }",
        "begin_line": 62,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.isPrimitive(java.lang.reflect.Type)",
        "snippet": "  public static boolean isPrimitive(Type type) {\n    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n  }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n   * Returns true if this type is a primitive.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.isWrapperType(java.lang.reflect.Type)",
        "snippet": "  public static boolean isWrapperType(Type type) {\n    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n        $Gson$Preconditions.checkNotNull(type));\n  }",
        "begin_line": 81,
        "end_line": 84,
        "comment": "\n   * Returns {@code true} if {@code type} is one of the nine\n   * primitive-wrapper types, such as {@link Integer}.\n   *\n   * @see Class#isPrimitive\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.wrap(java.lang.Class<T>)",
        "snippet": "  public static <T> Class<T> wrap(Class<T> type) {\n    // cast is safe: long.class and Long.class are both of type Class<Long>\n    @SuppressWarnings(\"unchecked\")\n    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n        $Gson$Preconditions.checkNotNull(type));\n    return (wrapped == null) ? type : wrapped;\n  }",
        "begin_line": 95,
        "end_line": 101,
        "comment": "\n   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n   * type; otherwise returns {@code type} itself. Idempotent.\n   * <pre>\n   *     wrap(int.class) == Integer.class\n   *     wrap(Integer.class) == Integer.class\n   *     wrap(String.class) == String.class\n   * </pre>\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Primitives.java",
        "class_name": "com.google.gson.internal.Primitives",
        "signature": "com.google.gson.internal.Primitives.unwrap(java.lang.Class<T>)",
        "snippet": "  public static <T> Class<T> unwrap(Class<T> type) {\n    // cast is safe: long.class and Long.class are both of type Class<Long>\n    @SuppressWarnings(\"unchecked\")\n    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n        $Gson$Preconditions.checkNotNull(type));\n    return (unwrapped == null) ? type : unwrapped;\n  }",
        "begin_line": 112,
        "end_line": 118,
        "comment": "\n   * Returns the corresponding primitive type of {@code type} if it is a\n   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n   * <pre>\n   *     unwrap(Integer.class) == int.class\n   *     unwrap(int.class) == int.class\n   *     unwrap(String.class) == String.class\n   * </pre>\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.clone()",
        "snippet": "  @Override protected Excluder clone() {\n    try {\n      return (Excluder) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError(e);\n    }\n  }",
        "begin_line": 61,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.withVersion(double)",
        "snippet": "  public Excluder withVersion(double ignoreVersionsAfter) {\n    Excluder result = clone();\n    result.version = ignoreVersionsAfter;\n    return result;\n  }",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.withModifiers(int...)",
        "snippet": "  public Excluder withModifiers(int... modifiers) {\n    Excluder result = clone();\n    result.modifiers = 0;\n    for (int modifier : modifiers) {\n      result.modifiers |= modifier;\n    }\n    return result;\n  }",
        "begin_line": 75,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.disableInnerClassSerialization()",
        "snippet": "  public Excluder disableInnerClassSerialization() {\n    Excluder result = clone();\n    result.serializeInnerClasses = false;\n    return result;\n  }",
        "begin_line": 84,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.excludeFieldsWithoutExposeAnnotation()",
        "snippet": "  public Excluder excludeFieldsWithoutExposeAnnotation() {\n    Excluder result = clone();\n    result.requireExpose = true;\n    return result;\n  }",
        "begin_line": 90,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.withExclusionStrategy(com.google.gson.ExclusionStrategy, boolean, boolean)",
        "snippet": "  public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,\n      boolean serialization, boolean deserialization) {\n    Excluder result = clone();\n    if (serialization) {\n      result.serializationStrategies = new ArrayList<ExclusionStrategy>(serializationStrategies);\n      result.serializationStrategies.add(exclusionStrategy);\n    }\n    if (deserialization) {\n      result.deserializationStrategies\n          = new ArrayList<ExclusionStrategy>(deserializationStrategies);\n      result.deserializationStrategies.add(exclusionStrategy);\n    }\n    return result;\n  }",
        "begin_line": 96,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\n    Class<?> rawType = type.getRawType();\n    final boolean skipSerialize = excludeClass(rawType, true);\n    final boolean skipDeserialize = excludeClass(rawType, false);\n\n    if (!skipSerialize && !skipDeserialize) {\n      return null;\n    }\n\n    return new TypeAdapter<T>() {\n      /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n      private TypeAdapter<T> delegate;\n\n      @Override public T read(JsonReader in) throws IOException {\n        if (skipDeserialize) {\n          in.skipValue();\n          return null;\n        }\n        return delegate().read(in);\n      }\n\n      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (skipSerialize) {\n          out.nullValue();\n          return;\n        }\n        delegate().write(out, value);\n      }\n\n      private TypeAdapter<T> delegate() {\n        TypeAdapter<T> d = delegate;\n        return d != null\n            ? d\n            : (delegate = gson.getDelegateAdapter(Excluder.this, type));\n      }\n    };\n  }",
        "begin_line": 111,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.Anonymous-839be528-ae0b-425f-84dc-7c482dda1bb5.read(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public T read(JsonReader in) throws IOException {\n        if (skipDeserialize) {\n          in.skipValue();\n          return null;\n        }\n        return delegate().read(in);\n      }",
        "begin_line": 124,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.Anonymous-05421831-0ccf-4633-9058-580aefb8c399.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "      @Override public void write(JsonWriter out, T value) throws IOException {\n        if (skipSerialize) {\n          out.nullValue();\n          return;\n        }\n        delegate().write(out, value);\n      }",
        "begin_line": 132,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.Anonymous-c67c5ac9-a40f-4583-a4f0-9e149d390caa.delegate()",
        "snippet": "      private TypeAdapter<T> delegate() {\n        TypeAdapter<T> d = delegate;\n        return d != null\n            ? d\n            : (delegate = gson.getDelegateAdapter(Excluder.this, type));\n      }",
        "begin_line": 140,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.excludeField(java.lang.reflect.Field, boolean)",
        "snippet": "  public boolean excludeField(Field field, boolean serialize) {\n    if ((modifiers & field.getModifiers()) != 0) {\n      return true;\n    }\n\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (field.isSynthetic()) {\n      return true;\n    }\n\n    if (requireExpose) {\n      Expose annotation = field.getAnnotation(Expose.class);\n      if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\n        return true;\n      }\n    }\n\n    if (!serializeInnerClasses && isInnerClass(field.getType())) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(field.getType())) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    if (!list.isEmpty()) {\n      FieldAttributes fieldAttributes = new FieldAttributes(field);\n      for (ExclusionStrategy exclusionStrategy : list) {\n        if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
        "begin_line": 149,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.excludeClass(java.lang.Class<?>, boolean)",
        "snippet": "  public boolean excludeClass(Class<?> clazz, boolean serialize) {\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses && isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
        "begin_line": 191,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isAnonymousOrLocal(java.lang.Class<?>)",
        "snippet": "  private boolean isAnonymousOrLocal(Class<?> clazz) {\n    return !Enum.class.isAssignableFrom(clazz)\n        && (clazz.isAnonymousClass() || clazz.isLocalClass());\n  }",
        "begin_line": 215,
        "end_line": 218,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isInnerClass(java.lang.Class<?>)",
        "snippet": "  private boolean isInnerClass(Class<?> clazz) {\n    return clazz.isMemberClass() && !isStatic(clazz);\n  }",
        "begin_line": 220,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isStatic(java.lang.Class<?>)",
        "snippet": "  private boolean isStatic(Class<?> clazz) {\n    return (clazz.getModifiers() & Modifier.STATIC) != 0;\n  }",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isValidVersion(com.google.gson.annotations.Since, com.google.gson.annotations.Until)",
        "snippet": "  private boolean isValidVersion(Since since, Until until) {\n    return isValidSince(since) && isValidUntil(until);\n  }",
        "begin_line": 228,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isValidSince(com.google.gson.annotations.Since)",
        "snippet": "  private boolean isValidSince(Since annotation) {\n    if (annotation != null) {\n      double annotationVersion = annotation.value();\n      if (annotationVersion > version) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "begin_line": 232,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Excluder.java",
        "class_name": "com.google.gson.internal.Excluder",
        "signature": "com.google.gson.internal.Excluder.isValidUntil(com.google.gson.annotations.Until)",
        "snippet": "  private boolean isValidUntil(Until annotation) {\n    if (annotation != null) {\n      double annotationVersion = annotation.value();\n      if (annotationVersion <= version) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "begin_line": 242,
        "end_line": 250,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ObjectConstructor.java",
        "class_name": "com.google.gson.internal.ObjectConstructor",
        "signature": "com.google.gson.internal.ObjectConstructor.construct()",
        "snippet": "  public T construct();",
        "begin_line": 32,
        "end_line": 32,
        "comment": "\n   * Returns a new instance.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Anonymous-404b87b8-26ab-45a5-aaa2-063b54f995e9.compare(java.lang.Comparable, java.lang.Comparable)",
        "snippet": "    public int compare(Comparable a, Comparable b) {\n      return a.compareTo(b);\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMap()",
        "snippet": "  @SuppressWarnings(\"unchecked\") // unsafe! this assumes K is comparable\n  public LinkedTreeMap() {\n    this((Comparator<? super K>) NATURAL_ORDER);\n  }",
        "begin_line": 58,
        "end_line": 61,
        "comment": "\n   * Create a natural order, empty tree map whose keys must be mutually\n   * comparable and non-null.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMap(java.util.Comparator<? super K>)",
        "snippet": "  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // unsafe! if comparator is null, this assumes K is comparable\n  public LinkedTreeMap(Comparator<? super K> comparator) {\n    this.comparator = comparator != null\n        ? comparator\n        : (Comparator) NATURAL_ORDER;\n  }",
        "begin_line": 70,
        "end_line": 75,
        "comment": "\n   * Create a tree map ordered by {@code comparator}. This map's keys may only\n   * be null if {@code comparator} permits.\n   *\n   * @param comparator the comparator to order elements with, or {@code null} to\n   *     use the natural ordering.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.size()",
        "snippet": "  @Override public int size() {\n    return size;\n  }",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.get(java.lang.Object)",
        "snippet": "  @Override public V get(Object key) {\n    Node<K, V> node = findByObject(key);\n    return node != null ? node.value : null;\n  }",
        "begin_line": 81,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.containsKey(java.lang.Object)",
        "snippet": "  @Override public boolean containsKey(Object key) {\n    return findByObject(key) != null;\n  }",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.put(K, V)",
        "snippet": "  @Override public V put(K key, V value) {\n    if (key == null) {\n      throw new NullPointerException(\"key == null\");\n    }\n    Node<K, V> created = find(key, true);\n    V result = created.value;\n    created.value = value;\n    return result;\n  }",
        "begin_line": 90,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.clear()",
        "snippet": "  @Override public void clear() {\n    root = null;\n    size = 0;\n    modCount++;\n\n    // Clear iteration order\n    Node<K, V> header = this.header;\n    header.next = header.prev = header;\n  }",
        "begin_line": 100,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.remove(java.lang.Object)",
        "snippet": "  @Override public V remove(Object key) {\n    Node<K, V> node = removeInternalByKey(key);\n    return node != null ? node.value : null;\n  }",
        "begin_line": 110,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.find(K, boolean)",
        "snippet": "  Node<K, V> find(K key, boolean create) {\n    Comparator<? super K> comparator = this.comparator;\n    Node<K, V> nearest = root;\n    int comparison = 0;\n\n    if (nearest != null) {\n      // Micro-optimization: avoid polymorphic calls to Comparator.compare().\n      @SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\n          Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n          ? (Comparable<Object>) key\n          : null;\n\n      while (true) {\n        comparison = (comparableKey != null)\n            ? comparableKey.compareTo(nearest.key)\n            : comparator.compare(key, nearest.key);\n\n        // We found the requested key.\n        if (comparison == 0) {\n          return nearest;\n        }\n\n        // If it exists, the key is in a subtree. Go deeper.\n        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\n        if (child == null) {\n          break;\n        }\n\n        nearest = child;\n      }\n    }\n\n    // The key doesn't exist in this tree.\n    if (!create) {\n      return null;\n    }\n\n    // Create the node and add it to the tree or the table.\n    Node<K, V> header = this.header;\n    Node<K, V> created;\n    if (nearest == null) {\n      // Check that the value is comparable if we didn't do any comparisons.\n      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\n        throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n      }\n      created = new Node<K, V>(nearest, key, header, header.prev);\n      root = created;\n    } else {\n      created = new Node<K, V>(nearest, key, header, header.prev);\n      if (comparison < 0) { // nearest.key is higher\n        nearest.left = created;\n      } else { // comparison > 0, nearest.key is lower\n        nearest.right = created;\n      }\n      rebalance(nearest, true);\n    }\n    size++;\n    modCount++;\n\n    return created;\n  }",
        "begin_line": 121,
        "end_line": 181,
        "comment": "\n   * Returns the node at or adjacent to the given key, creating it if requested.\n   *\n   * @throws ClassCastException if {@code key} and the tree's keys aren't\n   *     mutually comparable.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.findByObject(java.lang.Object)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  Node<K, V> findByObject(Object key) {\n    try {\n      return key != null ? find((K) key, false) : null;\n    } catch (ClassCastException e) {\n      return null;\n    }\n  }",
        "begin_line": 183,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.findByEntry(java.util.Map.Entry<?, ?>)",
        "snippet": "  Node<K, V> findByEntry(Entry<?, ?> entry) {\n    Node<K, V> mine = findByObject(entry.getKey());\n    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\n    return valuesEqual ? mine : null;\n  }",
        "begin_line": 201,
        "end_line": 205,
        "comment": "\n   * Returns this map's entry that has the same key and value as {@code\n   * entry}, or null if this map has no such entry.\n   *\n   * <p>This method uses the comparator for key equality rather than {@code\n   * equals}. If this map's comparator isn't consistent with equals (such as\n   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\n   * contains()} will violate the collections API.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.equal(java.lang.Object, java.lang.Object)",
        "snippet": "  private boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.removeInternal(com.google.gson.internal.LinkedTreeMap.Node<K, V>, boolean)",
        "snippet": "  void removeInternal(Node<K, V> node, boolean unlink) {\n    if (unlink) {\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n    }\n\n    Node<K, V> left = node.left;\n    Node<K, V> right = node.right;\n    Node<K, V> originalParent = node.parent;\n    if (left != null && right != null) {\n\n      /*\n       * To remove a node with both left and right subtrees, move an\n       * adjacent node from one of those subtrees into this node's place.\n       *\n       * Removing the adjacent node may change this node's subtrees. This\n       * node may no longer have two subtrees once the adjacent node is\n       * gone!\n       */\n\n      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\n      removeInternal(adjacent, false); // takes care of rebalance and size--\n\n      int leftHeight = 0;\n      left = node.left;\n      if (left != null) {\n        leftHeight = left.height;\n        adjacent.left = left;\n        left.parent = adjacent;\n        node.left = null;\n      }\n\n      int rightHeight = 0;\n      right = node.right;\n      if (right != null) {\n        rightHeight = right.height;\n        adjacent.right = right;\n        right.parent = adjacent;\n        node.right = null;\n      }\n\n      adjacent.height = Math.max(leftHeight, rightHeight) + 1;\n      replaceInParent(node, adjacent);\n      return;\n    } else if (left != null) {\n      replaceInParent(node, left);\n      node.left = null;\n    } else if (right != null) {\n      replaceInParent(node, right);\n      node.right = null;\n    } else {\n      replaceInParent(node, null);\n    }\n\n    rebalance(originalParent, false);\n    size--;\n    modCount++;\n  }",
        "begin_line": 217,
        "end_line": 274,
        "comment": "\n   * Removes {@code node} from this tree, rearranging the tree's structure as\n   * necessary.\n   *\n   * @param unlink true to also unlink this node from the iteration linked list.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.removeInternalByKey(java.lang.Object)",
        "snippet": "  Node<K, V> removeInternalByKey(Object key) {\n    Node<K, V> node = findByObject(key);\n    if (node != null) {\n      removeInternal(node, true);\n    }\n    return node;\n  }",
        "begin_line": 276,
        "end_line": 282,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.replaceInParent(com.google.gson.internal.LinkedTreeMap.Node<K, V>, com.google.gson.internal.LinkedTreeMap.Node<K, V>)",
        "snippet": "  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\n    Node<K, V> parent = node.parent;\n    node.parent = null;\n    if (replacement != null) {\n      replacement.parent = parent;\n    }\n\n    if (parent != null) {\n      if (parent.left == node) {\n        parent.left = replacement;\n      } else {\n        assert (parent.right == node);\n        parent.right = replacement;\n      }\n    } else {\n      root = replacement;\n    }\n  }",
        "begin_line": 284,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.rebalance(com.google.gson.internal.LinkedTreeMap.Node<K, V>, boolean)",
        "snippet": "  private void rebalance(Node<K, V> unbalanced, boolean insert) {\n    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\n      Node<K, V> left = node.left;\n      Node<K, V> right = node.right;\n      int leftHeight = left != null ? left.height : 0;\n      int rightHeight = right != null ? right.height : 0;\n\n      int delta = leftHeight - rightHeight;\n      if (delta == -2) {\n        Node<K, V> rightLeft = right.left;\n        Node<K, V> rightRight = right.right;\n        int rightRightHeight = rightRight != null ? rightRight.height : 0;\n        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\n\n        int rightDelta = rightLeftHeight - rightRightHeight;\n        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\n          rotateLeft(node); // AVL right right\n        } else {\n          assert (rightDelta == 1);\n          rotateRight(right); // AVL right left\n          rotateLeft(node);\n        }\n        if (insert) {\n          break; // no further rotations will be necessary\n        }\n\n      } else if (delta == 2) {\n        Node<K, V> leftLeft = left.left;\n        Node<K, V> leftRight = left.right;\n        int leftRightHeight = leftRight != null ? leftRight.height : 0;\n        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\n\n        int leftDelta = leftLeftHeight - leftRightHeight;\n        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\n          rotateRight(node); // AVL left left\n        } else {\n          assert (leftDelta == -1);\n          rotateLeft(left); // AVL left right\n          rotateRight(node);\n        }\n        if (insert) {\n          break; // no further rotations will be necessary\n        }\n\n      } else if (delta == 0) {\n        node.height = leftHeight + 1; // leftHeight == rightHeight\n        if (insert) {\n          break; // the insert caused balance, so rebalancing is done!\n        }\n\n      } else {\n        assert (delta == -1 || delta == 1);\n        node.height = Math.max(leftHeight, rightHeight) + 1;\n        if (!insert) {\n          break; // the height hasn't changed, so rebalancing is done!\n        }\n      }\n    }\n  }",
        "begin_line": 310,
        "end_line": 368,
        "comment": "\n   * Rebalances the tree by making any AVL rotations necessary between the\n   * newly-unbalanced node and the tree's root.\n   *\n   * @param insert true if the node was unbalanced by an insert; false if it\n   *     was by a removal.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.rotateLeft(com.google.gson.internal.LinkedTreeMap.Node<K, V>)",
        "snippet": "  private void rotateLeft(Node<K, V> root) {\n    Node<K, V> left = root.left;\n    Node<K, V> pivot = root.right;\n    Node<K, V> pivotLeft = pivot.left;\n    Node<K, V> pivotRight = pivot.right;\n\n    // move the pivot's left child to the root's right\n    root.right = pivotLeft;\n    if (pivotLeft != null) {\n      pivotLeft.parent = root;\n    }\n\n    replaceInParent(root, pivot);\n\n    // move the root to the pivot's left\n    pivot.left = root;\n    root.parent = pivot;\n\n    // fix heights\n    root.height = Math.max(left != null ? left.height : 0,\n        pivotLeft != null ? pivotLeft.height : 0) + 1;\n    pivot.height = Math.max(root.height,\n        pivotRight != null ? pivotRight.height : 0) + 1;\n  }",
        "begin_line": 373,
        "end_line": 396,
        "comment": "\n   * Rotates the subtree so that its root's right child is the new root.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.rotateRight(com.google.gson.internal.LinkedTreeMap.Node<K, V>)",
        "snippet": "  private void rotateRight(Node<K, V> root) {\n    Node<K, V> pivot = root.left;\n    Node<K, V> right = root.right;\n    Node<K, V> pivotLeft = pivot.left;\n    Node<K, V> pivotRight = pivot.right;\n\n    // move the pivot's right child to the root's left\n    root.left = pivotRight;\n    if (pivotRight != null) {\n      pivotRight.parent = root;\n    }\n\n    replaceInParent(root, pivot);\n\n    // move the root to the pivot's right\n    pivot.right = root;\n    root.parent = pivot;\n\n    // fixup heights\n    root.height = Math.max(right != null ? right.height : 0,\n        pivotRight != null ? pivotRight.height : 0) + 1;\n    pivot.height = Math.max(root.height,\n        pivotLeft != null ? pivotLeft.height : 0) + 1;\n  }",
        "begin_line": 401,
        "end_line": 424,
        "comment": "\n   * Rotates the subtree so that its root's left child is the new root.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.entrySet()",
        "snippet": "  @Override public Set<Entry<K, V>> entrySet() {\n    EntrySet result = entrySet;\n    return result != null ? result : (entrySet = new EntrySet());\n  }",
        "begin_line": 429,
        "end_line": 432,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.keySet()",
        "snippet": "  @Override public Set<K> keySet() {\n    KeySet result = keySet;\n    return result != null ? result : (keySet = new KeySet());\n  }",
        "begin_line": 434,
        "end_line": 437,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.Node()",
        "snippet": "    Node() {\n      key = null;\n      next = prev = this;\n    }",
        "begin_line": 450,
        "end_line": 453,
        "comment": " Create the header entry ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.Node(com.google.gson.internal.LinkedTreeMap.Node<K, V>, K, com.google.gson.internal.LinkedTreeMap.Node<K, V>, com.google.gson.internal.LinkedTreeMap.Node<K, V>)",
        "snippet": "    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\n      this.parent = parent;\n      this.key = key;\n      this.height = 1;\n      this.next = next;\n      this.prev = prev;\n      prev.next = this;\n      next.prev = this;\n    }",
        "begin_line": 456,
        "end_line": 464,
        "comment": " Create a regular entry ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.getKey()",
        "snippet": "    public K getKey() {\n      return key;\n    }",
        "begin_line": 466,
        "end_line": 468,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.getValue()",
        "snippet": "    public V getValue() {\n      return value;\n    }",
        "begin_line": 470,
        "end_line": 472,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.setValue(V)",
        "snippet": "    public V setValue(V value) {\n      V oldValue = this.value;\n      this.value = value;\n      return oldValue;\n    }",
        "begin_line": 474,
        "end_line": 478,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.equals(java.lang.Object)",
        "snippet": "    @SuppressWarnings(\"rawtypes\")\n    @Override public boolean equals(Object o) {\n      if (o instanceof Entry) {\n        Entry other = (Entry) o;\n        return (key == null ? other.getKey() == null : key.equals(other.getKey()))\n            && (value == null ? other.getValue() == null : value.equals(other.getValue()));\n      }\n      return false;\n    }",
        "begin_line": 480,
        "end_line": 488,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.hashCode()",
        "snippet": "    @Override public int hashCode() {\n      return (key == null ? 0 : key.hashCode())\n          ^ (value == null ? 0 : value.hashCode());\n    }",
        "begin_line": 490,
        "end_line": 493,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.toString()",
        "snippet": "    @Override public String toString() {\n      return key + \"=\" + value;\n    }",
        "begin_line": 495,
        "end_line": 497,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.first()",
        "snippet": "    public Node<K, V> first() {\n      Node<K, V> node = this;\n      Node<K, V> child = node.left;\n      while (child != null) {\n        node = child;\n        child = node.left;\n      }\n      return node;\n    }",
        "begin_line": 502,
        "end_line": 510,
        "comment": "\n     * Returns the first node in this subtree.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.Node.last()",
        "snippet": "    public Node<K, V> last() {\n      Node<K, V> node = this;\n      Node<K, V> child = node.right;\n      while (child != null) {\n        node = child;\n        child = node.right;\n      }\n      return node;\n    }",
        "begin_line": 515,
        "end_line": 523,
        "comment": "\n     * Returns the last node in this subtree.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator.LinkedTreeMapIterator()",
        "snippet": "    LinkedTreeMapIterator() {\n    }",
        "begin_line": 531,
        "end_line": 532,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator.hasNext()",
        "snippet": "    public final boolean hasNext() {\n      return next != header;\n    }",
        "begin_line": 534,
        "end_line": 536,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator.nextNode()",
        "snippet": "    final Node<K, V> nextNode() {\n      Node<K, V> e = next;\n      if (e == header) {\n        throw new NoSuchElementException();\n      }\n      if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n      }\n      next = e.next;\n      return lastReturned = e;\n    }",
        "begin_line": 538,
        "end_line": 548,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.LinkedTreeMapIterator.remove()",
        "snippet": "    public final void remove() {\n      if (lastReturned == null) {\n        throw new IllegalStateException();\n      }\n      removeInternal(lastReturned, true);\n      lastReturned = null;\n      expectedModCount = modCount;\n    }",
        "begin_line": 550,
        "end_line": 557,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.size()",
        "snippet": "    @Override public int size() {\n      return size;\n    }",
        "begin_line": 561,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.iterator()",
        "snippet": "    @Override public Iterator<Entry<K, V>> iterator() {\n      return new LinkedTreeMapIterator<Entry<K, V>>() {\n        public Entry<K, V> next() {\n          return nextNode();\n        }\n      };\n    }",
        "begin_line": 565,
        "end_line": 571,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.Anonymous-da03e6c4-1acc-4067-9347-2ffd48bdea21.next()",
        "snippet": "        public Entry<K, V> next() {\n          return nextNode();\n        }",
        "begin_line": 567,
        "end_line": 569,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.contains(java.lang.Object)",
        "snippet": "    @Override public boolean contains(Object o) {\n      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;\n    }",
        "begin_line": 573,
        "end_line": 575,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.remove(java.lang.Object)",
        "snippet": "    @Override public boolean remove(Object o) {\n      if (!(o instanceof Entry)) {\n        return false;\n      }\n\n      Node<K, V> node = findByEntry((Entry<?, ?>) o);\n      if (node == null) {\n        return false;\n      }\n      removeInternal(node, true);\n      return true;\n    }",
        "begin_line": 577,
        "end_line": 588,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.EntrySet.clear()",
        "snippet": "    @Override public void clear() {\n      LinkedTreeMap.this.clear();\n    }",
        "begin_line": 590,
        "end_line": 592,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.size()",
        "snippet": "    @Override public int size() {\n      return size;\n    }",
        "begin_line": 596,
        "end_line": 598,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.iterator()",
        "snippet": "    @Override public Iterator<K> iterator() {\n      return new LinkedTreeMapIterator<K>() {\n        public K next() {\n          return nextNode().key;\n        }\n      };\n    }",
        "begin_line": 600,
        "end_line": 606,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.Anonymous-85ab3cc0-ecec-49cb-8ae9-4a51eb91c1b2.next()",
        "snippet": "        public K next() {\n          return nextNode().key;\n        }",
        "begin_line": 602,
        "end_line": 604,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.contains(java.lang.Object)",
        "snippet": "    @Override public boolean contains(Object o) {\n      return containsKey(o);\n    }",
        "begin_line": 608,
        "end_line": 610,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.remove(java.lang.Object)",
        "snippet": "    @Override public boolean remove(Object key) {\n      return removeInternalByKey(key) != null;\n    }",
        "begin_line": 612,
        "end_line": 614,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.KeySet.clear()",
        "snippet": "    @Override public void clear() {\n      LinkedTreeMap.this.clear();\n    }",
        "begin_line": 616,
        "end_line": 618,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedTreeMap",
        "signature": "com.google.gson.internal.LinkedTreeMap.writeReplace()",
        "snippet": "  private Object writeReplace() throws ObjectStreamException {\n    return new LinkedHashMap<K, V>(this);\n  }",
        "begin_line": 627,
        "end_line": 629,
        "comment": "\n   * If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a LinkedHashMap so that they won't need Gson on the other side to\n   * deserialize it. Using serialization defeats our DoS defence, so most apps\n   * shouldn't use it.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.Streams()",
        "snippet": "  private Streams() {\n    throw new UnsupportedOperationException();\n  }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.parse(com.google.gson.stream.JsonReader)",
        "snippet": "  public static JsonElement parse(JsonReader reader) throws JsonParseException {\n    boolean isEmpty = true;\n    try {\n      reader.peek();\n      isEmpty = false;\n      return TypeAdapters.JSON_ELEMENT.read(reader);\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\n       * empty documents instead of throwing.\n       */\n      if (isEmpty) {\n        return JsonNull.INSTANCE;\n      }\n      // The stream ended prematurely so it is likely a syntax error.\n      throw new JsonSyntaxException(e);\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
        "begin_line": 43,
        "end_line": 66,
        "comment": "\n   * Takes a reader in any state and returns the next value as a JsonElement.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.write(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
        "snippet": "  public static void write(JsonElement element, JsonWriter writer) throws IOException {\n    TypeAdapters.JSON_ELEMENT.write(writer, element);\n  }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n   * Writes the JSON element to the writer, recursively.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.writerForAppendable(java.lang.Appendable)",
        "snippet": "  @SuppressWarnings(\"resource\")\n  public static Writer writerForAppendable(Appendable appendable) {\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n  }",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.AppendableWriter(java.lang.Appendable)",
        "snippet": "    AppendableWriter(Appendable appendable) {\n      this.appendable = appendable;\n    }",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.write(char[], int, int)",
        "snippet": "    @Override public void write(char[] chars, int offset, int length) throws IOException {\n      currentWrite.chars = chars;\n      appendable.append(currentWrite, offset, offset + length);\n    }",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.write(int)",
        "snippet": "    @Override public void write(int i) throws IOException {\n      appendable.append((char) i);\n    }",
        "begin_line": 97,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.flush()",
        "snippet": "    @Override public void flush() {}",
        "begin_line": 101,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.close()",
        "snippet": "    @Override public void close() {}",
        "begin_line": 102,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite.length()",
        "snippet": "      public int length() {\n        return chars.length;\n      }",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite.charAt(int)",
        "snippet": "      public char charAt(int i) {\n        return chars[i];\n      }",
        "begin_line": 112,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/Streams.java",
        "class_name": "com.google.gson.internal.Streams",
        "signature": "com.google.gson.internal.Streams.AppendableWriter.CurrentWrite.subSequence(int, int)",
        "snippet": "      public CharSequence subSequence(int start, int end) {\n        return new String(chars, start, end - start);\n      }",
        "begin_line": 115,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.newInstance(java.lang.Class<T>)",
        "snippet": "  public abstract <T> T newInstance(Class<T> c) throws Exception;",
        "begin_line": 32,
        "end_line": 32,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.create()",
        "snippet": "  public static UnsafeAllocator create() {\n    // try JVM\n    // public class Unsafe {\n    //   public Object allocateInstance(Class<?> type);\n    // }\n    try {\n      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n      f.setAccessible(true);\n      final Object unsafe = f.get(null);\n      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) allocateInstance.invoke(unsafe, c);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, post-gingerbread\n    // public class ObjectStreamClass {\n    //   private static native int getConstructorId(Class<?> c);\n    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n    // }\n    try {\n      Method getConstructorId = ObjectStreamClass.class\n          .getDeclaredMethod(\"getConstructorId\", Class.class);\n      getConstructorId.setAccessible(true);\n      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n      final Method newInstance = ObjectStreamClass.class\n          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, constructorId);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, pre-gingerbread\n    // public class ObjectInputStream {\n    //   private static native Object newInstance(\n    //     Class<?> instantiationClass, Class<?> constructorClass);\n    // }\n    try {\n      final Method newInstance = ObjectInputStream.class\n          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, Object.class);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // give up\n    return new UnsafeAllocator() {\n      @Override\n      public <T> T newInstance(Class<T> c) {\n        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n      }\n    };\n  }",
        "begin_line": 34,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.Anonymous-e47f4b74-e0dd-429a-a7cf-4223d616b9bc.newInstance(java.lang.Class<T>)",
        "snippet": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) allocateInstance.invoke(unsafe, c);\n        }",
        "begin_line": 46,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.Anonymous-3ec856bd-3af7-4951-8b20-d9670386b049.newInstance(java.lang.Class<T>)",
        "snippet": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, constructorId);\n        }",
        "begin_line": 70,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.Anonymous-c3ed4ce6-e251-49fa-9904-17a80dd65a60.newInstance(java.lang.Class<T>)",
        "snippet": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, Object.class);\n        }",
        "begin_line": 90,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.Anonymous-ef6bd0d3-8e59-48c8-bd95-02bcce5fbdcb.newInstance(java.lang.Class<T>)",
        "snippet": "      @Override\n      public <T> T newInstance(Class<T> c) {\n        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n      }",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
        "class_name": "com.google.gson.internal.UnsafeAllocator",
        "signature": "com.google.gson.internal.UnsafeAllocator.assertInstantiable(java.lang.Class<?>)",
        "snippet": "  private static void assertInstantiable(Class<?> c) {\n    int modifiers = c.getModifiers();\n    if (Modifier.isInterface(modifiers)) {\n      throw new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n    }\n    if (Modifier.isAbstract(modifiers)) {\n      throw new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n    }\n  }",
        "begin_line": 114,
        "end_line": 122,
        "comment": "\n   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers\n   * throw an {@link java.lang.UnsupportedOperationException}\n   * @param c instance of the class to be checked\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/JsonReaderInternalAccess.java",
        "class_name": "com.google.gson.internal.JsonReaderInternalAccess",
        "signature": "com.google.gson.internal.JsonReaderInternalAccess.promoteNameToValue(com.google.gson.stream.JsonReader)",
        "snippet": "  public abstract void promoteNameToValue(JsonReader reader) throws IOException;",
        "begin_line": 31,
        "end_line": 31,
        "comment": "\n   * Changes the type of the current property name token to a string value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Anonymous-73d22fe1-aa4a-4fba-866e-c3242200c17b.compare(java.lang.Comparable, java.lang.Comparable)",
        "snippet": "    public int compare(Comparable a, Comparable b) {\n      return a.compareTo(b);\n    }",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedHashTreeMap()",
        "snippet": "  @SuppressWarnings(\"unchecked\") // unsafe! this assumes K is comparable\n  public LinkedHashTreeMap() {\n    this((Comparator<? super K>) NATURAL_ORDER);\n  }",
        "begin_line": 59,
        "end_line": 62,
        "comment": "\n   * Create a natural order, empty tree map whose keys must be mutually\n   * comparable and non-null.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedHashTreeMap(java.util.Comparator<? super K>)",
        "snippet": "  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // unsafe! if comparator is null, this assumes K is comparable\n  public LinkedHashTreeMap(Comparator<? super K> comparator) {\n    this.comparator = comparator != null\n        ? comparator\n        : (Comparator) NATURAL_ORDER;\n    this.header = new Node<K, V>();\n    this.table = new Node[16]; // TODO: sizing/resizing policies\n    this.threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity\n  }",
        "begin_line": 71,
        "end_line": 79,
        "comment": "\n   * Create a tree map ordered by {@code comparator}. This map's keys may only\n   * be null if {@code comparator} permits.\n   *\n   * @param comparator the comparator to order elements with, or {@code null} to\n   *     use the natural ordering.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.size()",
        "snippet": "  @Override public int size() {\n    return size;\n  }",
        "begin_line": 81,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.get(java.lang.Object)",
        "snippet": "  @Override public V get(Object key) {\n    Node<K, V> node = findByObject(key);\n    return node != null ? node.value : null;\n  }",
        "begin_line": 85,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.containsKey(java.lang.Object)",
        "snippet": "  @Override public boolean containsKey(Object key) {\n    return findByObject(key) != null;\n  }",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.put(K, V)",
        "snippet": "  @Override public V put(K key, V value) {\n    if (key == null) {\n      throw new NullPointerException(\"key == null\");\n    }\n    Node<K, V> created = find(key, true);\n    V result = created.value;\n    created.value = value;\n    return result;\n  }",
        "begin_line": 94,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.clear()",
        "snippet": "  @Override public void clear() {\n    Arrays.fill(table, null);\n    size = 0;\n    modCount++;\n\n    // Clear all links to help GC\n    Node<K, V> header = this.header;\n    for (Node<K, V> e = header.next; e != header; ) {\n      Node<K, V> next = e.next;\n      e.next = e.prev = null;\n      e = next;\n    }\n\n    header.next = header.prev = header;\n  }",
        "begin_line": 104,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.remove(java.lang.Object)",
        "snippet": "  @Override public V remove(Object key) {\n    Node<K, V> node = removeInternalByKey(key);\n    return node != null ? node.value : null;\n  }",
        "begin_line": 120,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.find(K, boolean)",
        "snippet": "  Node<K, V> find(K key, boolean create) {\n    Comparator<? super K> comparator = this.comparator;\n    Node<K, V>[] table = this.table;\n    int hash = secondaryHash(key.hashCode());\n    int index = hash & (table.length - 1);\n    Node<K, V> nearest = table[index];\n    int comparison = 0;\n\n    if (nearest != null) {\n      // Micro-optimization: avoid polymorphic calls to Comparator.compare().\n      @SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\n      Comparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n          ? (Comparable<Object>) key\n          : null;\n\n      while (true) {\n        comparison = (comparableKey != null)\n            ? comparableKey.compareTo(nearest.key)\n            : comparator.compare(key, nearest.key);\n\n        // We found the requested key.\n        if (comparison == 0) {\n          return nearest;\n        }\n\n        // If it exists, the key is in a subtree. Go deeper.\n        Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\n        if (child == null) {\n          break;\n        }\n\n        nearest = child;\n      }\n    }\n\n    // The key doesn't exist in this tree.\n    if (!create) {\n      return null;\n    }\n\n    // Create the node and add it to the tree or the table.\n    Node<K, V> header = this.header;\n    Node<K, V> created;\n    if (nearest == null) {\n      // Check that the value is comparable if we didn't do any comparisons.\n      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\n        throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n      }\n      created = new Node<K, V>(nearest, key, hash, header, header.prev);\n      table[index] = created;\n    } else {\n      created = new Node<K, V>(nearest, key, hash, header, header.prev);\n      if (comparison < 0) { // nearest.key is higher\n        nearest.left = created;\n      } else { // comparison > 0, nearest.key is lower\n        nearest.right = created;\n      }\n      rebalance(nearest, true);\n    }\n\n    if (size++ > threshold) {\n      doubleCapacity();\n    }\n    modCount++;\n\n    return created;\n  }",
        "begin_line": 131,
        "end_line": 197,
        "comment": "\n   * Returns the node at or adjacent to the given key, creating it if requested.\n   *\n   * @throws ClassCastException if {@code key} and the tree's keys aren't\n   *     mutually comparable.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.findByObject(java.lang.Object)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  Node<K, V> findByObject(Object key) {\n    try {\n      return key != null ? find((K) key, false) : null;\n    } catch (ClassCastException e) {\n      return null;\n    }\n  }",
        "begin_line": 199,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.findByEntry(java.util.Map.Entry<?, ?>)",
        "snippet": "  Node<K, V> findByEntry(Entry<?, ?> entry) {\n    Node<K, V> mine = findByObject(entry.getKey());\n    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\n    return valuesEqual ? mine : null;\n  }",
        "begin_line": 217,
        "end_line": 221,
        "comment": "\n   * Returns this map's entry that has the same key and value as {@code\n   * entry}, or null if this map has no such entry.\n   *\n   * <p>This method uses the comparator for key equality rather than {@code\n   * equals}. If this map's comparator isn't consistent with equals (such as\n   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\n   * contains()} will violate the collections API.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.equal(java.lang.Object, java.lang.Object)",
        "snippet": "  private boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }",
        "begin_line": 223,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.secondaryHash(int)",
        "snippet": "  private static int secondaryHash(int h) {\n    // Doug Lea's supplemental hash function\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n  }",
        "begin_line": 233,
        "end_line": 237,
        "comment": "\n   * Applies a supplemental hash function to a given hashCode, which defends\n   * against poor quality hash functions. This is critical because HashMap\n   * uses power-of-two length hash tables, that otherwise encounter collisions\n   * for hashCodes that do not differ in lower or upper bits.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.removeInternal(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>, boolean)",
        "snippet": "  void removeInternal(Node<K, V> node, boolean unlink) {\n    if (unlink) {\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n      node.next = node.prev = null; // Help the GC (for performance)\n    }\n\n    Node<K, V> left = node.left;\n    Node<K, V> right = node.right;\n    Node<K, V> originalParent = node.parent;\n    if (left != null && right != null) {\n\n      /*\n       * To remove a node with both left and right subtrees, move an\n       * adjacent node from one of those subtrees into this node's place.\n       *\n       * Removing the adjacent node may change this node's subtrees. This\n       * node may no longer have two subtrees once the adjacent node is\n       * gone!\n       */\n\n      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\n      removeInternal(adjacent, false); // takes care of rebalance and size--\n\n      int leftHeight = 0;\n      left = node.left;\n      if (left != null) {\n        leftHeight = left.height;\n        adjacent.left = left;\n        left.parent = adjacent;\n        node.left = null;\n      }\n      int rightHeight = 0;\n      right = node.right;\n      if (right != null) {\n        rightHeight = right.height;\n        adjacent.right = right;\n        right.parent = adjacent;\n        node.right = null;\n      }\n      adjacent.height = Math.max(leftHeight, rightHeight) + 1;\n      replaceInParent(node, adjacent);\n      return;\n    } else if (left != null) {\n      replaceInParent(node, left);\n      node.left = null;\n    } else if (right != null) {\n      replaceInParent(node, right);\n      node.right = null;\n    } else {\n      replaceInParent(node, null);\n    }\n\n    rebalance(originalParent, false);\n    size--;\n    modCount++;\n  }",
        "begin_line": 245,
        "end_line": 301,
        "comment": "\n   * Removes {@code node} from this tree, rearranging the tree's structure as\n   * necessary.\n   *\n   * @param unlink true to also unlink this node from the iteration linked list.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.removeInternalByKey(java.lang.Object)",
        "snippet": "  Node<K, V> removeInternalByKey(Object key) {\n    Node<K, V> node = findByObject(key);\n    if (node != null) {\n      removeInternal(node, true);\n    }\n    return node;\n  }",
        "begin_line": 303,
        "end_line": 309,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.replaceInParent(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>, com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\n    Node<K, V> parent = node.parent;\n    node.parent = null;\n    if (replacement != null) {\n      replacement.parent = parent;\n    }\n\n    if (parent != null) {\n      if (parent.left == node) {\n        parent.left = replacement;\n      } else {\n        assert (parent.right == node);\n        parent.right = replacement;\n      }\n    } else {\n      int index = node.hash & (table.length - 1);\n      table[index] = replacement;\n    }\n  }",
        "begin_line": 311,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.rebalance(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>, boolean)",
        "snippet": "  private void rebalance(Node<K, V> unbalanced, boolean insert) {\n    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\n      Node<K, V> left = node.left;\n      Node<K, V> right = node.right;\n      int leftHeight = left != null ? left.height : 0;\n      int rightHeight = right != null ? right.height : 0;\n\n      int delta = leftHeight - rightHeight;\n      if (delta == -2) {\n        Node<K, V> rightLeft = right.left;\n        Node<K, V> rightRight = right.right;\n        int rightRightHeight = rightRight != null ? rightRight.height : 0;\n        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\n\n        int rightDelta = rightLeftHeight - rightRightHeight;\n        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\n          rotateLeft(node); // AVL right right\n        } else {\n          assert (rightDelta == 1);\n          rotateRight(right); // AVL right left\n          rotateLeft(node);\n        }\n        if (insert) {\n          break; // no further rotations will be necessary\n        }\n\n      } else if (delta == 2) {\n        Node<K, V> leftLeft = left.left;\n        Node<K, V> leftRight = left.right;\n        int leftRightHeight = leftRight != null ? leftRight.height : 0;\n        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\n\n        int leftDelta = leftLeftHeight - leftRightHeight;\n        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\n          rotateRight(node); // AVL left left\n        } else {\n          assert (leftDelta == -1);\n          rotateLeft(left); // AVL left right\n          rotateRight(node);\n        }\n        if (insert) {\n          break; // no further rotations will be necessary\n        }\n\n      } else if (delta == 0) {\n        node.height = leftHeight + 1; // leftHeight == rightHeight\n        if (insert) {\n          break; // the insert caused balance, so rebalancing is done!\n        }\n\n      } else {\n        assert (delta == -1 || delta == 1);\n        node.height = Math.max(leftHeight, rightHeight) + 1;\n        if (!insert) {\n          break; // the height hasn't changed, so rebalancing is done!\n        }\n      }\n    }\n  }",
        "begin_line": 338,
        "end_line": 396,
        "comment": "\n   * Rebalances the tree by making any AVL rotations necessary between the\n   * newly-unbalanced node and the tree's root.\n   *\n   * @param insert true if the node was unbalanced by an insert; false if it\n   *     was by a removal.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.rotateLeft(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "  private void rotateLeft(Node<K, V> root) {\n    Node<K, V> left = root.left;\n    Node<K, V> pivot = root.right;\n    Node<K, V> pivotLeft = pivot.left;\n    Node<K, V> pivotRight = pivot.right;\n\n    // move the pivot's left child to the root's right\n    root.right = pivotLeft;\n    if (pivotLeft != null) {\n      pivotLeft.parent = root;\n    }\n\n    replaceInParent(root, pivot);\n\n    // move the root to the pivot's left\n    pivot.left = root;\n    root.parent = pivot;\n\n    // fix heights\n    root.height = Math.max(left != null ? left.height : 0,\n        pivotLeft != null ? pivotLeft.height : 0) + 1;\n    pivot.height = Math.max(root.height,\n        pivotRight != null ? pivotRight.height : 0) + 1;\n  }",
        "begin_line": 401,
        "end_line": 424,
        "comment": "\n   * Rotates the subtree so that its root's right child is the new root.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.rotateRight(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "  private void rotateRight(Node<K, V> root) {\n    Node<K, V> pivot = root.left;\n    Node<K, V> right = root.right;\n    Node<K, V> pivotLeft = pivot.left;\n    Node<K, V> pivotRight = pivot.right;\n\n    // move the pivot's right child to the root's left\n    root.left = pivotRight;\n    if (pivotRight != null) {\n      pivotRight.parent = root;\n    }\n\n    replaceInParent(root, pivot);\n\n    // move the root to the pivot's right\n    pivot.right = root;\n    root.parent = pivot;\n\n    // fixup heights\n    root.height = Math.max(right != null ? right.height : 0,\n        pivotRight != null ? pivotRight.height : 0) + 1;\n    pivot.height = Math.max(root.height,\n        pivotLeft != null ? pivotLeft.height : 0) + 1;\n  }",
        "begin_line": 429,
        "end_line": 452,
        "comment": "\n   * Rotates the subtree so that its root's left child is the new root.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.entrySet()",
        "snippet": "  @Override public Set<Entry<K, V>> entrySet() {\n    EntrySet result = entrySet;\n    return result != null ? result : (entrySet = new EntrySet());\n  }",
        "begin_line": 457,
        "end_line": 460,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.keySet()",
        "snippet": "  @Override public Set<K> keySet() {\n    KeySet result = keySet;\n    return result != null ? result : (keySet = new KeySet());\n  }",
        "begin_line": 462,
        "end_line": 465,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.Node()",
        "snippet": "    Node() {\n      key = null;\n      hash = -1;\n      next = prev = this;\n    }",
        "begin_line": 479,
        "end_line": 483,
        "comment": " Create the header entry ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.Node(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>, K, int, com.google.gson.internal.LinkedHashTreeMap.Node<K, V>, com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "    Node(Node<K, V> parent, K key, int hash, Node<K, V> next, Node<K, V> prev) {\n      this.parent = parent;\n      this.key = key;\n      this.hash = hash;\n      this.height = 1;\n      this.next = next;\n      this.prev = prev;\n      prev.next = this;\n      next.prev = this;\n    }",
        "begin_line": 486,
        "end_line": 495,
        "comment": " Create a regular entry ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.getKey()",
        "snippet": "    public K getKey() {\n      return key;\n    }",
        "begin_line": 497,
        "end_line": 499,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.getValue()",
        "snippet": "    public V getValue() {\n      return value;\n    }",
        "begin_line": 501,
        "end_line": 503,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.setValue(V)",
        "snippet": "    public V setValue(V value) {\n      V oldValue = this.value;\n      this.value = value;\n      return oldValue;\n    }",
        "begin_line": 505,
        "end_line": 509,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.equals(java.lang.Object)",
        "snippet": "    @SuppressWarnings(\"rawtypes\")\n    @Override public boolean equals(Object o) {\n      if (o instanceof Entry) {\n        Entry other = (Entry) o;\n        return (key == null ? other.getKey() == null : key.equals(other.getKey()))\n            && (value == null ? other.getValue() == null : value.equals(other.getValue()));\n      }\n      return false;\n    }",
        "begin_line": 511,
        "end_line": 519,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.hashCode()",
        "snippet": "    @Override public int hashCode() {\n      return (key == null ? 0 : key.hashCode())\n          ^ (value == null ? 0 : value.hashCode());\n    }",
        "begin_line": 521,
        "end_line": 524,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.toString()",
        "snippet": "    @Override public String toString() {\n      return key + \"=\" + value;\n    }",
        "begin_line": 526,
        "end_line": 528,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.first()",
        "snippet": "    public Node<K, V> first() {\n      Node<K, V> node = this;\n      Node<K, V> child = node.left;\n      while (child != null) {\n        node = child;\n        child = node.left;\n      }\n      return node;\n    }",
        "begin_line": 533,
        "end_line": 541,
        "comment": "\n     * Returns the first node in this subtree.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.Node.last()",
        "snippet": "    public Node<K, V> last() {\n      Node<K, V> node = this;\n      Node<K, V> child = node.right;\n      while (child != null) {\n        node = child;\n        child = node.right;\n      }\n      return node;\n    }",
        "begin_line": 546,
        "end_line": 554,
        "comment": "\n     * Returns the last node in this subtree.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.doubleCapacity()",
        "snippet": "  private void doubleCapacity() {\n    table = doubleCapacity(table);\n    threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity\n  }",
        "begin_line": 557,
        "end_line": 560,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.doubleCapacity(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>[])",
        "snippet": "  static <K, V> Node<K, V>[] doubleCapacity(Node<K, V>[] oldTable) {\n    // TODO: don't do anything if we're already at MAX_CAPACITY\n    int oldCapacity = oldTable.length;\n    @SuppressWarnings(\"unchecked\") // Arrays and generics don't get along.\n    Node<K, V>[] newTable = new Node[oldCapacity * 2];\n    AvlIterator<K, V> iterator = new AvlIterator<K, V>();\n    AvlBuilder<K, V> leftBuilder = new AvlBuilder<K, V>();\n    AvlBuilder<K, V> rightBuilder = new AvlBuilder<K, V>();\n\n    // Split each tree into two trees.\n    for (int i = 0; i < oldCapacity; i++) {\n      Node<K, V> root = oldTable[i];\n      if (root == null) {\n        continue;\n      }\n\n      // Compute the sizes of the left and right trees.\n      iterator.reset(root);\n      int leftSize = 0;\n      int rightSize = 0;\n      for (Node<K, V> node; (node = iterator.next()) != null; ) {\n        if ((node.hash & oldCapacity) == 0) {\n          leftSize++;\n        } else {\n          rightSize++;\n        }\n      }\n\n      // Split the tree into two.\n      leftBuilder.reset(leftSize);\n      rightBuilder.reset(rightSize);\n      iterator.reset(root);\n      for (Node<K, V> node; (node = iterator.next()) != null; ) {\n        if ((node.hash & oldCapacity) == 0) {\n          leftBuilder.add(node);\n        } else {\n          rightBuilder.add(node);\n        }\n      }\n\n      // Populate the enlarged array with these new roots.\n      newTable[i] = leftSize > 0 ? leftBuilder.root() : null;\n      newTable[i + oldCapacity] = rightSize > 0 ? rightBuilder.root() : null;\n    }\n    return newTable;\n  }",
        "begin_line": 566,
        "end_line": 611,
        "comment": "\n   * Returns a new array containing the same nodes as {@code oldTable}, but with\n   * twice as many trees, each of (approximately) half the previous size.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.AvlIterator.reset(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "    void reset(Node<K, V> root) {\n      Node<K, V> stackTop = null;\n      for (Node<K, V> n = root; n != null; n = n.left) {\n        n.parent = stackTop;\n        stackTop = n; // Stack push.\n      }\n      this.stackTop = stackTop;\n    }",
        "begin_line": 626,
        "end_line": 633,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.AvlIterator.next()",
        "snippet": "    public Node<K, V> next() {\n      Node<K, V> stackTop = this.stackTop;\n      if (stackTop == null) {\n        return null;\n      }\n      Node<K, V> result = stackTop;\n      stackTop = result.parent;\n      result.parent = null;\n      for (Node<K, V> n = result.right; n != null; n = n.left) {\n        n.parent = stackTop;\n        stackTop = n; // Stack push.\n      }\n      this.stackTop = stackTop;\n      return result;\n    }",
        "begin_line": 635,
        "end_line": 649,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.AvlBuilder.reset(int)",
        "snippet": "    void reset(int targetSize) {\n      // compute the target tree size. This is a power of 2 minus one, like 15 or 31.\n      int treeCapacity = Integer.highestOneBit(targetSize) * 2 - 1;\n      leavesToSkip = treeCapacity - targetSize;\n      size = 0;\n      leavesSkipped = 0;\n      stack = null;\n    }",
        "begin_line": 677,
        "end_line": 684,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.AvlBuilder.add(com.google.gson.internal.LinkedHashTreeMap.Node<K, V>)",
        "snippet": "    void add(Node<K, V> node) {\n      node.left = node.parent = node.right = null;\n      node.height = 1;\n\n      // Skip a leaf if necessary.\n      if (leavesToSkip > 0 && (size & 1) == 0) {\n        size++;\n        leavesToSkip--;\n        leavesSkipped++;\n      }\n\n      node.parent = stack;\n      stack = node; // Stack push.\n      size++;\n\n      // Skip a leaf if necessary.\n      if (leavesToSkip > 0 && (size & 1) == 0) {\n        size++;\n        leavesToSkip--;\n        leavesSkipped++;\n      }\n\n      /*\n       * Combine 3 nodes into subtrees whenever the size is one less than a\n       * multiple of 4. For example we combine the nodes A, B, C into a\n       * 3-element tree with B as the root.\n       *\n       * Combine two subtrees and a spare single value whenever the size is one\n       * less than a multiple of 8. For example at 8 we may combine subtrees\n       * (A B C) and (E F G) with D as the root to form ((A B C) D (E F G)).\n       *\n       * Just as we combine single nodes when size nears a multiple of 4, and\n       * 3-element trees when size nears a multiple of 8, we combine subtrees of\n       * size (N-1) whenever the total size is 2N-1 whenever N is a power of 2.\n       */\n      for (int scale = 4; (size & scale - 1) == scale - 1; scale *= 2) {\n        if (leavesSkipped == 0) {\n          // Pop right, center and left, then make center the top of the stack.\n          Node<K, V> right = stack;\n          Node<K, V> center = right.parent;\n          Node<K, V> left = center.parent;\n          center.parent = left.parent;\n          stack = center;\n          // Construct a tree.\n          center.left = left;\n          center.right = right;\n          center.height = right.height + 1;\n          left.parent = center;\n          right.parent = center;\n        } else if (leavesSkipped == 1) {\n          // Pop right and center, then make center the top of the stack.\n          Node<K, V> right = stack;\n          Node<K, V> center = right.parent;\n          stack = center;\n          // Construct a tree with no left child.\n          center.right = right;\n          center.height = right.height + 1;\n          right.parent = center;\n          leavesSkipped = 0;\n        } else if (leavesSkipped == 2) {\n          leavesSkipped = 0;\n        }\n      }\n    }",
        "begin_line": 686,
        "end_line": 749,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.AvlBuilder.root()",
        "snippet": "    Node<K, V> root() {\n      Node<K, V> stackTop = this.stack;\n      if (stackTop.parent != null) {\n        throw new IllegalStateException();\n      }\n      return stackTop;\n    }",
        "begin_line": 751,
        "end_line": 757,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedTreeMapIterator.LinkedTreeMapIterator()",
        "snippet": "    LinkedTreeMapIterator() {\n    }",
        "begin_line": 765,
        "end_line": 766,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedTreeMapIterator.hasNext()",
        "snippet": "    public final boolean hasNext() {\n      return next != header;\n    }",
        "begin_line": 768,
        "end_line": 770,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedTreeMapIterator.nextNode()",
        "snippet": "    final Node<K, V> nextNode() {\n      Node<K, V> e = next;\n      if (e == header) {\n        throw new NoSuchElementException();\n      }\n      if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n      }\n      next = e.next;\n      return lastReturned = e;\n    }",
        "begin_line": 772,
        "end_line": 782,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.LinkedTreeMapIterator.remove()",
        "snippet": "    public final void remove() {\n      if (lastReturned == null) {\n        throw new IllegalStateException();\n      }\n      removeInternal(lastReturned, true);\n      lastReturned = null;\n      expectedModCount = modCount;\n    }",
        "begin_line": 784,
        "end_line": 791,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.size()",
        "snippet": "    @Override public int size() {\n      return size;\n    }",
        "begin_line": 795,
        "end_line": 797,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.iterator()",
        "snippet": "    @Override public Iterator<Entry<K, V>> iterator() {\n      return new LinkedTreeMapIterator<Entry<K, V>>() {\n        public Entry<K, V> next() {\n          return nextNode();\n        }\n      };\n    }",
        "begin_line": 799,
        "end_line": 805,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.Anonymous-b6231648-3c70-433f-ab4b-8f988fa6040a.next()",
        "snippet": "        public Entry<K, V> next() {\n          return nextNode();\n        }",
        "begin_line": 801,
        "end_line": 803,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.contains(java.lang.Object)",
        "snippet": "    @Override public boolean contains(Object o) {\n      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;\n    }",
        "begin_line": 807,
        "end_line": 809,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.remove(java.lang.Object)",
        "snippet": "    @Override public boolean remove(Object o) {\n      if (!(o instanceof Entry)) {\n        return false;\n      }\n\n      Node<K, V> node = findByEntry((Entry<?, ?>) o);\n      if (node == null) {\n        return false;\n      }\n      removeInternal(node, true);\n      return true;\n    }",
        "begin_line": 811,
        "end_line": 822,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.EntrySet.clear()",
        "snippet": "    @Override public void clear() {\n      LinkedHashTreeMap.this.clear();\n    }",
        "begin_line": 824,
        "end_line": 826,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.size()",
        "snippet": "    @Override public int size() {\n      return size;\n    }",
        "begin_line": 830,
        "end_line": 832,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.iterator()",
        "snippet": "    @Override public Iterator<K> iterator() {\n      return new LinkedTreeMapIterator<K>() {\n        public K next() {\n          return nextNode().key;\n        }\n      };\n    }",
        "begin_line": 834,
        "end_line": 840,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.Anonymous-2e1d8361-2aec-42c1-8b3a-8e23ea66ce1b.next()",
        "snippet": "        public K next() {\n          return nextNode().key;\n        }",
        "begin_line": 836,
        "end_line": 838,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.contains(java.lang.Object)",
        "snippet": "    @Override public boolean contains(Object o) {\n      return containsKey(o);\n    }",
        "begin_line": 842,
        "end_line": 844,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.remove(java.lang.Object)",
        "snippet": "    @Override public boolean remove(Object key) {\n      return removeInternalByKey(key) != null;\n    }",
        "begin_line": 846,
        "end_line": 848,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.KeySet.clear()",
        "snippet": "    @Override public void clear() {\n      LinkedHashTreeMap.this.clear();\n    }",
        "begin_line": 850,
        "end_line": 852,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java",
        "class_name": "com.google.gson.internal.LinkedHashTreeMap",
        "signature": "com.google.gson.internal.LinkedHashTreeMap.writeReplace()",
        "snippet": "  private Object writeReplace() throws ObjectStreamException {\n    return new LinkedHashMap<K, V>(this);\n  }",
        "begin_line": 861,
        "end_line": 863,
        "comment": "\n   * If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a LinkedHashMap so that they won't need Gson on the other side to\n   * deserialize it. Using serialization defeats our DoS defence, so most apps\n   * shouldn't use it.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.ConstructorConstructor(java.util.Map<java.lang.reflect.Type, com.google.gson.InstanceCreator<?>>)",
        "snippet": "  public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\n    this.instanceCreators = instanceCreators;\n  }",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.get(com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\n    final Type type = typeToken.getType();\n    final Class<? super T> rawType = typeToken.getRawType();\n\n    // first try an instance creator\n\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\n    if (typeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // Next try raw type match for instance creators\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> rawTypeCreator =\n        (InstanceCreator<T>) instanceCreators.get(rawType);\n    if (rawTypeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }\n      };\n    }\n\n    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\n    if (defaultConstructor != null) {\n      return defaultConstructor;\n    }\n\n    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation != null) {\n      return defaultImplementation;\n    }\n\n    // finally try unsafe\n    return newUnsafeAllocator(type, rawType);\n  }",
        "begin_line": 55,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-a9f1001c-dbe9-4ff9-aead-0ec04b89969a.construct()",
        "snippet": "        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-e390a0ed-40a7-4c79-a442-ee6503640618.construct()",
        "snippet": "        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultConstructor(java.lang.Class<? super T>)",
        "snippet": "  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\n    try {\n      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n      if (!constructor.isAccessible()) {\n        constructor.setAccessible(true);\n      }\n      return new ObjectConstructor<T>() {\n        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n        @Override public T construct() {\n          try {\n            Object[] args = null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don't wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }\n      };\n    } catch (NoSuchMethodException e) {\n      return null;\n    }\n  }",
        "begin_line": 97,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-a9217006-ef69-4fd5-ab11-531904da28df.construct()",
        "snippet": "        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n        @Override public T construct() {\n          try {\n            Object[] args = null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don't wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }",
        "begin_line": 104,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor(java.lang.reflect.Type, java.lang.Class<? super T>)",
        "snippet": "  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n      final Type type, Class<? super T> rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }\n        };\n      } else if (EnumSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedList<Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap<Object, Object>();\n          }\n        };\n      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentHashMap<Object, Object>();\n          }\n        };\n      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }\n        };\n      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }\n        };\n      }\n    }\n\n    return null;\n  }",
        "begin_line": 131,
        "end_line": 214,
        "comment": "\n   * Constructors for common interface types like Map and List and their\n   * subtypes.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-045aa590-c3f7-4846-a6b3-112256614810.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }",
        "begin_line": 171,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-860ecffa-dbee-47ed-9826-c35422d355ab.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new LinkedList<Object>();\n          }",
        "begin_line": 165,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-4111098e-1979-49cf-83a7-0f1f74fc0e2e.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-a43aaa0b-76c9-4ad5-95b1-36734afb4136.construct()",
        "snippet": "          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }",
        "begin_line": 143,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-4d02dace-178b-4203-8d8b-0cfb71507f50.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }",
        "begin_line": 137,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-2d825746-1720-48e4-afd8-db21ac8b6685.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }",
        "begin_line": 206,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-a1d4db9e-a9a5-4f81-9f7a-c3577a954822.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }",
        "begin_line": 200,
        "end_line": 202,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-03b6a99c-bc00-4694-905c-6eb879716f06.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }",
        "begin_line": 193,
        "end_line": 195,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-c4067476-ae51-45a2-af8a-ab4d0909e4d8.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new ConcurrentHashMap<Object, Object>();\n          }",
        "begin_line": 187,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-b3edd75d-4ad5-4e84-a0d6-2c6eb6fdad17.construct()",
        "snippet": "          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap<Object, Object>();\n          }",
        "begin_line": 181,
        "end_line": 183,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.newUnsafeAllocator(java.lang.reflect.Type, java.lang.Class<? super T>)",
        "snippet": "  private <T> ObjectConstructor<T> newUnsafeAllocator(\n      final Type type, final Class<? super T> rawType) {\n    return new ObjectConstructor<T>() {\n      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n      @SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance = unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }\n    };\n  }",
        "begin_line": 216,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.Anonymous-fe0d0083-5da7-4d5a-85e6-b841e02a563b.construct()",
        "snippet": "      @SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance = unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }",
        "begin_line": 220,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "class_name": "com.google.gson.internal.ConstructorConstructor",
        "signature": "com.google.gson.internal.ConstructorConstructor.toString()",
        "snippet": "  @Override public String toString() {\n    return instanceCreators.toString();\n  }",
        "begin_line": 233,
        "end_line": 235,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.Anonymous-8a85f4a4-8434-4c97-ae05-ca60b97dfc2b.write(char[], int, int)",
        "snippet": "    @Override public void write(char[] buffer, int offset, int counter) {\n      throw new AssertionError();\n    }",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.Anonymous-a45df5c2-7f6e-4c99-aa58-0a7542a2ce75.flush()",
        "snippet": "    @Override public void flush() throws IOException {\n      throw new AssertionError();\n    }",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.Anonymous-977206f1-e412-4556-8eaa-20b65e23c2ab.close()",
        "snippet": "    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.JsonTreeWriter()",
        "snippet": "  public JsonTreeWriter() {\n    super(UNWRITABLE_WRITER);\n  }",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.get()",
        "snippet": "  public JsonElement get() {\n    if (!stack.isEmpty()) {\n      throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\n    }\n    return product;\n  }",
        "begin_line": 64,
        "end_line": 69,
        "comment": "\n   * Returns the top level object produced by this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.peek()",
        "snippet": "  private JsonElement peek() {\n    return stack.get(stack.size() - 1);\n  }",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.put(com.google.gson.JsonElement)",
        "snippet": "  private void put(JsonElement value) {\n    if (pendingName != null) {\n      if (!value.isJsonNull() || getSerializeNulls()) {\n        JsonObject object = (JsonObject) peek();\n        object.add(pendingName, value);\n      }\n      pendingName = null;\n    } else if (stack.isEmpty()) {\n      product = value;\n    } else {\n      JsonElement element = peek();\n      if (element instanceof JsonArray) {\n        ((JsonArray) element).add(value);\n      } else {\n        throw new IllegalStateException();\n      }\n    }\n  }",
        "begin_line": 75,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.beginArray()",
        "snippet": "  @Override public JsonWriter beginArray() throws IOException {\n    JsonArray array = new JsonArray();\n    put(array);\n    stack.add(array);\n    return this;\n  }",
        "begin_line": 94,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.endArray()",
        "snippet": "  @Override public JsonWriter endArray() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonArray) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 101,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.beginObject()",
        "snippet": "  @Override public JsonWriter beginObject() throws IOException {\n    JsonObject object = new JsonObject();\n    put(object);\n    stack.add(object);\n    return this;\n  }",
        "begin_line": 113,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.endObject()",
        "snippet": "  @Override public JsonWriter endObject() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 120,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.name(java.lang.String)",
        "snippet": "  @Override public JsonWriter name(String name) throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      pendingName = name;\n      return this;\n    }\n    throw new IllegalStateException();\n  }",
        "begin_line": 132,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.value(java.lang.String)",
        "snippet": "  @Override public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "begin_line": 144,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.nullValue()",
        "snippet": "  @Override public JsonWriter nullValue() throws IOException {\n    put(JsonNull.INSTANCE);\n    return this;\n  }",
        "begin_line": 152,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.value(boolean)",
        "snippet": "  @Override public JsonWriter value(boolean value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "begin_line": 157,
        "end_line": 160,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.value(double)",
        "snippet": "  @Override public JsonWriter value(double value) throws IOException {\n    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "begin_line": 163,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.value(long)",
        "snippet": "  @Override public JsonWriter value(long value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.value(java.lang.Number)",
        "snippet": "  @Override public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    if (!isLenient()) {\n      double d = value.doubleValue();\n      if (Double.isNaN(d) || Double.isInfinite(d)) {\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n      }\n    }\n\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "begin_line": 176,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.flush()",
        "snippet": "  @Override public void flush() throws IOException {\n  }",
        "begin_line": 192,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeWriter",
        "signature": "com.google.gson.internal.bind.JsonTreeWriter.close()",
        "snippet": "  @Override public void close() throws IOException {\n    if (!stack.isEmpty()) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stack.add(SENTINEL_CLOSED);\n  }",
        "begin_line": 195,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
        "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.Anonymous-df77dbe6-9cfa-47fe-9989-1cc0bb6259be.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Type type = typeToken.getType();\n      if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n        return null;\n      }\n\n      Type componentType = $Gson$Types.getArrayComponentType(type);\n      TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\n      return new ArrayTypeAdapter(\n              gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n    }",
        "begin_line": 40,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
        "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.ArrayTypeAdapter(com.google.gson.Gson, com.google.gson.TypeAdapter<E>, java.lang.Class<E>)",
        "snippet": "  public ArrayTypeAdapter(Gson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n    this.componentTypeAdapter =\n      new TypeAdapterRuntimeTypeWrapper<E>(context, componentTypeAdapter, componentType);\n    this.componentType = componentType;\n  }",
        "begin_line": 57,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
        "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override public Object read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n\n    List<E> list = new ArrayList<E>();\n    in.beginArray();\n    while (in.hasNext()) {\n      E instance = componentTypeAdapter.read(in);\n      list.add(instance);\n    }\n    in.endArray();\n    Object array = Array.newInstance(componentType, list.size());\n    for (int i = 0; i < list.size(); i++) {\n      Array.set(array, i, list.get(i));\n    }\n    return array;\n  }",
        "begin_line": 63,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
        "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  @Override public void write(JsonWriter out, Object array) throws IOException {\n    if (array == null) {\n      out.nullValue();\n      return;\n    }\n\n    out.beginArray();\n    for (int i = 0, length = Array.getLength(array); i < length; i++) {\n      E value = (E) Array.get(array, i);\n      componentTypeAdapter.write(out, value);\n    }\n    out.endArray();\n  }",
        "begin_line": 83,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.TypeAdapters()",
        "snippet": "  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d55edb15-58f5-46c0-9db0-8df0e8ccaee0.write(com.google.gson.stream.JsonWriter, java.lang.Class)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }",
        "begin_line": 70,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-00a32053-2e11-4993-a8c1-989224b3e595.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }",
        "begin_line": 79,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-7fe525ee-d867-4585-bfe9-ae8b3fe7796f.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }",
        "begin_line": 93,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-2c433ada-2102-47cd-b9d5-8a93828f72d0.write(com.google.gson.stream.JsonWriter, java.util.BitSet)",
        "snippet": "    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }",
        "begin_line": 134,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-0751d2c8-00ca-43af-8bb1-4ebbfd04ad3a.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }",
        "begin_line": 152,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-5da9d589-5980-4dc0-8179-6c67712b7e30.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }",
        "begin_line": 163,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-be1099e2-2ed3-448a-ac5b-231a9b6b936e.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }",
        "begin_line": 178,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-fd09b0a3-f9d8-4b34-bd54-0e82b36ccae9.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
        "snippet": "    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }",
        "begin_line": 186,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-97e9944d-dadf-4edb-8482-be2f360f64eb.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 195,
        "end_line": 207,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-33ae3a06-0808-4533-ad2e-ebc94e9f6447.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 208,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-3ece3d12-c479-4595-940a-47415dc129d7.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 218,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d3da5776-5b33-45f6-a7e1-cdfb25196aeb.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 230,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-15734410-2db9-45d3-8908-925e6e9faff3.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 240,
        "end_line": 251,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-3494744b-66d7-467f-bfcb-1500136f7a18.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 252,
        "end_line": 255,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-246b0947-ec74-4a8f-8dd3-5ce772ab9fd9.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 261,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-ea37d2b8-663c-46e9-81fc-72f8bb29b681.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicInteger)",
        "snippet": "    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }",
        "begin_line": 268,
        "end_line": 270,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-bd5a4ff5-bc0c-4202-a660-48fdd6863ec5.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }",
        "begin_line": 276,
        "end_line": 278,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-2aec056b-75c7-414d-ad82-df8358fec1b1.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicBoolean)",
        "snippet": "    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }",
        "begin_line": 279,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-183e54e6-f33b-4d3e-81bf-45a80aec896f.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }",
        "begin_line": 287,
        "end_line": 305,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-401e6e74-0bfa-4999-a969-96ea8c03eb1c.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicIntegerArray)",
        "snippet": "    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }",
        "begin_line": 306,
        "end_line": 312,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-9639f499-63f8-4c1f-a36b-e1b37aeb676b.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 318,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-ed9b092e-e0ea-41e7-8bbd-ca92573b5f5d.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 330,
        "end_line": 333,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-681e2564-9436-4b7d-b8a1-1967c4fc1f38.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }",
        "begin_line": 337,
        "end_line": 344,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-06c16f17-5033-49a4-aff8-8b573639b731.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 345,
        "end_line": 348,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-18395e69-240f-4562-a8ff-200430009447.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }",
        "begin_line": 352,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-6e5e3376-e28b-4a44-8c95-5eeb058d932e.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 360,
        "end_line": 363,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-1d53e41d-dbda-47e7-93ed-7371893f2e32.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }",
        "begin_line": 367,
        "end_line": 379,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-ee1e20a1-9488-425b-abe9-2b36ee9f4732.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 380,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-0825218b-86a1-45e6-b34a-829232117ac2.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }",
        "begin_line": 389,
        "end_line": 400,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-0f858aa7-3154-426b-aaa2-34fe16e1e36a.write(com.google.gson.stream.JsonWriter, java.lang.Character)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }",
        "begin_line": 401,
        "end_line": 404,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-75021e49-5b3e-470b-a120-38dd202d678b.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }",
        "begin_line": 411,
        "end_line": 423,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-b53aa0ab-408a-4819-8683-7bd18d769ad4.write(com.google.gson.stream.JsonWriter, java.lang.String)",
        "snippet": "    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 424,
        "end_line": 427,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d9236372-3b52-45ba-9f1b-e16ecd2a2f9a.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 431,
        "end_line": 441,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-7151d00d-c28f-4842-850e-b42e176f6c71.write(com.google.gson.stream.JsonWriter, java.math.BigDecimal)",
        "snippet": "    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 443,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-4325ddb2-f3f5-44ff-9a7a-4f61101bffab.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }",
        "begin_line": 449,
        "end_line": 459,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-5300cdcd-db87-4be4-adb1-1f12187fc3ac.write(com.google.gson.stream.JsonWriter, java.math.BigInteger)",
        "snippet": "    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }",
        "begin_line": 461,
        "end_line": 463,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-49d8e386-72ec-47ef-bcfa-d961ab7f442a.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }",
        "begin_line": 469,
        "end_line": 476,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-f277a5ad-955e-4a43-8818-5d23ad809072.write(com.google.gson.stream.JsonWriter, java.lang.StringBuilder)",
        "snippet": "    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }",
        "begin_line": 477,
        "end_line": 480,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-cbe07b07-7664-44cc-8052-acee3b43a5cf.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }",
        "begin_line": 487,
        "end_line": 494,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-c8d237a3-ddbf-4c3f-8e76-78589b3b95a2.write(com.google.gson.stream.JsonWriter, java.lang.StringBuffer)",
        "snippet": "    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }",
        "begin_line": 495,
        "end_line": 498,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-1d3c1e0f-7bf4-4383-bbf7-6b32f483f0d1.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }",
        "begin_line": 505,
        "end_line": 513,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-58a44504-13f2-4d83-8b81-5d1f64cccf03.write(com.google.gson.stream.JsonWriter, java.net.URL)",
        "snippet": "    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }",
        "begin_line": 514,
        "end_line": 517,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-6ff98f6a-6dd1-473f-a3a0-f2401c2bf13b.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }",
        "begin_line": 523,
        "end_line": 535,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-955d632c-c159-4b82-aa82-b51d4611ed03.write(com.google.gson.stream.JsonWriter, java.net.URI)",
        "snippet": "    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }",
        "begin_line": 536,
        "end_line": 539,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-154c14ee-73fc-4baa-a3d1-988e167f3d5e.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }",
        "begin_line": 545,
        "end_line": 553,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-78d491bb-e5b4-4881-8da3-3fc300133863.write(com.google.gson.stream.JsonWriter, java.net.InetAddress)",
        "snippet": "    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }",
        "begin_line": 554,
        "end_line": 557,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d7f6d84e-f3f6-4cd9-857a-9d20b7550b91.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }",
        "begin_line": 564,
        "end_line": 571,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-e299a96e-dfae-44a0-ba03-483430af7c55.write(com.google.gson.stream.JsonWriter, java.util.UUID)",
        "snippet": "    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }",
        "begin_line": 572,
        "end_line": 575,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-68b2f756-d5b8-4474-afe2-217d1eb13a57.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }",
        "begin_line": 581,
        "end_line": 584,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-147650cc-2aa2-4f39-8028-3e0ce60619ef.write(com.google.gson.stream.JsonWriter, java.util.Currency)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }",
        "begin_line": 585,
        "end_line": 588,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-9cb72494-6e8a-48d1-84d7-eb0e35c0ea8c.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }",
        "begin_line": 593,
        "end_line": 610,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-bdf4743a-fec9-4b5f-af6f-90fc63ab66a3.read(com.google.gson.stream.JsonReader)",
        "snippet": "        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }",
        "begin_line": 601,
        "end_line": 604,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-e72fff17-2f5c-4b82-8f5c-74f11a0f87a5.write(com.google.gson.stream.JsonWriter, java.sql.Timestamp)",
        "snippet": "        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }",
        "begin_line": 606,
        "end_line": 608,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-3ff2890c-5f77-40d8-9aaf-84e58da54aa4.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }",
        "begin_line": 621,
        "end_line": 653,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d1c934ae-f3da-4062-87b6-4559823bb09a.write(com.google.gson.stream.JsonWriter, java.util.Calendar)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }",
        "begin_line": 655,
        "end_line": 675,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-e0278873-c7d6-43de-ba02-53739e250c74.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }",
        "begin_line": 682,
        "end_line": 709,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-cd0d633e-76c3-4db1-895b-2f6c4a3a2e06.write(com.google.gson.stream.JsonWriter, java.util.Locale)",
        "snippet": "    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }",
        "begin_line": 710,
        "end_line": 713,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-e9f6e936-7d06-4a25-a11d-1d387ee519e6.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }",
        "begin_line": 719,
        "end_line": 754,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-020ec7c6-d7b3-4b43-927c-8071f66a500d.write(com.google.gson.stream.JsonWriter, com.google.gson.JsonElement)",
        "snippet": "    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }",
        "begin_line": 756,
        "end_line": 787,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter.EnumTypeAdapter(java.lang.Class<T>)",
        "snippet": "    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n      }\n    }",
        "begin_line": 797,
        "end_line": 814,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }",
        "begin_line": 815,
        "end_line": 821,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }",
        "begin_line": 823,
        "end_line": 825,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-c3fe75b2-1889-447f-86f2-6d3d41fbd44f.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }",
        "begin_line": 829,
        "end_line": 839,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(com.google.gson.reflect.TypeToken<TT>, com.google.gson.TypeAdapter<TT>)",
        "snippet": "  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }",
        "begin_line": 842,
        "end_line": 850,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-12ec81b5-c6b0-4bcc-bf16-3b98e1e4532a.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }",
        "begin_line": 845,
        "end_line": 848,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class<TT>, com.google.gson.TypeAdapter<TT>)",
        "snippet": "  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
        "begin_line": 852,
        "end_line": 863,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-2e933383-6043-4c83-ab4c-cebda2292fdd.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }",
        "begin_line": 855,
        "end_line": 858,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-f96ead54-1607-47d9-b90f-9c3b626cda5d.toString()",
        "snippet": "      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }",
        "begin_line": 859,
        "end_line": 861,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class<TT>, java.lang.Class<TT>, com.google.gson.TypeAdapter<? super TT>)",
        "snippet": "  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
        "begin_line": 865,
        "end_line": 878,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-75932472-1a0e-436a-b609-1c90513f6c63.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }",
        "begin_line": 868,
        "end_line": 872,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-2b2bd8e2-bc78-4941-b65a-b067091f70ee.toString()",
        "snippet": "      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }",
        "begin_line": 873,
        "end_line": 876,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.newFactoryForMultipleTypes(java.lang.Class<TT>, java.lang.Class<? extends TT>, com.google.gson.TypeAdapter<? super TT>)",
        "snippet": "  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
        "begin_line": 880,
        "end_line": 893,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-bc82129a-b89a-410b-affd-730631a0a42e.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }",
        "begin_line": 883,
        "end_line": 887,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-96479809-6e6b-4824-ab8d-85e8405abcbc.toString()",
        "snippet": "      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }",
        "begin_line": 888,
        "end_line": 891,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.newTypeHierarchyFactory(java.lang.Class<T1>, com.google.gson.TypeAdapter<T1>)",
        "snippet": "  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
        "begin_line": 899,
        "end_line": 927,
        "comment": "\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-bba2ed51-4670-4775-adb9-0058abef24cb.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T2>)",
        "snippet": "      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }",
        "begin_line": 902,
        "end_line": 922,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-d97f2632-10b2-4b34-a6ab-25a89b45e968.write(com.google.gson.stream.JsonWriter, T1)",
        "snippet": "          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }",
        "begin_line": 909,
        "end_line": 911,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-16c29e99-48a6-4c29-89f9-a96850a07632.read(com.google.gson.stream.JsonReader)",
        "snippet": "          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }",
        "begin_line": 913,
        "end_line": 920,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapters",
        "signature": "com.google.gson.internal.bind.TypeAdapters.Anonymous-afe8dd0f-a144-4899-838e-cfbadde05a40.toString()",
        "snippet": "      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }",
        "begin_line": 923,
        "end_line": 925,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
        "signature": "com.google.gson.internal.bind.DateTypeAdapter.Anonymous-2b73e148-f233-46c1-87c8-3820d49b89b0.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n    }",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
        "signature": "com.google.gson.internal.bind.DateTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override public Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    return deserializeToDate(in.nextString());\n  }",
        "begin_line": 54,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
        "signature": "com.google.gson.internal.bind.DateTypeAdapter.deserializeToDate(java.lang.String)",
        "snippet": "  private synchronized Date deserializeToDate(String json) {\n    try {\n      return localFormat.parse(json);\n    } catch (ParseException ignored) {\n    }\n    try {\n      return enUsFormat.parse(json);\n    } catch (ParseException ignored) {\n    }\n    try {\n    \treturn ISO8601Utils.parse(json, new ParsePosition(0));\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(json, e);\n    }\n  }",
        "begin_line": 62,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
        "signature": "com.google.gson.internal.bind.DateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.util.Date)",
        "snippet": "  @Override public synchronized void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    String dateFormatAsString = enUsFormat.format(value);\n    out.value(dateFormatAsString);\n  }",
        "begin_line": 78,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.MapTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, boolean)",
        "snippet": "  public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      boolean complexMapKeySerialization) {\n    this.constructorConstructor = constructorConstructor;\n    this.complexMapKeySerialization = complexMapKeySerialization;\n  }",
        "begin_line": 109,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n    Type type = typeToken.getType();\n\n    Class<? super T> rawType = typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\n    TypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    // we don't define a type parameter for the key or value types\n    TypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\n        keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n  }",
        "begin_line": 115,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.getKeyAdapter(com.google.gson.Gson, java.lang.reflect.Type)",
        "snippet": "  private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\n    return (keyType == boolean.class || keyType == Boolean.class)\n        ? TypeAdapters.BOOLEAN_AS_STRING\n        : context.getAdapter(TypeToken.get(keyType));\n  }",
        "begin_line": 139,
        "end_line": 143,
        "comment": "\n   * Returns a type adapter that writes the value as a string.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter<K>, java.lang.reflect.Type, com.google.gson.TypeAdapter<V>, com.google.gson.internal.ObjectConstructor<? extends java.util.Map<K, V>>)",
        "snippet": "    public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\n        Type valueType, TypeAdapter<V> valueTypeAdapter,\n        ObjectConstructor<? extends Map<K, V>> constructor) {\n      this.keyTypeAdapter =\n        new TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\n      this.valueTypeAdapter =\n        new TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\n      this.constructor = constructor;\n    }",
        "begin_line": 150,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public Map<K, V> read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      Map<K, V> map = constructor.construct();\n\n      if (peek == JsonToken.BEGIN_ARRAY) {\n        in.beginArray();\n        while (in.hasNext()) {\n          in.beginArray(); // entry array\n          K key = keyTypeAdapter.read(in);\n          V value = valueTypeAdapter.read(in);\n          V replaced = map.put(key, value);\n          if (replaced != null) {\n            throw new JsonSyntaxException(\"duplicate key: \" + key);\n          }\n          in.endArray();\n        }\n        in.endArray();\n      } else {\n        in.beginObject();\n        while (in.hasNext()) {\n          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n          K key = keyTypeAdapter.read(in);\n          V value = valueTypeAdapter.read(in);\n          V replaced = map.put(key, value);\n          if (replaced != null) {\n            throw new JsonSyntaxException(\"duplicate key: \" + key);\n          }\n        }\n        in.endObject();\n      }\n      return map;\n    }",
        "begin_line": 160,
        "end_line": 196,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter.write(com.google.gson.stream.JsonWriter, java.util.Map<K, V>)",
        "snippet": "    @Override public void write(JsonWriter out, Map<K, V> map) throws IOException {\n      if (map == null) {\n        out.nullValue();\n        return;\n      }\n\n      if (!complexMapKeySerialization) {\n        out.beginObject();\n        for (Map.Entry<K, V> entry : map.entrySet()) {\n          out.name(String.valueOf(entry.getKey()));\n          valueTypeAdapter.write(out, entry.getValue());\n        }\n        out.endObject();\n        return;\n      }\n\n      boolean hasComplexKeys = false;\n      List<JsonElement> keys = new ArrayList<JsonElement>(map.size());\n\n      List<V> values = new ArrayList<V>(map.size());\n      for (Map.Entry<K, V> entry : map.entrySet()) {\n        JsonElement keyElement = keyTypeAdapter.toJsonTree(entry.getKey());\n        keys.add(keyElement);\n        values.add(entry.getValue());\n        hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject();\n      }\n\n      if (hasComplexKeys) {\n        out.beginArray();\n        for (int i = 0; i < keys.size(); i++) {\n          out.beginArray(); // entry array\n          Streams.write(keys.get(i), out);\n          valueTypeAdapter.write(out, values.get(i));\n          out.endArray();\n        }\n        out.endArray();\n      } else {\n        out.beginObject();\n        for (int i = 0; i < keys.size(); i++) {\n          JsonElement keyElement = keys.get(i);\n          out.name(keyToString(keyElement));\n          valueTypeAdapter.write(out, values.get(i));\n        }\n        out.endObject();\n      }\n    }",
        "begin_line": 198,
        "end_line": 243,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter.keyToString(com.google.gson.JsonElement)",
        "snippet": "    private String keyToString(JsonElement keyElement) {\n      if (keyElement.isJsonPrimitive()) {\n        JsonPrimitive primitive = keyElement.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          return String.valueOf(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          return Boolean.toString(primitive.getAsBoolean());\n        } else if (primitive.isString()) {\n          return primitive.getAsString();\n        } else {\n          throw new AssertionError();\n        }\n      } else if (keyElement.isJsonNull()) {\n        return \"null\";\n      } else {\n        throw new AssertionError();\n      }\n    }",
        "begin_line": 245,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
        "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.Anonymous-a9e0a357-e4e7-41a2-bece-28e12b028ea7.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      return typeToken.getRawType() == java.sql.Date.class\n          ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n    }",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
        "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override\n  public synchronized java.sql.Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    try {\n      final long utilDate = format.parse(in.nextString()).getTime();\n      return new java.sql.Date(utilDate);\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
        "begin_line": 49,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
        "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Date)",
        "snippet": "  @Override\n  public synchronized void write(JsonWriter out, java.sql.Date value) throws IOException {\n    out.value(value == null ? null : format.format(value));\n  }",
        "begin_line": 63,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.CollectionTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
        "snippet": "  public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor = constructorConstructor;\n  }",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n    Type type = typeToken.getType();\n\n    Class<? super T> rawType = typeToken.getRawType();\n    if (!Collection.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n    TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\n    ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\n    TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\n    return result;\n  }",
        "begin_line": 43,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter<E>, com.google.gson.internal.ObjectConstructor<? extends java.util.Collection<E>>)",
        "snippet": "    public Adapter(Gson context, Type elementType,\n        TypeAdapter<E> elementTypeAdapter,\n        ObjectConstructor<? extends Collection<E>> constructor) {\n      this.elementTypeAdapter =\n          new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\n      this.constructor = constructor;\n    }",
        "begin_line": 65,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public Collection<E> read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      Collection<E> collection = constructor.construct();\n      in.beginArray();\n      while (in.hasNext()) {\n        E instance = elementTypeAdapter.read(in);\n        collection.add(instance);\n      }\n      in.endArray();\n      return collection;\n    }",
        "begin_line": 73,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter.write(com.google.gson.stream.JsonWriter, java.util.Collection<E>)",
        "snippet": "    @Override public void write(JsonWriter out, Collection<E> collection) throws IOException {\n      if (collection == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (E element : collection) {\n        elementTypeAdapter.write(out, element);\n      }\n      out.endArray();\n    }",
        "begin_line": 89,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.Anonymous-7c91b259-2634-42e6-a556-6317e39574d1.read(char[], int, int)",
        "snippet": "    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n      throw new AssertionError();\n    }",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.Anonymous-ff83763b-c806-43df-a158-c4ff054524fa.close()",
        "snippet": "    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.JsonTreeReader(com.google.gson.JsonElement)",
        "snippet": "  public JsonTreeReader(JsonElement element) {\n    super(UNREADABLE_READER);\n    stack.add(element);\n  }",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.beginArray()",
        "snippet": "  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    stack.add(array.iterator());\n  }",
        "begin_line": 57,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.endArray()",
        "snippet": "  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); // empty iterator\n    popStack(); // array\n  }",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.beginObject()",
        "snippet": "  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    stack.add(object.entrySet().iterator());\n  }",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.endObject()",
        "snippet": "  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); // empty iterator\n    popStack(); // object\n  }",
        "begin_line": 75,
        "end_line": 79,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.hasNext()",
        "snippet": "  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }",
        "begin_line": 81,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.peek()",
        "snippet": "  @Override public JsonToken peek() throws IOException {\n    if (stack.isEmpty()) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          stack.add(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }",
        "begin_line": 86,
        "end_line": 127,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.peekStack()",
        "snippet": "  private Object peekStack() {\n    return stack.get(stack.size() - 1);\n  }",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.popStack()",
        "snippet": "  private Object popStack() {\n    return stack.remove(stack.size() - 1);\n  }",
        "begin_line": 133,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.expect(com.google.gson.stream.JsonToken)",
        "snippet": "  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n    }\n  }",
        "begin_line": 137,
        "end_line": 141,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextName()",
        "snippet": "  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    stack.add(entry.getValue());\n    return (String) entry.getKey();\n  }",
        "begin_line": 143,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextString()",
        "snippet": "  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token);\n    }\n    return ((JsonPrimitive) popStack()).getAsString();\n  }",
        "begin_line": 151,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextBoolean()",
        "snippet": "  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    return ((JsonPrimitive) popStack()).getAsBoolean();\n  }",
        "begin_line": 159,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextNull()",
        "snippet": "  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n  }",
        "begin_line": 164,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextDouble()",
        "snippet": "  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    return result;\n  }",
        "begin_line": 169,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextLong()",
        "snippet": "  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    return result;\n  }",
        "begin_line": 182,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.nextInt()",
        "snippet": "  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    return result;\n  }",
        "begin_line": 192,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.close()",
        "snippet": "  @Override public void close() throws IOException {\n    stack.clear();\n    stack.add(SENTINEL_CLOSED);\n  }",
        "begin_line": 202,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.skipValue()",
        "snippet": "  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n    } else {\n      popStack();\n    }\n  }",
        "begin_line": 207,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.toString()",
        "snippet": "  @Override public String toString() {\n    return getClass().getSimpleName();\n  }",
        "begin_line": 215,
        "end_line": 217,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "class_name": "com.google.gson.internal.bind.JsonTreeReader",
        "signature": "com.google.gson.internal.bind.JsonTreeReader.promoteNameToValue()",
        "snippet": "  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    stack.add(entry.getValue());\n    stack.add(new JsonPrimitive((String)entry.getKey()));\n  }",
        "begin_line": 219,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
        "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.Anonymous-95fadc4e-a8fb-404a-bc46-6a3892a7f864.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n      if (type.getRawType() == Object.class) {\n        return (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n      }\n      return null;\n    }",
        "begin_line": 39,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
        "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.ObjectTypeAdapter(com.google.gson.Gson)",
        "snippet": "  ObjectTypeAdapter(Gson gson) {\n    this.gson = gson;\n  }",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
        "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override public Object read(JsonReader in) throws IOException {\n    JsonToken token = in.peek();\n    switch (token) {\n    case BEGIN_ARRAY:\n      List<Object> list = new ArrayList<Object>();\n      in.beginArray();\n      while (in.hasNext()) {\n        list.add(read(in));\n      }\n      in.endArray();\n      return list;\n\n    case BEGIN_OBJECT:\n      Map<String, Object> map = new LinkedTreeMap<String, Object>();\n      in.beginObject();\n      while (in.hasNext()) {\n        map.put(in.nextName(), read(in));\n      }\n      in.endObject();\n      return map;\n\n    case STRING:\n      return in.nextString();\n\n    case NUMBER:\n      return in.nextDouble();\n\n    case BOOLEAN:\n      return in.nextBoolean();\n\n    case NULL:\n      in.nextNull();\n      return null;\n\n    default:\n      throw new IllegalStateException();\n    }\n  }",
        "begin_line": 54,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
        "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  @Override public void write(JsonWriter out, Object value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n\n    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());\n    if (typeAdapter instanceof ObjectTypeAdapter) {\n      out.beginObject();\n      out.endObject();\n      return;\n    }\n\n    typeAdapter.write(out, value);\n  }",
        "begin_line": 93,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
        "signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.TypeAdapterRuntimeTypeWrapper(com.google.gson.Gson, com.google.gson.TypeAdapter<T>, java.lang.reflect.Type)",
        "snippet": "  TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\n    this.context = context;\n    this.delegate = delegate;\n    this.type = type;\n  }",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
        "signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override\n  public T read(JsonReader in) throws IOException {\n    return delegate.read(in);\n  }",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
        "signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  @Override\n  public void write(JsonWriter out, T value) throws IOException {\n    // Order of preference for choosing type adapters\n    // First preference: a type adapter registered for the runtime type\n    // Second preference: a type adapter registered for the declared type\n    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)\n    // Fourth preference: reflective type adapter for the declared type\n\n    TypeAdapter chosen = delegate;\n    Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value);\n    if (runtimeType != type) {\n      TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType));\n      if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n        // The user registered a type adapter for the runtime type, so we will use that\n        chosen = runtimeTypeAdapter;\n      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {\n        // The user registered a type adapter for Base class, so we prefer it over the\n        // reflective type adapter for the runtime type\n        chosen = delegate;\n      } else {\n        // Use the type adapter for runtime type\n        chosen = runtimeTypeAdapter;\n      }\n    }\n    chosen.write(out, value);\n  }",
        "begin_line": 43,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java",
        "class_name": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper",
        "signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.getRuntimeTypeIfMoreSpecific(java.lang.reflect.Type, java.lang.Object)",
        "snippet": "  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\n    if (value != null\n        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\n      type = value.getClass();\n    }\n    return type;\n  }",
        "begin_line": 74,
        "end_line": 80,
        "comment": "\r\n   * Finds a compatible runtime type if it is more specific\r\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TimeTypeAdapter.Anonymous-8de3c9ff-4f3f-466d-9ae2-9e634b57f57e.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n    }",
        "begin_line": 42,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TimeTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override public synchronized Time read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    try {\n      Date date = format.parse(in.nextString());\n      return new Time(date.getTime());\n    } catch (ParseException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
        "begin_line": 50,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TimeTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Time)",
        "snippet": "  @Override public synchronized void write(JsonWriter out, Time value) throws IOException {\n    out.value(value == null ? null : format.format(value));\n  }",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.JsonAdapterAnnotationTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
        "snippet": "  public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor = constructorConstructor;\n  }",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }",
        "begin_line": 40,
        "end_line": 48,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter(com.google.gson.internal.ConstructorConstructor, com.google.gson.Gson, com.google.gson.reflect.TypeToken<?>, com.google.gson.annotations.JsonAdapter)",
        "snippet": "  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n    if (typeAdapter != null) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n    return typeAdapter;\n  }",
        "begin_line": 50,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.TreeTypeAdapter(com.google.gson.JsonSerializer<T>, com.google.gson.JsonDeserializer<T>, com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>, com.google.gson.TypeAdapterFactory)",
        "snippet": "  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.gson = gson;\n    this.typeToken = typeToken;\n    this.skipPast = skipPast;\n  }",
        "begin_line": 52,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "  @Override public T read(JsonReader in) throws IOException {\n    if (deserializer == null) {\n      return delegate().read(in);\n    }\n    JsonElement value = Streams.parse(in);\n    if (value.isJsonNull()) {\n      return null;\n    }\n    return deserializer.deserialize(value, typeToken.getType(), context);\n  }",
        "begin_line": 61,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "  @Override public void write(JsonWriter out, T value) throws IOException {\n    if (serializer == null) {\n      delegate().write(out, value);\n      return;\n    }\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);\n    Streams.write(tree, out);\n  }",
        "begin_line": 72,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.delegate()",
        "snippet": "  private TypeAdapter<T> delegate() {\n    TypeAdapter<T> d = delegate;\n    return d != null\n        ? d\n        : (delegate = gson.getDelegateAdapter(skipPast, typeToken));\n  }",
        "begin_line": 85,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.newFactory(com.google.gson.reflect.TypeToken<?>, java.lang.Object)",
        "snippet": "  public static TypeAdapterFactory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n    return new SingleTypeFactory(typeAdapter, exactType, false, null);\n  }",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n   * Returns a new factory that will match each type against {@code exactType}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.newFactoryWithMatchRawType(com.google.gson.reflect.TypeToken<?>, java.lang.Object)",
        "snippet": "  public static TypeAdapterFactory newFactoryWithMatchRawType(\n      TypeToken<?> exactType, Object typeAdapter) {\n    // only bother matching raw types if exact type is a raw type\n    boolean matchRawType = exactType.getType() == exactType.getRawType();\n    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\n  }",
        "begin_line": 103,
        "end_line": 108,
        "comment": "\n   * Returns a new factory that will match each type and its raw type against\n   * {@code exactType}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.newTypeHierarchyFactory(java.lang.Class<?>, java.lang.Object)",
        "snippet": "  public static TypeAdapterFactory newTypeHierarchyFactory(\n      Class<?> hierarchyType, Object typeAdapter) {\n    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\n  }",
        "begin_line": 114,
        "end_line": 117,
        "comment": "\n   * Returns a new factory that will match each type's raw type for assignability\n   * to {@code hierarchyType}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.SingleTypeFactory.SingleTypeFactory(java.lang.Object, com.google.gson.reflect.TypeToken<?>, boolean, java.lang.Class<?>)",
        "snippet": "    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n        Class<?> hierarchyType) {\n      serializer = typeAdapter instanceof JsonSerializer\n          ? (JsonSerializer<?>) typeAdapter\n          : null;\n      deserializer = typeAdapter instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) typeAdapter\n          : null;\n      $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n      this.exactType = exactType;\n      this.matchRawType = matchRawType;\n      this.hierarchyType = hierarchyType;\n    }",
        "begin_line": 126,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.SingleTypeFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "    @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n    @Override\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n      boolean matches = exactType != null\n          ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()\n          : hierarchyType.isAssignableFrom(type.getRawType());\n      return matches\n          ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,\n              (JsonDeserializer<T>) deserializer, gson, type, this)\n          : null;\n    }",
        "begin_line": 140,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl.serialize(java.lang.Object)",
        "snippet": "    @Override public JsonElement serialize(Object src) {\n      return gson.toJsonTree(src);\n    }",
        "begin_line": 154,
        "end_line": 156,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl.serialize(java.lang.Object, java.lang.reflect.Type)",
        "snippet": "    @Override public JsonElement serialize(Object src, Type typeOfSrc) {\n      return gson.toJsonTree(src, typeOfSrc);\n    }",
        "begin_line": 157,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
        "class_name": "com.google.gson.internal.bind.TreeTypeAdapter",
        "signature": "com.google.gson.internal.bind.TreeTypeAdapter.GsonContextImpl.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n      return (R) gson.fromJson(json, typeOfT);\n    }",
        "begin_line": 160,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.ReflectiveTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, com.google.gson.FieldNamingStrategy, com.google.gson.internal.Excluder)",
        "snippet": "  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor = constructorConstructor;\n    this.fieldNamingPolicy = fieldNamingPolicy;\n    this.excluder = excluder;\n  }",
        "begin_line": 53,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean)",
        "snippet": "  public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean, com.google.gson.internal.Excluder)",
        "snippet": "  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldNames(java.lang.reflect.Field)",
        "snippet": "  private List<String> getFieldNames(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }",
        "begin_line": 69,
        "end_line": 71,
        "comment": " first element holds the default name ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldName(com.google.gson.FieldNamingStrategy, java.lang.reflect.Field)",
        "snippet": "  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    List<String> fieldNames = new LinkedList<String>();\n    if (serializedName == null) {\n      fieldNames.add(fieldNamingPolicy.translateName(f));\n    } else {\n      fieldNames.add(serializedName.value());\n      for (String alternate : serializedName.alternate()) {\n        fieldNames.add(alternate);\n      }\n    }\n    return fieldNames;\n  }",
        "begin_line": 74,
        "end_line": 86,
        "comment": " first element holds the default name ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken<T>)",
        "snippet": "  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n    Class<? super T> raw = type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; // it's a primitive!\n    }\n\n    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n  }",
        "begin_line": 88,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.createBoundField(com.google.gson.Gson, java.lang.reflect.Field, java.lang.String, com.google.gson.reflect.TypeToken<?>, boolean, boolean)",
        "snippet": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
        "begin_line": 99,
        "end_line": 127,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Anonymous-28dc051c-c814-4799-862c-8673ac89812c.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
        "snippet": "      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }",
        "begin_line": 106,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Anonymous-925e3ead-a35e-4524-9768-53c0ad26c4f1.read(com.google.gson.stream.JsonReader, java.lang.Object)",
        "snippet": "      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }",
        "begin_line": 114,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Anonymous-097bd378-4edc-4d4f-b995-e8377d5431c2.writeField(java.lang.Object)",
        "snippet": "      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }",
        "begin_line": 121,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldAdapter(com.google.gson.Gson, java.lang.reflect.Field, com.google.gson.reflect.TypeToken<?>)",
        "snippet": "  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    if (annotation != null) {\n      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n      if (adapter != null) return adapter;\n    }\n    return gson.getAdapter(fieldType);\n  }",
        "begin_line": 129,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getBoundFields(com.google.gson.Gson, com.google.gson.reflect.TypeToken<?>, java.lang.Class<?>)",
        "snippet": "  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType = type.getType();\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize = excludeField(field, true);\n        boolean deserialize = excludeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0; i < fieldNames.size(); ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; // only serialize the default name\n          BoundField boundField = createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }",
        "begin_line": 138,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField.BoundField(java.lang.String, boolean, boolean)",
        "snippet": "    protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name = name;\n      this.serialized = serialized;\n      this.deserialized = deserialized;\n    }",
        "begin_line": 181,
        "end_line": 185,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField.writeField(java.lang.Object)",
        "snippet": "    abstract boolean writeField(Object value) throws IOException, IllegalAccessException;",
        "begin_line": 186,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
        "snippet": "    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;",
        "begin_line": 187,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField.read(com.google.gson.stream.JsonReader, java.lang.Object)",
        "snippet": "    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;",
        "begin_line": 188,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter.Adapter(com.google.gson.internal.ObjectConstructor<T>, java.util.Map<java.lang.String, com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField>)",
        "snippet": "    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n      this.constructor = constructor;\n      this.boundFields = boundFields;\n    }",
        "begin_line": 195,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter.read(com.google.gson.stream.JsonReader)",
        "snippet": "    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance = constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name = in.nextName();\n          BoundField field = boundFields.get(name);\n          if (field == null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }",
        "begin_line": 200,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter.write(com.google.gson.stream.JsonWriter, T)",
        "snippet": "    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }",
        "begin_line": 228,
        "end_line": 246,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.format(java.util.Date)",
        "snippet": "    public static String format(Date date) {\n        return format(date, false, TIMEZONE_UTC);\n    }",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n     * \n     * @param date the date to format\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.format(java.util.Date, boolean)",
        "snippet": "    public static String format(Date date, boolean millis) {\n        return format(date, millis, TIMEZONE_UTC);\n    }",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.format(java.util.Date, boolean, java.util.TimeZone)",
        "snippet": "    public static String format(Date date, boolean millis, TimeZone tz) {\n        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n        calendar.setTime(date);\n\n        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n        capacity += millis ? \".sss\".length() : 0;\n        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n        StringBuilder formatted = new StringBuilder(capacity);\n\n        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n        formatted.append('T');\n        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n        if (millis) {\n            formatted.append('.');\n            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n        }\n\n        int offset = tz.getOffset(calendar.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            formatted.append(offset < 0 ? '-' : '+');\n            padInt(formatted, hours, \"hh\".length());\n            formatted.append(':');\n            padInt(formatted, minutes, \"mm\".length());\n        } else {\n            formatted.append('Z');\n        }\n\n        return formatted.toString();\n    }",
        "begin_line": 67,
        "end_line": 106,
        "comment": "\n     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.parse(java.lang.String, java.text.ParsePosition)",
        "snippet": "    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }",
        "begin_line": 123,
        "end_line": 277,
        "comment": "\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.checkOffset(java.lang.String, int, char)",
        "snippet": "    private static boolean checkOffset(String value, int offset, char expected) {\n        return (offset < value.length()) && (value.charAt(offset) == expected);\n    }",
        "begin_line": 287,
        "end_line": 289,
        "comment": "\n     * Check if the expected character exist at the given offset in the value.\n     * \n     * @param value the string to check at the specified offset\n     * @param offset the offset to look for the expected character\n     * @param expected the expected character\n     * @return true if the expected character exist at the given offset\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.parseInt(java.lang.String, int, int)",
        "snippet": "    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n            throw new NumberFormatException(value);\n        }\n        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n        int i = beginIndex;\n        int result = 0;\n        int digit;\n        if (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result = -digit;\n        }\n        while (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result *= 10;\n            result -= digit;\n        }\n        return -result;\n    }",
        "begin_line": 300,
        "end_line": 324,
        "comment": "\n     * Parse an integer located between 2 given offsets in a string\n     * \n     * @param value the string to parse\n     * @param beginIndex the start index for the integer in the string\n     * @param endIndex the end index for the integer in the string\n     * @return the int\n     * @throws NumberFormatException if the value is not a number\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.padInt(java.lang.StringBuilder, int, int)",
        "snippet": "    private static void padInt(StringBuilder buffer, int value, int length) {\n        String strValue = Integer.toString(value);\n        for (int i = length - strValue.length(); i > 0; i--) {\n            buffer.append('0');\n        }\n        buffer.append(strValue);\n    }",
        "begin_line": 333,
        "end_line": 339,
        "comment": "\n     * Zero pad a number to a specified length\n     * \n     * @param buffer buffer to use for padding\n     * @param value the integer value to pad if necessary.\n     * @param length the length of the string we should zero pad\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
        "class_name": "com.google.gson.internal.bind.util.ISO8601Utils",
        "signature": "com.google.gson.internal.bind.util.ISO8601Utils.indexOfNonDigit(java.lang.String, int)",
        "snippet": "    private static int indexOfNonDigit(String string, int offset) {\n        for (int i = offset; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c < '0' || c > '9') return i;\n        }\n        return string.length();\n    }",
        "begin_line": 344,
        "end_line": 350,
        "comment": "\n     * Returns the index of the first character in the string that is not a digit, starting at offset.\n     ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.JsonWriter(java.io.Writer)",
        "snippet": "  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }",
        "begin_line": 197,
        "end_line": 202,
        "comment": "\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.setIndent(java.lang.String)",
        "snippet": "  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }",
        "begin_line": 212,
        "end_line": 220,
        "comment": "\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.setLenient(boolean)",
        "snippet": "  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }",
        "begin_line": 234,
        "end_line": 236,
        "comment": "\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.isLenient()",
        "snippet": "  public boolean isLenient() {\n    return lenient;\n  }",
        "begin_line": 241,
        "end_line": 243,
        "comment": "\n   * Returns true if this writer has relaxed syntax rules.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.setHtmlSafe(boolean)",
        "snippet": "  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }",
        "begin_line": 252,
        "end_line": 254,
        "comment": "\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.isHtmlSafe()",
        "snippet": "  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }",
        "begin_line": 260,
        "end_line": 262,
        "comment": "\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.setSerializeNulls(boolean)",
        "snippet": "  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }",
        "begin_line": 268,
        "end_line": 270,
        "comment": "\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.getSerializeNulls()",
        "snippet": "  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }",
        "begin_line": 276,
        "end_line": 278,
        "comment": "\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.beginArray()",
        "snippet": "  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }",
        "begin_line": 286,
        "end_line": 289,
        "comment": "\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.endArray()",
        "snippet": "  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }",
        "begin_line": 296,
        "end_line": 298,
        "comment": "\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.beginObject()",
        "snippet": "  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }",
        "begin_line": 306,
        "end_line": 309,
        "comment": "\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.endObject()",
        "snippet": "  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }",
        "begin_line": 316,
        "end_line": 318,
        "comment": "\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.open(int, java.lang.String)",
        "snippet": "  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }",
        "begin_line": 324,
        "end_line": 329,
        "comment": "\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.close(int, int, java.lang.String)",
        "snippet": "  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }",
        "begin_line": 335,
        "end_line": 351,
        "comment": "\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.push(int)",
        "snippet": "  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }",
        "begin_line": 353,
        "end_line": 360,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.peek()",
        "snippet": "  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }",
        "begin_line": 365,
        "end_line": 370,
        "comment": "\n   * Returns the value on the top of the stack.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.replaceTop(int)",
        "snippet": "  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }",
        "begin_line": 375,
        "end_line": 377,
        "comment": "\n   * Replace the value on the top of the stack with the given value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.name(java.lang.String)",
        "snippet": "  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }",
        "begin_line": 385,
        "end_line": 397,
        "comment": "\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.writeDeferredName()",
        "snippet": "  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }",
        "begin_line": 399,
        "end_line": 405,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.value(java.lang.String)",
        "snippet": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }",
        "begin_line": 413,
        "end_line": 421,
        "comment": "\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.jsonValue(java.lang.String)",
        "snippet": "  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }",
        "begin_line": 430,
        "end_line": 438,
        "comment": "\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.nullValue()",
        "snippet": "  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }",
        "begin_line": 445,
        "end_line": 457,
        "comment": "\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.value(boolean)",
        "snippet": "  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }",
        "begin_line": 464,
        "end_line": 469,
        "comment": "\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.value(double)",
        "snippet": "  public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }",
        "begin_line": 484,
        "end_line": 492,
        "comment": "\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.value(long)",
        "snippet": "  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }",
        "begin_line": 499,
        "end_line": 504,
        "comment": "\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.value(java.lang.Number)",
        "snippet": "  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }",
        "begin_line": 513,
        "end_line": 527,
        "comment": "\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.flush()",
        "snippet": "  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }",
        "begin_line": 533,
        "end_line": 538,
        "comment": "\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.close()",
        "snippet": "  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }",
        "begin_line": 545,
        "end_line": 553,
        "comment": "\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.string(java.lang.String)",
        "snippet": "  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }",
        "begin_line": 555,
        "end_line": 585,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.newline()",
        "snippet": "  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }",
        "begin_line": 587,
        "end_line": 596,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.beforeName()",
        "snippet": "  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }",
        "begin_line": 602,
        "end_line": 611,
        "comment": "\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
        "class_name": "com.google.gson.stream.JsonWriter",
        "signature": "com.google.gson.stream.JsonWriter.beforeValue()",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }",
        "begin_line": 618,
        "end_line": 649,
        "comment": "\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.JsonReader(java.io.Reader)",
        "snippet": "  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }",
        "begin_line": 289,
        "end_line": 294,
        "comment": "\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.setLenient(boolean)",
        "snippet": "  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }",
        "begin_line": 325,
        "end_line": 327,
        "comment": "\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.isLenient()",
        "snippet": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "begin_line": 332,
        "end_line": 334,
        "comment": "\n   * Returns true if this parser is liberal in what it accepts.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.beginArray()",
        "snippet": "  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "begin_line": 340,
        "end_line": 353,
        "comment": "\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.endArray()",
        "snippet": "  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "begin_line": 359,
        "end_line": 372,
        "comment": "\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.beginObject()",
        "snippet": "  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "begin_line": 378,
        "end_line": 390,
        "comment": "\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.endObject()",
        "snippet": "  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "begin_line": 396,
        "end_line": 410,
        "comment": "\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.hasNext()",
        "snippet": "  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }",
        "begin_line": 415,
        "end_line": 421,
        "comment": "\n   * Returns true if the current array or object has another element.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.peek()",
        "snippet": "  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }",
        "begin_line": 426,
        "end_line": 463,
        "comment": "\n   * Returns the type of the next token without consuming it.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.doPeek()",
        "snippet": "  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }",
        "begin_line": 465,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.peekKeyword()",
        "snippet": "  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }",
        "begin_line": 601,
        "end_line": 643,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.peekNumber()",
        "snippet": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }",
        "begin_line": 645,
        "end_line": 746,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.isLiteral(char)",
        "snippet": "  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }",
        "begin_line": 748,
        "end_line": 771,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextName()",
        "snippet": "  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
        "begin_line": 780,
        "end_line": 799,
        "comment": "\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextString()",
        "snippet": "  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "begin_line": 809,
        "end_line": 836,
        "comment": "\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextBoolean()",
        "snippet": "  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
        "begin_line": 845,
        "end_line": 861,
        "comment": "\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextNull()",
        "snippet": "  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "begin_line": 870,
        "end_line": 882,
        "comment": "\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextDouble()",
        "snippet": "  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "begin_line": 893,
        "end_line": 927,
        "comment": "\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextLong()",
        "snippet": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "begin_line": 939,
        "end_line": 984,
        "comment": "\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextQuotedValue(char)",
        "snippet": "  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = new StringBuilder();\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c == '\\\\') {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }",
        "begin_line": 996,
        "end_line": 1031,
        "comment": "\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextUnquotedValue()",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }",
        "begin_line": 1036,
        "end_line": 1096,
        "comment": "\n   * Returns an unquoted value as a string.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.skipQuotedValue(char)",
        "snippet": "  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }",
        "begin_line": 1098,
        "end_line": 1123,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.skipUnquotedValue()",
        "snippet": "  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }",
        "begin_line": 1125,
        "end_line": 1153,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextInt()",
        "snippet": "  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "begin_line": 1165,
        "end_line": 1216,
        "comment": "\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.close()",
        "snippet": "  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }",
        "begin_line": 1221,
        "end_line": 1226,
        "comment": "\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.skipValue()",
        "snippet": "  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }",
        "begin_line": 1233,
        "end_line": 1267,
        "comment": "\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.push(int)",
        "snippet": "  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }",
        "begin_line": 1269,
        "end_line": 1282,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.fillBuffer(int)",
        "snippet": "  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }",
        "begin_line": 1289,
        "end_line": 1316,
        "comment": "\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.getLineNumber()",
        "snippet": "  int getLineNumber() {\n    return lineNumber + 1;\n  }",
        "begin_line": 1318,
        "end_line": 1320,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.getColumnNumber()",
        "snippet": "  int getColumnNumber() {\n    return pos - lineStart + 1;\n  }",
        "begin_line": 1322,
        "end_line": 1324,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.nextNonWhitespace(boolean)",
        "snippet": "  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }",
        "begin_line": 1332,
        "end_line": 1420,
        "comment": "\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.checkLenient()",
        "snippet": "  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }",
        "begin_line": 1422,
        "end_line": 1426,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.skipToEndOfLine()",
        "snippet": "  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }",
        "begin_line": 1433,
        "end_line": 1444,
        "comment": "\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.skipTo(java.lang.String)",
        "snippet": "  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
        "begin_line": 1449,
        "end_line": 1465,
        "comment": "\n   * @param toFind a string to search for. Must not contain a newline.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.toString()",
        "snippet": "  @Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }",
        "begin_line": 1467,
        "end_line": 1470,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.getPath()",
        "snippet": "  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }",
        "begin_line": 1476,
        "end_line": 1501,
        "comment": "\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.readEscapeCharacter()",
        "snippet": "  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    default:\n      return escaped;\n    }\n  }",
        "begin_line": 1512,
        "end_line": 1567,
        "comment": "\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.syntaxError(java.lang.String)",
        "snippet": "  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
        "begin_line": 1573,
        "end_line": 1576,
        "comment": "\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.consumeNonExecutePrefix()",
        "snippet": "  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }",
        "begin_line": 1581,
        "end_line": 1598,
        "comment": "\n   * Consumes the non-execute prefix if it exists.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
        "class_name": "com.google.gson.stream.JsonReader",
        "signature": "com.google.gson.stream.JsonReader.Anonymous-187f8915-ce15-488a-b076-26620ad46110.promoteNameToValue(com.google.gson.stream.JsonReader)",
        "snippet": "      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }",
        "begin_line": 1602,
        "end_line": 1622,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/MalformedJsonException.java",
        "class_name": "com.google.gson.stream.MalformedJsonException",
        "signature": "com.google.gson.stream.MalformedJsonException.MalformedJsonException(java.lang.String)",
        "snippet": "  public MalformedJsonException(String msg) {\n    super(msg);\n  }",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/MalformedJsonException.java",
        "class_name": "com.google.gson.stream.MalformedJsonException",
        "signature": "com.google.gson.stream.MalformedJsonException.MalformedJsonException(java.lang.String, java.lang.Throwable)",
        "snippet": "  public MalformedJsonException(String msg, Throwable throwable) {\n    super(msg);\n    // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException\n    // with a constructor with Throwable. This was done in Java 1.6\n    initCause(throwable);\n  }",
        "begin_line": 32,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/stream/MalformedJsonException.java",
        "class_name": "com.google.gson.stream.MalformedJsonException",
        "signature": "com.google.gson.stream.MalformedJsonException.MalformedJsonException(java.lang.Throwable)",
        "snippet": "  public MalformedJsonException(Throwable throwable) {\n    // Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException\n    // with a constructor with Throwable. This was done in Java 1.6\n    initCause(throwable);\n  }",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.TypeToken()",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  protected TypeToken() {\n    this.type = getSuperclassTypeParameter(getClass());\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n    this.hashCode = type.hashCode();\n  }",
        "begin_line": 60,
        "end_line": 65,
        "comment": "\n   * Constructs a new type literal. Derives represented class from type\n   * parameter.\n   *\n   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n   * parameter in the anonymous class's type hierarchy so we can reconstitute it\n   * at runtime despite erasure.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.TypeToken(java.lang.reflect.Type)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  TypeToken(Type type) {\n    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n    this.hashCode = this.type.hashCode();\n  }",
        "begin_line": 70,
        "end_line": 75,
        "comment": "\n   * Unsafe. Constructs a type literal manually.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.getSuperclassTypeParameter(java.lang.Class<?>)",
        "snippet": "  static Type getSuperclassTypeParameter(Class<?> subclass) {\n    Type superclass = subclass.getGenericSuperclass();\n    if (superclass instanceof Class) {\n      throw new RuntimeException(\"Missing type parameter.\");\n    }\n    ParameterizedType parameterized = (ParameterizedType) superclass;\n    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n  }",
        "begin_line": 81,
        "end_line": 88,
        "comment": "\n   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n   * canonical form}.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.getRawType()",
        "snippet": "  public final Class<? super T> getRawType() {\n    return rawType;\n  }",
        "begin_line": 93,
        "end_line": 95,
        "comment": "\n   * Returns the raw (non-generic) type for this type.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.getType()",
        "snippet": "  public final Type getType() {\n    return type;\n  }",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n   * Gets underlying {@code Type} instance.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.Class<?>)",
        "snippet": "  @Deprecated\n  public boolean isAssignableFrom(Class<?> cls) {\n    return isAssignableFrom((Type) cls);\n  }",
        "begin_line": 110,
        "end_line": 113,
        "comment": "\n   * Check if this type is assignable from the given class object.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type)",
        "snippet": "  @Deprecated\n  public boolean isAssignableFrom(Type from) {\n    if (from == null) {\n      return false;\n    }\n\n    if (type.equals(from)) {\n      return true;\n    }\n\n    if (type instanceof Class<?>) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n    } else if (type instanceof ParameterizedType) {\n      return isAssignableFrom(from, (ParameterizedType) type,\n          new HashMap<String, Type>());\n    } else if (type instanceof GenericArrayType) {\n      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n          && isAssignableFrom(from, (GenericArrayType) type);\n    } else {\n      throw buildUnexpectedTypeError(\n          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n    }\n  }",
        "begin_line": 121,
        "end_line": 143,
        "comment": "\n   * Check if this type is assignable from the given Type.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(com.google.gson.reflect.TypeToken<?>)",
        "snippet": "  @Deprecated\n  public boolean isAssignableFrom(TypeToken<?> token) {\n    return isAssignableFrom(token.getType());\n  }",
        "begin_line": 151,
        "end_line": 154,
        "comment": "\n   * Check if this type is assignable from the given type token.\n   *\n   * @deprecated this implementation may be inconsistent with javac for types\n   *     with wildcards.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.GenericArrayType)",
        "snippet": "  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n    Type toGenericComponentType = to.getGenericComponentType();\n    if (toGenericComponentType instanceof ParameterizedType) {\n      Type t = from;\n      if (from instanceof GenericArrayType) {\n        t = ((GenericArrayType) from).getGenericComponentType();\n      } else if (from instanceof Class<?>) {\n        Class<?> classType = (Class<?>) from;\n        while (classType.isArray()) {\n          classType = classType.getComponentType();\n        }\n        t = classType;\n      }\n      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n          new HashMap<String, Type>());\n    }\n    // No generic defined on \"to\"; therefore, return true and let other\n    // checks determine assignability\n    return true;\n  }",
        "begin_line": 160,
        "end_line": 179,
        "comment": "\n   * Private helper function that performs some assignability checks for\n   * the provided GenericArrayType.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.ParameterizedType, java.util.Map<java.lang.String, java.lang.reflect.Type>)",
        "snippet": "  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n      Map<String, Type> typeVarMap) {\n\n    if (from == null) {\n      return false;\n    }\n\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
        "begin_line": 185,
        "end_line": 232,
        "comment": "\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.typeEquals(java.lang.reflect.ParameterizedType, java.lang.reflect.ParameterizedType, java.util.Map<java.lang.String, java.lang.reflect.Type>)",
        "snippet": "  private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap) {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
        "begin_line": 238,
        "end_line": 251,
        "comment": "\n   * Checks if two parameterized types are exactly equal, under the variable\n   * replacement described in the typeVarMap.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.buildUnexpectedTypeError(java.lang.reflect.Type, java.lang.Class<?>...)",
        "snippet": "  private static AssertionError buildUnexpectedTypeError(\n      Type token, Class<?>... expected) {\n\n    // Build exception message\n    StringBuilder exceptionMessage =\n        new StringBuilder(\"Unexpected type. Expected one of: \");\n    for (Class<?> clazz : expected) {\n      exceptionMessage.append(clazz.getName()).append(\", \");\n    }\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n        .append(\", for type token: \").append(token.toString()).append('.');\n\n    return new AssertionError(exceptionMessage.toString());\n  }",
        "begin_line": 253,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.matches(java.lang.reflect.Type, java.lang.reflect.Type, java.util.Map<java.lang.String, java.lang.reflect.Type>)",
        "snippet": "  private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n    return to.equals(from)\n        || (from instanceof TypeVariable\n        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n\n  }",
        "begin_line": 272,
        "end_line": 277,
        "comment": "\n   * Checks if two types are the same or are equivalent under a variable mapping\n   * given in the type map that was provided.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.hashCode()",
        "snippet": "  @Override public final int hashCode() {\n    return this.hashCode;\n  }",
        "begin_line": 279,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.equals(java.lang.Object)",
        "snippet": "  @Override public final boolean equals(Object o) {\n    return o instanceof TypeToken<?>\n        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n  }",
        "begin_line": 283,
        "end_line": 286,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.toString()",
        "snippet": "  @Override public final String toString() {\n    return $Gson$Types.typeToString(type);\n  }",
        "begin_line": 288,
        "end_line": 290,
        "comment": "",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.get(java.lang.reflect.Type)",
        "snippet": "  public static TypeToken<?> get(Type type) {\n    return new TypeToken<Object>(type);\n  }",
        "begin_line": 295,
        "end_line": 297,
        "comment": "\n   * Gets type literal for the given {@code Type} instance.\n   ",
        "resolved_comments": {}
    },
    {
        "src_path": "gson/src/main/java/com/google/gson/reflect/TypeToken.java",
        "class_name": "com.google.gson.reflect.TypeToken",
        "signature": "com.google.gson.reflect.TypeToken.get(java.lang.Class<T>)",
        "snippet": "  public static <T> TypeToken<T> get(Class<T> type) {\n    return new TypeToken<T>(type);\n  }",
        "begin_line": 302,
        "end_line": 304,
        "comment": "\n   * Gets type literal for the given {@code Class} instance.\n   ",
        "resolved_comments": {}
    }
]